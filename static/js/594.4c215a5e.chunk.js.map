{"version":3,"sources":["../node_modules/code-example/lib/xquery.js"],"names":["Object","defineProperty","exports","value","default"],"mappings":"6IAEAA,OAAOC,eAAeC,EAAS,aAAc,CAC3CC,OAAO,IAETD,EAAQE,aAAU,EAGlBF,EAAQE,QAFG","file":"static/js/594.4c215a5e.chunk.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar code = \" \\nxquery version \\\"1.0-ml\\\";\\n(: this is\\n : a \\n   \\\"comment\\\" :)\\nlet $let := <x attr=\\\"value\\\">\\\"test\\\"<func>function() $var {function()} {$var}</func></x>\\nlet $joe:=1\\nreturn element element {\\n  attribute attribute { 1 },\\n  element test { 'a' }, \\n  attribute foo { \\\"bar\\\" },\\n  fn:doc()[ foo/@bar eq $let ],\\n  //x }  \\n \\n(: a more 'evil' test :)\\n(: Modified Blakeley example (: with nested comment :) ... :)\\ndeclare private function local:declare() {()};\\ndeclare private function local:private() {()};\\ndeclare private function local:function() {()};\\ndeclare private function local:local() {()};\\nlet $let := <let>let $let := \\\"let\\\"</let>\\nreturn element element {\\n  attribute attribute { try { xdmp:version() } catch($e) { xdmp:log($e) } },\\n  attribute fn:doc { \\\"bar\\\" castable as xs:string },\\n  element text { text { \\\"text\\\" } },\\n  fn:doc()[ child::eq/(@bar | attribute::attribute) eq $let ],\\n  //fn:doc\\n}\\n\\n\\n\\nxquery version \\\"1.0-ml\\\";\\n\\n(: Copyright 2006-2010 Mark Logic Corporation. :)\\n\\n(:\\n : Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n : you may not use this file except in compliance with the License.\\n : You may obtain a copy of the License at\\n :\\n :     http://www.apache.org/licenses/LICENSE-2.0\\n :\\n : Unless required by applicable law or agreed to in writing, software\\n : distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n : WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n : See the License for the specific language governing permissions and\\n : limitations under the License.\\n :)\\n\\nmodule namespace json = \\\"http://marklogic.com/json\\\";\\ndeclare default function namespace \\\"http://www.w3.org/2005/xpath-functions\\\";\\n\\n(: Need to backslash escape any double quotes, backslashes, and newlines :)\\ndeclare function json:escape($s as xs:string) as xs:string {\\n  let $s := replace($s, \\\"\\\\\\\", \\\"\\\\\\\\\\\")\\n  let $s := replace($s, \\\"\\\"\\\"\\\", \\\"\\\\\\\"\\\"\\\")\\n  let $s := replace($s, codepoints-to-string((13, 10)), \\\"\\\\n\\\")\\n  let $s := replace($s, codepoints-to-string(13), \\\"\\\\n\\\")\\n  let $s := replace($s, codepoints-to-string(10), \\\"\\\\n\\\")\\n  return $s\\n};\\n\\ndeclare function json:atomize($x as element()) as xs:string {\\n  if (count($x/node()) = 0) then 'null'\\n  else if ($x/@type = \\\"number\\\") then\\n    let $castable := $x castable as xs:float or\\n                     $x castable as xs:double or\\n                     $x castable as xs:decimal\\n    return\\n    if ($castable) then xs:string($x)\\n    else error(concat(\\\"Not a number: \\\", xdmp:describe($x)))\\n  else if ($x/@type = \\\"boolean\\\") then\\n    let $castable := $x castable as xs:boolean\\n    return\\n    if ($castable) then xs:string(xs:boolean($x))\\n    else error(concat(\\\"Not a boolean: \\\", xdmp:describe($x)))\\n  else concat('\\\"', json:escape($x), '\\\"')\\n};\\n\\n(: Print the thing that comes after the colon :)\\ndeclare function json:print-value($x as element()) as xs:string {\\n  if (count($x/*) = 0) then\\n    json:atomize($x)\\n  else if ($x/@quote = \\\"true\\\") then\\n    concat('\\\"', json:escape(xdmp:quote($x/node())), '\\\"')\\n  else\\n    string-join(('{',\\n      string-join(for $i in $x/* return json:print-name-value($i), \\\",\\\"),\\n    '}'), \\\"\\\")\\n};\\n\\n(: Print the name and value both :)\\ndeclare function json:print-name-value($x as element()) as xs:string? {\\n  let $name := name($x)\\n  let $first-in-array :=\\n    count($x/preceding-sibling::*[name(.) = $name]) = 0 and\\n    (count($x/following-sibling::*[name(.) = $name]) > 0 or $x/@array = \\\"true\\\")\\n  let $later-in-array := count($x/preceding-sibling::*[name(.) = $name]) > 0\\n  return\\n\\n  if ($later-in-array) then\\n    ()  (: I was handled previously :)\\n  else if ($first-in-array) then\\n    string-join(('\\\"', json:escape($name), '\\\":[',\\n      string-join((for $i in ($x, $x/following-sibling::*[name(.) = $name]) return json:print-value($i)), \\\",\\\"),\\n    ']'), \\\"\\\")\\n   else\\n     string-join(('\\\"', json:escape($name), '\\\":', json:print-value($x)), \\\"\\\")\\n};\\n\\n(:~\\n  Transforms an XML element into a JSON string representation.  See http://json.org.\\n  <p/>\\n  Sample usage:\\n  <pre>\\n    xquery version \\\"1.0-ml\\\";\\n    import module namespace json=\\\"http://marklogic.com/json\\\" at \\\"json.xqy\\\";\\n    json:serialize(&lt;foo&gt;&lt;bar&gt;kid&lt;/bar&gt;&lt;/foo&gt;)\\n  </pre>\\n  Sample transformations:\\n  <pre>\\n  &lt;e/&gt; becomes {\\\"e\\\":null}\\n  &lt;e&gt;text&lt;/e&gt; becomes {\\\"e\\\":\\\"text\\\"}\\n  &lt;e&gt;quote \\\" escaping&lt;/e&gt; becomes {\\\"e\\\":\\\"quote \\\\\\\" escaping\\\"}\\n  &lt;e&gt;backslash \\\\ escaping&lt;/e&gt; becomes {\\\"e\\\":\\\"backslash \\\\ escaping\\\"}\\n  &lt;e&gt;&lt;a&gt;text1&lt;/a&gt;&lt;b&gt;text2&lt;/b&gt;&lt;/e&gt; becomes {\\\"e\\\":{\\\"a\\\":\\\"text1\\\",\\\"b\\\":\\\"text2\\\"}}\\n  &lt;e&gt;&lt;a&gt;text1&lt;/a&gt;&lt;a&gt;text2&lt;/a&gt;&lt;/e&gt; becomes {\\\"e\\\":{\\\"a\\\":[\\\"text1\\\",\\\"text2\\\"]}}\\n  &lt;e&gt;&lt;a array=\\\"true\\\"&gt;text1&lt;/a&gt;&lt;/e&gt; becomes {\\\"e\\\":{\\\"a\\\":[\\\"text1\\\"]}}\\n  &lt;e&gt;&lt;a type=\\\"boolean\\\"&gt;false&lt;/a&gt;&lt;/e&gt; becomes {\\\"e\\\":{\\\"a\\\":false}}\\n  &lt;e&gt;&lt;a type=\\\"number\\\"&gt;123.5&lt;/a&gt;&lt;/e&gt; becomes {\\\"e\\\":{\\\"a\\\":123.5}}\\n  &lt;e quote=\\\"true\\\"&gt;&lt;div attrib=\\\"value\\\"/&gt;&lt;/e&gt; becomes {\\\"e\\\":\\\"&lt;div attrib=\\\\\\\"value\\\\\\\"/&gt;\\\"}\\n  </pre>\\n  <p/>\\n  Namespace URIs are ignored. Namespace prefixes are included in the JSON name.\\n  <p/>\\n  Attributes are ignored, except for the special attribute @array=\\\"true\\\" that\\n  indicates the JSON serialization should write the node, even if single, as an\\n  array, and the attribute @type that can be set to \\\"boolean\\\" or \\\"number\\\" to\\n  dictate the value should be written as that type (unquoted).  There's also\\n  an @quote attribute that when set to true writes the inner content as text\\n  rather than as structured JSON, useful for sending some XHTML over the\\n  wire.\\n  <p/>\\n  Text nodes within mixed content are ignored.\\n\\n  @param $x Element node to convert\\n  @return String holding JSON serialized representation of $x\\n\\n  @author Jason Hunter\\n  @version 1.0.1\\n    \\n  Ported to xquery 1.0-ml; double escaped backslashes in json:escape\\n:)\\ndeclare function json:serialize($x as element())  as xs:string {\\n  string-join(('{', json:print-name-value($x), '}'), \\\"\\\")\\n};\\n    \\n\";\nvar _default = code;\nexports.default = _default;"],"sourceRoot":""}