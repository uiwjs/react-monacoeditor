{"version":3,"file":"static/js/monaco-editor-vendor.ffbeb0f7.4b2b45e2.js","mappings":"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","sources":["../node_modules/monaco-editor/esm/vs/editor/common/encodedTokenAttributes.js","../node_modules/monaco-editor/esm/vs/editor/common/languageSelector.js","../node_modules/monaco-editor/esm/vs/editor/common/languageFeatureRegistry.js","../node_modules/monaco-editor/esm/vs/editor/common/languages.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/autoIndent.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/enterAction.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/language.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/characterPair.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/electricCharacter.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/indentRules.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/onEnter.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/languageBracketsConfiguration.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfigurationRegistry.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/modesRegistry.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/nullTokenize.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/supports.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/richEditBrackets.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/tokenization.js","../node_modules/monaco-editor/esm/vs/editor/common/languages/textToHtmlTokenizer.js","../node_modules/monaco-editor/esm/vs/editor/common/model.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/nodeReader.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js","../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/fixBrackets.js","../node_modules/monaco-editor/esm/vs/editor/common/model/editStack.js","../node_modules/monaco-editor/esm/vs/editor/common/model/guidesTextModelPart.js","../node_modules/monaco-editor/esm/vs/editor/common/model/indentationGuesser.js","../node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js","../node_modules/monaco-editor/esm/vs/editor/common/modelLineProjectionData.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n */\nexport class TokenMetadata {\n    static getLanguageId(metadata) {\n        return (metadata & 255 /* MetadataConsts.LANGUAGEID_MASK */) >>> 0 /* MetadataConsts.LANGUAGEID_OFFSET */;\n    }\n    static getTokenType(metadata) {\n        return (metadata & 768 /* MetadataConsts.TOKEN_TYPE_MASK */) >>> 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */;\n    }\n    static containsBalancedBrackets(metadata) {\n        return (metadata & 1024 /* MetadataConsts.BALANCED_BRACKETS_MASK */) !== 0;\n    }\n    static getFontStyle(metadata) {\n        return (metadata & 30720 /* MetadataConsts.FONT_STYLE_MASK */) >>> 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n    }\n    static getForeground(metadata) {\n        return (metadata & 16744448 /* MetadataConsts.FOREGROUND_MASK */) >>> 15 /* MetadataConsts.FOREGROUND_OFFSET */;\n    }\n    static getBackground(metadata) {\n        return (metadata & 4278190080 /* MetadataConsts.BACKGROUND_MASK */) >>> 24 /* MetadataConsts.BACKGROUND_OFFSET */;\n    }\n    static getClassNameFromMetadata(metadata) {\n        const foreground = this.getForeground(metadata);\n        let className = 'mtk' + foreground;\n        const fontStyle = this.getFontStyle(metadata);\n        if (fontStyle & 1 /* FontStyle.Italic */) {\n            className += ' mtki';\n        }\n        if (fontStyle & 2 /* FontStyle.Bold */) {\n            className += ' mtkb';\n        }\n        if (fontStyle & 4 /* FontStyle.Underline */) {\n            className += ' mtku';\n        }\n        if (fontStyle & 8 /* FontStyle.Strikethrough */) {\n            className += ' mtks';\n        }\n        return className;\n    }\n    static getInlineStyleFromMetadata(metadata, colorMap) {\n        const foreground = this.getForeground(metadata);\n        const fontStyle = this.getFontStyle(metadata);\n        let result = `color: ${colorMap[foreground]};`;\n        if (fontStyle & 1 /* FontStyle.Italic */) {\n            result += 'font-style: italic;';\n        }\n        if (fontStyle & 2 /* FontStyle.Bold */) {\n            result += 'font-weight: bold;';\n        }\n        let textDecoration = '';\n        if (fontStyle & 4 /* FontStyle.Underline */) {\n            textDecoration += ' underline';\n        }\n        if (fontStyle & 8 /* FontStyle.Strikethrough */) {\n            textDecoration += ' line-through';\n        }\n        if (textDecoration) {\n            result += `text-decoration:${textDecoration};`;\n        }\n        return result;\n    }\n    static getPresentationFromMetadata(metadata) {\n        const foreground = this.getForeground(metadata);\n        const fontStyle = this.getFontStyle(metadata);\n        return {\n            foreground: foreground,\n            italic: Boolean(fontStyle & 1 /* FontStyle.Italic */),\n            bold: Boolean(fontStyle & 2 /* FontStyle.Bold */),\n            underline: Boolean(fontStyle & 4 /* FontStyle.Underline */),\n            strikethrough: Boolean(fontStyle & 8 /* FontStyle.Strikethrough */),\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { match as matchGlobPattern } from '../../base/common/glob.js';\nimport { normalize } from '../../base/common/path.js';\nexport function score(selector, candidateUri, candidateLanguage, candidateIsSynchronized, candidateNotebookUri, candidateNotebookType) {\n    if (Array.isArray(selector)) {\n        // array -> take max individual value\n        let ret = 0;\n        for (const filter of selector) {\n            const value = score(filter, candidateUri, candidateLanguage, candidateIsSynchronized, candidateNotebookUri, candidateNotebookType);\n            if (value === 10) {\n                return value; // already at the highest\n            }\n            if (value > ret) {\n                ret = value;\n            }\n        }\n        return ret;\n    }\n    else if (typeof selector === 'string') {\n        if (!candidateIsSynchronized) {\n            return 0;\n        }\n        // short-hand notion, desugars to\n        // 'fooLang' -> { language: 'fooLang'}\n        // '*' -> { language: '*' }\n        if (selector === '*') {\n            return 5;\n        }\n        else if (selector === candidateLanguage) {\n            return 10;\n        }\n        else {\n            return 0;\n        }\n    }\n    else if (selector) {\n        // filter -> select accordingly, use defaults for scheme\n        const { language, pattern, scheme, hasAccessToAllModels, notebookType } = selector; // TODO: microsoft/TypeScript#42768\n        if (!candidateIsSynchronized && !hasAccessToAllModels) {\n            return 0;\n        }\n        // selector targets a notebook -> use the notebook uri instead\n        // of the \"normal\" document uri.\n        if (notebookType && candidateNotebookUri) {\n            candidateUri = candidateNotebookUri;\n        }\n        let ret = 0;\n        if (scheme) {\n            if (scheme === candidateUri.scheme) {\n                ret = 10;\n            }\n            else if (scheme === '*') {\n                ret = 5;\n            }\n            else {\n                return 0;\n            }\n        }\n        if (language) {\n            if (language === candidateLanguage) {\n                ret = 10;\n            }\n            else if (language === '*') {\n                ret = Math.max(ret, 5);\n            }\n            else {\n                return 0;\n            }\n        }\n        if (notebookType) {\n            if (notebookType === candidateNotebookType) {\n                ret = 10;\n            }\n            else if (notebookType === '*' && candidateNotebookType !== undefined) {\n                ret = Math.max(ret, 5);\n            }\n            else {\n                return 0;\n            }\n        }\n        if (pattern) {\n            let normalizedPattern;\n            if (typeof pattern === 'string') {\n                normalizedPattern = pattern;\n            }\n            else {\n                // Since this pattern has a `base` property, we need\n                // to normalize this path first before passing it on\n                // because we will compare it against `Uri.fsPath`\n                // which uses platform specific separators.\n                // Refs: https://github.com/microsoft/vscode/issues/99938\n                normalizedPattern = Object.assign(Object.assign({}, pattern), { base: normalize(pattern.base) });\n            }\n            if (normalizedPattern === candidateUri.fsPath || matchGlobPattern(normalizedPattern, candidateUri.fsPath)) {\n                ret = 10;\n            }\n            else {\n                return 0;\n            }\n        }\n        return ret;\n    }\n    else {\n        return 0;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../base/common/event.js';\nimport { toDisposable } from '../../base/common/lifecycle.js';\nimport { shouldSynchronizeModel } from './model.js';\nimport { score } from './languageSelector.js';\nfunction isExclusive(selector) {\n    if (typeof selector === 'string') {\n        return false;\n    }\n    else if (Array.isArray(selector)) {\n        return selector.every(isExclusive);\n    }\n    else {\n        return !!selector.exclusive; // TODO: microsoft/TypeScript#42768\n    }\n}\nclass MatchCandidate {\n    constructor(uri, languageId, notebookUri, notebookType) {\n        this.uri = uri;\n        this.languageId = languageId;\n        this.notebookUri = notebookUri;\n        this.notebookType = notebookType;\n    }\n    equals(other) {\n        var _a, _b;\n        return this.notebookType === other.notebookType\n            && this.languageId === other.languageId\n            && this.uri.toString() === other.uri.toString()\n            && ((_a = this.notebookUri) === null || _a === void 0 ? void 0 : _a.toString()) === ((_b = other.notebookUri) === null || _b === void 0 ? void 0 : _b.toString());\n    }\n}\nexport class LanguageFeatureRegistry {\n    constructor(_notebookInfoResolver) {\n        this._notebookInfoResolver = _notebookInfoResolver;\n        this._clock = 0;\n        this._entries = [];\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n    }\n    register(selector, provider) {\n        let entry = {\n            selector,\n            provider,\n            _score: -1,\n            _time: this._clock++\n        };\n        this._entries.push(entry);\n        this._lastCandidate = undefined;\n        this._onDidChange.fire(this._entries.length);\n        return toDisposable(() => {\n            if (entry) {\n                const idx = this._entries.indexOf(entry);\n                if (idx >= 0) {\n                    this._entries.splice(idx, 1);\n                    this._lastCandidate = undefined;\n                    this._onDidChange.fire(this._entries.length);\n                    entry = undefined;\n                }\n            }\n        });\n    }\n    has(model) {\n        return this.all(model).length > 0;\n    }\n    all(model) {\n        if (!model) {\n            return [];\n        }\n        this._updateScores(model);\n        const result = [];\n        // from registry\n        for (const entry of this._entries) {\n            if (entry._score > 0) {\n                result.push(entry.provider);\n            }\n        }\n        return result;\n    }\n    ordered(model) {\n        const result = [];\n        this._orderedForEach(model, entry => result.push(entry.provider));\n        return result;\n    }\n    orderedGroups(model) {\n        const result = [];\n        let lastBucket;\n        let lastBucketScore;\n        this._orderedForEach(model, entry => {\n            if (lastBucket && lastBucketScore === entry._score) {\n                lastBucket.push(entry.provider);\n            }\n            else {\n                lastBucketScore = entry._score;\n                lastBucket = [entry.provider];\n                result.push(lastBucket);\n            }\n        });\n        return result;\n    }\n    _orderedForEach(model, callback) {\n        this._updateScores(model);\n        for (const entry of this._entries) {\n            if (entry._score > 0) {\n                callback(entry);\n            }\n        }\n    }\n    _updateScores(model) {\n        var _a, _b;\n        const notebookInfo = (_a = this._notebookInfoResolver) === null || _a === void 0 ? void 0 : _a.call(this, model.uri);\n        // use the uri (scheme, pattern) of the notebook info iff we have one\n        // otherwise it's the model's/document's uri\n        const candidate = notebookInfo\n            ? new MatchCandidate(model.uri, model.getLanguageId(), notebookInfo.uri, notebookInfo.type)\n            : new MatchCandidate(model.uri, model.getLanguageId(), undefined, undefined);\n        if ((_b = this._lastCandidate) === null || _b === void 0 ? void 0 : _b.equals(candidate)) {\n            // nothing has changed\n            return;\n        }\n        this._lastCandidate = candidate;\n        for (const entry of this._entries) {\n            entry._score = score(entry.selector, candidate.uri, candidate.languageId, shouldSynchronizeModel(model), candidate.notebookUri, candidate.notebookType);\n            if (isExclusive(entry.selector) && entry._score > 0) {\n                // support for one exclusive selector that overwrites\n                // any other selector\n                for (const entry of this._entries) {\n                    entry._score = 0;\n                }\n                entry._score = 1000;\n                break;\n            }\n        }\n        // needs sorting\n        this._entries.sort(LanguageFeatureRegistry._compareByScoreAndTime);\n    }\n    static _compareByScoreAndTime(a, b) {\n        if (a._score < b._score) {\n            return 1;\n        }\n        else if (a._score > b._score) {\n            return -1;\n        }\n        else if (a._time < b._time) {\n            return 1;\n        }\n        else if (a._time > b._time) {\n            return -1;\n        }\n        else {\n            return 0;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Codicon } from '../../base/common/codicons.js';\nimport { URI } from '../../base/common/uri.js';\nimport { Range } from './core/range.js';\nimport { TokenizationRegistry as TokenizationRegistryImpl } from './tokenizationRegistry.js';\nexport class Token {\n    constructor(offset, type, language) {\n        this._tokenBrand = undefined;\n        this.offset = offset;\n        this.type = type;\n        this.language = language;\n    }\n    toString() {\n        return '(' + this.offset + ', ' + this.type + ')';\n    }\n}\n/**\n * @internal\n */\nexport class TokenizationResult {\n    constructor(tokens, endState) {\n        this._tokenizationResultBrand = undefined;\n        this.tokens = tokens;\n        this.endState = endState;\n    }\n}\n/**\n * @internal\n */\nexport class EncodedTokenizationResult {\n    constructor(tokens, endState) {\n        this._encodedTokenizationResultBrand = undefined;\n        this.tokens = tokens;\n        this.endState = endState;\n    }\n}\n/**\n * @internal\n */\nexport var CompletionItemKinds;\n(function (CompletionItemKinds) {\n    const byKind = new Map();\n    byKind.set(0 /* CompletionItemKind.Method */, Codicon.symbolMethod);\n    byKind.set(1 /* CompletionItemKind.Function */, Codicon.symbolFunction);\n    byKind.set(2 /* CompletionItemKind.Constructor */, Codicon.symbolConstructor);\n    byKind.set(3 /* CompletionItemKind.Field */, Codicon.symbolField);\n    byKind.set(4 /* CompletionItemKind.Variable */, Codicon.symbolVariable);\n    byKind.set(5 /* CompletionItemKind.Class */, Codicon.symbolClass);\n    byKind.set(6 /* CompletionItemKind.Struct */, Codicon.symbolStruct);\n    byKind.set(7 /* CompletionItemKind.Interface */, Codicon.symbolInterface);\n    byKind.set(8 /* CompletionItemKind.Module */, Codicon.symbolModule);\n    byKind.set(9 /* CompletionItemKind.Property */, Codicon.symbolProperty);\n    byKind.set(10 /* CompletionItemKind.Event */, Codicon.symbolEvent);\n    byKind.set(11 /* CompletionItemKind.Operator */, Codicon.symbolOperator);\n    byKind.set(12 /* CompletionItemKind.Unit */, Codicon.symbolUnit);\n    byKind.set(13 /* CompletionItemKind.Value */, Codicon.symbolValue);\n    byKind.set(15 /* CompletionItemKind.Enum */, Codicon.symbolEnum);\n    byKind.set(14 /* CompletionItemKind.Constant */, Codicon.symbolConstant);\n    byKind.set(15 /* CompletionItemKind.Enum */, Codicon.symbolEnum);\n    byKind.set(16 /* CompletionItemKind.EnumMember */, Codicon.symbolEnumMember);\n    byKind.set(17 /* CompletionItemKind.Keyword */, Codicon.symbolKeyword);\n    byKind.set(27 /* CompletionItemKind.Snippet */, Codicon.symbolSnippet);\n    byKind.set(18 /* CompletionItemKind.Text */, Codicon.symbolText);\n    byKind.set(19 /* CompletionItemKind.Color */, Codicon.symbolColor);\n    byKind.set(20 /* CompletionItemKind.File */, Codicon.symbolFile);\n    byKind.set(21 /* CompletionItemKind.Reference */, Codicon.symbolReference);\n    byKind.set(22 /* CompletionItemKind.Customcolor */, Codicon.symbolCustomColor);\n    byKind.set(23 /* CompletionItemKind.Folder */, Codicon.symbolFolder);\n    byKind.set(24 /* CompletionItemKind.TypeParameter */, Codicon.symbolTypeParameter);\n    byKind.set(25 /* CompletionItemKind.User */, Codicon.account);\n    byKind.set(26 /* CompletionItemKind.Issue */, Codicon.issues);\n    /**\n     * @internal\n     */\n    function toIcon(kind) {\n        let codicon = byKind.get(kind);\n        if (!codicon) {\n            console.info('No codicon found for CompletionItemKind ' + kind);\n            codicon = Codicon.symbolProperty;\n        }\n        return codicon;\n    }\n    CompletionItemKinds.toIcon = toIcon;\n    const data = new Map();\n    data.set('method', 0 /* CompletionItemKind.Method */);\n    data.set('function', 1 /* CompletionItemKind.Function */);\n    data.set('constructor', 2 /* CompletionItemKind.Constructor */);\n    data.set('field', 3 /* CompletionItemKind.Field */);\n    data.set('variable', 4 /* CompletionItemKind.Variable */);\n    data.set('class', 5 /* CompletionItemKind.Class */);\n    data.set('struct', 6 /* CompletionItemKind.Struct */);\n    data.set('interface', 7 /* CompletionItemKind.Interface */);\n    data.set('module', 8 /* CompletionItemKind.Module */);\n    data.set('property', 9 /* CompletionItemKind.Property */);\n    data.set('event', 10 /* CompletionItemKind.Event */);\n    data.set('operator', 11 /* CompletionItemKind.Operator */);\n    data.set('unit', 12 /* CompletionItemKind.Unit */);\n    data.set('value', 13 /* CompletionItemKind.Value */);\n    data.set('constant', 14 /* CompletionItemKind.Constant */);\n    data.set('enum', 15 /* CompletionItemKind.Enum */);\n    data.set('enum-member', 16 /* CompletionItemKind.EnumMember */);\n    data.set('enumMember', 16 /* CompletionItemKind.EnumMember */);\n    data.set('keyword', 17 /* CompletionItemKind.Keyword */);\n    data.set('snippet', 27 /* CompletionItemKind.Snippet */);\n    data.set('text', 18 /* CompletionItemKind.Text */);\n    data.set('color', 19 /* CompletionItemKind.Color */);\n    data.set('file', 20 /* CompletionItemKind.File */);\n    data.set('reference', 21 /* CompletionItemKind.Reference */);\n    data.set('customcolor', 22 /* CompletionItemKind.Customcolor */);\n    data.set('folder', 23 /* CompletionItemKind.Folder */);\n    data.set('type-parameter', 24 /* CompletionItemKind.TypeParameter */);\n    data.set('typeParameter', 24 /* CompletionItemKind.TypeParameter */);\n    data.set('account', 25 /* CompletionItemKind.User */);\n    data.set('issue', 26 /* CompletionItemKind.Issue */);\n    /**\n     * @internal\n     */\n    function fromString(value, strict) {\n        let res = data.get(value);\n        if (typeof res === 'undefined' && !strict) {\n            res = 9 /* CompletionItemKind.Property */;\n        }\n        return res;\n    }\n    CompletionItemKinds.fromString = fromString;\n})(CompletionItemKinds || (CompletionItemKinds = {}));\n/**\n * How an {@link InlineCompletionsProvider inline completion provider} was triggered.\n */\nexport var InlineCompletionTriggerKind;\n(function (InlineCompletionTriggerKind) {\n    /**\n     * Completion was triggered automatically while editing.\n     * It is sufficient to return a single completion item in this case.\n     */\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Automatic\"] = 0] = \"Automatic\";\n    /**\n     * Completion was triggered explicitly by a user gesture.\n     * Return multiple completion items to enable cycling through them.\n     */\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Explicit\"] = 1] = \"Explicit\";\n})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));\nexport var SignatureHelpTriggerKind;\n(function (SignatureHelpTriggerKind) {\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"Invoke\"] = 1] = \"Invoke\";\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"TriggerCharacter\"] = 2] = \"TriggerCharacter\";\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"ContentChange\"] = 3] = \"ContentChange\";\n})(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));\n/**\n * A document highlight kind.\n */\nexport var DocumentHighlightKind;\n(function (DocumentHighlightKind) {\n    /**\n     * A textual occurrence.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Text\"] = 0] = \"Text\";\n    /**\n     * Read-access of a symbol, like reading a variable.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Read\"] = 1] = \"Read\";\n    /**\n     * Write-access of a symbol, like writing to a variable.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Write\"] = 2] = \"Write\";\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\n/**\n * @internal\n */\nexport function isLocationLink(thing) {\n    return thing\n        && URI.isUri(thing.uri)\n        && Range.isIRange(thing.range)\n        && (Range.isIRange(thing.originSelectionRange) || Range.isIRange(thing.targetSelectionRange));\n}\n/**\n * @internal\n */\nexport var SymbolKinds;\n(function (SymbolKinds) {\n    const byKind = new Map();\n    byKind.set(0 /* SymbolKind.File */, Codicon.symbolFile);\n    byKind.set(1 /* SymbolKind.Module */, Codicon.symbolModule);\n    byKind.set(2 /* SymbolKind.Namespace */, Codicon.symbolNamespace);\n    byKind.set(3 /* SymbolKind.Package */, Codicon.symbolPackage);\n    byKind.set(4 /* SymbolKind.Class */, Codicon.symbolClass);\n    byKind.set(5 /* SymbolKind.Method */, Codicon.symbolMethod);\n    byKind.set(6 /* SymbolKind.Property */, Codicon.symbolProperty);\n    byKind.set(7 /* SymbolKind.Field */, Codicon.symbolField);\n    byKind.set(8 /* SymbolKind.Constructor */, Codicon.symbolConstructor);\n    byKind.set(9 /* SymbolKind.Enum */, Codicon.symbolEnum);\n    byKind.set(10 /* SymbolKind.Interface */, Codicon.symbolInterface);\n    byKind.set(11 /* SymbolKind.Function */, Codicon.symbolFunction);\n    byKind.set(12 /* SymbolKind.Variable */, Codicon.symbolVariable);\n    byKind.set(13 /* SymbolKind.Constant */, Codicon.symbolConstant);\n    byKind.set(14 /* SymbolKind.String */, Codicon.symbolString);\n    byKind.set(15 /* SymbolKind.Number */, Codicon.symbolNumber);\n    byKind.set(16 /* SymbolKind.Boolean */, Codicon.symbolBoolean);\n    byKind.set(17 /* SymbolKind.Array */, Codicon.symbolArray);\n    byKind.set(18 /* SymbolKind.Object */, Codicon.symbolObject);\n    byKind.set(19 /* SymbolKind.Key */, Codicon.symbolKey);\n    byKind.set(20 /* SymbolKind.Null */, Codicon.symbolNull);\n    byKind.set(21 /* SymbolKind.EnumMember */, Codicon.symbolEnumMember);\n    byKind.set(22 /* SymbolKind.Struct */, Codicon.symbolStruct);\n    byKind.set(23 /* SymbolKind.Event */, Codicon.symbolEvent);\n    byKind.set(24 /* SymbolKind.Operator */, Codicon.symbolOperator);\n    byKind.set(25 /* SymbolKind.TypeParameter */, Codicon.symbolTypeParameter);\n    /**\n     * @internal\n     */\n    function toIcon(kind) {\n        let icon = byKind.get(kind);\n        if (!icon) {\n            console.info('No codicon found for SymbolKind ' + kind);\n            icon = Codicon.symbolProperty;\n        }\n        return icon;\n    }\n    SymbolKinds.toIcon = toIcon;\n})(SymbolKinds || (SymbolKinds = {}));\nexport class FoldingRangeKind {\n    /**\n     * Creates a new {@link FoldingRangeKind}.\n     *\n     * @param value of the kind.\n     */\n    constructor(value) {\n        this.value = value;\n    }\n}\n/**\n * Kind for folding range representing a comment. The value of the kind is 'comment'.\n */\nFoldingRangeKind.Comment = new FoldingRangeKind('comment');\n/**\n * Kind for folding range representing a import. The value of the kind is 'imports'.\n */\nFoldingRangeKind.Imports = new FoldingRangeKind('imports');\n/**\n * Kind for folding range representing regions (for example marked by `#region`, `#endregion`).\n * The value of the kind is 'region'.\n */\nFoldingRangeKind.Region = new FoldingRangeKind('region');\n/**\n * @internal\n */\nexport var Command;\n(function (Command) {\n    /**\n     * @internal\n     */\n    function is(obj) {\n        if (!obj || typeof obj !== 'object') {\n            return false;\n        }\n        return typeof obj.id === 'string' &&\n            typeof obj.title === 'string';\n    }\n    Command.is = is;\n})(Command || (Command = {}));\nexport var InlayHintKind;\n(function (InlayHintKind) {\n    InlayHintKind[InlayHintKind[\"Type\"] = 1] = \"Type\";\n    InlayHintKind[InlayHintKind[\"Parameter\"] = 2] = \"Parameter\";\n})(InlayHintKind || (InlayHintKind = {}));\n/**\n * @internal\n */\nexport const TokenizationRegistry = new TokenizationRegistryImpl();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { IndentAction } from './languageConfiguration.js';\nimport { createScopedLineTokens } from './supports.js';\nimport { getScopedLineTokens } from './languageConfigurationRegistry.js';\n/**\n * Get nearest preceding line which doesn't match unIndentPattern or contains all whitespace.\n * Result:\n * -1: run into the boundary of embedded languages\n * 0: every line above are invalid\n * else: nearest preceding line of the same language\n */\nfunction getPrecedingValidLine(model, lineNumber, indentRulesSupport) {\n    const languageId = model.tokenization.getLanguageIdAtPosition(lineNumber, 0);\n    if (lineNumber > 1) {\n        let lastLineNumber;\n        let resultLineNumber = -1;\n        for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n            if (model.tokenization.getLanguageIdAtPosition(lastLineNumber, 0) !== languageId) {\n                return resultLineNumber;\n            }\n            const text = model.getLineContent(lastLineNumber);\n            if (indentRulesSupport.shouldIgnore(text) || /^\\s+$/.test(text) || text === '') {\n                resultLineNumber = lastLineNumber;\n                continue;\n            }\n            return lastLineNumber;\n        }\n    }\n    return -1;\n}\n/**\n * Get inherited indentation from above lines.\n * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.\n * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.\n * 3. If this line doesn't match any indent rules\n *   a. check whether the line above it matches indentNextLinePattern\n *   b. If not, the indent level of this line is the result\n *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).\n * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`\n *\n * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.\n */\nexport function getInheritIndentForLine(autoIndent, model, lineNumber, honorIntentialIndent = true, languageConfigurationService) {\n    if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n        return null;\n    }\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(model.tokenization.getLanguageId()).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    if (lineNumber <= 1) {\n        return {\n            indentation: '',\n            action: null\n        };\n    }\n    const precedingUnIgnoredLine = getPrecedingValidLine(model, lineNumber, indentRulesSupport);\n    if (precedingUnIgnoredLine < 0) {\n        return null;\n    }\n    else if (precedingUnIgnoredLine < 1) {\n        return {\n            indentation: '',\n            action: null\n        };\n    }\n    const precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\n    if (indentRulesSupport.shouldIncrease(precedingUnIgnoredLineContent) || indentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLineContent)) {\n        return {\n            indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n            action: IndentAction.Indent,\n            line: precedingUnIgnoredLine\n        };\n    }\n    else if (indentRulesSupport.shouldDecrease(precedingUnIgnoredLineContent)) {\n        return {\n            indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n            action: null,\n            line: precedingUnIgnoredLine\n        };\n    }\n    else {\n        // precedingUnIgnoredLine can not be ignored.\n        // it doesn't increase indent of following lines\n        // it doesn't increase just next line\n        // so current line is not affect by precedingUnIgnoredLine\n        // and then we should get a correct inheritted indentation from above lines\n        if (precedingUnIgnoredLine === 1) {\n            return {\n                indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n                action: null,\n                line: precedingUnIgnoredLine\n            };\n        }\n        const previousLine = precedingUnIgnoredLine - 1;\n        const previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));\n        if (!(previousLineIndentMetadata & (1 /* IndentConsts.INCREASE_MASK */ | 2 /* IndentConsts.DECREASE_MASK */)) &&\n            (previousLineIndentMetadata & 4 /* IndentConsts.INDENT_NEXTLINE_MASK */)) {\n            let stopLine = 0;\n            for (let i = previousLine - 1; i > 0; i--) {\n                if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n                    continue;\n                }\n                stopLine = i;\n                break;\n            }\n            return {\n                indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n                action: null,\n                line: stopLine + 1\n            };\n        }\n        if (honorIntentialIndent) {\n            return {\n                indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n                action: null,\n                line: precedingUnIgnoredLine\n            };\n        }\n        else {\n            // search from precedingUnIgnoredLine until we find one whose indent is not temporary\n            for (let i = precedingUnIgnoredLine; i > 0; i--) {\n                const lineContent = model.getLineContent(i);\n                if (indentRulesSupport.shouldIncrease(lineContent)) {\n                    return {\n                        indentation: strings.getLeadingWhitespace(lineContent),\n                        action: IndentAction.Indent,\n                        line: i\n                    };\n                }\n                else if (indentRulesSupport.shouldIndentNextLine(lineContent)) {\n                    let stopLine = 0;\n                    for (let j = i - 1; j > 0; j--) {\n                        if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n                            continue;\n                        }\n                        stopLine = j;\n                        break;\n                    }\n                    return {\n                        indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n                        action: null,\n                        line: stopLine + 1\n                    };\n                }\n                else if (indentRulesSupport.shouldDecrease(lineContent)) {\n                    return {\n                        indentation: strings.getLeadingWhitespace(lineContent),\n                        action: null,\n                        line: i\n                    };\n                }\n            }\n            return {\n                indentation: strings.getLeadingWhitespace(model.getLineContent(1)),\n                action: null,\n                line: 1\n            };\n        }\n    }\n}\nexport function getGoodIndentForLine(autoIndent, virtualModel, languageId, lineNumber, indentConverter, languageConfigurationService) {\n    if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n        return null;\n    }\n    const richEditSupport = languageConfigurationService.getLanguageConfiguration(languageId);\n    if (!richEditSupport) {\n        return null;\n    }\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(languageId).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    const indent = getInheritIndentForLine(autoIndent, virtualModel, lineNumber, undefined, languageConfigurationService);\n    const lineContent = virtualModel.getLineContent(lineNumber);\n    if (indent) {\n        const inheritLine = indent.line;\n        if (inheritLine !== undefined) {\n            const enterResult = richEditSupport.onEnter(autoIndent, '', virtualModel.getLineContent(inheritLine), '');\n            if (enterResult) {\n                let indentation = strings.getLeadingWhitespace(virtualModel.getLineContent(inheritLine));\n                if (enterResult.removeText) {\n                    indentation = indentation.substring(0, indentation.length - enterResult.removeText);\n                }\n                if ((enterResult.indentAction === IndentAction.Indent) ||\n                    (enterResult.indentAction === IndentAction.IndentOutdent)) {\n                    indentation = indentConverter.shiftIndent(indentation);\n                }\n                else if (enterResult.indentAction === IndentAction.Outdent) {\n                    indentation = indentConverter.unshiftIndent(indentation);\n                }\n                if (indentRulesSupport.shouldDecrease(lineContent)) {\n                    indentation = indentConverter.unshiftIndent(indentation);\n                }\n                if (enterResult.appendText) {\n                    indentation += enterResult.appendText;\n                }\n                return strings.getLeadingWhitespace(indentation);\n            }\n        }\n        if (indentRulesSupport.shouldDecrease(lineContent)) {\n            if (indent.action === IndentAction.Indent) {\n                return indent.indentation;\n            }\n            else {\n                return indentConverter.unshiftIndent(indent.indentation);\n            }\n        }\n        else {\n            if (indent.action === IndentAction.Indent) {\n                return indentConverter.shiftIndent(indent.indentation);\n            }\n            else {\n                return indent.indentation;\n            }\n        }\n    }\n    return null;\n}\nexport function getIndentForEnter(autoIndent, model, range, indentConverter, languageConfigurationService) {\n    if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n        return null;\n    }\n    model.tokenization.forceTokenization(range.startLineNumber);\n    const lineTokens = model.tokenization.getLineTokens(range.startLineNumber);\n    const scopedLineTokens = createScopedLineTokens(lineTokens, range.startColumn - 1);\n    const scopedLineText = scopedLineTokens.getLineContent();\n    let embeddedLanguage = false;\n    let beforeEnterText;\n    if (scopedLineTokens.firstCharOffset > 0 && lineTokens.getLanguageId(0) !== scopedLineTokens.languageId) {\n        // we are in the embeded language content\n        embeddedLanguage = true; // if embeddedLanguage is true, then we don't touch the indentation of current line\n        beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    else {\n        beforeEnterText = lineTokens.getLineContent().substring(0, range.startColumn - 1);\n    }\n    let afterEnterText;\n    if (range.isEmpty()) {\n        afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    else {\n        const endScopedLineTokens = getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n        afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    const beforeEnterResult = beforeEnterText;\n    const beforeEnterIndent = strings.getLeadingWhitespace(beforeEnterText);\n    const virtualModel = {\n        tokenization: {\n            getLineTokens: (lineNumber) => {\n                return model.tokenization.getLineTokens(lineNumber);\n            },\n            getLanguageId: () => {\n                return model.getLanguageId();\n            },\n            getLanguageIdAtPosition: (lineNumber, column) => {\n                return model.getLanguageIdAtPosition(lineNumber, column);\n            },\n        },\n        getLineContent: (lineNumber) => {\n            if (lineNumber === range.startLineNumber) {\n                return beforeEnterResult;\n            }\n            else {\n                return model.getLineContent(lineNumber);\n            }\n        }\n    };\n    const currentLineIndent = strings.getLeadingWhitespace(lineTokens.getLineContent());\n    const afterEnterAction = getInheritIndentForLine(autoIndent, virtualModel, range.startLineNumber + 1, undefined, languageConfigurationService);\n    if (!afterEnterAction) {\n        const beforeEnter = embeddedLanguage ? currentLineIndent : beforeEnterIndent;\n        return {\n            beforeEnter: beforeEnter,\n            afterEnter: beforeEnter\n        };\n    }\n    let afterEnterIndent = embeddedLanguage ? currentLineIndent : afterEnterAction.indentation;\n    if (afterEnterAction.action === IndentAction.Indent) {\n        afterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);\n    }\n    if (indentRulesSupport.shouldDecrease(afterEnterText)) {\n        afterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);\n    }\n    return {\n        beforeEnter: embeddedLanguage ? currentLineIndent : beforeEnterIndent,\n        afterEnter: afterEnterIndent\n    };\n}\n/**\n * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of\n * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.\n */\nexport function getIndentActionForType(autoIndent, model, range, ch, indentConverter, languageConfigurationService) {\n    if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n        return null;\n    }\n    const scopedLineTokens = getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n    if (scopedLineTokens.firstCharOffset) {\n        // this line has mixed languages and indentation rules will not work\n        return null;\n    }\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    const scopedLineText = scopedLineTokens.getLineContent();\n    const beforeTypeText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    // selection support\n    let afterTypeText;\n    if (range.isEmpty()) {\n        afterTypeText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    else {\n        const endScopedLineTokens = getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n        afterTypeText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    // If previous content already matches decreaseIndentPattern, it means indentation of this line should already be adjusted\n    // Users might change the indentation by purpose and we should honor that instead of readjusting.\n    if (!indentRulesSupport.shouldDecrease(beforeTypeText + afterTypeText) && indentRulesSupport.shouldDecrease(beforeTypeText + ch + afterTypeText)) {\n        // after typing `ch`, the content matches decreaseIndentPattern, we should adjust the indent to a good manner.\n        // 1. Get inherited indent action\n        const r = getInheritIndentForLine(autoIndent, model, range.startLineNumber, false, languageConfigurationService);\n        if (!r) {\n            return null;\n        }\n        let indentation = r.indentation;\n        if (r.action !== IndentAction.Indent) {\n            indentation = indentConverter.unshiftIndent(indentation);\n        }\n        return indentation;\n    }\n    return null;\n}\nexport function getIndentMetadata(model, lineNumber, languageConfigurationService) {\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    if (lineNumber < 1 || lineNumber > model.getLineCount()) {\n        return null;\n    }\n    return indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IndentAction } from './languageConfiguration.js';\nimport { getIndentationAtPosition, getScopedLineTokens } from './languageConfigurationRegistry.js';\nexport function getEnterAction(autoIndent, model, range, languageConfigurationService) {\n    const scopedLineTokens = getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n    const richEditSupport = languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId);\n    if (!richEditSupport) {\n        return null;\n    }\n    const scopedLineText = scopedLineTokens.getLineContent();\n    const beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    // selection support\n    let afterEnterText;\n    if (range.isEmpty()) {\n        afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    else {\n        const endScopedLineTokens = getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n        afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    let previousLineText = '';\n    if (range.startLineNumber > 1 && scopedLineTokens.firstCharOffset === 0) {\n        // This is not the first line and the entire line belongs to this mode\n        const oneLineAboveScopedLineTokens = getScopedLineTokens(model, range.startLineNumber - 1);\n        if (oneLineAboveScopedLineTokens.languageId === scopedLineTokens.languageId) {\n            // The line above ends with text belonging to the same mode\n            previousLineText = oneLineAboveScopedLineTokens.getLineContent();\n        }\n    }\n    const enterResult = richEditSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n    if (!enterResult) {\n        return null;\n    }\n    const indentAction = enterResult.indentAction;\n    let appendText = enterResult.appendText;\n    const removeText = enterResult.removeText || 0;\n    // Here we add `\\t` to appendText first because enterAction is leveraging appendText and removeText to change indentation.\n    if (!appendText) {\n        if ((indentAction === IndentAction.Indent) ||\n            (indentAction === IndentAction.IndentOutdent)) {\n            appendText = '\\t';\n        }\n        else {\n            appendText = '';\n        }\n    }\n    else if (indentAction === IndentAction.Indent) {\n        appendText = '\\t' + appendText;\n    }\n    let indentation = getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n    if (removeText) {\n        indentation = indentation.substring(0, indentation.length - removeText);\n    }\n    return {\n        indentAction: indentAction,\n        appendText: appendText,\n        removeText: removeText,\n        indentation: indentation\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ILanguageService = createDecorator('languageService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Describes what to do with the indentation when pressing Enter.\n */\nexport var IndentAction;\n(function (IndentAction) {\n    /**\n     * Insert new line and copy the previous line's indentation.\n     */\n    IndentAction[IndentAction[\"None\"] = 0] = \"None\";\n    /**\n     * Insert new line and indent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Indent\"] = 1] = \"Indent\";\n    /**\n     * Insert two new lines:\n     *  - the first one indented which will hold the cursor\n     *  - the second one at the same indentation level\n     */\n    IndentAction[IndentAction[\"IndentOutdent\"] = 2] = \"IndentOutdent\";\n    /**\n     * Insert new line and outdent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Outdent\"] = 3] = \"Outdent\";\n})(IndentAction || (IndentAction = {}));\n/**\n * @internal\n */\nexport class StandardAutoClosingPairConditional {\n    constructor(source) {\n        this._neutralCharacter = null;\n        this._neutralCharacterSearched = false;\n        this.open = source.open;\n        this.close = source.close;\n        // initially allowed in all tokens\n        this._inString = true;\n        this._inComment = true;\n        this._inRegEx = true;\n        if (Array.isArray(source.notIn)) {\n            for (let i = 0, len = source.notIn.length; i < len; i++) {\n                const notIn = source.notIn[i];\n                switch (notIn) {\n                    case 'string':\n                        this._inString = false;\n                        break;\n                    case 'comment':\n                        this._inComment = false;\n                        break;\n                    case 'regex':\n                        this._inRegEx = false;\n                        break;\n                }\n            }\n        }\n    }\n    isOK(standardToken) {\n        switch (standardToken) {\n            case 0 /* StandardTokenType.Other */:\n                return true;\n            case 1 /* StandardTokenType.Comment */:\n                return this._inComment;\n            case 2 /* StandardTokenType.String */:\n                return this._inString;\n            case 3 /* StandardTokenType.RegEx */:\n                return this._inRegEx;\n        }\n    }\n    shouldAutoClose(context, column) {\n        // Always complete on empty line\n        if (context.getTokenCount() === 0) {\n            return true;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 2);\n        const standardTokenType = context.getStandardTokenType(tokenIndex);\n        return this.isOK(standardTokenType);\n    }\n    _findNeutralCharacterInRange(fromCharCode, toCharCode) {\n        for (let charCode = fromCharCode; charCode <= toCharCode; charCode++) {\n            const character = String.fromCharCode(charCode);\n            if (!this.open.includes(character) && !this.close.includes(character)) {\n                return character;\n            }\n        }\n        return null;\n    }\n    /**\n     * Find a character in the range [0-9a-zA-Z] that does not appear in the open or close\n     */\n    findNeutralCharacter() {\n        if (!this._neutralCharacterSearched) {\n            this._neutralCharacterSearched = true;\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(48 /* CharCode.Digit0 */, 57 /* CharCode.Digit9 */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(97 /* CharCode.a */, 122 /* CharCode.z */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(65 /* CharCode.A */, 90 /* CharCode.Z */);\n            }\n        }\n        return this._neutralCharacter;\n    }\n}\n/**\n * @internal\n */\nexport class AutoClosingPairs {\n    constructor(autoClosingPairs) {\n        this.autoClosingPairsOpenByStart = new Map();\n        this.autoClosingPairsOpenByEnd = new Map();\n        this.autoClosingPairsCloseByStart = new Map();\n        this.autoClosingPairsCloseByEnd = new Map();\n        this.autoClosingPairsCloseSingleChar = new Map();\n        for (const pair of autoClosingPairs) {\n            appendEntry(this.autoClosingPairsOpenByStart, pair.open.charAt(0), pair);\n            appendEntry(this.autoClosingPairsOpenByEnd, pair.open.charAt(pair.open.length - 1), pair);\n            appendEntry(this.autoClosingPairsCloseByStart, pair.close.charAt(0), pair);\n            appendEntry(this.autoClosingPairsCloseByEnd, pair.close.charAt(pair.close.length - 1), pair);\n            if (pair.close.length === 1 && pair.open.length === 1) {\n                appendEntry(this.autoClosingPairsCloseSingleChar, pair.close, pair);\n            }\n        }\n    }\n}\nfunction appendEntry(target, key, value) {\n    if (target.has(key)) {\n        target.get(key).push(value);\n    }\n    else {\n        target.set(key, [value]);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { StandardAutoClosingPairConditional } from '../languageConfiguration.js';\nexport class CharacterPairSupport {\n    constructor(config) {\n        if (config.autoClosingPairs) {\n            this._autoClosingPairs = config.autoClosingPairs.map(el => new StandardAutoClosingPairConditional(el));\n        }\n        else if (config.brackets) {\n            this._autoClosingPairs = config.brackets.map(b => new StandardAutoClosingPairConditional({ open: b[0], close: b[1] }));\n        }\n        else {\n            this._autoClosingPairs = [];\n        }\n        if (config.__electricCharacterSupport && config.__electricCharacterSupport.docComment) {\n            const docComment = config.__electricCharacterSupport.docComment;\n            // IDocComment is legacy, only partially supported\n            this._autoClosingPairs.push(new StandardAutoClosingPairConditional({ open: docComment.open, close: docComment.close || '' }));\n        }\n        this._autoCloseBefore = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED;\n        this._surroundingPairs = config.surroundingPairs || this._autoClosingPairs;\n    }\n    getAutoClosingPairs() {\n        return this._autoClosingPairs;\n    }\n    getAutoCloseBeforeSet() {\n        return this._autoCloseBefore;\n    }\n    getSurroundingPairs() {\n        return this._surroundingPairs;\n    }\n}\nCharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED = ';:.,=}])> \\n\\t';\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { distinct } from '../../../../base/common/arrays.js';\nimport { ignoreBracketsInToken } from '../supports.js';\nimport { BracketsUtils } from './richEditBrackets.js';\nexport class BracketElectricCharacterSupport {\n    constructor(richEditBrackets) {\n        this._richEditBrackets = richEditBrackets;\n    }\n    getElectricCharacters() {\n        const result = [];\n        if (this._richEditBrackets) {\n            for (const bracket of this._richEditBrackets.brackets) {\n                for (const close of bracket.close) {\n                    const lastChar = close.charAt(close.length - 1);\n                    result.push(lastChar);\n                }\n            }\n        }\n        return distinct(result);\n    }\n    onElectricCharacter(character, context, column) {\n        if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) {\n            return null;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 1);\n        if (ignoreBracketsInToken(context.getStandardTokenType(tokenIndex))) {\n            return null;\n        }\n        const reversedBracketRegex = this._richEditBrackets.reversedRegex;\n        const text = context.getLineContent().substring(0, column - 1) + character;\n        const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, 1, text, 0, text.length);\n        if (!r) {\n            return null;\n        }\n        const bracketText = text.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n        const isOpen = this._richEditBrackets.textIsOpenBracket[bracketText];\n        if (isOpen) {\n            return null;\n        }\n        const textBeforeBracket = context.getActualLineContentBefore(r.startColumn - 1);\n        if (!/^\\s*$/.test(textBeforeBracket)) {\n            // There is other text on the line before the bracket\n            return null;\n        }\n        return {\n            matchOpenBracket: bracketText\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction resetGlobalRegex(reg) {\n    if (reg.global) {\n        reg.lastIndex = 0;\n    }\n    return true;\n}\nexport class IndentRulesSupport {\n    constructor(indentationRules) {\n        this._indentationRules = indentationRules;\n    }\n    shouldIncrease(text) {\n        if (this._indentationRules) {\n            if (this._indentationRules.increaseIndentPattern && resetGlobalRegex(this._indentationRules.increaseIndentPattern) && this._indentationRules.increaseIndentPattern.test(text)) {\n                return true;\n            }\n            // if (this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(text)) {\n            // \treturn true;\n            // }\n        }\n        return false;\n    }\n    shouldDecrease(text) {\n        if (this._indentationRules && this._indentationRules.decreaseIndentPattern && resetGlobalRegex(this._indentationRules.decreaseIndentPattern) && this._indentationRules.decreaseIndentPattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIndentNextLine(text) {\n        if (this._indentationRules && this._indentationRules.indentNextLinePattern && resetGlobalRegex(this._indentationRules.indentNextLinePattern) && this._indentationRules.indentNextLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIgnore(text) {\n        // the text matches `unIndentedLinePattern`\n        if (this._indentationRules && this._indentationRules.unIndentedLinePattern && resetGlobalRegex(this._indentationRules.unIndentedLinePattern) && this._indentationRules.unIndentedLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    getIndentMetadata(text) {\n        let ret = 0;\n        if (this.shouldIncrease(text)) {\n            ret += 1 /* IndentConsts.INCREASE_MASK */;\n        }\n        if (this.shouldDecrease(text)) {\n            ret += 2 /* IndentConsts.DECREASE_MASK */;\n        }\n        if (this.shouldIndentNextLine(text)) {\n            ret += 4 /* IndentConsts.INDENT_NEXTLINE_MASK */;\n        }\n        if (this.shouldIgnore(text)) {\n            ret += 8 /* IndentConsts.UNINDENT_MASK */;\n        }\n        return ret;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { IndentAction } from '../languageConfiguration.js';\nexport class OnEnterSupport {\n    constructor(opts) {\n        opts = opts || {};\n        opts.brackets = opts.brackets || [\n            ['(', ')'],\n            ['{', '}'],\n            ['[', ']']\n        ];\n        this._brackets = [];\n        opts.brackets.forEach((bracket) => {\n            const openRegExp = OnEnterSupport._createOpenBracketRegExp(bracket[0]);\n            const closeRegExp = OnEnterSupport._createCloseBracketRegExp(bracket[1]);\n            if (openRegExp && closeRegExp) {\n                this._brackets.push({\n                    open: bracket[0],\n                    openRegExp: openRegExp,\n                    close: bracket[1],\n                    closeRegExp: closeRegExp,\n                });\n            }\n        });\n        this._regExpRules = opts.onEnterRules || [];\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        // (1): `regExpRules`\n        if (autoIndent >= 3 /* EditorAutoIndentStrategy.Advanced */) {\n            for (let i = 0, len = this._regExpRules.length; i < len; i++) {\n                const rule = this._regExpRules[i];\n                const regResult = [{\n                        reg: rule.beforeText,\n                        text: beforeEnterText\n                    }, {\n                        reg: rule.afterText,\n                        text: afterEnterText\n                    }, {\n                        reg: rule.previousLineText,\n                        text: previousLineText\n                    }].every((obj) => {\n                    if (!obj.reg) {\n                        return true;\n                    }\n                    obj.reg.lastIndex = 0; // To disable the effect of the \"g\" flag.\n                    return obj.reg.test(obj.text);\n                });\n                if (regResult) {\n                    return rule.action;\n                }\n            }\n        }\n        // (2): Special indent-outdent\n        if (autoIndent >= 2 /* EditorAutoIndentStrategy.Brackets */) {\n            if (beforeEnterText.length > 0 && afterEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    const bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText) && bracket.closeRegExp.test(afterEnterText)) {\n                        return { indentAction: IndentAction.IndentOutdent };\n                    }\n                }\n            }\n        }\n        // (4): Open bracket based logic\n        if (autoIndent >= 2 /* EditorAutoIndentStrategy.Brackets */) {\n            if (beforeEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    const bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText)) {\n                        return { indentAction: IndentAction.Indent };\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    static _createOpenBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(0))) {\n            str = '\\\\b' + str;\n        }\n        str += '\\\\s*$';\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _createCloseBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(str.length - 1))) {\n            str = str + '\\\\b';\n        }\n        str = '^\\\\s*' + str;\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _safeRegExp(def) {\n        try {\n            return new RegExp(def);\n        }\n        catch (err) {\n            onUnexpectedError(err);\n            return null;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CachedFunction } from '../../../../base/common/cache.js';\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\n/**\n * Captures all bracket related configurations for a single language.\n * Immutable.\n*/\nexport class LanguageBracketsConfiguration {\n    constructor(languageId, config) {\n        this.languageId = languageId;\n        let brackets;\n        // Prefer colorized bracket pairs, as they are more accurate.\n        // TODO@hediet: Deprecate `colorizedBracketPairs` and increase accuracy for brackets.\n        if (config.colorizedBracketPairs) {\n            brackets = filterValidBrackets(config.colorizedBracketPairs.map(b => [b[0], b[1]]));\n        }\n        else if (config.brackets) {\n            brackets = filterValidBrackets(config.brackets\n                .map((b) => [b[0], b[1]])\n                // Many languages set < ... > as bracket pair, even though they also use it as comparison operator.\n                // This leads to problems when colorizing this bracket, so we exclude it by default.\n                // Languages can still override this by configuring `colorizedBracketPairs`\n                // https://github.com/microsoft/vscode/issues/132476\n                .filter((p) => !(p[0] === '<' && p[1] === '>')));\n        }\n        else {\n            brackets = [];\n        }\n        const openingBracketInfos = new CachedFunction((bracket) => {\n            const closing = new Set();\n            return {\n                info: new OpeningBracketKind(this, bracket, closing),\n                closing,\n            };\n        });\n        const closingBracketInfos = new CachedFunction((bracket) => {\n            const opening = new Set();\n            return {\n                info: new ClosingBracketKind(this, bracket, opening),\n                opening,\n            };\n        });\n        for (const [open, close] of brackets) {\n            const opening = openingBracketInfos.get(open);\n            const closing = closingBracketInfos.get(close);\n            opening.closing.add(closing.info);\n            closing.opening.add(opening.info);\n        }\n        this._openingBrackets = new Map([...openingBracketInfos.cachedValues].map(([k, v]) => [k, v.info]));\n        this._closingBrackets = new Map([...closingBracketInfos.cachedValues].map(([k, v]) => [k, v.info]));\n    }\n    /**\n     * No two brackets have the same bracket text.\n    */\n    get openingBrackets() {\n        return [...this._openingBrackets.values()];\n    }\n    /**\n     * No two brackets have the same bracket text.\n    */\n    get closingBrackets() {\n        return [...this._closingBrackets.values()];\n    }\n    getOpeningBracketInfo(bracketText) {\n        return this._openingBrackets.get(bracketText);\n    }\n    getClosingBracketInfo(bracketText) {\n        return this._closingBrackets.get(bracketText);\n    }\n    getBracketInfo(bracketText) {\n        return this.getOpeningBracketInfo(bracketText) || this.getClosingBracketInfo(bracketText);\n    }\n}\nfunction filterValidBrackets(bracketPairs) {\n    return bracketPairs.filter(([open, close]) => open !== '' && close !== '');\n}\nexport class BracketKindBase {\n    constructor(config, bracketText) {\n        this.config = config;\n        this.bracketText = bracketText;\n    }\n    get languageId() {\n        return this.config.languageId;\n    }\n}\nexport class OpeningBracketKind extends BracketKindBase {\n    constructor(config, bracketText, openedBrackets) {\n        super(config, bracketText);\n        this.openedBrackets = openedBrackets;\n        this.isOpeningBracket = true;\n    }\n}\nexport class ClosingBracketKind extends BracketKindBase {\n    constructor(config, bracketText, \n    /**\n     * Non empty array of all opening brackets this bracket closes.\n    */\n    closedBrackets) {\n        super(config, bracketText);\n        this.closedBrackets = closedBrackets;\n        this.isOpeningBracket = false;\n    }\n    /**\n     * Checks if this bracket closes the given other bracket.\n     * Brackets from other language configuration can be used (they will always return false).\n     * If other is a bracket with the same language id, they have to be from the same configuration.\n    */\n    closes(other) {\n        if (other.languageId === this.languageId) {\n            if (other['config'] !== this.config) {\n                throw new BugIndicatingError('Brackets from different language configuration cannot be used.');\n            }\n        }\n        return this.closedBrackets.has(other);\n    }\n    getClosedBrackets() {\n        return [...this.closedBrackets];\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { DEFAULT_WORD_REGEXP, ensureValidWordDefinition } from '../core/wordHelper.js';\nimport { AutoClosingPairs } from './languageConfiguration.js';\nimport { createScopedLineTokens } from './supports.js';\nimport { CharacterPairSupport } from './supports/characterPair.js';\nimport { BracketElectricCharacterSupport } from './supports/electricCharacter.js';\nimport { IndentRulesSupport } from './supports/indentRules.js';\nimport { OnEnterSupport } from './supports/onEnter.js';\nimport { RichEditBrackets } from './supports/richEditBrackets.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { ILanguageService } from './language.js';\nimport { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nimport { PLAINTEXT_LANGUAGE_ID } from './modesRegistry.js';\nimport { LanguageBracketsConfiguration } from './supports/languageBracketsConfiguration.js';\nexport class LanguageConfigurationServiceChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n    affects(languageId) {\n        return !this.languageId ? true : this.languageId === languageId;\n    }\n}\nexport const ILanguageConfigurationService = createDecorator('languageConfigurationService');\nlet LanguageConfigurationService = class LanguageConfigurationService extends Disposable {\n    constructor(configurationService, languageService) {\n        super();\n        this.configurationService = configurationService;\n        this.languageService = languageService;\n        this._registry = this._register(new LanguageConfigurationRegistry());\n        this.onDidChangeEmitter = this._register(new Emitter());\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.configurations = new Map();\n        const languageConfigKeys = new Set(Object.values(customizedLanguageConfigKeys));\n        this._register(this.configurationService.onDidChangeConfiguration((e) => {\n            const globalConfigChanged = e.change.keys.some((k) => languageConfigKeys.has(k));\n            const localConfigChanged = e.change.overrides\n                .filter(([overrideLangName, keys]) => keys.some((k) => languageConfigKeys.has(k)))\n                .map(([overrideLangName]) => overrideLangName);\n            if (globalConfigChanged) {\n                this.configurations.clear();\n                this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(undefined));\n            }\n            else {\n                for (const languageId of localConfigChanged) {\n                    if (this.languageService.isRegisteredLanguageId(languageId)) {\n                        this.configurations.delete(languageId);\n                        this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(languageId));\n                    }\n                }\n            }\n        }));\n        this._register(this._registry.onDidChange((e) => {\n            this.configurations.delete(e.languageId);\n            this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(e.languageId));\n        }));\n    }\n    register(languageId, configuration, priority) {\n        return this._registry.register(languageId, configuration, priority);\n    }\n    getLanguageConfiguration(languageId) {\n        let result = this.configurations.get(languageId);\n        if (!result) {\n            result = computeConfig(languageId, this._registry, this.configurationService, this.languageService);\n            this.configurations.set(languageId, result);\n        }\n        return result;\n    }\n};\nLanguageConfigurationService = __decorate([\n    __param(0, IConfigurationService),\n    __param(1, ILanguageService)\n], LanguageConfigurationService);\nexport { LanguageConfigurationService };\nfunction computeConfig(languageId, registry, configurationService, languageService) {\n    let languageConfig = registry.getLanguageConfiguration(languageId);\n    if (!languageConfig) {\n        if (!languageService.isRegisteredLanguageId(languageId)) {\n            throw new Error(`Language id \"${languageId}\" is not configured nor known`);\n        }\n        languageConfig = new ResolvedLanguageConfiguration(languageId, {});\n    }\n    const customizedConfig = getCustomizedLanguageConfig(languageConfig.languageId, configurationService);\n    const data = combineLanguageConfigurations([languageConfig.underlyingConfig, customizedConfig]);\n    const config = new ResolvedLanguageConfiguration(languageConfig.languageId, data);\n    return config;\n}\nconst customizedLanguageConfigKeys = {\n    brackets: 'editor.language.brackets',\n    colorizedBracketPairs: 'editor.language.colorizedBracketPairs'\n};\nfunction getCustomizedLanguageConfig(languageId, configurationService) {\n    const brackets = configurationService.getValue(customizedLanguageConfigKeys.brackets, {\n        overrideIdentifier: languageId,\n    });\n    const colorizedBracketPairs = configurationService.getValue(customizedLanguageConfigKeys.colorizedBracketPairs, {\n        overrideIdentifier: languageId,\n    });\n    return {\n        brackets: validateBracketPairs(brackets),\n        colorizedBracketPairs: validateBracketPairs(colorizedBracketPairs),\n    };\n}\nfunction validateBracketPairs(data) {\n    if (!Array.isArray(data)) {\n        return undefined;\n    }\n    return data.map(pair => {\n        if (!Array.isArray(pair) || pair.length !== 2) {\n            return undefined;\n        }\n        return [pair[0], pair[1]];\n    }).filter((p) => !!p);\n}\nexport function getIndentationAtPosition(model, lineNumber, column) {\n    const lineText = model.getLineContent(lineNumber);\n    let indentation = strings.getLeadingWhitespace(lineText);\n    if (indentation.length > column - 1) {\n        indentation = indentation.substring(0, column - 1);\n    }\n    return indentation;\n}\nexport function getScopedLineTokens(model, lineNumber, columnNumber) {\n    model.tokenization.forceTokenization(lineNumber);\n    const lineTokens = model.tokenization.getLineTokens(lineNumber);\n    const column = (typeof columnNumber === 'undefined' ? model.getLineMaxColumn(lineNumber) - 1 : columnNumber - 1);\n    return createScopedLineTokens(lineTokens, column);\n}\nclass ComposedLanguageConfiguration {\n    constructor(languageId) {\n        this.languageId = languageId;\n        this._resolved = null;\n        this._entries = [];\n        this._order = 0;\n        this._resolved = null;\n    }\n    register(configuration, priority) {\n        const entry = new LanguageConfigurationContribution(configuration, priority, ++this._order);\n        this._entries.push(entry);\n        this._resolved = null;\n        return toDisposable(() => {\n            for (let i = 0; i < this._entries.length; i++) {\n                if (this._entries[i] === entry) {\n                    this._entries.splice(i, 1);\n                    this._resolved = null;\n                    break;\n                }\n            }\n        });\n    }\n    getResolvedConfiguration() {\n        if (!this._resolved) {\n            const config = this._resolve();\n            if (config) {\n                this._resolved = new ResolvedLanguageConfiguration(this.languageId, config);\n            }\n        }\n        return this._resolved;\n    }\n    _resolve() {\n        if (this._entries.length === 0) {\n            return null;\n        }\n        this._entries.sort(LanguageConfigurationContribution.cmp);\n        return combineLanguageConfigurations(this._entries.map(e => e.configuration));\n    }\n}\nfunction combineLanguageConfigurations(configs) {\n    let result = {\n        comments: undefined,\n        brackets: undefined,\n        wordPattern: undefined,\n        indentationRules: undefined,\n        onEnterRules: undefined,\n        autoClosingPairs: undefined,\n        surroundingPairs: undefined,\n        autoCloseBefore: undefined,\n        folding: undefined,\n        colorizedBracketPairs: undefined,\n        __electricCharacterSupport: undefined,\n    };\n    for (const entry of configs) {\n        result = {\n            comments: entry.comments || result.comments,\n            brackets: entry.brackets || result.brackets,\n            wordPattern: entry.wordPattern || result.wordPattern,\n            indentationRules: entry.indentationRules || result.indentationRules,\n            onEnterRules: entry.onEnterRules || result.onEnterRules,\n            autoClosingPairs: entry.autoClosingPairs || result.autoClosingPairs,\n            surroundingPairs: entry.surroundingPairs || result.surroundingPairs,\n            autoCloseBefore: entry.autoCloseBefore || result.autoCloseBefore,\n            folding: entry.folding || result.folding,\n            colorizedBracketPairs: entry.colorizedBracketPairs || result.colorizedBracketPairs,\n            __electricCharacterSupport: entry.__electricCharacterSupport || result.__electricCharacterSupport,\n        };\n    }\n    return result;\n}\nclass LanguageConfigurationContribution {\n    constructor(configuration, priority, order) {\n        this.configuration = configuration;\n        this.priority = priority;\n        this.order = order;\n    }\n    static cmp(a, b) {\n        if (a.priority === b.priority) {\n            // higher order last\n            return a.order - b.order;\n        }\n        // higher priority last\n        return a.priority - b.priority;\n    }\n}\nexport class LanguageConfigurationChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n}\nexport class LanguageConfigurationRegistry extends Disposable {\n    constructor() {\n        super();\n        this._entries = new Map();\n        this._onDidChange = this._register(new Emitter());\n        this.onDidChange = this._onDidChange.event;\n        this._register(this.register(PLAINTEXT_LANGUAGE_ID, {\n            brackets: [\n                ['(', ')'],\n                ['[', ']'],\n                ['{', '}'],\n            ],\n            surroundingPairs: [\n                { open: '{', close: '}' },\n                { open: '[', close: ']' },\n                { open: '(', close: ')' },\n                { open: '<', close: '>' },\n                { open: '\\\"', close: '\\\"' },\n                { open: '\\'', close: '\\'' },\n                { open: '`', close: '`' },\n            ],\n            colorizedBracketPairs: [],\n            folding: {\n                offSide: true\n            }\n        }, 0));\n    }\n    /**\n     * @param priority Use a higher number for higher priority\n     */\n    register(languageId, configuration, priority = 0) {\n        let entries = this._entries.get(languageId);\n        if (!entries) {\n            entries = new ComposedLanguageConfiguration(languageId);\n            this._entries.set(languageId, entries);\n        }\n        const disposable = entries.register(configuration, priority);\n        this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        return toDisposable(() => {\n            disposable.dispose();\n            this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        });\n    }\n    getLanguageConfiguration(languageId) {\n        const entries = this._entries.get(languageId);\n        return (entries === null || entries === void 0 ? void 0 : entries.getResolvedConfiguration()) || null;\n    }\n}\n/**\n * Immutable.\n*/\nexport class ResolvedLanguageConfiguration {\n    constructor(languageId, underlyingConfig) {\n        this.languageId = languageId;\n        this.underlyingConfig = underlyingConfig;\n        this._brackets = null;\n        this._electricCharacter = null;\n        this._onEnterSupport =\n            this.underlyingConfig.brackets ||\n                this.underlyingConfig.indentationRules ||\n                this.underlyingConfig.onEnterRules\n                ? new OnEnterSupport(this.underlyingConfig)\n                : null;\n        this.comments = ResolvedLanguageConfiguration._handleComments(this.underlyingConfig);\n        this.characterPair = new CharacterPairSupport(this.underlyingConfig);\n        this.wordDefinition = this.underlyingConfig.wordPattern || DEFAULT_WORD_REGEXP;\n        this.indentationRules = this.underlyingConfig.indentationRules;\n        if (this.underlyingConfig.indentationRules) {\n            this.indentRulesSupport = new IndentRulesSupport(this.underlyingConfig.indentationRules);\n        }\n        else {\n            this.indentRulesSupport = null;\n        }\n        this.foldingRules = this.underlyingConfig.folding || {};\n        this.bracketsNew = new LanguageBracketsConfiguration(languageId, this.underlyingConfig);\n    }\n    getWordDefinition() {\n        return ensureValidWordDefinition(this.wordDefinition);\n    }\n    get brackets() {\n        if (!this._brackets && this.underlyingConfig.brackets) {\n            this._brackets = new RichEditBrackets(this.languageId, this.underlyingConfig.brackets);\n        }\n        return this._brackets;\n    }\n    get electricCharacter() {\n        if (!this._electricCharacter) {\n            this._electricCharacter = new BracketElectricCharacterSupport(this.brackets);\n        }\n        return this._electricCharacter;\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        if (!this._onEnterSupport) {\n            return null;\n        }\n        return this._onEnterSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n    }\n    getAutoClosingPairs() {\n        return new AutoClosingPairs(this.characterPair.getAutoClosingPairs());\n    }\n    getAutoCloseBeforeSet() {\n        return this.characterPair.getAutoCloseBeforeSet();\n    }\n    getSurroundingPairs() {\n        return this.characterPair.getSurroundingPairs();\n    }\n    static _handleComments(conf) {\n        const commentRule = conf.comments;\n        if (!commentRule) {\n            return null;\n        }\n        // comment configuration\n        const comments = {};\n        if (commentRule.lineComment) {\n            comments.lineCommentToken = commentRule.lineComment;\n        }\n        if (commentRule.blockComment) {\n            const [blockStart, blockEnd] = commentRule.blockComment;\n            comments.blockCommentStartToken = blockStart;\n            comments.blockCommentEndToken = blockEnd;\n        }\n        return comments;\n    }\n}\nregisterSingleton(ILanguageConfigurationService, LanguageConfigurationService);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CharacterClassifier } from '../core/characterClassifier.js';\nexport class Uint8Matrix {\n    constructor(rows, cols, defaultValue) {\n        const data = new Uint8Array(rows * cols);\n        for (let i = 0, len = rows * cols; i < len; i++) {\n            data[i] = defaultValue;\n        }\n        this._data = data;\n        this.rows = rows;\n        this.cols = cols;\n    }\n    get(row, col) {\n        return this._data[row * this.cols + col];\n    }\n    set(row, col, value) {\n        this._data[row * this.cols + col] = value;\n    }\n}\nexport class StateMachine {\n    constructor(edges) {\n        let maxCharCode = 0;\n        let maxState = 0 /* State.Invalid */;\n        for (let i = 0, len = edges.length; i < len; i++) {\n            const [from, chCode, to] = edges[i];\n            if (chCode > maxCharCode) {\n                maxCharCode = chCode;\n            }\n            if (from > maxState) {\n                maxState = from;\n            }\n            if (to > maxState) {\n                maxState = to;\n            }\n        }\n        maxCharCode++;\n        maxState++;\n        const states = new Uint8Matrix(maxState, maxCharCode, 0 /* State.Invalid */);\n        for (let i = 0, len = edges.length; i < len; i++) {\n            const [from, chCode, to] = edges[i];\n            states.set(from, chCode, to);\n        }\n        this._states = states;\n        this._maxCharCode = maxCharCode;\n    }\n    nextState(currentState, chCode) {\n        if (chCode < 0 || chCode >= this._maxCharCode) {\n            return 0 /* State.Invalid */;\n        }\n        return this._states.get(currentState, chCode);\n    }\n}\n// State machine for http:// or https:// or file://\nlet _stateMachine = null;\nfunction getStateMachine() {\n    if (_stateMachine === null) {\n        _stateMachine = new StateMachine([\n            [1 /* State.Start */, 104 /* CharCode.h */, 2 /* State.H */],\n            [1 /* State.Start */, 72 /* CharCode.H */, 2 /* State.H */],\n            [1 /* State.Start */, 102 /* CharCode.f */, 6 /* State.F */],\n            [1 /* State.Start */, 70 /* CharCode.F */, 6 /* State.F */],\n            [2 /* State.H */, 116 /* CharCode.t */, 3 /* State.HT */],\n            [2 /* State.H */, 84 /* CharCode.T */, 3 /* State.HT */],\n            [3 /* State.HT */, 116 /* CharCode.t */, 4 /* State.HTT */],\n            [3 /* State.HT */, 84 /* CharCode.T */, 4 /* State.HTT */],\n            [4 /* State.HTT */, 112 /* CharCode.p */, 5 /* State.HTTP */],\n            [4 /* State.HTT */, 80 /* CharCode.P */, 5 /* State.HTTP */],\n            [5 /* State.HTTP */, 115 /* CharCode.s */, 9 /* State.BeforeColon */],\n            [5 /* State.HTTP */, 83 /* CharCode.S */, 9 /* State.BeforeColon */],\n            [5 /* State.HTTP */, 58 /* CharCode.Colon */, 10 /* State.AfterColon */],\n            [6 /* State.F */, 105 /* CharCode.i */, 7 /* State.FI */],\n            [6 /* State.F */, 73 /* CharCode.I */, 7 /* State.FI */],\n            [7 /* State.FI */, 108 /* CharCode.l */, 8 /* State.FIL */],\n            [7 /* State.FI */, 76 /* CharCode.L */, 8 /* State.FIL */],\n            [8 /* State.FIL */, 101 /* CharCode.e */, 9 /* State.BeforeColon */],\n            [8 /* State.FIL */, 69 /* CharCode.E */, 9 /* State.BeforeColon */],\n            [9 /* State.BeforeColon */, 58 /* CharCode.Colon */, 10 /* State.AfterColon */],\n            [10 /* State.AfterColon */, 47 /* CharCode.Slash */, 11 /* State.AlmostThere */],\n            [11 /* State.AlmostThere */, 47 /* CharCode.Slash */, 12 /* State.End */],\n        ]);\n    }\n    return _stateMachine;\n}\nlet _classifier = null;\nfunction getClassifier() {\n    if (_classifier === null) {\n        _classifier = new CharacterClassifier(0 /* CharacterClass.None */);\n        // allow-any-unicode-next-line\n        const FORCE_TERMINATION_CHARACTERS = ' \\t<>\\'\\\"';\n        for (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {\n            _classifier.set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), 1 /* CharacterClass.ForceTermination */);\n        }\n        const CANNOT_END_WITH_CHARACTERS = '.,;:';\n        for (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {\n            _classifier.set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), 2 /* CharacterClass.CannotEndIn */);\n        }\n    }\n    return _classifier;\n}\nexport class LinkComputer {\n    static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {\n        // Do not allow to end link in certain characters...\n        let lastIncludedCharIndex = linkEndIndex - 1;\n        do {\n            const chCode = line.charCodeAt(lastIncludedCharIndex);\n            const chClass = classifier.get(chCode);\n            if (chClass !== 2 /* CharacterClass.CannotEndIn */) {\n                break;\n            }\n            lastIncludedCharIndex--;\n        } while (lastIncludedCharIndex > linkBeginIndex);\n        // Handle links enclosed in parens, square brackets and curlys.\n        if (linkBeginIndex > 0) {\n            const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);\n            const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);\n            if ((charCodeBeforeLink === 40 /* CharCode.OpenParen */ && lastCharCodeInLink === 41 /* CharCode.CloseParen */)\n                || (charCodeBeforeLink === 91 /* CharCode.OpenSquareBracket */ && lastCharCodeInLink === 93 /* CharCode.CloseSquareBracket */)\n                || (charCodeBeforeLink === 123 /* CharCode.OpenCurlyBrace */ && lastCharCodeInLink === 125 /* CharCode.CloseCurlyBrace */)) {\n                // Do not end in ) if ( is before the link start\n                // Do not end in ] if [ is before the link start\n                // Do not end in } if { is before the link start\n                lastIncludedCharIndex--;\n            }\n        }\n        return {\n            range: {\n                startLineNumber: lineNumber,\n                startColumn: linkBeginIndex + 1,\n                endLineNumber: lineNumber,\n                endColumn: lastIncludedCharIndex + 2\n            },\n            url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)\n        };\n    }\n    static computeLinks(model, stateMachine = getStateMachine()) {\n        const classifier = getClassifier();\n        const result = [];\n        for (let i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {\n            const line = model.getLineContent(i);\n            const len = line.length;\n            let j = 0;\n            let linkBeginIndex = 0;\n            let linkBeginChCode = 0;\n            let state = 1 /* State.Start */;\n            let hasOpenParens = false;\n            let hasOpenSquareBracket = false;\n            let inSquareBrackets = false;\n            let hasOpenCurlyBracket = false;\n            while (j < len) {\n                let resetStateMachine = false;\n                const chCode = line.charCodeAt(j);\n                if (state === 13 /* State.Accept */) {\n                    let chClass;\n                    switch (chCode) {\n                        case 40 /* CharCode.OpenParen */:\n                            hasOpenParens = true;\n                            chClass = 0 /* CharacterClass.None */;\n                            break;\n                        case 41 /* CharCode.CloseParen */:\n                            chClass = (hasOpenParens ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        case 91 /* CharCode.OpenSquareBracket */:\n                            inSquareBrackets = true;\n                            hasOpenSquareBracket = true;\n                            chClass = 0 /* CharacterClass.None */;\n                            break;\n                        case 93 /* CharCode.CloseSquareBracket */:\n                            inSquareBrackets = false;\n                            chClass = (hasOpenSquareBracket ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        case 123 /* CharCode.OpenCurlyBrace */:\n                            hasOpenCurlyBracket = true;\n                            chClass = 0 /* CharacterClass.None */;\n                            break;\n                        case 125 /* CharCode.CloseCurlyBrace */:\n                            chClass = (hasOpenCurlyBracket ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        /* The following three rules make it that ' or \" or ` are allowed inside links if the link didn't begin with them */\n                        case 39 /* CharCode.SingleQuote */:\n                            chClass = (linkBeginChCode === 39 /* CharCode.SingleQuote */ ? 1 /* CharacterClass.ForceTermination */ : 0 /* CharacterClass.None */);\n                            break;\n                        case 34 /* CharCode.DoubleQuote */:\n                            chClass = (linkBeginChCode === 34 /* CharCode.DoubleQuote */ ? 1 /* CharacterClass.ForceTermination */ : 0 /* CharacterClass.None */);\n                            break;\n                        case 96 /* CharCode.BackTick */:\n                            chClass = (linkBeginChCode === 96 /* CharCode.BackTick */ ? 1 /* CharacterClass.ForceTermination */ : 0 /* CharacterClass.None */);\n                            break;\n                        case 42 /* CharCode.Asterisk */:\n                            // `*` terminates a link if the link began with `*`\n                            chClass = (linkBeginChCode === 42 /* CharCode.Asterisk */) ? 1 /* CharacterClass.ForceTermination */ : 0 /* CharacterClass.None */;\n                            break;\n                        case 124 /* CharCode.Pipe */:\n                            // `|` terminates a link if the link began with `|`\n                            chClass = (linkBeginChCode === 124 /* CharCode.Pipe */) ? 1 /* CharacterClass.ForceTermination */ : 0 /* CharacterClass.None */;\n                            break;\n                        case 32 /* CharCode.Space */:\n                            // ` ` allow space in between [ and ]\n                            chClass = (inSquareBrackets ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        default:\n                            chClass = classifier.get(chCode);\n                    }\n                    // Check if character terminates link\n                    if (chClass === 1 /* CharacterClass.ForceTermination */) {\n                        result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));\n                        resetStateMachine = true;\n                    }\n                }\n                else if (state === 12 /* State.End */) {\n                    let chClass;\n                    if (chCode === 91 /* CharCode.OpenSquareBracket */) {\n                        // Allow for the authority part to contain ipv6 addresses which contain [ and ]\n                        hasOpenSquareBracket = true;\n                        chClass = 0 /* CharacterClass.None */;\n                    }\n                    else {\n                        chClass = classifier.get(chCode);\n                    }\n                    // Check if character terminates link\n                    if (chClass === 1 /* CharacterClass.ForceTermination */) {\n                        resetStateMachine = true;\n                    }\n                    else {\n                        state = 13 /* State.Accept */;\n                    }\n                }\n                else {\n                    state = stateMachine.nextState(state, chCode);\n                    if (state === 0 /* State.Invalid */) {\n                        resetStateMachine = true;\n                    }\n                }\n                if (resetStateMachine) {\n                    state = 1 /* State.Start */;\n                    hasOpenParens = false;\n                    hasOpenSquareBracket = false;\n                    hasOpenCurlyBracket = false;\n                    // Record where the link started\n                    linkBeginIndex = j + 1;\n                    linkBeginChCode = chCode;\n                }\n                j++;\n            }\n            if (state === 13 /* State.Accept */) {\n                result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));\n            }\n        }\n        return result;\n    }\n}\n/**\n * Returns an array of all links contains in the provided\n * document. *Note* that this operation is computational\n * expensive and should not run in the UI thread.\n */\nexport function computeLinks(model) {\n    if (!model || typeof model.getLineCount !== 'function' || typeof model.getLineContent !== 'function') {\n        // Unknown caller!\n        return [];\n    }\n    return LinkComputer.computeLinks(model);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Registry } from '../../../platform/registry/common/platform.js';\nimport { Mimes } from '../../../base/common/mime.js';\nimport { Extensions as ConfigurationExtensions } from '../../../platform/configuration/common/configurationRegistry.js';\n// Define extension point ids\nexport const Extensions = {\n    ModesRegistry: 'editor.modesRegistry'\n};\nexport class EditorModesRegistry {\n    constructor() {\n        this._onDidChangeLanguages = new Emitter();\n        this.onDidChangeLanguages = this._onDidChangeLanguages.event;\n        this._languages = [];\n    }\n    registerLanguage(def) {\n        this._languages.push(def);\n        this._onDidChangeLanguages.fire(undefined);\n        return {\n            dispose: () => {\n                for (let i = 0, len = this._languages.length; i < len; i++) {\n                    if (this._languages[i] === def) {\n                        this._languages.splice(i, 1);\n                        return;\n                    }\n                }\n            }\n        };\n    }\n    getLanguages() {\n        return this._languages;\n    }\n}\nexport const ModesRegistry = new EditorModesRegistry();\nRegistry.add(Extensions.ModesRegistry, ModesRegistry);\nexport const PLAINTEXT_LANGUAGE_ID = 'plaintext';\nexport const PLAINTEXT_EXTENSION = '.txt';\nModesRegistry.registerLanguage({\n    id: PLAINTEXT_LANGUAGE_ID,\n    extensions: [PLAINTEXT_EXTENSION],\n    aliases: [nls.localize('plainText.alias', \"Plain Text\"), 'text'],\n    mimetypes: [Mimes.text]\n});\nRegistry.as(ConfigurationExtensions.Configuration)\n    .registerDefaultConfigurations([{\n        overrides: {\n            '[plaintext]': {\n                'editor.unicodeHighlight.ambiguousCharacters': false,\n                'editor.unicodeHighlight.invisibleCharacters': false\n            }\n        }\n    }]);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Token, TokenizationResult, EncodedTokenizationResult } from '../languages.js';\nexport const NullState = new class {\n    clone() {\n        return this;\n    }\n    equals(other) {\n        return (this === other);\n    }\n};\nexport function nullTokenize(languageId, state) {\n    return new TokenizationResult([new Token(0, '', languageId)], state);\n}\nexport function nullTokenizeEncoded(languageId, state) {\n    const tokens = new Uint32Array(2);\n    tokens[0] = 0;\n    tokens[1] = ((languageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)\n        | (0 /* StandardTokenType.Other */ << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)\n        | (0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    return new EncodedTokenizationResult(tokens, state === null ? NullState : state);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function createScopedLineTokens(context, offset) {\n    const tokenCount = context.getCount();\n    const tokenIndex = context.findTokenIndexAtOffset(offset);\n    const desiredLanguageId = context.getLanguageId(tokenIndex);\n    let lastTokenIndex = tokenIndex;\n    while (lastTokenIndex + 1 < tokenCount && context.getLanguageId(lastTokenIndex + 1) === desiredLanguageId) {\n        lastTokenIndex++;\n    }\n    let firstTokenIndex = tokenIndex;\n    while (firstTokenIndex > 0 && context.getLanguageId(firstTokenIndex - 1) === desiredLanguageId) {\n        firstTokenIndex--;\n    }\n    return new ScopedLineTokens(context, desiredLanguageId, firstTokenIndex, lastTokenIndex + 1, context.getStartOffset(firstTokenIndex), context.getEndOffset(lastTokenIndex));\n}\nexport class ScopedLineTokens {\n    constructor(actual, languageId, firstTokenIndex, lastTokenIndex, firstCharOffset, lastCharOffset) {\n        this._scopedLineTokensBrand = undefined;\n        this._actual = actual;\n        this.languageId = languageId;\n        this._firstTokenIndex = firstTokenIndex;\n        this._lastTokenIndex = lastTokenIndex;\n        this.firstCharOffset = firstCharOffset;\n        this._lastCharOffset = lastCharOffset;\n    }\n    getLineContent() {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(this.firstCharOffset, this._lastCharOffset);\n    }\n    getActualLineContentBefore(offset) {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(0, this.firstCharOffset + offset);\n    }\n    getTokenCount() {\n        return this._lastTokenIndex - this._firstTokenIndex;\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._actual.findTokenIndexAtOffset(offset + this.firstCharOffset) - this._firstTokenIndex;\n    }\n    getStandardTokenType(tokenIndex) {\n        return this._actual.getStandardTokenType(tokenIndex + this._firstTokenIndex);\n    }\n}\nexport function ignoreBracketsInToken(standardTokenType) {\n    return (standardTokenType & 3 /* IgnoreBracketsInTokens.value */) !== 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class BasicInplaceReplace {\n    constructor() {\n        this._defaultValueSet = [\n            ['true', 'false'],\n            ['True', 'False'],\n            ['Private', 'Public', 'Friend', 'ReadOnly', 'Partial', 'Protected', 'WriteOnly'],\n            ['public', 'protected', 'private'],\n        ];\n    }\n    navigateValueSet(range1, text1, range2, text2, up) {\n        if (range1 && text1) {\n            const result = this.doNavigateValueSet(text1, up);\n            if (result) {\n                return {\n                    range: range1,\n                    value: result\n                };\n            }\n        }\n        if (range2 && text2) {\n            const result = this.doNavigateValueSet(text2, up);\n            if (result) {\n                return {\n                    range: range2,\n                    value: result\n                };\n            }\n        }\n        return null;\n    }\n    doNavigateValueSet(text, up) {\n        const numberResult = this.numberReplace(text, up);\n        if (numberResult !== null) {\n            return numberResult;\n        }\n        return this.textReplace(text, up);\n    }\n    numberReplace(value, up) {\n        const precision = Math.pow(10, value.length - (value.lastIndexOf('.') + 1));\n        let n1 = Number(value);\n        const n2 = parseFloat(value);\n        if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {\n            if (n1 === 0 && !up) {\n                return null; // don't do negative\n                //\t\t\t} else if(n1 === 9 && up) {\n                //\t\t\t\treturn null; // don't insert 10 into a number\n            }\n            else {\n                n1 = Math.floor(n1 * precision);\n                n1 += up ? precision : -precision;\n                return String(n1 / precision);\n            }\n        }\n        return null;\n    }\n    textReplace(value, up) {\n        return this.valueSetsReplace(this._defaultValueSet, value, up);\n    }\n    valueSetsReplace(valueSets, value, up) {\n        let result = null;\n        for (let i = 0, len = valueSets.length; result === null && i < len; i++) {\n            result = this.valueSetReplace(valueSets[i], value, up);\n        }\n        return result;\n    }\n    valueSetReplace(valueSet, value, up) {\n        let idx = valueSet.indexOf(value);\n        if (idx >= 0) {\n            idx += up ? +1 : -1;\n            if (idx < 0) {\n                idx = valueSet.length - 1;\n            }\n            else {\n                idx %= valueSet.length;\n            }\n            return valueSet[idx];\n        }\n        return null;\n    }\n}\nBasicInplaceReplace.INSTANCE = new BasicInplaceReplace();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport * as stringBuilder from '../../core/stringBuilder.js';\nimport { Range } from '../../core/range.js';\n/**\n * Represents a grouping of colliding bracket pairs.\n *\n * Most of the times this contains a single bracket pair,\n * but sometimes this contains multiple bracket pairs in cases\n * where the same string appears as a closing bracket for multiple\n * bracket pairs, or the same string appears an opening bracket for\n * multiple bracket pairs.\n *\n * e.g. of a group containing a single pair:\n *   open: ['{'], close: ['}']\n *\n * e.g. of a group containing multiple pairs:\n *   open: ['if', 'for'], close: ['end', 'end']\n */\nexport class RichEditBracket {\n    constructor(languageId, index, open, close, forwardRegex, reversedRegex) {\n        this._richEditBracketBrand = undefined;\n        this.languageId = languageId;\n        this.index = index;\n        this.open = open;\n        this.close = close;\n        this.forwardRegex = forwardRegex;\n        this.reversedRegex = reversedRegex;\n        this._openSet = RichEditBracket._toSet(this.open);\n        this._closeSet = RichEditBracket._toSet(this.close);\n    }\n    /**\n     * Check if the provided `text` is an open bracket in this group.\n     */\n    isOpen(text) {\n        return this._openSet.has(text);\n    }\n    /**\n     * Check if the provided `text` is a close bracket in this group.\n     */\n    isClose(text) {\n        return this._closeSet.has(text);\n    }\n    static _toSet(arr) {\n        const result = new Set();\n        for (const element of arr) {\n            result.add(element);\n        }\n        return result;\n    }\n}\n/**\n * Groups together brackets that have equal open or close sequences.\n *\n * For example, if the following brackets are defined:\n *   ['IF','END']\n *   ['for','end']\n *   ['{','}']\n *\n * Then the grouped brackets would be:\n *   { open: ['if', 'for'], close: ['end', 'end'] }\n *   { open: ['{'], close: ['}'] }\n *\n */\nfunction groupFuzzyBrackets(brackets) {\n    const N = brackets.length;\n    brackets = brackets.map(b => [b[0].toLowerCase(), b[1].toLowerCase()]);\n    const group = [];\n    for (let i = 0; i < N; i++) {\n        group[i] = i;\n    }\n    const areOverlapping = (a, b) => {\n        const [aOpen, aClose] = a;\n        const [bOpen, bClose] = b;\n        return (aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose);\n    };\n    const mergeGroups = (g1, g2) => {\n        const newG = Math.min(g1, g2);\n        const oldG = Math.max(g1, g2);\n        for (let i = 0; i < N; i++) {\n            if (group[i] === oldG) {\n                group[i] = newG;\n            }\n        }\n    };\n    // group together brackets that have the same open or the same close sequence\n    for (let i = 0; i < N; i++) {\n        const a = brackets[i];\n        for (let j = i + 1; j < N; j++) {\n            const b = brackets[j];\n            if (areOverlapping(a, b)) {\n                mergeGroups(group[i], group[j]);\n            }\n        }\n    }\n    const result = [];\n    for (let g = 0; g < N; g++) {\n        const currentOpen = [];\n        const currentClose = [];\n        for (let i = 0; i < N; i++) {\n            if (group[i] === g) {\n                const [open, close] = brackets[i];\n                currentOpen.push(open);\n                currentClose.push(close);\n            }\n        }\n        if (currentOpen.length > 0) {\n            result.push({\n                open: currentOpen,\n                close: currentClose\n            });\n        }\n    }\n    return result;\n}\nexport class RichEditBrackets {\n    constructor(languageId, _brackets) {\n        this._richEditBracketsBrand = undefined;\n        const brackets = groupFuzzyBrackets(_brackets);\n        this.brackets = brackets.map((b, index) => {\n            return new RichEditBracket(languageId, index, b.open, b.close, getRegexForBracketPair(b.open, b.close, brackets, index), getReversedRegexForBracketPair(b.open, b.close, brackets, index));\n        });\n        this.forwardRegex = getRegexForBrackets(this.brackets);\n        this.reversedRegex = getReversedRegexForBrackets(this.brackets);\n        this.textIsBracket = {};\n        this.textIsOpenBracket = {};\n        this.maxBracketLength = 0;\n        for (const bracket of this.brackets) {\n            for (const open of bracket.open) {\n                this.textIsBracket[open] = bracket;\n                this.textIsOpenBracket[open] = true;\n                this.maxBracketLength = Math.max(this.maxBracketLength, open.length);\n            }\n            for (const close of bracket.close) {\n                this.textIsBracket[close] = bracket;\n                this.textIsOpenBracket[close] = false;\n                this.maxBracketLength = Math.max(this.maxBracketLength, close.length);\n            }\n        }\n    }\n}\nfunction collectSuperstrings(str, brackets, currentIndex, dest) {\n    for (let i = 0, len = brackets.length; i < len; i++) {\n        if (i === currentIndex) {\n            continue;\n        }\n        const bracket = brackets[i];\n        for (const open of bracket.open) {\n            if (open.indexOf(str) >= 0) {\n                dest.push(open);\n            }\n        }\n        for (const close of bracket.close) {\n            if (close.indexOf(str) >= 0) {\n                dest.push(close);\n            }\n        }\n    }\n}\nfunction lengthcmp(a, b) {\n    return a.length - b.length;\n}\nfunction unique(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n    const result = [];\n    const seen = new Set();\n    for (const element of arr) {\n        if (seen.has(element)) {\n            continue;\n        }\n        result.push(element);\n        seen.add(element);\n    }\n    return result;\n}\n/**\n * Create a regular expression that can be used to search forward in a piece of text\n * for a group of bracket pairs. But this regex must be built in a way in which\n * it is aware of the other bracket pairs defined for the language.\n *\n * For example, if a language contains the following bracket pairs:\n *   ['begin', 'end']\n *   ['if', 'end if']\n * The two bracket pairs do not collide because no open or close brackets are equal.\n * So the function getRegexForBracketPair is called twice, once with\n * the ['begin'], ['end'] group consisting of one bracket pair, and once with\n * the ['if'], ['end if'] group consiting of the other bracket pair.\n *\n * But there could be a situation where an occurrence of 'end if' is mistaken\n * for an occurrence of 'end'.\n *\n * Therefore, for the bracket pair ['begin', 'end'], the regex will also\n * target 'end if'. The regex will be something like:\n *   /(\\bend if\\b)|(\\bend\\b)|(\\bif\\b)/\n *\n * The regex also searches for \"superstrings\" (other brackets that might be mistaken with the current bracket).\n *\n */\nfunction getRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * This function also has the fine details of `getRegexForBracketPair`. For the same example\n * given above, the regex produced here would look like:\n *   /(\\bfi dne\\b)|(\\bdne\\b)|(\\bfi\\b)/\n */\nfunction getReversedRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\n/**\n * Creates a regular expression that targets all bracket pairs.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bbegin\\b)|(\\bend\\b)|(\\bfor\\b)/\n */\nfunction getRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bnigeb\\b)|(\\bdne\\b)|(\\brof\\b)/\n */\nfunction getReversedRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\nfunction prepareBracketForRegExp(str) {\n    // This bracket pair uses letters like e.g. \"begin\" - \"end\"\n    const insertWordBoundaries = (/^[\\w ]+$/.test(str));\n    str = strings.escapeRegExpCharacters(str);\n    return (insertWordBoundaries ? `\\\\b${str}\\\\b` : str);\n}\nfunction createBracketOrRegExp(pieces) {\n    const regexStr = `(${pieces.map(prepareBracketForRegExp).join(')|(')})`;\n    return strings.createRegExp(regexStr, true);\n}\nconst toReversedString = (function () {\n    function reverse(str) {\n        if (stringBuilder.hasTextDecoder) {\n            // create a Uint16Array and then use a TextDecoder to create a string\n            const arr = new Uint16Array(str.length);\n            let offset = 0;\n            for (let i = str.length - 1; i >= 0; i--) {\n                arr[offset++] = str.charCodeAt(i);\n            }\n            return stringBuilder.getPlatformTextDecoder().decode(arr);\n        }\n        else {\n            const result = [];\n            let resultLen = 0;\n            for (let i = str.length - 1; i >= 0; i--) {\n                result[resultLen++] = str.charAt(i);\n            }\n            return result.join('');\n        }\n    }\n    let lastInput = null;\n    let lastOutput = null;\n    return function toReversedString(str) {\n        if (lastInput !== str) {\n            lastInput = str;\n            lastOutput = reverse(lastInput);\n        }\n        return lastOutput;\n    };\n})();\nexport class BracketsUtils {\n    static _findPrevBracketInText(reversedBracketRegex, lineNumber, reversedText, offset) {\n        const m = reversedText.match(reversedBracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = reversedText.length - (m.index || 0);\n        const matchLength = m[0].length;\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);\n    }\n    static findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)\n        const reversedLineText = toReversedString(lineText);\n        const reversedSubstr = reversedLineText.substring(lineText.length - endOffset, lineText.length - startOffset);\n        return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);\n    }\n    static findNextBracketInText(bracketRegex, lineNumber, text, offset) {\n        const m = text.match(bracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = m.index || 0;\n        const matchLength = m[0].length;\n        if (matchLength === 0) {\n            return null;\n        }\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);\n    }\n    static findNextBracketInRange(bracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        const substr = lineText.substring(startOffset, endOffset);\n        return this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Color } from '../../../../base/common/color.js';\nexport class ParsedTokenThemeRule {\n    constructor(token, index, fontStyle, foreground, background) {\n        this._parsedThemeRuleBrand = undefined;\n        this.token = token;\n        this.index = index;\n        this.fontStyle = fontStyle;\n        this.foreground = foreground;\n        this.background = background;\n    }\n}\n/**\n * Parse a raw theme into rules.\n */\nexport function parseTokenTheme(source) {\n    if (!source || !Array.isArray(source)) {\n        return [];\n    }\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0, len = source.length; i < len; i++) {\n        const entry = source[i];\n        let fontStyle = -1 /* FontStyle.NotSet */;\n        if (typeof entry.fontStyle === 'string') {\n            fontStyle = 0 /* FontStyle.None */;\n            const segments = entry.fontStyle.split(' ');\n            for (let j = 0, lenJ = segments.length; j < lenJ; j++) {\n                const segment = segments[j];\n                switch (segment) {\n                    case 'italic':\n                        fontStyle = fontStyle | 1 /* FontStyle.Italic */;\n                        break;\n                    case 'bold':\n                        fontStyle = fontStyle | 2 /* FontStyle.Bold */;\n                        break;\n                    case 'underline':\n                        fontStyle = fontStyle | 4 /* FontStyle.Underline */;\n                        break;\n                    case 'strikethrough':\n                        fontStyle = fontStyle | 8 /* FontStyle.Strikethrough */;\n                        break;\n                }\n            }\n        }\n        let foreground = null;\n        if (typeof entry.foreground === 'string') {\n            foreground = entry.foreground;\n        }\n        let background = null;\n        if (typeof entry.background === 'string') {\n            background = entry.background;\n        }\n        result[resultLen++] = new ParsedTokenThemeRule(entry.token || '', i, fontStyle, foreground, background);\n    }\n    return result;\n}\n/**\n * Resolve rules (i.e. inheritance).\n */\nfunction resolveParsedTokenThemeRules(parsedThemeRules, customTokenColors) {\n    // Sort rules lexicographically, and then by index if necessary\n    parsedThemeRules.sort((a, b) => {\n        const r = strcmp(a.token, b.token);\n        if (r !== 0) {\n            return r;\n        }\n        return a.index - b.index;\n    });\n    // Determine defaults\n    let defaultFontStyle = 0 /* FontStyle.None */;\n    let defaultForeground = '000000';\n    let defaultBackground = 'ffffff';\n    while (parsedThemeRules.length >= 1 && parsedThemeRules[0].token === '') {\n        const incomingDefaults = parsedThemeRules.shift();\n        if (incomingDefaults.fontStyle !== -1 /* FontStyle.NotSet */) {\n            defaultFontStyle = incomingDefaults.fontStyle;\n        }\n        if (incomingDefaults.foreground !== null) {\n            defaultForeground = incomingDefaults.foreground;\n        }\n        if (incomingDefaults.background !== null) {\n            defaultBackground = incomingDefaults.background;\n        }\n    }\n    const colorMap = new ColorMap();\n    // start with token colors from custom token themes\n    for (const color of customTokenColors) {\n        colorMap.getId(color);\n    }\n    const foregroundColorId = colorMap.getId(defaultForeground);\n    const backgroundColorId = colorMap.getId(defaultBackground);\n    const defaults = new ThemeTrieElementRule(defaultFontStyle, foregroundColorId, backgroundColorId);\n    const root = new ThemeTrieElement(defaults);\n    for (let i = 0, len = parsedThemeRules.length; i < len; i++) {\n        const rule = parsedThemeRules[i];\n        root.insert(rule.token, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));\n    }\n    return new TokenTheme(colorMap, root);\n}\nconst colorRegExp = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;\nexport class ColorMap {\n    constructor() {\n        this._lastColorId = 0;\n        this._id2color = [];\n        this._color2id = new Map();\n    }\n    getId(color) {\n        if (color === null) {\n            return 0;\n        }\n        const match = color.match(colorRegExp);\n        if (!match) {\n            throw new Error('Illegal value for token color: ' + color);\n        }\n        color = match[1].toUpperCase();\n        let value = this._color2id.get(color);\n        if (value) {\n            return value;\n        }\n        value = ++this._lastColorId;\n        this._color2id.set(color, value);\n        this._id2color[value] = Color.fromHex('#' + color);\n        return value;\n    }\n    getColorMap() {\n        return this._id2color.slice(0);\n    }\n}\nexport class TokenTheme {\n    constructor(colorMap, root) {\n        this._colorMap = colorMap;\n        this._root = root;\n        this._cache = new Map();\n    }\n    static createFromRawTokenTheme(source, customTokenColors) {\n        return this.createFromParsedTokenTheme(parseTokenTheme(source), customTokenColors);\n    }\n    static createFromParsedTokenTheme(source, customTokenColors) {\n        return resolveParsedTokenThemeRules(source, customTokenColors);\n    }\n    getColorMap() {\n        return this._colorMap.getColorMap();\n    }\n    _match(token) {\n        return this._root.match(token);\n    }\n    match(languageId, token) {\n        // The cache contains the metadata without the language bits set.\n        let result = this._cache.get(token);\n        if (typeof result === 'undefined') {\n            const rule = this._match(token);\n            const standardToken = toStandardTokenType(token);\n            result = (rule.metadata\n                | (standardToken << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)) >>> 0;\n            this._cache.set(token, result);\n        }\n        return (result\n            | (languageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)) >>> 0;\n    }\n}\nconst STANDARD_TOKEN_TYPE_REGEXP = /\\b(comment|string|regex|regexp)\\b/;\nexport function toStandardTokenType(tokenType) {\n    const m = tokenType.match(STANDARD_TOKEN_TYPE_REGEXP);\n    if (!m) {\n        return 0 /* StandardTokenType.Other */;\n    }\n    switch (m[1]) {\n        case 'comment':\n            return 1 /* StandardTokenType.Comment */;\n        case 'string':\n            return 2 /* StandardTokenType.String */;\n        case 'regex':\n            return 3 /* StandardTokenType.RegEx */;\n        case 'regexp':\n            return 3 /* StandardTokenType.RegEx */;\n    }\n    throw new Error('Unexpected match for standard token type!');\n}\nexport function strcmp(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nexport class ThemeTrieElementRule {\n    constructor(fontStyle, foreground, background) {\n        this._themeTrieElementRuleBrand = undefined;\n        this._fontStyle = fontStyle;\n        this._foreground = foreground;\n        this._background = background;\n        this.metadata = ((this._fontStyle << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n            | (this._foreground << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n            | (this._background << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    }\n    clone() {\n        return new ThemeTrieElementRule(this._fontStyle, this._foreground, this._background);\n    }\n    acceptOverwrite(fontStyle, foreground, background) {\n        if (fontStyle !== -1 /* FontStyle.NotSet */) {\n            this._fontStyle = fontStyle;\n        }\n        if (foreground !== 0 /* ColorId.None */) {\n            this._foreground = foreground;\n        }\n        if (background !== 0 /* ColorId.None */) {\n            this._background = background;\n        }\n        this.metadata = ((this._fontStyle << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n            | (this._foreground << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n            | (this._background << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    }\n}\nexport class ThemeTrieElement {\n    constructor(mainRule) {\n        this._themeTrieElementBrand = undefined;\n        this._mainRule = mainRule;\n        this._children = new Map();\n    }\n    match(token) {\n        if (token === '') {\n            return this._mainRule;\n        }\n        const dotIndex = token.indexOf('.');\n        let head;\n        let tail;\n        if (dotIndex === -1) {\n            head = token;\n            tail = '';\n        }\n        else {\n            head = token.substring(0, dotIndex);\n            tail = token.substring(dotIndex + 1);\n        }\n        const child = this._children.get(head);\n        if (typeof child !== 'undefined') {\n            return child.match(tail);\n        }\n        return this._mainRule;\n    }\n    insert(token, fontStyle, foreground, background) {\n        if (token === '') {\n            // Merge into the main rule\n            this._mainRule.acceptOverwrite(fontStyle, foreground, background);\n            return;\n        }\n        const dotIndex = token.indexOf('.');\n        let head;\n        let tail;\n        if (dotIndex === -1) {\n            head = token;\n            tail = '';\n        }\n        else {\n            head = token.substring(0, dotIndex);\n            tail = token.substring(dotIndex + 1);\n        }\n        let child = this._children.get(head);\n        if (typeof child === 'undefined') {\n            child = new ThemeTrieElement(this._mainRule.clone());\n            this._children.set(head, child);\n        }\n        child.insert(tail, fontStyle, foreground, background);\n    }\n}\nexport function generateTokensCSSForColorMap(colorMap) {\n    const rules = [];\n    for (let i = 1, len = colorMap.length; i < len; i++) {\n        const color = colorMap[i];\n        rules[i] = `.mtk${i} { color: ${color}; }`;\n    }\n    rules.push('.mtki { font-style: italic; }');\n    rules.push('.mtkb { font-weight: bold; }');\n    rules.push('.mtku { text-decoration: underline; text-underline-position: under; }');\n    rules.push('.mtks { text-decoration: line-through; }');\n    rules.push('.mtks.mtku { text-decoration: underline line-through; text-underline-position: under; }');\n    return rules.join('\\n');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as strings from '../../../base/common/strings.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { NullState, nullTokenizeEncoded } from './nullTokenize.js';\nconst fallback = {\n    getInitialState: () => NullState,\n    tokenizeEncoded: (buffer, hasEOL, state) => nullTokenizeEncoded(0 /* LanguageId.Null */, state)\n};\nexport function tokenizeToString(languageService, text, languageId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!languageId) {\n            return _tokenizeToString(text, languageService.languageIdCodec, fallback);\n        }\n        const tokenizationSupport = yield TokenizationRegistry.getOrCreate(languageId);\n        return _tokenizeToString(text, languageService.languageIdCodec, tokenizationSupport || fallback);\n    });\n}\nexport function tokenizeLineToHTML(text, viewLineTokens, colorMap, startOffset, endOffset, tabSize, useNbsp) {\n    let result = `<div>`;\n    let charIndex = startOffset;\n    let tabsCharDelta = 0;\n    let prevIsSpace = true;\n    for (let tokenIndex = 0, tokenCount = viewLineTokens.getCount(); tokenIndex < tokenCount; tokenIndex++) {\n        const tokenEndIndex = viewLineTokens.getEndOffset(tokenIndex);\n        if (tokenEndIndex <= startOffset) {\n            continue;\n        }\n        let partContent = '';\n        for (; charIndex < tokenEndIndex && charIndex < endOffset; charIndex++) {\n            const charCode = text.charCodeAt(charIndex);\n            switch (charCode) {\n                case 9 /* CharCode.Tab */: {\n                    let insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n                    tabsCharDelta += insertSpacesCount - 1;\n                    while (insertSpacesCount > 0) {\n                        if (useNbsp && prevIsSpace) {\n                            partContent += '&#160;';\n                            prevIsSpace = false;\n                        }\n                        else {\n                            partContent += ' ';\n                            prevIsSpace = true;\n                        }\n                        insertSpacesCount--;\n                    }\n                    break;\n                }\n                case 60 /* CharCode.LessThan */:\n                    partContent += '&lt;';\n                    prevIsSpace = false;\n                    break;\n                case 62 /* CharCode.GreaterThan */:\n                    partContent += '&gt;';\n                    prevIsSpace = false;\n                    break;\n                case 38 /* CharCode.Ampersand */:\n                    partContent += '&amp;';\n                    prevIsSpace = false;\n                    break;\n                case 0 /* CharCode.Null */:\n                    partContent += '&#00;';\n                    prevIsSpace = false;\n                    break;\n                case 65279 /* CharCode.UTF8_BOM */:\n                case 8232 /* CharCode.LINE_SEPARATOR */:\n                case 8233 /* CharCode.PARAGRAPH_SEPARATOR */:\n                case 133 /* CharCode.NEXT_LINE */:\n                    partContent += '\\ufffd';\n                    prevIsSpace = false;\n                    break;\n                case 13 /* CharCode.CarriageReturn */:\n                    // zero width space, because carriage return would introduce a line break\n                    partContent += '&#8203';\n                    prevIsSpace = false;\n                    break;\n                case 32 /* CharCode.Space */:\n                    if (useNbsp && prevIsSpace) {\n                        partContent += '&#160;';\n                        prevIsSpace = false;\n                    }\n                    else {\n                        partContent += ' ';\n                        prevIsSpace = true;\n                    }\n                    break;\n                default:\n                    partContent += String.fromCharCode(charCode);\n                    prevIsSpace = false;\n            }\n        }\n        result += `<span style=\"${viewLineTokens.getInlineStyle(tokenIndex, colorMap)}\">${partContent}</span>`;\n        if (tokenEndIndex > endOffset || charIndex >= endOffset) {\n            break;\n        }\n    }\n    result += `</div>`;\n    return result;\n}\nexport function _tokenizeToString(text, languageIdCodec, tokenizationSupport) {\n    let result = `<div class=\"monaco-tokenized-source\">`;\n    const lines = strings.splitLines(text);\n    let currentState = tokenizationSupport.getInitialState();\n    for (let i = 0, len = lines.length; i < len; i++) {\n        const line = lines[i];\n        if (i > 0) {\n            result += `<br/>`;\n        }\n        const tokenizationResult = tokenizationSupport.tokenizeEncoded(line, true, currentState);\n        LineTokens.convertToEndOffset(tokenizationResult.tokens, line.length);\n        const lineTokens = new LineTokens(tokenizationResult.tokens, line, languageIdCodec);\n        const viewLineTokens = lineTokens.inflate();\n        let startOffset = 0;\n        for (let j = 0, lenJ = viewLineTokens.getCount(); j < lenJ; j++) {\n            const type = viewLineTokens.getClassName(j);\n            const endIndex = viewLineTokens.getEndOffset(j);\n            result += `<span class=\"${type}\">${strings.escape(line.substring(startOffset, endIndex))}</span>`;\n            startOffset = endIndex;\n        }\n        currentState = tokenizationResult.endState;\n    }\n    result += `</div>`;\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { equals } from '../../base/common/objects.js';\n/**\n * Vertical Lane in the overview ruler of the editor.\n */\nexport var OverviewRulerLane;\n(function (OverviewRulerLane) {\n    OverviewRulerLane[OverviewRulerLane[\"Left\"] = 1] = \"Left\";\n    OverviewRulerLane[OverviewRulerLane[\"Center\"] = 2] = \"Center\";\n    OverviewRulerLane[OverviewRulerLane[\"Right\"] = 4] = \"Right\";\n    OverviewRulerLane[OverviewRulerLane[\"Full\"] = 7] = \"Full\";\n})(OverviewRulerLane || (OverviewRulerLane = {}));\n/**\n * Position in the minimap to render the decoration.\n */\nexport var MinimapPosition;\n(function (MinimapPosition) {\n    MinimapPosition[MinimapPosition[\"Inline\"] = 1] = \"Inline\";\n    MinimapPosition[MinimapPosition[\"Gutter\"] = 2] = \"Gutter\";\n})(MinimapPosition || (MinimapPosition = {}));\nexport var InjectedTextCursorStops;\n(function (InjectedTextCursorStops) {\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Both\"] = 0] = \"Both\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Right\"] = 1] = \"Right\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Left\"] = 2] = \"Left\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"None\"] = 3] = \"None\";\n})(InjectedTextCursorStops || (InjectedTextCursorStops = {}));\nexport class TextModelResolvedOptions {\n    /**\n     * @internal\n     */\n    constructor(src) {\n        this._textModelResolvedOptionsBrand = undefined;\n        this.tabSize = Math.max(1, src.tabSize | 0);\n        this.indentSize = src.tabSize | 0;\n        this.insertSpaces = Boolean(src.insertSpaces);\n        this.defaultEOL = src.defaultEOL | 0;\n        this.trimAutoWhitespace = Boolean(src.trimAutoWhitespace);\n        this.bracketPairColorizationOptions = src.bracketPairColorizationOptions;\n    }\n    /**\n     * @internal\n     */\n    equals(other) {\n        return (this.tabSize === other.tabSize\n            && this.indentSize === other.indentSize\n            && this.insertSpaces === other.insertSpaces\n            && this.defaultEOL === other.defaultEOL\n            && this.trimAutoWhitespace === other.trimAutoWhitespace\n            && equals(this.bracketPairColorizationOptions, other.bracketPairColorizationOptions));\n    }\n    /**\n     * @internal\n     */\n    createChangeEvent(newOpts) {\n        return {\n            tabSize: this.tabSize !== newOpts.tabSize,\n            indentSize: this.indentSize !== newOpts.indentSize,\n            insertSpaces: this.insertSpaces !== newOpts.insertSpaces,\n            trimAutoWhitespace: this.trimAutoWhitespace !== newOpts.trimAutoWhitespace,\n        };\n    }\n}\nexport class FindMatch {\n    /**\n     * @internal\n     */\n    constructor(range, matches) {\n        this._findMatchBrand = undefined;\n        this.range = range;\n        this.matches = matches;\n    }\n}\n/**\n * @internal\n */\nexport function isITextSnapshot(obj) {\n    return (obj && typeof obj.read === 'function');\n}\n/**\n * @internal\n */\nexport class ValidAnnotatedEditOperation {\n    constructor(identifier, range, text, forceMoveMarkers, isAutoWhitespaceEdit, _isTracked) {\n        this.identifier = identifier;\n        this.range = range;\n        this.text = text;\n        this.forceMoveMarkers = forceMoveMarkers;\n        this.isAutoWhitespaceEdit = isAutoWhitespaceEdit;\n        this._isTracked = _isTracked;\n    }\n}\n/**\n * @internal\n */\nexport class SearchData {\n    constructor(regex, wordSeparators, simpleSearch) {\n        this.regex = regex;\n        this.wordSeparators = wordSeparators;\n        this.simpleSearch = simpleSearch;\n    }\n}\n/**\n * @internal\n */\nexport class ApplyEditsResult {\n    constructor(reverseEdits, changes, trimAutoWhitespaceLineNumbers) {\n        this.reverseEdits = reverseEdits;\n        this.changes = changes;\n        this.trimAutoWhitespaceLineNumbers = trimAutoWhitespaceLineNumbers;\n    }\n}\n/**\n * @internal\n */\nexport function shouldSynchronizeModel(model) {\n    return (!model.isTooLargeForSyncing() && !model.isForSimpleWidget);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { Range } from '../../../core/range.js';\nimport { BracketInfo, BracketPairWithMinIndentationInfo } from '../../../textModelBracketPairs.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { LanguageAgnosticBracketTokens } from './brackets.js';\nimport { lengthAdd, lengthGreaterThanEqual, lengthLessThan, lengthLessThanEqual, lengthOfString, lengthsToRange, lengthZero, positionToLength, toLength } from './length.js';\nimport { parseDocument } from './parser.js';\nimport { DenseKeyProvider } from './smallImmutableSet.js';\nimport { FastTokenizer, TextBufferTokenizer } from './tokenizer.js';\nexport class BracketPairsTree extends Disposable {\n    constructor(textModel, getLanguageConfiguration) {\n        super();\n        this.textModel = textModel;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.didChangeEmitter = new Emitter();\n        this.denseKeyProvider = new DenseKeyProvider();\n        this.brackets = new LanguageAgnosticBracketTokens(this.denseKeyProvider, this.getLanguageConfiguration);\n        this.onDidChange = this.didChangeEmitter.event;\n        if (textModel.tokenization.backgroundTokenizationState === 0 /* BackgroundTokenizationState.Uninitialized */) {\n            // There are no token information yet\n            const brackets = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId());\n            const tokenizer = new FastTokenizer(this.textModel.getValue(), brackets);\n            this.initialAstWithoutTokens = parseDocument(tokenizer, [], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n        else if (textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            // Skip the initial ast, as there is no flickering.\n            // Directly create the tree with token information.\n            this.initialAstWithoutTokens = undefined;\n            this.astWithTokens = this.parseDocumentFromTextBuffer([], undefined, false);\n        }\n        else if (textModel.tokenization.backgroundTokenizationState === 1 /* BackgroundTokenizationState.InProgress */) {\n            this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n    }\n    didLanguageChange(languageId) {\n        return this.brackets.didLanguageChange(languageId);\n    }\n    //#region TextModel events\n    handleDidChangeBackgroundTokenizationState() {\n        if (this.textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            const wasUndefined = this.initialAstWithoutTokens === undefined;\n            // Clear the initial tree as we can use the tree with token information now.\n            this.initialAstWithoutTokens = undefined;\n            if (!wasUndefined) {\n                this.didChangeEmitter.fire();\n            }\n        }\n    }\n    handleDidChangeTokens({ ranges }) {\n        const edits = ranges.map(r => new TextEditInfo(toLength(r.fromLineNumber - 1, 0), toLength(r.toLineNumber, 0), toLength(r.toLineNumber - r.fromLineNumber + 1, 0)));\n        this.astWithTokens = this.parseDocumentFromTextBuffer(edits, this.astWithTokens, false);\n        if (!this.initialAstWithoutTokens) {\n            this.didChangeEmitter.fire();\n        }\n    }\n    handleContentChanged(change) {\n        const edits = change.changes.map(c => {\n            const range = Range.lift(c.range);\n            return new TextEditInfo(positionToLength(range.getStartPosition()), positionToLength(range.getEndPosition()), lengthOfString(c.text));\n        }).reverse();\n        this.astWithTokens = this.parseDocumentFromTextBuffer(edits, this.astWithTokens, false);\n        if (this.initialAstWithoutTokens) {\n            this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(edits, this.initialAstWithoutTokens, false);\n        }\n    }\n    //#endregion\n    /**\n     * @pure (only if isPure = true)\n    */\n    parseDocumentFromTextBuffer(edits, previousAst, immutable) {\n        // Is much faster if `isPure = false`.\n        const isPure = false;\n        const previousAstClone = isPure ? previousAst === null || previousAst === void 0 ? void 0 : previousAst.deepClone() : previousAst;\n        const tokenizer = new TextBufferTokenizer(this.textModel, this.brackets);\n        const result = parseDocument(tokenizer, edits, previousAstClone, immutable);\n        return result;\n    }\n    getBracketsInRange(range) {\n        const startOffset = toLength(range.startLineNumber - 1, range.startColumn - 1);\n        const endOffset = toLength(range.endLineNumber - 1, range.endColumn - 1);\n        const result = new Array();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        collectBrackets(node, lengthZero, node.length, startOffset, endOffset, result, 0, new Map());\n        return result;\n    }\n    getBracketPairsInRange(range, includeMinIndentation) {\n        const result = new Array();\n        const startLength = positionToLength(range.getStartPosition());\n        const endLength = positionToLength(range.getEndPosition());\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        const context = new CollectBracketPairsContext(result, includeMinIndentation, this.textModel);\n        collectBracketPairs(node, lengthZero, node.length, startLength, endLength, context, 0, new Map());\n        return result;\n    }\n    getFirstBracketAfter(position) {\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketAfter(node, lengthZero, node.length, positionToLength(position));\n    }\n    getFirstBracketBefore(position) {\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketBefore(node, lengthZero, node.length, positionToLength(position));\n    }\n}\nfunction getFirstBracketBefore(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        const lengths = [];\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            lengths.push({ nodeOffsetStart, nodeOffsetEnd });\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        for (let i = lengths.length - 1; i >= 0; i--) {\n            const { nodeOffsetStart, nodeOffsetEnd } = lengths[i];\n            if (lengthLessThan(nodeOffsetStart, position)) {\n                const result = getFirstBracketBefore(node.children[i], nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction getFirstBracketAfter(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThan(position, nodeOffsetEnd)) {\n                const result = getFirstBracketAfter(child, nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction collectBrackets(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level, levelPerBracketType) {\n    if (level > 200) {\n        return;\n    }\n    if (node.kind === 4 /* AstNodeKind.List */) {\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level, levelPerBracketType);\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n    }\n    else if (node.kind === 2 /* AstNodeKind.Pair */) {\n        let levelPerBracket = 0;\n        if (levelPerBracketType) {\n            let existing = levelPerBracketType.get(node.openingBracket.text);\n            if (existing === undefined) {\n                existing = 0;\n            }\n            levelPerBracket = existing;\n            existing++;\n            levelPerBracketType.set(node.openingBracket.text, existing);\n        }\n        // Don't use node.children here to improve performance\n        {\n            const child = node.openingBracket;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                result.push(new BracketInfo(range, level, levelPerBracket, !node.closingBracket));\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        if (node.child) {\n            const child = node.child;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, result, level + 1, levelPerBracketType);\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        if (node.closingBracket) {\n            const child = node.closingBracket;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                result.push(new BracketInfo(range, level, levelPerBracket, false));\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        levelPerBracketType === null || levelPerBracketType === void 0 ? void 0 : levelPerBracketType.set(node.openingBracket.text, levelPerBracket);\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        result.push(new BracketInfo(range, level - 1, 0, true));\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        result.push(new BracketInfo(range, level - 1, 0, false));\n    }\n}\nclass CollectBracketPairsContext {\n    constructor(result, includeMinIndentation, textModel) {\n        this.result = result;\n        this.includeMinIndentation = includeMinIndentation;\n        this.textModel = textModel;\n    }\n}\nfunction collectBracketPairs(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level, levelPerBracketType) {\n    var _a;\n    if (level > 200) {\n        return;\n    }\n    if (node.kind === 2 /* AstNodeKind.Pair */) {\n        let levelPerBracket = 0;\n        if (levelPerBracketType) {\n            let existing = levelPerBracketType.get(node.openingBracket.text);\n            if (existing === undefined) {\n                existing = 0;\n            }\n            levelPerBracket = existing;\n            existing++;\n            levelPerBracketType.set(node.openingBracket.text, existing);\n        }\n        const openingBracketEnd = lengthAdd(nodeOffsetStart, node.openingBracket.length);\n        let minIndentation = -1;\n        if (context.includeMinIndentation) {\n            minIndentation = node.computeMinIndentation(nodeOffsetStart, context.textModel);\n        }\n        context.result.push(new BracketPairWithMinIndentationInfo(lengthsToRange(nodeOffsetStart, nodeOffsetEnd), lengthsToRange(nodeOffsetStart, openingBracketEnd), node.closingBracket\n            ? lengthsToRange(lengthAdd(openingBracketEnd, ((_a = node.child) === null || _a === void 0 ? void 0 : _a.length) || lengthZero), nodeOffsetEnd)\n            : undefined, level, levelPerBracket, node, minIndentation));\n        nodeOffsetStart = openingBracketEnd;\n        if (node.child) {\n            const child = node.child;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                collectBracketPairs(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level + 1, levelPerBracketType);\n            }\n        }\n        levelPerBracketType === null || levelPerBracketType === void 0 ? void 0 : levelPerBracketType.set(node.openingBracket.text, levelPerBracket);\n    }\n    else {\n        let curOffset = nodeOffsetStart;\n        for (const child of node.children) {\n            const childOffset = curOffset;\n            curOffset = lengthAdd(curOffset, child.length);\n            if (lengthLessThanEqual(childOffset, endOffset) &&\n                lengthLessThanEqual(startOffset, curOffset)) {\n                collectBracketPairs(child, childOffset, curOffset, startOffset, endOffset, context, level, levelPerBracketType);\n            }\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { BracketPairsTree } from './bracketPairsTree/bracketPairsTree.js';\nimport { ignoreBracketsInToken } from '../../languages/supports.js';\nimport { BracketsUtils } from '../../languages/supports/richEditBrackets.js';\nimport { compareBy, findLast, findLastMaxBy } from '../../../../base/common/arrays.js';\nexport class BracketPairsTextModelPart extends Disposable {\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n        this.bracketPairsTree = this._register(new MutableDisposable());\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.bracketsRequested = false;\n        this._register(this.languageConfigurationService.onDidChange(e => {\n            var _a;\n            if (!e.languageId || ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.didLanguageChange(e.languageId))) {\n                this.bracketPairsTree.clear();\n                this.updateBracketPairsTree();\n            }\n        }));\n    }\n    get canBuildAST() {\n        const maxSupportedDocumentLength = /* max lines */ 50000 * /* average column count */ 100;\n        return this.textModel.getValueLength() <= maxSupportedDocumentLength;\n    }\n    //#region TextModel events\n    handleDidChangeOptions(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeLanguage(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeContent(change) {\n        var _a;\n        (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleContentChanged(change);\n    }\n    handleDidChangeBackgroundTokenizationState() {\n        var _a;\n        (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleDidChangeBackgroundTokenizationState();\n    }\n    handleDidChangeTokens(e) {\n        var _a;\n        (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleDidChangeTokens(e);\n    }\n    //#endregion\n    updateBracketPairsTree() {\n        if (this.bracketsRequested && this.canBuildAST) {\n            if (!this.bracketPairsTree.value) {\n                const store = new DisposableStore();\n                this.bracketPairsTree.value = createDisposableRef(store.add(new BracketPairsTree(this.textModel, (languageId) => {\n                    return this.languageConfigurationService.getLanguageConfiguration(languageId);\n                })), store);\n                store.add(this.bracketPairsTree.value.object.onDidChange(e => this.onDidChangeEmitter.fire(e)));\n                this.onDidChangeEmitter.fire();\n            }\n        }\n        else {\n            if (this.bracketPairsTree.value) {\n                this.bracketPairsTree.clear();\n                // Important: Don't call fire if there was no change!\n                this.onDidChangeEmitter.fire();\n            }\n        }\n    }\n    /**\n     * Returns all bracket pairs that intersect the given range.\n     * The result is sorted by the start position.\n    */\n    getBracketPairsInRange(range) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, false)) || [];\n    }\n    getBracketPairsInRangeWithMinIndentation(range) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, true)) || [];\n    }\n    getBracketsInRange(range) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketsInRange(range)) || [];\n    }\n    findMatchingBracketUp(_bracket, _position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        const languageId = this.textModel.getLanguageIdAtPosition(position.lineNumber, position.column);\n        if (this.canBuildAST) {\n            const closingBracketInfo = this.languageConfigurationService\n                .getLanguageConfiguration(languageId)\n                .bracketsNew.getClosingBracketInfo(_bracket);\n            if (!closingBracketInfo) {\n                return null;\n            }\n            const bracketPair = findLast(this.getBracketPairsInRange(Range.fromPositions(_position, _position)) || [], (b) => closingBracketInfo.closes(b.openingBracketInfo));\n            if (bracketPair) {\n                return bracketPair.openingBracketRange;\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const bracket = _bracket.toLowerCase();\n            const bracketsSupport = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n            if (!bracketsSupport) {\n                return null;\n            }\n            const data = bracketsSupport.textIsBracket[bracket];\n            if (!data) {\n                return null;\n            }\n            return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, createTimeBasedContinueBracketSearchPredicate(maxDuration)));\n        }\n    }\n    matchBracket(position, maxDuration) {\n        if (this.canBuildAST) {\n            const bracketPair = findLastMaxBy(this.getBracketPairsInRange(Range.fromPositions(position, position)).filter((item) => item.closingBracketRange !== undefined &&\n                (item.openingBracketRange.containsPosition(position) ||\n                    item.closingBracketRange.containsPosition(position))), compareBy((item) => item.openingBracketRange.containsPosition(position)\n                ? item.openingBracketRange\n                : item.closingBracketRange, Range.compareRangesUsingStarts));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n            return this._matchBracket(this.textModel.validatePosition(position), continueSearchPredicate);\n        }\n    }\n    _establishBracketSearchOffsets(position, lineTokens, modeBrackets, tokenIndex) {\n        const tokenCount = lineTokens.getCount();\n        const currentLanguageId = lineTokens.getLanguageId(tokenIndex);\n        // limit search to not go before `maxBracketLength`\n        let searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);\n        for (let i = tokenIndex - 1; i >= 0; i--) {\n            const tokenEndOffset = lineTokens.getEndOffset(i);\n            if (tokenEndOffset <= searchStartOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchStartOffset = tokenEndOffset;\n                break;\n            }\n        }\n        // limit search to not go after `maxBracketLength`\n        let searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);\n        for (let i = tokenIndex + 1; i < tokenCount; i++) {\n            const tokenStartOffset = lineTokens.getStartOffset(i);\n            if (tokenStartOffset >= searchEndOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchEndOffset = tokenStartOffset;\n                break;\n            }\n        }\n        return { searchStartOffset, searchEndOffset };\n    }\n    _matchBracket(position, continueSearchPredicate) {\n        const lineNumber = position.lineNumber;\n        const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n        const lineText = this.textModel.getLineContent(lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        if (tokenIndex < 0) {\n            return null;\n        }\n        const currentModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).brackets;\n        // check that the token is not to be ignored\n        if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n            let { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex);\n            // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n            // `bestResult` will contain the most right-side result\n            let bestResult = null;\n            while (true) {\n                const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!foundBracket) {\n                    // there are no more brackets in this text\n                    break;\n                }\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        bestResult = r;\n                    }\n                }\n                searchStartOffset = foundBracket.endColumn - 1;\n            }\n            if (bestResult) {\n                return bestResult;\n            }\n        }\n        // If position is in between two tokens, try also looking in the previous token\n        if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n            const prevTokenIndex = tokenIndex - 1;\n            const prevModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(prevTokenIndex)).brackets;\n            // check that previous token is not to be ignored\n            if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\n                const { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex);\n                const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        return r;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {\n        if (!data) {\n            return null;\n        }\n        const matched = (isOpen\n            ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate)\n            : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate));\n        if (!matched) {\n            return null;\n        }\n        if (matched instanceof BracketSearchCanceled) {\n            return matched;\n        }\n        return [foundBracket, matched];\n    }\n    _findMatchingBracketUp(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const reversedBracketRegex = bracket.reversedRegex;\n        let count = -1;\n        let totalCallCount = 0;\n        const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchEndOffset = r.startColumn - 1;\n            }\n            return null;\n        };\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    _findMatchingBracketDown(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const bracketRegex = bracket.forwardRegex;\n        let count = 1;\n        let totalCallCount = 0;\n        const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        const lineCount = this.textModel.getLineCount();\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    findPrevBracket(_position) {\n        var _a;\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getFirstBracketBefore(position)) || null;\n        }\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && bracketConfig && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findNextBracket(_position) {\n        var _a;\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getFirstBracketAfter(position)) || null;\n        }\n        const lineCount = this.textModel.getLineCount();\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findEnclosingBrackets(_position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            const range = Range.fromPositions(position);\n            const bracketPair = findLast(this.getBracketPairsInRange(Range.fromPositions(position, position)), (item) => item.closingBracketRange !== undefined && item.range.strictContainsRange(range));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n        const lineCount = this.textModel.getLineCount();\n        const savedCounts = new Map();\n        let counts = [];\n        const resetCounts = (languageId, modeBrackets) => {\n            if (!savedCounts.has(languageId)) {\n                const tmp = [];\n                for (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\n                    tmp[i] = 0;\n                }\n                savedCounts.set(languageId, tmp);\n            }\n            counts = savedCounts.get(languageId);\n        };\n        let totalCallCount = 0;\n        const searchInRange = (modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                const bracket = modeBrackets.textIsBracket[hitText];\n                if (bracket) {\n                    if (bracket.isOpen(hitText)) {\n                        counts[bracket.index]++;\n                    }\n                    else if (bracket.isClose(hitText)) {\n                        counts[bracket.index]--;\n                    }\n                    if (counts[bracket.index] === -1) {\n                        return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);\n                    }\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        let languageId = null;\n        let modeBrackets = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return stripBracketSearchCanceled(r);\n                }\n            }\n        }\n        return null;\n    }\n    _toFoundBracket(bracketConfig, r) {\n        if (!r) {\n            return null;\n        }\n        let text = this.textModel.getValueInRange(r);\n        text = text.toLowerCase();\n        const bracketInfo = bracketConfig.getBracketInfo(text);\n        if (!bracketInfo) {\n            return null;\n        }\n        return {\n            range: r,\n            bracketInfo\n        };\n    }\n}\nfunction createDisposableRef(object, disposable) {\n    return {\n        object,\n        dispose: () => disposable === null || disposable === void 0 ? void 0 : disposable.dispose(),\n    };\n}\nfunction createTimeBasedContinueBracketSearchPredicate(maxDuration) {\n    if (typeof maxDuration === 'undefined') {\n        return () => true;\n    }\n    else {\n        const startTime = Date.now();\n        return () => {\n            return (Date.now() - startTime <= maxDuration);\n        };\n    }\n}\nclass BracketSearchCanceled {\n    constructor() {\n        this._searchCanceledBrand = undefined;\n    }\n}\nBracketSearchCanceled.INSTANCE = new BracketSearchCanceled();\nfunction stripBracketSearchCanceled(result) {\n    if (result instanceof BracketSearchCanceled) {\n        return null;\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorColumns } from '../../../core/cursorColumns.js';\nimport { lengthAdd, lengthGetLineCount, lengthToObj, lengthZero } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\n/**\n * The base implementation for all AST nodes.\n*/\nclass BaseAstNode {\n    constructor(length) {\n        this._length = length;\n    }\n    /**\n     * The length of the entire node, which should equal the sum of lengths of all children.\n    */\n    get length() {\n        return this._length;\n    }\n}\n/**\n * Represents a bracket pair including its child (e.g. `{ ... }`).\n * Might be unclosed.\n * Immutable, if all children are immutable.\n*/\nexport class PairAstNode extends BaseAstNode {\n    constructor(length, openingBracket, child, closingBracket, missingOpeningBracketIds) {\n        super(length);\n        this.openingBracket = openingBracket;\n        this.child = child;\n        this.closingBracket = closingBracket;\n        this.missingOpeningBracketIds = missingOpeningBracketIds;\n    }\n    static create(openingBracket, child, closingBracket) {\n        let length = openingBracket.length;\n        if (child) {\n            length = lengthAdd(length, child.length);\n        }\n        if (closingBracket) {\n            length = lengthAdd(length, closingBracket.length);\n        }\n        return new PairAstNode(length, openingBracket, child, closingBracket, child ? child.missingOpeningBracketIds : SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 2 /* AstNodeKind.Pair */;\n    }\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 3;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this.openingBracket;\n            case 1: return this.child;\n            case 2: return this.closingBracket;\n        }\n        throw new Error('Invalid child index');\n    }\n    /**\n     * Avoid using this property, it allocates an array!\n    */\n    get children() {\n        const result = new Array();\n        result.push(this.openingBracket);\n        if (this.child) {\n            result.push(this.child);\n        }\n        if (this.closingBracket) {\n            result.push(this.closingBracket);\n        }\n        return result;\n    }\n    canBeReused(openBracketIds) {\n        if (this.closingBracket === null) {\n            // Unclosed pair ast nodes only\n            // end at the end of the document\n            // or when a parent node is closed.\n            // This could be improved:\n            // Only return false if some next token is neither \"undefined\" nor a bracket that closes a parent.\n            return false;\n        }\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        return true;\n    }\n    deepClone() {\n        return new PairAstNode(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return this.child ? this.child.computeMinIndentation(lengthAdd(offset, this.openingBracket.length), textModel) : Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class ListAstNode extends BaseAstNode {\n    /**\n     * Use ListAstNode.create.\n    */\n    constructor(length, listHeight, _missingOpeningBracketIds) {\n        super(length);\n        this.listHeight = listHeight;\n        this._missingOpeningBracketIds = _missingOpeningBracketIds;\n        this.cachedMinIndentation = -1;\n    }\n    /**\n     * This method uses more memory-efficient list nodes that can only store 2 or 3 children.\n    */\n    static create23(item1, item2, item3, immutable = false) {\n        let length = item1.length;\n        let missingBracketIds = item1.missingOpeningBracketIds;\n        if (item1.listHeight !== item2.listHeight) {\n            throw new Error('Invalid list heights');\n        }\n        length = lengthAdd(length, item2.length);\n        missingBracketIds = missingBracketIds.merge(item2.missingOpeningBracketIds);\n        if (item3) {\n            if (item1.listHeight !== item3.listHeight) {\n                throw new Error('Invalid list heights');\n            }\n            length = lengthAdd(length, item3.length);\n            missingBracketIds = missingBracketIds.merge(item3.missingOpeningBracketIds);\n        }\n        return immutable\n            ? new Immutable23ListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds)\n            : new TwoThreeListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds);\n    }\n    static getEmpty() {\n        return new ImmutableArrayListAstNode(lengthZero, 0, [], SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 4 /* AstNodeKind.List */;\n    }\n    get missingOpeningBracketIds() {\n        return this._missingOpeningBracketIds;\n    }\n    throwIfImmutable() {\n        // NOOP\n    }\n    makeLastElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const lastChild = this.getChild(childCount - 1);\n        const mutable = lastChild.kind === 4 /* AstNodeKind.List */ ? lastChild.toMutable() : lastChild;\n        if (lastChild !== mutable) {\n            this.setChild(childCount - 1, mutable);\n        }\n        return mutable;\n    }\n    makeFirstElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const firstChild = this.getChild(0);\n        const mutable = firstChild.kind === 4 /* AstNodeKind.List */ ? firstChild.toMutable() : firstChild;\n        if (firstChild !== mutable) {\n            this.setChild(0, mutable);\n        }\n        return mutable;\n    }\n    canBeReused(openBracketIds) {\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        let lastChild = this;\n        let lastLength;\n        while (lastChild.kind === 4 /* AstNodeKind.List */ && (lastLength = lastChild.childrenLength) > 0) {\n            lastChild = lastChild.getChild(lastLength - 1);\n        }\n        return lastChild.canBeReused(openBracketIds);\n    }\n    handleChildrenChanged() {\n        this.throwIfImmutable();\n        const count = this.childrenLength;\n        let length = this.getChild(0).length;\n        let unopenedBrackets = this.getChild(0).missingOpeningBracketIds;\n        for (let i = 1; i < count; i++) {\n            const child = this.getChild(i);\n            length = lengthAdd(length, child.length);\n            unopenedBrackets = unopenedBrackets.merge(child.missingOpeningBracketIds);\n        }\n        this._length = length;\n        this._missingOpeningBracketIds = unopenedBrackets;\n        this.cachedMinIndentation = -1;\n    }\n    computeMinIndentation(offset, textModel) {\n        if (this.cachedMinIndentation !== -1) {\n            return this.cachedMinIndentation;\n        }\n        let minIndentation = Number.MAX_SAFE_INTEGER;\n        let childOffset = offset;\n        for (let i = 0; i < this.childrenLength; i++) {\n            const child = this.getChild(i);\n            if (child) {\n                minIndentation = Math.min(minIndentation, child.computeMinIndentation(childOffset, textModel));\n                childOffset = lengthAdd(childOffset, child.length);\n            }\n        }\n        this.cachedMinIndentation = minIndentation;\n        return minIndentation;\n    }\n}\nclass TwoThreeListAstNode extends ListAstNode {\n    constructor(length, listHeight, _item1, _item2, _item3, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._item1 = _item1;\n        this._item2 = _item2;\n        this._item3 = _item3;\n    }\n    get childrenLength() {\n        return this._item3 !== null ? 3 : 2;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this._item1;\n            case 1: return this._item2;\n            case 2: return this._item3;\n        }\n        throw new Error('Invalid child index');\n    }\n    setChild(idx, node) {\n        switch (idx) {\n            case 0:\n                this._item1 = node;\n                return;\n            case 1:\n                this._item2 = node;\n                return;\n            case 2:\n                this._item3 = node;\n                return;\n        }\n        throw new Error('Invalid child index');\n    }\n    get children() {\n        return this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];\n    }\n    get item1() {\n        return this._item1;\n    }\n    get item2() {\n        return this._item2;\n    }\n    get item3() {\n        return this._item3;\n    }\n    deepClone() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot append to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = node;\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    prependChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot prepend to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = this._item2;\n        this._item2 = this._item1;\n        this._item1 = node;\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item1;\n        this._item1 = this._item2;\n        this._item2 = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass Immutable23ListAstNode extends TwoThreeListAstNode {\n    toMutable() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\n/**\n * For debugging.\n*/\nclass ArrayListAstNode extends ListAstNode {\n    constructor(length, listHeight, _children, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._children = _children;\n    }\n    get childrenLength() {\n        return this._children.length;\n    }\n    getChild(idx) {\n        return this._children[idx];\n    }\n    setChild(idx, child) {\n        this._children[idx] = child;\n    }\n    get children() {\n        return this._children;\n    }\n    deepClone() {\n        const children = new Array(this._children.length);\n        for (let i = 0; i < this._children.length; i++) {\n            children[i] = this._children[i].deepClone();\n        }\n        return new ArrayListAstNode(this.length, this.listHeight, children, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.push(node);\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        this.throwIfImmutable();\n        const item = this._children.pop();\n        this.handleChildrenChanged();\n        return item;\n    }\n    prependChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.unshift(node);\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        this.throwIfImmutable();\n        const item = this._children.shift();\n        this.handleChildrenChanged();\n        return item;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass ImmutableArrayListAstNode extends ArrayListAstNode {\n    toMutable() {\n        return new ArrayListAstNode(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\nconst emptyArray = [];\nclass ImmutableLeafAstNode extends BaseAstNode {\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 0;\n    }\n    getChild(idx) {\n        return null;\n    }\n    get children() {\n        return emptyArray;\n    }\n    deepClone() {\n        return this;\n    }\n}\nexport class TextAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 0 /* AstNodeKind.Text */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    canBeReused(_openedBracketIds) {\n        return true;\n    }\n    computeMinIndentation(offset, textModel) {\n        const start = lengthToObj(offset);\n        // Text ast nodes don't have partial indentation (ensured by the tokenizer).\n        // Thus, if this text node does not start at column 0, the first line cannot have any indentation at all.\n        const startLineNumber = (start.columnCount === 0 ? start.lineCount : start.lineCount + 1) + 1;\n        const endLineNumber = lengthGetLineCount(lengthAdd(offset, this.length)) + 1;\n        let result = Number.MAX_SAFE_INTEGER;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const firstNonWsColumn = textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n            const lineContent = textModel.getLineContent(lineNumber);\n            if (firstNonWsColumn === 0) {\n                continue;\n            }\n            const visibleColumn = CursorColumns.visibleColumnFromColumn(lineContent, firstNonWsColumn, textModel.getOptions().tabSize);\n            result = Math.min(result, visibleColumn);\n        }\n        return result;\n    }\n}\nexport class BracketAstNode extends ImmutableLeafAstNode {\n    constructor(length, bracketInfo, \n    /**\n     * In case of a opening bracket, this is the id of the opening bracket.\n     * In case of a closing bracket, this contains the ids of all opening brackets it can close.\n    */\n    bracketIds) {\n        super(length);\n        this.bracketInfo = bracketInfo;\n        this.bracketIds = bracketIds;\n    }\n    static create(length, bracketInfo, bracketIds) {\n        const node = new BracketAstNode(length, bracketInfo, bracketIds);\n        return node;\n    }\n    get kind() {\n        return 1 /* AstNodeKind.Bracket */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    get text() {\n        return this.bracketInfo.bracketText;\n    }\n    get languageId() {\n        return this.bracketInfo.languageId;\n    }\n    canBeReused(_openedBracketIds) {\n        // These nodes could be reused,\n        // but not in a general way.\n        // Their parent may be reused.\n        return false;\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class InvalidBracketAstNode extends ImmutableLeafAstNode {\n    constructor(closingBrackets, length) {\n        super(length);\n        this.missingOpeningBracketIds = closingBrackets;\n    }\n    get kind() {\n        return 3 /* AstNodeKind.UnexpectedClosingBracket */;\n    }\n    canBeReused(openedBracketIds) {\n        return !openedBracketIds.intersects(this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { lengthAdd, lengthDiffNonNegative, lengthLessThanEqual, lengthToObj, toLength } from './length.js';\nexport class TextEditInfo {\n    constructor(startOffset, endOffset, newLength) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.newLength = newLength;\n    }\n}\nexport class BeforeEditPositionMapper {\n    /**\n     * @param edits Must be sorted by offset in ascending order.\n    */\n    constructor(edits, documentLength) {\n        this.documentLength = documentLength;\n        this.nextEditIdx = 0;\n        this.deltaOldToNewLineCount = 0;\n        this.deltaOldToNewColumnCount = 0;\n        this.deltaLineIdxInOld = -1;\n        this.edits = edits.map(edit => TextEditInfoCache.from(edit));\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n    */\n    getOffsetBeforeChange(offset) {\n        this.adjustNextEdit(offset);\n        return this.translateCurToOld(offset);\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n    */\n    getDistanceToNextChange(offset) {\n        this.adjustNextEdit(offset);\n        const nextEdit = this.edits[this.nextEditIdx];\n        const nextChangeOffset = nextEdit ? this.translateOldToCur(nextEdit.offsetObj) : this.documentLength;\n        return lengthDiffNonNegative(offset, nextChangeOffset);\n    }\n    translateOldToCur(oldOffsetObj) {\n        if (oldOffsetObj.lineCount === this.deltaLineIdxInOld) {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount + this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount);\n        }\n    }\n    translateCurToOld(newOffset) {\n        const offsetObj = lengthToObj(newOffset);\n        if (offsetObj.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld) {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount - this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount);\n        }\n    }\n    adjustNextEdit(offset) {\n        while (this.nextEditIdx < this.edits.length) {\n            const nextEdit = this.edits[this.nextEditIdx];\n            // After applying the edit, what is its end offset (considering all previous edits)?\n            const nextEditEndOffsetInCur = this.translateOldToCur(nextEdit.endOffsetAfterObj);\n            if (lengthLessThanEqual(nextEditEndOffsetInCur, offset)) {\n                // We are after the edit, skip it\n                this.nextEditIdx++;\n                const nextEditEndOffsetInCurObj = lengthToObj(nextEditEndOffsetInCur);\n                // Before applying the edit, what is its end offset (considering all previous edits)?\n                const nextEditEndOffsetBeforeInCurObj = lengthToObj(this.translateOldToCur(nextEdit.endOffsetBeforeObj));\n                const lineDelta = nextEditEndOffsetInCurObj.lineCount - nextEditEndOffsetBeforeInCurObj.lineCount;\n                this.deltaOldToNewLineCount += lineDelta;\n                const previousColumnDelta = this.deltaLineIdxInOld === nextEdit.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0;\n                const columnDelta = nextEditEndOffsetInCurObj.columnCount - nextEditEndOffsetBeforeInCurObj.columnCount;\n                this.deltaOldToNewColumnCount = previousColumnDelta + columnDelta;\n                this.deltaLineIdxInOld = nextEdit.endOffsetBeforeObj.lineCount;\n            }\n            else {\n                // We are in or before the edit.\n                break;\n            }\n        }\n    }\n}\nclass TextEditInfoCache {\n    constructor(startOffset, endOffset, textLength) {\n        this.endOffsetBeforeObj = lengthToObj(endOffset);\n        this.endOffsetAfterObj = lengthToObj(lengthAdd(startOffset, textLength));\n        this.offsetObj = lengthToObj(startOffset);\n    }\n    static from(edit) {\n        return new TextEditInfoCache(edit.startOffset, edit.endOffset, edit.newLength);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { escapeRegExpCharacters } from '../../../../../base/common/strings.js';\nimport { BracketAstNode } from './ast.js';\nimport { toLength } from './length.js';\nimport { identityKeyProvider, SmallImmutableSet } from './smallImmutableSet.js';\nimport { Token } from './tokenizer.js';\nexport class BracketTokens {\n    constructor(map) {\n        this.map = map;\n        this.hasRegExp = false;\n        this._regExpGlobal = null;\n    }\n    static createFromLanguage(configuration, denseKeyProvider) {\n        function getId(bracketInfo) {\n            return denseKeyProvider.getKey(`${bracketInfo.languageId}:::${bracketInfo.bracketText}`);\n        }\n        const map = new Map();\n        for (const openingBracket of configuration.bracketsNew.openingBrackets) {\n            const length = toLength(0, openingBracket.bracketText.length);\n            const openingTextId = getId(openingBracket);\n            const bracketIds = SmallImmutableSet.getEmpty().add(openingTextId, identityKeyProvider);\n            map.set(openingBracket.bracketText, new Token(length, 1 /* TokenKind.OpeningBracket */, openingTextId, bracketIds, BracketAstNode.create(length, openingBracket, bracketIds)));\n        }\n        for (const closingBracket of configuration.bracketsNew.closingBrackets) {\n            const length = toLength(0, closingBracket.bracketText.length);\n            let bracketIds = SmallImmutableSet.getEmpty();\n            const closingBrackets = closingBracket.getClosedBrackets();\n            for (const bracket of closingBrackets) {\n                bracketIds = bracketIds.add(getId(bracket), identityKeyProvider);\n            }\n            map.set(closingBracket.bracketText, new Token(length, 2 /* TokenKind.ClosingBracket */, getId(closingBrackets[0]), bracketIds, BracketAstNode.create(length, closingBracket, bracketIds)));\n        }\n        return new BracketTokens(map);\n    }\n    getRegExpStr() {\n        if (this.isEmpty) {\n            return null;\n        }\n        else {\n            const keys = [...this.map.keys()];\n            keys.sort();\n            keys.reverse();\n            return keys.map(k => prepareBracketForRegExp(k)).join('|');\n        }\n    }\n    /**\n     * Returns null if there is no such regexp (because there are no brackets).\n    */\n    get regExpGlobal() {\n        if (!this.hasRegExp) {\n            const regExpStr = this.getRegExpStr();\n            this._regExpGlobal = regExpStr ? new RegExp(regExpStr, 'gi') : null;\n            this.hasRegExp = true;\n        }\n        return this._regExpGlobal;\n    }\n    getToken(value) {\n        return this.map.get(value.toLowerCase());\n    }\n    findClosingTokenText(openingBracketIds) {\n        for (const [closingText, info] of this.map) {\n            if (info.kind === 2 /* TokenKind.ClosingBracket */ && info.bracketIds.intersects(openingBracketIds)) {\n                return closingText;\n            }\n        }\n        return undefined;\n    }\n    get isEmpty() {\n        return this.map.size === 0;\n    }\n}\nfunction prepareBracketForRegExp(str) {\n    let escaped = escapeRegExpCharacters(str);\n    // These bracket pair delimiters start or end with letters\n    // see https://github.com/microsoft/vscode/issues/132162 https://github.com/microsoft/vscode/issues/150440\n    if (/^[\\w ]+/.test(str)) {\n        escaped = `\\\\b${escaped}`;\n    }\n    if (/[\\w ]+$/.test(str)) {\n        escaped = `${escaped}\\\\b`;\n    }\n    return escaped;\n}\nexport class LanguageAgnosticBracketTokens {\n    constructor(denseKeyProvider, getLanguageConfiguration) {\n        this.denseKeyProvider = denseKeyProvider;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.languageIdToBracketTokens = new Map();\n    }\n    didLanguageChange(languageId) {\n        // Report a change whenever the language configuration updates.\n        return this.languageIdToBracketTokens.has(languageId);\n    }\n    getSingleLanguageBracketTokens(languageId) {\n        let singleLanguageBracketTokens = this.languageIdToBracketTokens.get(languageId);\n        if (!singleLanguageBracketTokens) {\n            singleLanguageBracketTokens = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider);\n            this.languageIdToBracketTokens.set(languageId, singleLanguageBracketTokens);\n        }\n        return singleLanguageBracketTokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { splitLines } from '../../../../../base/common/strings.js';\nimport { Range } from '../../../core/range.js';\n/**\n * Represents a non-negative length in terms of line and column count.\n * Prefer using {@link Length} for performance reasons.\n*/\nexport class LengthObj {\n    constructor(lineCount, columnCount) {\n        this.lineCount = lineCount;\n        this.columnCount = columnCount;\n    }\n    toString() {\n        return `${this.lineCount},${this.columnCount}`;\n    }\n}\nLengthObj.zero = new LengthObj(0, 0);\n/**\n * The end must be greater than or equal to the start.\n*/\nexport function lengthDiff(startLineCount, startColumnCount, endLineCount, endColumnCount) {\n    return (startLineCount !== endLineCount)\n        ? toLength(endLineCount - startLineCount, endColumnCount)\n        : toLength(0, endColumnCount - startColumnCount);\n}\nexport const lengthZero = 0;\nexport function lengthIsZero(length) {\n    return length === 0;\n}\n/*\n * We have 52 bits available in a JS number.\n * We use the upper 26 bits to store the line and the lower 26 bits to store the column.\n *\n * Set boolean to `true` when debugging, so that debugging is easier.\n */\nconst factor = /* is debug: */ false ? 100000 : Math.pow(2, 26);\nexport function toLength(lineCount, columnCount) {\n    // llllllllllllllllllllllllllcccccccccccccccccccccccccc (52 bits)\n    //       line count (26 bits)    column count (26 bits)\n    // If there is no overflow (all values/sums below 2^26 = 67108864),\n    // we have `toLength(lns1, cols1) + toLength(lns2, cols2) = toLength(lns1 + lns2, cols1 + cols2)`.\n    return (lineCount * factor + columnCount);\n}\nexport function lengthToObj(length) {\n    const l = length;\n    const lineCount = Math.floor(l / factor);\n    const columnCount = l - lineCount * factor;\n    return new LengthObj(lineCount, columnCount);\n}\nexport function lengthGetLineCount(length) {\n    return Math.floor(length / factor);\n}\n/**\n * Returns the amount of columns of the given length, assuming that it does not span any line.\n*/\nexport function lengthGetColumnCountIfZeroLineCount(length) {\n    return length;\n}\nexport function lengthAdd(l1, l2) {\n    return ((l2 < factor)\n        ? (l1 + l2) // l2 is the amount of columns (zero line count). Keep the column count from l1.\n        : (l1 - (l1 % factor) + l2)); // l1 - (l1 % factor) equals toLength(l1.lineCount, 0)\n}\n/**\n * Returns a non negative length `result` such that `lengthAdd(length1, result) = length2`, or zero if such length does not exist.\n */\nexport function lengthDiffNonNegative(length1, length2) {\n    const l1 = length1;\n    const l2 = length2;\n    const diff = l2 - l1;\n    if (diff <= 0) {\n        // line-count of length1 is higher than line-count of length2\n        // or they are equal and column-count of length1 is higher than column-count of length2\n        return lengthZero;\n    }\n    const lineCount1 = Math.floor(l1 / factor);\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    if (lineCount1 === lineCount2) {\n        const colCount1 = l1 - lineCount1 * factor;\n        return toLength(0, colCount2 - colCount1);\n    }\n    else {\n        return toLength(lineCount2 - lineCount1, colCount2);\n    }\n}\nexport function lengthLessThan(length1, length2) {\n    // First, compare line counts, then column counts.\n    return length1 < length2;\n}\nexport function lengthLessThanEqual(length1, length2) {\n    return length1 <= length2;\n}\nexport function lengthGreaterThanEqual(length1, length2) {\n    return length1 >= length2;\n}\nexport function positionToLength(position) {\n    return toLength(position.lineNumber - 1, position.column - 1);\n}\nexport function lengthsToRange(lengthStart, lengthEnd) {\n    const l = lengthStart;\n    const lineCount = Math.floor(l / factor);\n    const colCount = l - lineCount * factor;\n    const l2 = lengthEnd;\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    return new Range(lineCount + 1, colCount + 1, lineCount2 + 1, colCount2 + 1);\n}\nexport function lengthOfString(str) {\n    const lines = splitLines(str);\n    return toLength(lines.length - 1, lines[lines.length - 1].length);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ListAstNode } from './ast.js';\n/**\n * Concatenates a list of (2,3) AstNode's into a single (2,3) AstNode.\n * This mutates the items of the input array!\n * If all items have the same height, this method has runtime O(items.length).\n * Otherwise, it has runtime O(items.length * max(log(items.length), items.max(i => i.height))).\n*/\nexport function concat23Trees(items) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let i = 0;\n    /**\n     * Reads nodes of same height and concatenates them to a single node.\n    */\n    function readNode() {\n        if (i >= items.length) {\n            return null;\n        }\n        const start = i;\n        const height = items[start].listHeight;\n        i++;\n        while (i < items.length && items[i].listHeight === height) {\n            i++;\n        }\n        if (i - start >= 2) {\n            return concat23TreesOfSameHeight(start === 0 && i === items.length ? items : items.slice(start, i), false);\n        }\n        else {\n            return items[start];\n        }\n    }\n    // The items might not have the same height.\n    // We merge all items by using a binary concat operator.\n    let first = readNode(); // There must be a first item\n    let second = readNode();\n    if (!second) {\n        return first;\n    }\n    for (let item = readNode(); item; item = readNode()) {\n        // Prefer concatenating smaller trees, as the runtime of concat depends on the tree height.\n        if (heightDiff(first, second) <= heightDiff(second, item)) {\n            first = concat(first, second);\n            second = item;\n        }\n        else {\n            second = concat(second, item);\n        }\n    }\n    const result = concat(first, second);\n    return result;\n}\nexport function concat23TreesOfSameHeight(items, createImmutableLists = false) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let length = items.length;\n    // All trees have same height, just create parent nodes.\n    while (length > 3) {\n        const newLength = length >> 1;\n        for (let i = 0; i < newLength; i++) {\n            const j = i << 1;\n            items[i] = ListAstNode.create23(items[j], items[j + 1], j + 3 === length ? items[j + 2] : null, createImmutableLists);\n        }\n        length = newLength;\n    }\n    return ListAstNode.create23(items[0], items[1], length >= 3 ? items[2] : null, createImmutableLists);\n}\nfunction heightDiff(node1, node2) {\n    return Math.abs(node1.listHeight - node2.listHeight);\n}\nfunction concat(node1, node2) {\n    if (node1.listHeight === node2.listHeight) {\n        return ListAstNode.create23(node1, node2, null, false);\n    }\n    else if (node1.listHeight > node2.listHeight) {\n        // node1 is the tree we want to insert into\n        return append(node1, node2);\n    }\n    else {\n        return prepend(node2, node1);\n    }\n}\n/**\n * Appends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction append(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = new Array();\n    let nodeToAppendOfCorrectHeight;\n    while (true) {\n        // assert nodeToInsert.listHeight <= curNode.listHeight\n        if (nodeToAppend.listHeight === curNode.listHeight) {\n            nodeToAppendOfCorrectHeight = nodeToAppend;\n            break;\n        }\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* AstNodeKind.List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenLength <= 3\n        curNode = curNode.makeLastElementMutable();\n    }\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToAppendOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToAppendOfCorrectHeight = ListAstNode.create23(parent.unappendChild(), nodeToAppendOfCorrectHeight, null, false);\n            }\n            else {\n                parent.appendChildOfSameHeight(nodeToAppendOfCorrectHeight);\n                nodeToAppendOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToAppendOfCorrectHeight) {\n        return ListAstNode.create23(list, nodeToAppendOfCorrectHeight, null, false);\n    }\n    else {\n        return list;\n    }\n}\n/**\n * Prepends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction prepend(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = new Array();\n    // assert nodeToInsert.listHeight <= curNode.listHeight\n    while (nodeToAppend.listHeight !== curNode.listHeight) {\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* AstNodeKind.List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenFast.length <= 3\n        curNode = curNode.makeFirstElementMutable();\n    }\n    let nodeToPrependOfCorrectHeight = nodeToAppend;\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToPrependOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToPrependOfCorrectHeight = ListAstNode.create23(nodeToPrependOfCorrectHeight, parent.unprependChild(), null, false);\n            }\n            else {\n                parent.prependChildOfSameHeight(nodeToPrependOfCorrectHeight);\n                nodeToPrependOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToPrependOfCorrectHeight) {\n        return ListAstNode.create23(nodeToPrependOfCorrectHeight, list, null, false);\n    }\n    else {\n        return list;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { lengthAdd, lengthZero, lengthLessThan } from './length.js';\n/**\n * Allows to efficiently find a longest child at a given offset in a fixed node.\n * The requested offsets must increase monotonously.\n*/\nexport class NodeReader {\n    constructor(node) {\n        this.lastOffset = lengthZero;\n        this.nextNodes = [node];\n        this.offsets = [lengthZero];\n        this.idxs = [];\n    }\n    /**\n     * Returns the longest node at `offset` that satisfies the predicate.\n     * @param offset must be greater than or equal to the last offset this method has been called with!\n    */\n    readLongestNodeAt(offset, predicate) {\n        if (lengthLessThan(offset, this.lastOffset)) {\n            throw new Error('Invalid offset');\n        }\n        this.lastOffset = offset;\n        // Find the longest node of all those that are closest to the current offset.\n        while (true) {\n            const curNode = lastOrUndefined(this.nextNodes);\n            if (!curNode) {\n                return undefined;\n            }\n            const curNodeOffset = lastOrUndefined(this.offsets);\n            if (lengthLessThan(offset, curNodeOffset)) {\n                // The next best node is not here yet.\n                // The reader must advance before a cached node is hit.\n                return undefined;\n            }\n            if (lengthLessThan(curNodeOffset, offset)) {\n                // The reader is ahead of the current node.\n                if (lengthAdd(curNodeOffset, curNode.length) <= offset) {\n                    // The reader is after the end of the current node.\n                    this.nextNodeAfterCurrent();\n                }\n                else {\n                    // The reader is somewhere in the current node.\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    if (nextChildIdx !== -1) {\n                        // Go to the first child and repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                    else {\n                        // We don't have children\n                        this.nextNodeAfterCurrent();\n                    }\n                }\n            }\n            else {\n                // readerOffsetBeforeChange === curNodeOffset\n                if (predicate(curNode)) {\n                    this.nextNodeAfterCurrent();\n                    return curNode;\n                }\n                else {\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    // look for shorter node\n                    if (nextChildIdx === -1) {\n                        // There is no shorter node.\n                        this.nextNodeAfterCurrent();\n                        return undefined;\n                    }\n                    else {\n                        // Descend into first child & repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                }\n            }\n        }\n    }\n    // Navigates to the longest node that continues after the current node.\n    nextNodeAfterCurrent() {\n        while (true) {\n            const currentOffset = lastOrUndefined(this.offsets);\n            const currentNode = lastOrUndefined(this.nextNodes);\n            this.nextNodes.pop();\n            this.offsets.pop();\n            if (this.idxs.length === 0) {\n                // We just popped the root node, there is no next node.\n                break;\n            }\n            // Parent is not undefined, because idxs is not empty\n            const parent = lastOrUndefined(this.nextNodes);\n            const nextChildIdx = getNextChildIdx(parent, this.idxs[this.idxs.length - 1]);\n            if (nextChildIdx !== -1) {\n                this.nextNodes.push(parent.getChild(nextChildIdx));\n                this.offsets.push(lengthAdd(currentOffset, currentNode.length));\n                this.idxs[this.idxs.length - 1] = nextChildIdx;\n                break;\n            }\n            else {\n                this.idxs.pop();\n            }\n            // We fully consumed the parent.\n            // Current node is now parent, so call nextNodeAfterCurrent again\n        }\n    }\n}\nfunction getNextChildIdx(node, curIdx = -1) {\n    while (true) {\n        curIdx++;\n        if (curIdx >= node.childrenLength) {\n            return -1;\n        }\n        if (node.getChild(curIdx)) {\n            return curIdx;\n        }\n    }\n}\nfunction lastOrUndefined(arr) {\n    return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { InvalidBracketAstNode, ListAstNode, PairAstNode } from './ast.js';\nimport { BeforeEditPositionMapper } from './beforeEditPositionMapper.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nimport { lengthIsZero, lengthLessThan } from './length.js';\nimport { concat23Trees, concat23TreesOfSameHeight } from './concat23Trees.js';\nimport { NodeReader } from './nodeReader.js';\n/**\n * Non incrementally built ASTs are immutable.\n*/\nexport function parseDocument(tokenizer, edits, oldNode, createImmutableLists) {\n    const parser = new Parser(tokenizer, edits, oldNode, createImmutableLists);\n    return parser.parseDocument();\n}\n/**\n * Non incrementally built ASTs are immutable.\n*/\nclass Parser {\n    constructor(tokenizer, edits, oldNode, createImmutableLists) {\n        this.tokenizer = tokenizer;\n        this.createImmutableLists = createImmutableLists;\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        if (oldNode && createImmutableLists) {\n            throw new Error('Not supported');\n        }\n        this.oldNodeReader = oldNode ? new NodeReader(oldNode) : undefined;\n        this.positionMapper = new BeforeEditPositionMapper(edits, tokenizer.length);\n    }\n    parseDocument() {\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        let result = this.parseList(SmallImmutableSet.getEmpty());\n        if (!result) {\n            result = ListAstNode.getEmpty();\n        }\n        return result;\n    }\n    parseList(openedBracketIds) {\n        const items = new Array();\n        while (true) {\n            const token = this.tokenizer.peek();\n            if (!token ||\n                (token.kind === 2 /* TokenKind.ClosingBracket */ &&\n                    token.bracketIds.intersects(openedBracketIds))) {\n                break;\n            }\n            const child = this.parseChild(openedBracketIds);\n            if (child.kind === 4 /* AstNodeKind.List */ && child.childrenLength === 0) {\n                continue;\n            }\n            items.push(child);\n        }\n        // When there is no oldNodeReader, all items are created from scratch and must have the same height.\n        const result = this.oldNodeReader ? concat23Trees(items) : concat23TreesOfSameHeight(items, this.createImmutableLists);\n        return result;\n    }\n    parseChild(openedBracketIds) {\n        if (this.oldNodeReader) {\n            const maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);\n            if (!lengthIsZero(maxCacheableLength)) {\n                const cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), curNode => {\n                    if (!lengthLessThan(curNode.length, maxCacheableLength)) {\n                        // Either the node contains edited text or touches edited text.\n                        // In the latter case, brackets might have been extended (`end` -> `ending`), so even touching nodes cannot be reused.\n                        return false;\n                    }\n                    const canBeReused = curNode.canBeReused(openedBracketIds);\n                    return canBeReused;\n                });\n                if (cachedNode) {\n                    this._itemsFromCache++;\n                    this.tokenizer.skip(cachedNode.length);\n                    return cachedNode;\n                }\n            }\n        }\n        this._itemsConstructed++;\n        const token = this.tokenizer.read();\n        switch (token.kind) {\n            case 2 /* TokenKind.ClosingBracket */:\n                return new InvalidBracketAstNode(token.bracketIds, token.length);\n            case 0 /* TokenKind.Text */:\n                return token.astNode;\n            case 1 /* TokenKind.OpeningBracket */: {\n                const set = openedBracketIds.merge(token.bracketIds);\n                const child = this.parseList(set);\n                const nextToken = this.tokenizer.peek();\n                if (nextToken &&\n                    nextToken.kind === 2 /* TokenKind.ClosingBracket */ &&\n                    (nextToken.bracketId === token.bracketId || nextToken.bracketIds.intersects(token.bracketIds))) {\n                    this.tokenizer.read();\n                    return PairAstNode.create(token.astNode, child, nextToken.astNode);\n                }\n                else {\n                    return PairAstNode.create(token.astNode, child, null);\n                }\n            }\n            default:\n                throw new Error('unexpected');\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst emptyArr = new Array();\n/**\n * Represents an immutable set that works best for a small number of elements (less than 32).\n * It uses bits to encode element membership efficiently.\n*/\nexport class SmallImmutableSet {\n    constructor(items, additionalItems) {\n        this.items = items;\n        this.additionalItems = additionalItems;\n    }\n    static create(items, additionalItems) {\n        if (items <= 128 && additionalItems.length === 0) {\n            // We create a cache of 128=2^7 elements to cover all sets with up to 7 (dense) elements.\n            let cached = SmallImmutableSet.cache[items];\n            if (!cached) {\n                cached = new SmallImmutableSet(items, additionalItems);\n                SmallImmutableSet.cache[items] = cached;\n            }\n            return cached;\n        }\n        return new SmallImmutableSet(items, additionalItems);\n    }\n    static getEmpty() {\n        return this.empty;\n    }\n    add(value, keyProvider) {\n        const key = keyProvider.getKey(value);\n        let idx = key >> 5; // divided by 32\n        if (idx === 0) {\n            // fast path\n            const newItem = (1 << key) | this.items;\n            if (newItem === this.items) {\n                return this;\n            }\n            return SmallImmutableSet.create(newItem, this.additionalItems);\n        }\n        idx--;\n        const newItems = this.additionalItems.slice(0);\n        while (newItems.length < idx) {\n            newItems.push(0);\n        }\n        newItems[idx] |= 1 << (key & 31);\n        return SmallImmutableSet.create(this.items, newItems);\n    }\n    merge(other) {\n        const merged = this.items | other.items;\n        if (this.additionalItems === emptyArr && other.additionalItems === emptyArr) {\n            // fast path\n            if (merged === this.items) {\n                return this;\n            }\n            if (merged === other.items) {\n                return other;\n            }\n            return SmallImmutableSet.create(merged, emptyArr);\n        }\n        // This can be optimized, but it's not a common case\n        const newItems = new Array();\n        for (let i = 0; i < Math.max(this.additionalItems.length, other.additionalItems.length); i++) {\n            const item1 = this.additionalItems[i] || 0;\n            const item2 = other.additionalItems[i] || 0;\n            newItems.push(item1 | item2);\n        }\n        return SmallImmutableSet.create(merged, newItems);\n    }\n    intersects(other) {\n        if ((this.items & other.items) !== 0) {\n            return true;\n        }\n        for (let i = 0; i < Math.min(this.additionalItems.length, other.additionalItems.length); i++) {\n            if ((this.additionalItems[i] & other.additionalItems[i]) !== 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nSmallImmutableSet.cache = new Array(129);\nSmallImmutableSet.empty = SmallImmutableSet.create(0, emptyArr);\nexport const identityKeyProvider = {\n    getKey(value) {\n        return value;\n    }\n};\n/**\n * Assigns values a unique incrementing key.\n*/\nexport class DenseKeyProvider {\n    constructor() {\n        this.items = new Map();\n    }\n    getKey(value) {\n        let existing = this.items.get(value);\n        if (existing === undefined) {\n            existing = this.items.size;\n            this.items.set(value, existing);\n        }\n        return existing;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { NotSupportedError } from '../../../../../base/common/errors.js';\nimport { TokenMetadata } from '../../../encodedTokenAttributes.js';\nimport { TextAstNode } from './ast.js';\nimport { lengthAdd, lengthDiff, lengthGetColumnCountIfZeroLineCount, lengthToObj, lengthZero, toLength } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nexport class Token {\n    constructor(length, kind, \n    /**\n     * If this token is an opening bracket, this is the id of the opening bracket.\n     * If this token is a closing bracket, this is the id of the first opening bracket that is closed by this bracket.\n     * Otherwise, it is -1.\n     */\n    bracketId, \n    /**\n     * If this token is an opening bracket, this just contains `bracketId`.\n     * If this token is a closing bracket, this lists all opening bracket ids, that it closes.\n     * Otherwise, it is empty.\n     */\n    bracketIds, astNode) {\n        this.length = length;\n        this.kind = kind;\n        this.bracketId = bracketId;\n        this.bracketIds = bracketIds;\n        this.astNode = astNode;\n    }\n}\nexport class TextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);\n        this._offset = lengthZero;\n        this.didPeek = false;\n        this.peeked = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    get offset() {\n        return this._offset;\n    }\n    get length() {\n        return toLength(this.textBufferLineCount, this.textBufferLastLineLength);\n    }\n    skip(length) {\n        this.didPeek = false;\n        this._offset = lengthAdd(this._offset, length);\n        const obj = lengthToObj(this._offset);\n        this.reader.setPosition(obj.lineCount, obj.columnCount);\n    }\n    read() {\n        let token;\n        if (this.peeked) {\n            this.didPeek = false;\n            token = this.peeked;\n        }\n        else {\n            token = this.reader.read();\n        }\n        if (token) {\n            this._offset = lengthAdd(this._offset, token.length);\n        }\n        return token;\n    }\n    peek() {\n        if (!this.didPeek) {\n            this.peeked = this.reader.read();\n            this.didPeek = true;\n        }\n        return this.peeked;\n    }\n}\n/**\n * Does not support peek.\n*/\nclass NonPeekableTextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.lineIdx = 0;\n        this.line = null;\n        this.lineCharOffset = 0;\n        this.lineTokens = null;\n        this.lineTokenOffset = 0;\n        /** Must be a zero line token. The end of the document cannot be peeked. */\n        this.peekedToken = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    setPosition(lineIdx, column) {\n        // We must not jump into a token!\n        if (lineIdx === this.lineIdx) {\n            this.lineCharOffset = column;\n            this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n        }\n        else {\n            this.lineIdx = lineIdx;\n            this.lineCharOffset = column;\n            this.line = null;\n        }\n        this.peekedToken = null;\n    }\n    read() {\n        if (this.peekedToken) {\n            const token = this.peekedToken;\n            this.peekedToken = null;\n            this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(token.length);\n            return token;\n        }\n        if (this.lineIdx > this.textBufferLineCount - 1 || (this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)) {\n            // We are after the end\n            return null;\n        }\n        if (this.line === null) {\n            this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n            this.line = this.lineTokens.getLineContent();\n            this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n        }\n        const startLineIdx = this.lineIdx;\n        const startLineCharOffset = this.lineCharOffset;\n        // limits the length of text tokens.\n        // If text tokens get too long, incremental updates will be slow\n        let lengthHeuristic = 0;\n        while (true) {\n            const lineTokens = this.lineTokens;\n            const tokenCount = lineTokens.getCount();\n            let peekedBracketToken = null;\n            if (this.lineTokenOffset < tokenCount) {\n                const tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);\n                while (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {\n                    // Skip tokens that are identical.\n                    // Sometimes, (bracket) identifiers are split up into multiple tokens.\n                    this.lineTokenOffset++;\n                }\n                const isOther = TokenMetadata.getTokenType(tokenMetadata) === 0 /* StandardTokenType.Other */;\n                const containsBracketType = TokenMetadata.containsBalancedBrackets(tokenMetadata);\n                const endOffset = lineTokens.getEndOffset(this.lineTokenOffset);\n                // Is there a bracket token next? Only consume text.\n                if (containsBracketType && isOther && this.lineCharOffset < endOffset) {\n                    const languageId = lineTokens.getLanguageId(this.lineTokenOffset);\n                    const text = this.line.substring(this.lineCharOffset, endOffset);\n                    const brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);\n                    const regexp = brackets.regExpGlobal;\n                    if (regexp) {\n                        regexp.lastIndex = 0;\n                        const match = regexp.exec(text);\n                        if (match) {\n                            peekedBracketToken = brackets.getToken(match[0]);\n                            if (peekedBracketToken) {\n                                // Consume leading text of the token\n                                this.lineCharOffset += match.index;\n                            }\n                        }\n                    }\n                }\n                lengthHeuristic += endOffset - this.lineCharOffset;\n                if (peekedBracketToken) {\n                    // Don't skip the entire token, as a single token could contain multiple brackets.\n                    if (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {\n                        // There is text before the bracket\n                        this.peekedToken = peekedBracketToken;\n                        break;\n                    }\n                    else {\n                        // Consume the peeked token\n                        this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(peekedBracketToken.length);\n                        return peekedBracketToken;\n                    }\n                }\n                else {\n                    // Skip the entire token, as the token contains no brackets at all.\n                    this.lineTokenOffset++;\n                    this.lineCharOffset = endOffset;\n                }\n            }\n            else {\n                if (this.lineIdx === this.textBufferLineCount - 1) {\n                    break;\n                }\n                this.lineIdx++;\n                this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n                this.lineTokenOffset = 0;\n                this.line = this.lineTokens.getLineContent();\n                this.lineCharOffset = 0;\n                lengthHeuristic += 33; // max 1000/33 = 30 lines\n                // This limits the amount of work to recompute min-indentation\n                if (lengthHeuristic > 1000) {\n                    // only break (automatically) at the end of line.\n                    break;\n                }\n            }\n            if (lengthHeuristic > 1500) {\n                // Eventually break regardless of the line length so that\n                // very long lines do not cause bad performance.\n                // This effective limits max indentation to 500, as\n                // indentation is not computed across multiple text nodes.\n                break;\n            }\n        }\n        // If a token contains some proper indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION}),\n        // unless the line is too long.\n        // Thus, the min indentation of the document is the minimum min indentation of every text node.\n        const length = lengthDiff(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);\n        return new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n    }\n}\nexport class FastTokenizer {\n    constructor(text, brackets) {\n        this.text = text;\n        this._offset = lengthZero;\n        this.idx = 0;\n        const regExpStr = brackets.getRegExpStr();\n        const regexp = regExpStr ? new RegExp(regExpStr + '|\\n', 'gi') : null;\n        const tokens = [];\n        let match;\n        let curLineCount = 0;\n        let lastLineBreakOffset = 0;\n        let lastTokenEndOffset = 0;\n        let lastTokenEndLine = 0;\n        const smallTextTokens0Line = new Array();\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens0Line.push(new Token(toLength(0, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(0, i))));\n        }\n        const smallTextTokens1Line = new Array();\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens1Line.push(new Token(toLength(1, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(1, i))));\n        }\n        if (regexp) {\n            regexp.lastIndex = 0;\n            // If a token contains indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION})\n            while ((match = regexp.exec(text)) !== null) {\n                const curOffset = match.index;\n                const value = match[0];\n                if (value === '\\n') {\n                    curLineCount++;\n                    lastLineBreakOffset = curOffset + 1;\n                }\n                else {\n                    if (lastTokenEndOffset !== curOffset) {\n                        let token;\n                        if (lastTokenEndLine === curLineCount) {\n                            const colCount = curOffset - lastTokenEndOffset;\n                            if (colCount < smallTextTokens0Line.length) {\n                                token = smallTextTokens0Line[colCount];\n                            }\n                            else {\n                                const length = toLength(0, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        else {\n                            const lineCount = curLineCount - lastTokenEndLine;\n                            const colCount = curOffset - lastLineBreakOffset;\n                            if (lineCount === 1 && colCount < smallTextTokens1Line.length) {\n                                token = smallTextTokens1Line[colCount];\n                            }\n                            else {\n                                const length = toLength(lineCount, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        tokens.push(token);\n                    }\n                    // value is matched by regexp, so the token must exist\n                    tokens.push(brackets.getToken(value));\n                    lastTokenEndOffset = curOffset + value.length;\n                    lastTokenEndLine = curLineCount;\n                }\n            }\n        }\n        const offset = text.length;\n        if (lastTokenEndOffset !== offset) {\n            const length = (lastTokenEndLine === curLineCount)\n                ? toLength(0, offset - lastTokenEndOffset)\n                : toLength(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);\n            tokens.push(new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length)));\n        }\n        this.length = toLength(curLineCount, offset - lastLineBreakOffset);\n        this.tokens = tokens;\n    }\n    get offset() {\n        return this._offset;\n    }\n    read() {\n        return this.tokens[this.idx++] || null;\n    }\n    peek() {\n        return this.tokens[this.idx] || null;\n    }\n    skip(length) {\n        throw new NotSupportedError();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { editorBracketHighlightingForeground1, editorBracketHighlightingForeground2, editorBracketHighlightingForeground3, editorBracketHighlightingForeground4, editorBracketHighlightingForeground5, editorBracketHighlightingForeground6, editorBracketHighlightingUnexpectedBracketForeground } from '../../core/editorColorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nexport class ColorizedBracketPairsDecorationProvider extends Disposable {\n    constructor(textModel) {\n        super();\n        this.textModel = textModel;\n        this.colorProvider = new ColorProvider();\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.colorizationOptions = textModel.getOptions().bracketPairColorizationOptions;\n        this._register(textModel.bracketPairs.onDidChange(e => {\n            this.onDidChangeEmitter.fire();\n        }));\n    }\n    //#region TextModel events\n    handleDidChangeOptions(e) {\n        this.colorizationOptions = this.textModel.getOptions().bracketPairColorizationOptions;\n    }\n    //#endregion\n    getDecorationsInRange(range, ownerId, filterOutValidation) {\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        const result = new Array();\n        const bracketsInRange = this.textModel.bracketPairs.getBracketsInRange(range);\n        for (const bracket of bracketsInRange) {\n            result.push({\n                id: `bracket${bracket.range.toString()}-${bracket.nestingLevel}`,\n                options: {\n                    description: 'BracketPairColorization',\n                    inlineClassName: this.colorProvider.getInlineClassName(bracket, this.colorizationOptions.independentColorPoolPerBracketType),\n                },\n                ownerId: 0,\n                range: bracket.range,\n            });\n        }\n        return result;\n    }\n    getAllDecorations(ownerId, filterOutValidation) {\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        return this.getDecorationsInRange(new Range(1, 1, this.textModel.getLineCount(), 1), ownerId, filterOutValidation);\n    }\n}\nclass ColorProvider {\n    constructor() {\n        this.unexpectedClosingBracketClassName = 'unexpected-closing-bracket';\n    }\n    getInlineClassName(bracket, independentColorPoolPerBracketType) {\n        if (bracket.isInvalid) {\n            return this.unexpectedClosingBracketClassName;\n        }\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? bracket.nestingLevelOfEqualBracketType : bracket.nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-highlighting-${level % 30}`;\n    }\n}\nregisterThemingParticipant((theme, collector) => {\n    const colors = [\n        editorBracketHighlightingForeground1,\n        editorBracketHighlightingForeground2,\n        editorBracketHighlightingForeground3,\n        editorBracketHighlightingForeground4,\n        editorBracketHighlightingForeground5,\n        editorBracketHighlightingForeground6\n    ];\n    const colorProvider = new ColorProvider();\n    collector.addRule(`.monaco-editor .${colorProvider.unexpectedClosingBracketClassName} { color: ${theme.getColor(editorBracketHighlightingUnexpectedBracketForeground)}; }`);\n    const colorValues = colors\n        .map(c => theme.getColor(c))\n        .filter((c) => !!c)\n        .filter(c => !c.isTransparent());\n    for (let level = 0; level < 30; level++) {\n        const color = colorValues[level % colorValues.length];\n        collector.addRule(`.monaco-editor .${colorProvider.getInlineClassNameOfLevel(level)} { color: ${color}; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LanguageAgnosticBracketTokens } from './bracketPairsTree/brackets.js';\nimport { lengthAdd, lengthGetColumnCountIfZeroLineCount, lengthZero } from './bracketPairsTree/length.js';\nimport { parseDocument } from './bracketPairsTree/parser.js';\nimport { DenseKeyProvider } from './bracketPairsTree/smallImmutableSet.js';\nimport { TextBufferTokenizer } from './bracketPairsTree/tokenizer.js';\nexport function fixBracketsInLine(tokens, languageConfigurationService) {\n    const denseKeyProvider = new DenseKeyProvider();\n    const bracketTokens = new LanguageAgnosticBracketTokens(denseKeyProvider, (languageId) => languageConfigurationService.getLanguageConfiguration(languageId));\n    const tokenizer = new TextBufferTokenizer(new StaticTokenizerSource([tokens]), bracketTokens);\n    const node = parseDocument(tokenizer, [], undefined, true);\n    let str = '';\n    const line = tokens.getLineContent();\n    function processNode(node, offset) {\n        if (node.kind === 2 /* AstNodeKind.Pair */) {\n            processNode(node.openingBracket, offset);\n            offset = lengthAdd(offset, node.openingBracket.length);\n            if (node.child) {\n                processNode(node.child, offset);\n                offset = lengthAdd(offset, node.child.length);\n            }\n            if (node.closingBracket) {\n                processNode(node.closingBracket, offset);\n                offset = lengthAdd(offset, node.closingBracket.length);\n            }\n            else {\n                const singleLangBracketTokens = bracketTokens.getSingleLanguageBracketTokens(node.openingBracket.languageId);\n                const closingTokenText = singleLangBracketTokens.findClosingTokenText(node.openingBracket.bracketIds);\n                str += closingTokenText;\n            }\n        }\n        else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n            // remove the bracket\n        }\n        else if (node.kind === 0 /* AstNodeKind.Text */ || node.kind === 1 /* AstNodeKind.Bracket */) {\n            str += line.substring(lengthGetColumnCountIfZeroLineCount(offset), lengthGetColumnCountIfZeroLineCount(lengthAdd(offset, node.length)));\n        }\n        else if (node.kind === 4 /* AstNodeKind.List */) {\n            for (const child of node.children) {\n                processNode(child, offset);\n                offset = lengthAdd(offset, child.length);\n            }\n        }\n    }\n    processNode(node, lengthZero);\n    return str;\n}\nclass StaticTokenizerSource {\n    constructor(lines) {\n        this.lines = lines;\n        this.tokenization = {\n            getLineTokens: (lineNumber) => {\n                return this.lines[lineNumber - 1];\n            }\n        };\n    }\n    getLineCount() {\n        return this.lines.length;\n    }\n    getLineLength(lineNumber) {\n        return this.lines[lineNumber - 1].getLineContent().length;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Selection } from '../core/selection.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { TextChange, compressConsecutiveTextChanges } from '../core/textChange.js';\nimport * as buffer from '../../../base/common/buffer.js';\nimport { basename } from '../../../base/common/resources.js';\nfunction uriGetComparisonKey(resource) {\n    return resource.toString();\n}\nexport class SingleModelEditStackData {\n    constructor(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes) {\n        this.beforeVersionId = beforeVersionId;\n        this.afterVersionId = afterVersionId;\n        this.beforeEOL = beforeEOL;\n        this.afterEOL = afterEOL;\n        this.beforeCursorState = beforeCursorState;\n        this.afterCursorState = afterCursorState;\n        this.changes = changes;\n    }\n    static create(model, beforeCursorState) {\n        const alternativeVersionId = model.getAlternativeVersionId();\n        const eol = getModelEOL(model);\n        return new SingleModelEditStackData(alternativeVersionId, alternativeVersionId, eol, eol, beforeCursorState, beforeCursorState, []);\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (textChanges.length > 0) {\n            this.changes = compressConsecutiveTextChanges(this.changes, textChanges);\n        }\n        this.afterEOL = afterEOL;\n        this.afterVersionId = afterVersionId;\n        this.afterCursorState = afterCursorState;\n    }\n    static _writeSelectionsSize(selections) {\n        return 4 + 4 * 4 * (selections ? selections.length : 0);\n    }\n    static _writeSelections(b, selections, offset) {\n        buffer.writeUInt32BE(b, (selections ? selections.length : 0), offset);\n        offset += 4;\n        if (selections) {\n            for (const selection of selections) {\n                buffer.writeUInt32BE(b, selection.selectionStartLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.selectionStartColumn, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionColumn, offset);\n                offset += 4;\n            }\n        }\n        return offset;\n    }\n    static _readSelections(b, offset, dest) {\n        const count = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        for (let i = 0; i < count; i++) {\n            const selectionStartLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const selectionStartColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            dest.push(new Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn));\n        }\n        return offset;\n    }\n    serialize() {\n        let necessarySize = (+4 // beforeVersionId\n            + 4 // afterVersionId\n            + 1 // beforeEOL\n            + 1 // afterEOL\n            + SingleModelEditStackData._writeSelectionsSize(this.beforeCursorState)\n            + SingleModelEditStackData._writeSelectionsSize(this.afterCursorState)\n            + 4 // change count\n        );\n        for (const change of this.changes) {\n            necessarySize += change.writeSize();\n        }\n        const b = new Uint8Array(necessarySize);\n        let offset = 0;\n        buffer.writeUInt32BE(b, this.beforeVersionId, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.afterVersionId, offset);\n        offset += 4;\n        buffer.writeUInt8(b, this.beforeEOL, offset);\n        offset += 1;\n        buffer.writeUInt8(b, this.afterEOL, offset);\n        offset += 1;\n        offset = SingleModelEditStackData._writeSelections(b, this.beforeCursorState, offset);\n        offset = SingleModelEditStackData._writeSelections(b, this.afterCursorState, offset);\n        buffer.writeUInt32BE(b, this.changes.length, offset);\n        offset += 4;\n        for (const change of this.changes) {\n            offset = change.write(b, offset);\n        }\n        return b.buffer;\n    }\n    static deserialize(source) {\n        const b = new Uint8Array(source);\n        let offset = 0;\n        const beforeVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const afterVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const beforeEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const afterEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const beforeCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, beforeCursorState);\n        const afterCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, afterCursorState);\n        const changeCount = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const changes = [];\n        for (let i = 0; i < changeCount; i++) {\n            offset = TextChange.read(b, offset, changes);\n        }\n        return new SingleModelEditStackData(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes);\n    }\n}\nexport class SingleModelEditStackElement {\n    constructor(label, code, model, beforeCursorState) {\n        this.label = label;\n        this.code = code;\n        this.model = model;\n        this._data = SingleModelEditStackData.create(model, beforeCursorState);\n    }\n    get type() {\n        return 0 /* UndoRedoElementType.Resource */;\n    }\n    get resource() {\n        if (URI.isUri(this.model)) {\n            return this.model;\n        }\n        return this.model.uri;\n    }\n    toString() {\n        const data = (this._data instanceof SingleModelEditStackData ? this._data : SingleModelEditStackData.deserialize(this._data));\n        return data.changes.map(change => change.toString()).join(', ');\n    }\n    matchesResource(resource) {\n        const uri = (URI.isUri(this.model) ? this.model : this.model.uri);\n        return (uri.toString() === resource.toString());\n    }\n    setModel(model) {\n        this.model = model;\n    }\n    canAppend(model) {\n        return (this.model === model && this._data instanceof SingleModelEditStackData);\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n        }\n    }\n    close() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n    }\n    open() {\n        if (!(this._data instanceof SingleModelEditStackData)) {\n            this._data = SingleModelEditStackData.deserialize(this._data);\n        }\n    }\n    undo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyUndo(data.changes, data.beforeEOL, data.beforeVersionId, data.beforeCursorState);\n    }\n    redo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyRedo(data.changes, data.afterEOL, data.afterVersionId, data.afterCursorState);\n    }\n    heapSize() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        return this._data.byteLength + 168 /*heap overhead*/;\n    }\n}\nexport class MultiModelEditStackElement {\n    constructor(label, code, editStackElements) {\n        this.label = label;\n        this.code = code;\n        this.type = 1 /* UndoRedoElementType.Workspace */;\n        this._isOpen = true;\n        this._editStackElementsArr = editStackElements.slice(0);\n        this._editStackElementsMap = new Map();\n        for (const editStackElement of this._editStackElementsArr) {\n            const key = uriGetComparisonKey(editStackElement.resource);\n            this._editStackElementsMap.set(key, editStackElement);\n        }\n        this._delegate = null;\n    }\n    get resources() {\n        return this._editStackElementsArr.map(editStackElement => editStackElement.resource);\n    }\n    prepareUndoRedo() {\n        if (this._delegate) {\n            return this._delegate.prepareUndoRedo(this);\n        }\n    }\n    matchesResource(resource) {\n        const key = uriGetComparisonKey(resource);\n        return (this._editStackElementsMap.has(key));\n    }\n    setModel(model) {\n        const key = uriGetComparisonKey(URI.isUri(model) ? model : model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            this._editStackElementsMap.get(key).setModel(model);\n        }\n    }\n    canAppend(model) {\n        if (!this._isOpen) {\n            return false;\n        }\n        const key = uriGetComparisonKey(model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.canAppend(model);\n        }\n        return false;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        const key = uriGetComparisonKey(model.uri);\n        const editStackElement = this._editStackElementsMap.get(key);\n        editStackElement.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n    }\n    close() {\n        this._isOpen = false;\n    }\n    open() {\n        // cannot reopen\n    }\n    undo() {\n        this._isOpen = false;\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.undo();\n        }\n    }\n    redo() {\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.redo();\n        }\n    }\n    heapSize(resource) {\n        const key = uriGetComparisonKey(resource);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.heapSize();\n        }\n        return 0;\n    }\n    split() {\n        return this._editStackElementsArr;\n    }\n    toString() {\n        const result = [];\n        for (const editStackElement of this._editStackElementsArr) {\n            result.push(`${basename(editStackElement.resource)}: ${editStackElement}`);\n        }\n        return `{${result.join(', ')}}`;\n    }\n}\nfunction getModelEOL(model) {\n    const eol = model.getEOL();\n    if (eol === '\\n') {\n        return 0 /* EndOfLineSequence.LF */;\n    }\n    else {\n        return 1 /* EndOfLineSequence.CRLF */;\n    }\n}\nexport function isEditStackElement(element) {\n    if (!element) {\n        return false;\n    }\n    return ((element instanceof SingleModelEditStackElement) || (element instanceof MultiModelEditStackElement));\n}\nexport class EditStack {\n    constructor(model, undoRedoService) {\n        this._model = model;\n        this._undoRedoService = undoRedoService;\n    }\n    pushStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.close();\n        }\n    }\n    popStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.open();\n        }\n    }\n    clear() {\n        this._undoRedoService.removeElements(this._model.uri);\n    }\n    _getOrCreateEditStackElement(beforeCursorState) {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement) && lastElement.canAppend(this._model)) {\n            return lastElement;\n        }\n        const newElement = new SingleModelEditStackElement(nls.localize('edit', \"Typing\"), 'undoredo.textBufferEdit', this._model, beforeCursorState);\n        this._undoRedoService.pushElement(newElement);\n        return newElement;\n    }\n    pushEOL(eol) {\n        const editStackElement = this._getOrCreateEditStackElement(null);\n        this._model.setEOL(eol);\n        editStackElement.append(this._model, [], getModelEOL(this._model), this._model.getAlternativeVersionId(), null);\n    }\n    pushEditOperation(beforeCursorState, editOperations, cursorStateComputer) {\n        const editStackElement = this._getOrCreateEditStackElement(beforeCursorState);\n        const inverseEditOperations = this._model.applyEdits(editOperations, true);\n        const afterCursorState = EditStack._computeCursorState(cursorStateComputer, inverseEditOperations);\n        const textChanges = inverseEditOperations.map((op, index) => ({ index: index, textChange: op.textChange }));\n        textChanges.sort((a, b) => {\n            if (a.textChange.oldPosition === b.textChange.oldPosition) {\n                return a.index - b.index;\n            }\n            return a.textChange.oldPosition - b.textChange.oldPosition;\n        });\n        editStackElement.append(this._model, textChanges.map(op => op.textChange), getModelEOL(this._model), this._model.getAlternativeVersionId(), afterCursorState);\n        return afterCursorState;\n    }\n    static _computeCursorState(cursorStateComputer, inverseEditOperations) {\n        try {\n            return cursorStateComputer ? cursorStateComputer(inverseEditOperations) : null;\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findLast } from '../../../base/common/arrays.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Range } from '../core/range.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { computeIndentLevel } from './utils.js';\nimport { HorizontalGuidesState, IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nexport class GuidesTextModelPart extends TextModelPart {\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n    }\n    getLanguageConfiguration(languageId) {\n        return this.languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    _computeIndentLevel(lineIndex) {\n        return computeIndentLevel(this.textModel.getLineContent(lineIndex + 1), this.textModel.getOptions().tabSize);\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (lineNumber < 1 || lineNumber > lineCount) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        let up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_aboveContentLineIndent = -1;\n        let up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_belowContentLineIndent = -1;\n        const up_resolveIndents = (lineNumber) => {\n            if (up_aboveContentLineIndex !== -1 &&\n                (up_aboveContentLineIndex === -2 ||\n                    up_aboveContentLineIndex > lineNumber - 1)) {\n                up_aboveContentLineIndex = -1;\n                up_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_aboveContentLineIndex = lineIndex;\n                        up_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (up_belowContentLineIndex === -2) {\n                up_belowContentLineIndex = -1;\n                up_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_belowContentLineIndex = lineIndex;\n                        up_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_aboveContentLineIndent = -1;\n        let down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_belowContentLineIndent = -1;\n        const down_resolveIndents = (lineNumber) => {\n            if (down_aboveContentLineIndex === -2) {\n                down_aboveContentLineIndex = -1;\n                down_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_aboveContentLineIndex = lineIndex;\n                        down_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (down_belowContentLineIndex !== -1 &&\n                (down_belowContentLineIndex === -2 ||\n                    down_belowContentLineIndex < lineNumber - 1)) {\n                down_belowContentLineIndex = -1;\n                down_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_belowContentLineIndex = lineIndex;\n                        down_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let startLineNumber = 0;\n        let goUp = true;\n        let endLineNumber = 0;\n        let goDown = true;\n        let indent = 0;\n        let initialIndent = 0;\n        for (let distance = 0; goUp || goDown; distance++) {\n            const upLineNumber = lineNumber - distance;\n            const downLineNumber = lineNumber + distance;\n            if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n                goUp = false;\n            }\n            if (distance > 1 &&\n                (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\n                goDown = false;\n            }\n            if (distance > 50000) {\n                // stop processing\n                goUp = false;\n                goDown = false;\n            }\n            let upLineIndentLevel = -1;\n            if (goUp && upLineNumber >= 1) {\n                // compute indent level going up\n                const currentIndent = this._computeIndentLevel(upLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    up_belowContentLineIndex = upLineNumber - 1;\n                    up_belowContentLineIndent = currentIndent;\n                    upLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    up_resolveIndents(upLineNumber);\n                    upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\n                }\n            }\n            let downLineIndentLevel = -1;\n            if (goDown && downLineNumber <= lineCount) {\n                // compute indent level going down\n                const currentIndent = this._computeIndentLevel(downLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    down_aboveContentLineIndex = downLineNumber - 1;\n                    down_aboveContentLineIndent = currentIndent;\n                    downLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    down_resolveIndents(downLineNumber);\n                    downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\n                }\n            }\n            if (distance === 0) {\n                initialIndent = upLineIndentLevel;\n                continue;\n            }\n            if (distance === 1) {\n                if (downLineNumber <= lineCount &&\n                    downLineIndentLevel >= 0 &&\n                    initialIndent + 1 === downLineIndentLevel) {\n                    // This is the beginning of a scope, we have special handling here, since we want the\n                    // child scope indent to be active, not the parent scope\n                    goUp = false;\n                    startLineNumber = downLineNumber;\n                    endLineNumber = downLineNumber;\n                    indent = downLineIndentLevel;\n                    continue;\n                }\n                if (upLineNumber >= 1 &&\n                    upLineIndentLevel >= 0 &&\n                    upLineIndentLevel - 1 === initialIndent) {\n                    // This is the end of a scope, just like above\n                    goDown = false;\n                    startLineNumber = upLineNumber;\n                    endLineNumber = upLineNumber;\n                    indent = upLineIndentLevel;\n                    continue;\n                }\n                startLineNumber = lineNumber;\n                endLineNumber = lineNumber;\n                indent = initialIndent;\n                if (indent === 0) {\n                    // No need to continue\n                    return { startLineNumber, endLineNumber, indent };\n                }\n            }\n            if (goUp) {\n                if (upLineIndentLevel >= indent) {\n                    startLineNumber = upLineNumber;\n                }\n                else {\n                    goUp = false;\n                }\n            }\n            if (goDown) {\n                if (downLineIndentLevel >= indent) {\n                    endLineNumber = downLineNumber;\n                }\n                else {\n                    goDown = false;\n                }\n            }\n        }\n        return { startLineNumber, endLineNumber, indent };\n    }\n    getLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options) {\n        var _a;\n        const result = [];\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            result.push([]);\n        }\n        // If requested, this could be made configurable.\n        const includeSingleLinePairs = true;\n        const bracketPairs = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new Range(startLineNumber, 1, endLineNumber, this.textModel.getLineMaxColumn(endLineNumber)));\n        let activeBracketPairRange = undefined;\n        if (activePosition && bracketPairs.length > 0) {\n            const bracketsContainingActivePosition = (startLineNumber <= activePosition.lineNumber &&\n                activePosition.lineNumber <= endLineNumber\n                // We don't need to query the brackets again if the cursor is in the viewport\n                ? bracketPairs\n                : this.textModel.bracketPairs.getBracketPairsInRange(Range.fromPositions(activePosition))).filter((bp) => Range.strictContainsPosition(bp.range, activePosition));\n            activeBracketPairRange = (_a = findLast(bracketsContainingActivePosition, (i) => includeSingleLinePairs || i.range.startLineNumber !== i.range.endLineNumber)) === null || _a === void 0 ? void 0 : _a.range;\n        }\n        const independentColorPoolPerBracketType = this.textModel.getOptions().bracketPairColorizationOptions.independentColorPoolPerBracketType;\n        const colorProvider = new BracketPairGuidesClassNames();\n        for (const pair of bracketPairs) {\n            /*\n\n\n                    {\n                    |\n                    }\n\n                    {\n                    |\n                    ----}\n\n                ____{\n                |test\n                ----}\n\n                renderHorizontalEndLineAtTheBottom:\n                    {\n                    |\n                    |x}\n                    --\n                renderHorizontalEndLineAtTheBottom:\n                ____{\n                |test\n                | x }\n                ----\n            */\n            if (!pair.closingBracketRange) {\n                continue;\n            }\n            const isActive = activeBracketPairRange && pair.range.equalsRange(activeBracketPairRange);\n            if (!isActive && !options.includeInactive) {\n                continue;\n            }\n            const className = colorProvider.getInlineClassName(pair.nestingLevel, pair.nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) +\n                (options.highlightActive && isActive\n                    ? ' ' + colorProvider.activeClassName\n                    : '');\n            const start = pair.openingBracketRange.getStartPosition();\n            const end = pair.closingBracketRange.getStartPosition();\n            const horizontalGuides = options.horizontalGuides === HorizontalGuidesState.Enabled || (options.horizontalGuides === HorizontalGuidesState.EnabledForActive && isActive);\n            if (pair.range.startLineNumber === pair.range.endLineNumber) {\n                if (includeSingleLinePairs && horizontalGuides) {\n                    result[pair.range.startLineNumber - startLineNumber].push(new IndentGuide(-1, pair.openingBracketRange.getEndPosition().column, className, new IndentGuideHorizontalLine(false, end.column), -1, -1));\n                }\n                continue;\n            }\n            const endVisibleColumn = this.getVisibleColumnFromPosition(end);\n            const startVisibleColumn = this.getVisibleColumnFromPosition(pair.openingBracketRange.getStartPosition());\n            const guideVisibleColumn = Math.min(startVisibleColumn, endVisibleColumn, pair.minVisibleColumnIndentation + 1);\n            let renderHorizontalEndLineAtTheBottom = false;\n            const firstNonWsIndex = strings.firstNonWhitespaceIndex(this.textModel.getLineContent(pair.closingBracketRange.startLineNumber));\n            const hasTextBeforeClosingBracket = firstNonWsIndex < pair.closingBracketRange.startColumn - 1;\n            if (hasTextBeforeClosingBracket) {\n                renderHorizontalEndLineAtTheBottom = true;\n            }\n            const visibleGuideStartLineNumber = Math.max(start.lineNumber, startLineNumber);\n            const visibleGuideEndLineNumber = Math.min(end.lineNumber, endLineNumber);\n            const offset = renderHorizontalEndLineAtTheBottom ? 1 : 0;\n            for (let l = visibleGuideStartLineNumber; l < visibleGuideEndLineNumber + offset; l++) {\n                result[l - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, null, l === start.lineNumber ? start.column : -1, l === end.lineNumber ? end.column : -1));\n            }\n            if (horizontalGuides) {\n                if (start.lineNumber >= startLineNumber && startVisibleColumn > guideVisibleColumn) {\n                    result[start.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(false, start.column), -1, -1));\n                }\n                if (end.lineNumber <= endLineNumber && endVisibleColumn > guideVisibleColumn) {\n                    result[end.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(!renderHorizontalEndLineAtTheBottom, end.column), -1, -1));\n                }\n            }\n        }\n        for (const guides of result) {\n            guides.sort((a, b) => a.visibleColumn - b.visibleColumn);\n        }\n        return result;\n    }\n    getVisibleColumnFromPosition(position) {\n        return (CursorColumns.visibleColumnFromColumn(this.textModel.getLineContent(position.lineNumber), position.column, this.textModel.getOptions().tabSize) + 1);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (startLineNumber < 1 || startLineNumber > lineCount) {\n            throw new Error('Illegal value for startLineNumber');\n        }\n        if (endLineNumber < 1 || endLineNumber > lineCount) {\n            throw new Error('Illegal value for endLineNumber');\n        }\n        const options = this.textModel.getOptions();\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        const result = new Array(endLineNumber - startLineNumber + 1);\n        let aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let aboveContentLineIndent = -1;\n        let belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let belowContentLineIndent = -1;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const resultIndex = lineNumber - startLineNumber;\n            const currentIndent = this._computeIndentLevel(lineNumber - 1);\n            if (currentIndent >= 0) {\n                // This line has content (besides whitespace)\n                // Use the line's indent\n                aboveContentLineIndex = lineNumber - 1;\n                aboveContentLineIndent = currentIndent;\n                result[resultIndex] = Math.ceil(currentIndent / options.indentSize);\n                continue;\n            }\n            if (aboveContentLineIndex === -2) {\n                aboveContentLineIndex = -1;\n                aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        aboveContentLineIndex = lineIndex;\n                        aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (belowContentLineIndex !== -1 &&\n                (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\n                belowContentLineIndex = -1;\n                belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        belowContentLineIndex = lineIndex;\n                        belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\n        }\n        return result;\n    }\n    _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {\n        const options = this.textModel.getOptions();\n        if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n            // At the top or bottom of the file\n            return 0;\n        }\n        else if (aboveContentLineIndent < belowContentLineIndent) {\n            // we are inside the region above\n            return 1 + Math.floor(aboveContentLineIndent / options.indentSize);\n        }\n        else if (aboveContentLineIndent === belowContentLineIndent) {\n            // we are in between two regions\n            return Math.ceil(belowContentLineIndent / options.indentSize);\n        }\n        else {\n            if (offSide) {\n                // same level as region below\n                return Math.ceil(belowContentLineIndent / options.indentSize);\n            }\n            else {\n                // we are inside the region that ends below\n                return 1 + Math.floor(belowContentLineIndent / options.indentSize);\n            }\n        }\n    }\n}\nexport class BracketPairGuidesClassNames {\n    constructor() {\n        this.activeClassName = 'indent-active';\n    }\n    getInlineClassName(nestingLevel, nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) {\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? nestingLevelOfEqualBracketType : nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-indent-guide lvl-${level % 30}`;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass SpacesDiffResult {\n    constructor() {\n        this.spacesDiff = 0;\n        this.looksLikeAlignment = false;\n    }\n}\n/**\n * Compute the diff in spaces between two line's indentation.\n */\nfunction spacesDiff(a, aLength, b, bLength, result) {\n    result.spacesDiff = 0;\n    result.looksLikeAlignment = false;\n    // This can go both ways (e.g.):\n    //  - a: \"\\t\"\n    //  - b: \"\\t    \"\n    //  => This should count 1 tab and 4 spaces\n    let i;\n    for (i = 0; i < aLength && i < bLength; i++) {\n        const aCharCode = a.charCodeAt(i);\n        const bCharCode = b.charCodeAt(i);\n        if (aCharCode !== bCharCode) {\n            break;\n        }\n    }\n    let aSpacesCnt = 0, aTabsCount = 0;\n    for (let j = i; j < aLength; j++) {\n        const aCharCode = a.charCodeAt(j);\n        if (aCharCode === 32 /* CharCode.Space */) {\n            aSpacesCnt++;\n        }\n        else {\n            aTabsCount++;\n        }\n    }\n    let bSpacesCnt = 0, bTabsCount = 0;\n    for (let j = i; j < bLength; j++) {\n        const bCharCode = b.charCodeAt(j);\n        if (bCharCode === 32 /* CharCode.Space */) {\n            bSpacesCnt++;\n        }\n        else {\n            bTabsCount++;\n        }\n    }\n    if (aSpacesCnt > 0 && aTabsCount > 0) {\n        return;\n    }\n    if (bSpacesCnt > 0 && bTabsCount > 0) {\n        return;\n    }\n    const tabsDiff = Math.abs(aTabsCount - bTabsCount);\n    const spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);\n    if (tabsDiff === 0) {\n        // check if the indentation difference might be caused by alignment reasons\n        // sometime folks like to align their code, but this should not be used as a hint\n        result.spacesDiff = spacesDiff;\n        if (spacesDiff > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {\n            if (b.charCodeAt(bSpacesCnt) !== 32 /* CharCode.Space */ && a.charCodeAt(bSpacesCnt - 1) === 32 /* CharCode.Space */) {\n                if (a.charCodeAt(a.length - 1) === 44 /* CharCode.Comma */) {\n                    // This looks like an alignment desire: e.g.\n                    // const a = b + c,\n                    //       d = b - c;\n                    result.looksLikeAlignment = true;\n                }\n            }\n        }\n        return;\n    }\n    if (spacesDiff % tabsDiff === 0) {\n        result.spacesDiff = spacesDiff / tabsDiff;\n        return;\n    }\n}\nexport function guessIndentation(source, defaultTabSize, defaultInsertSpaces) {\n    // Look at most at the first 10k lines\n    const linesCount = Math.min(source.getLineCount(), 10000);\n    let linesIndentedWithTabsCount = 0; // number of lines that contain at least one tab in indentation\n    let linesIndentedWithSpacesCount = 0; // number of lines that contain only spaces in indentation\n    let previousLineText = ''; // content of latest line that contained non-whitespace chars\n    let previousLineIndentation = 0; // index at which latest line contained the first non-whitespace char\n    const ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7]; // prefer even guesses for `tabSize`, limit to [2, 8].\n    const MAX_ALLOWED_TAB_SIZE_GUESS = 8; // max(ALLOWED_TAB_SIZE_GUESSES) = 8\n    const spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // `tabSize` scores\n    const tmp = new SpacesDiffResult();\n    for (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {\n        const currentLineLength = source.getLineLength(lineNumber);\n        const currentLineText = source.getLineContent(lineNumber);\n        // if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.\n        // checking charCode on chunks directly is cheaper.\n        const useCurrentLineText = (currentLineLength <= 65536);\n        let currentLineHasContent = false; // does `currentLineText` contain non-whitespace chars\n        let currentLineIndentation = 0; // index at which `currentLineText` contains the first non-whitespace char\n        let currentLineSpacesCount = 0; // count of spaces found in `currentLineText` indentation\n        let currentLineTabsCount = 0; // count of tabs found in `currentLineText` indentation\n        for (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {\n            const charCode = (useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j));\n            if (charCode === 9 /* CharCode.Tab */) {\n                currentLineTabsCount++;\n            }\n            else if (charCode === 32 /* CharCode.Space */) {\n                currentLineSpacesCount++;\n            }\n            else {\n                // Hit non whitespace character on this line\n                currentLineHasContent = true;\n                currentLineIndentation = j;\n                break;\n            }\n        }\n        // Ignore empty or only whitespace lines\n        if (!currentLineHasContent) {\n            continue;\n        }\n        if (currentLineTabsCount > 0) {\n            linesIndentedWithTabsCount++;\n        }\n        else if (currentLineSpacesCount > 1) {\n            linesIndentedWithSpacesCount++;\n        }\n        spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);\n        if (tmp.looksLikeAlignment) {\n            // if defaultInsertSpaces === true && the spaces count == tabSize, we may want to count it as valid indentation\n            //\n            // - item1\n            //   - item2\n            //\n            // otherwise skip this line entirely\n            //\n            // const a = 1,\n            //       b = 2;\n            if (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {\n                continue;\n            }\n        }\n        const currentSpacesDiff = tmp.spacesDiff;\n        if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {\n            spacesDiffCount[currentSpacesDiff]++;\n        }\n        previousLineText = currentLineText;\n        previousLineIndentation = currentLineIndentation;\n    }\n    let insertSpaces = defaultInsertSpaces;\n    if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {\n        insertSpaces = (linesIndentedWithTabsCount < linesIndentedWithSpacesCount);\n    }\n    let tabSize = defaultTabSize;\n    // Guess tabSize only if inserting spaces...\n    if (insertSpaces) {\n        let tabSizeScore = (insertSpaces ? 0 : 0.1 * linesCount);\n        // console.log(\"score threshold: \" + tabSizeScore);\n        ALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {\n            const possibleTabSizeScore = spacesDiffCount[possibleTabSize];\n            if (possibleTabSizeScore > tabSizeScore) {\n                tabSizeScore = possibleTabSizeScore;\n                tabSize = possibleTabSize;\n            }\n        });\n        // Let a tabSize of 2 win even if it is not the maximum\n        // (only in case 4 was guessed)\n        if (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {\n            tabSize = 2;\n        }\n    }\n    // console.log('--------------------------');\n    // console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);\n    // console.log('spacesDiffCount: ' + spacesDiffCount);\n    // console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);\n    return {\n        insertSpaces: insertSpaces,\n        tabSize: tabSize\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function getNodeColor(node) {\n    return ((node.metadata & 1 /* Constants.ColorMask */) >>> 0 /* Constants.ColorOffset */);\n}\nfunction setNodeColor(node, color) {\n    node.metadata = ((node.metadata & 254 /* Constants.ColorMaskInverse */) | (color << 0 /* Constants.ColorOffset */));\n}\nfunction getNodeIsVisited(node) {\n    return ((node.metadata & 2 /* Constants.IsVisitedMask */) >>> 1 /* Constants.IsVisitedOffset */) === 1;\n}\nfunction setNodeIsVisited(node, value) {\n    node.metadata = ((node.metadata & 253 /* Constants.IsVisitedMaskInverse */) | ((value ? 1 : 0) << 1 /* Constants.IsVisitedOffset */));\n}\nfunction getNodeIsForValidation(node) {\n    return ((node.metadata & 4 /* Constants.IsForValidationMask */) >>> 2 /* Constants.IsForValidationOffset */) === 1;\n}\nfunction setNodeIsForValidation(node, value) {\n    node.metadata = ((node.metadata & 251 /* Constants.IsForValidationMaskInverse */) | ((value ? 1 : 0) << 2 /* Constants.IsForValidationOffset */));\n}\nfunction getNodeStickiness(node) {\n    return ((node.metadata & 24 /* Constants.StickinessMask */) >>> 3 /* Constants.StickinessOffset */);\n}\nfunction _setNodeStickiness(node, stickiness) {\n    node.metadata = ((node.metadata & 231 /* Constants.StickinessMaskInverse */) | (stickiness << 3 /* Constants.StickinessOffset */));\n}\nfunction getCollapseOnReplaceEdit(node) {\n    return ((node.metadata & 32 /* Constants.CollapseOnReplaceEditMask */) >>> 5 /* Constants.CollapseOnReplaceEditOffset */) === 1;\n}\nfunction setCollapseOnReplaceEdit(node, value) {\n    node.metadata = ((node.metadata & 223 /* Constants.CollapseOnReplaceEditMaskInverse */) | ((value ? 1 : 0) << 5 /* Constants.CollapseOnReplaceEditOffset */));\n}\nexport class IntervalNode {\n    constructor(id, start, end) {\n        this.metadata = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n        setNodeColor(this, 1 /* NodeColor.Red */);\n        this.start = start;\n        this.end = end;\n        // FORCE_OVERFLOWING_TEST: this.delta = start;\n        this.delta = 0;\n        this.maxEnd = end;\n        this.id = id;\n        this.ownerId = 0;\n        this.options = null;\n        setNodeIsForValidation(this, false);\n        _setNodeStickiness(this, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        setCollapseOnReplaceEdit(this, false);\n        this.cachedVersionId = 0;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = null;\n        setNodeIsVisited(this, false);\n    }\n    reset(versionId, start, end, range) {\n        this.start = start;\n        this.end = end;\n        this.maxEnd = end;\n        this.cachedVersionId = versionId;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = range;\n    }\n    setOptions(options) {\n        this.options = options;\n        const className = this.options.className;\n        setNodeIsForValidation(this, (className === \"squiggly-error\" /* ClassName.EditorErrorDecoration */\n            || className === \"squiggly-warning\" /* ClassName.EditorWarningDecoration */\n            || className === \"squiggly-info\" /* ClassName.EditorInfoDecoration */));\n        _setNodeStickiness(this, this.options.stickiness);\n        setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n    }\n    setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {\n        if (this.cachedVersionId !== cachedVersionId) {\n            this.range = null;\n        }\n        this.cachedVersionId = cachedVersionId;\n        this.cachedAbsoluteStart = absoluteStart;\n        this.cachedAbsoluteEnd = absoluteEnd;\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new IntervalNode(null, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, 0 /* NodeColor.Black */);\nexport class IntervalTree {\n    constructor() {\n        this.root = SENTINEL;\n        this.requestNormalizeDelta = false;\n    }\n    intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n    }\n    search(filterOwnerId, filterOutValidation, cachedVersionId) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return search(this, filterOwnerId, filterOutValidation, cachedVersionId);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesFromOwner(ownerId) {\n        return collectNodesFromOwner(this, ownerId);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesPostOrder() {\n        return collectNodesPostOrder(this);\n    }\n    insert(node) {\n        rbTreeInsert(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    delete(node) {\n        rbTreeDelete(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    resolveNode(node, cachedVersionId) {\n        const initialNode = node;\n        let delta = 0;\n        while (node !== this.root) {\n            if (node === node.parent.right) {\n                delta += node.parent.delta;\n            }\n            node = node.parent;\n        }\n        const nodeStart = initialNode.start + delta;\n        const nodeEnd = initialNode.end + delta;\n        initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n        // (1) collect all nodes that are intersecting this edit as nodes of interest\n        const nodesOfInterest = searchForEditing(this, offset, offset + length);\n        // (2) remove all nodes that are intersecting this edit\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            rbTreeDelete(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n        // (3) edit all tree nodes except the nodes of interest\n        noOverlapReplace(this, offset, offset + length, textLength);\n        this._normalizeDeltaIfNecessary();\n        // (4) edit the nodes of interest and insert them back in the tree\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            node.start = node.cachedAbsoluteStart;\n            node.end = node.cachedAbsoluteEnd;\n            nodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\n            node.maxEnd = node.end;\n            rbTreeInsert(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n    }\n    _normalizeDeltaIfNecessary() {\n        if (!this.requestNormalizeDelta) {\n            return;\n        }\n        this.requestNormalizeDelta = false;\n        normalizeDelta(this);\n    }\n}\n//#region Delta Normalization\nfunction normalizeDelta(T) {\n    let node = T.root;\n    let delta = 0;\n    while (node !== SENTINEL) {\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        node.start = delta + node.start;\n        node.end = delta + node.end;\n        node.delta = 0;\n        recomputeMaxEnd(node);\n        setNodeIsVisited(node, true);\n        // going up from this node\n        setNodeIsVisited(node.left, false);\n        setNodeIsVisited(node.right, false);\n        if (node === node.parent.right) {\n            delta -= node.parent.delta;\n        }\n        node = node.parent;\n    }\n    setNodeIsVisited(T.root, false);\n}\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n    if (markerOffset < checkOffset) {\n        return true;\n    }\n    if (markerOffset > checkOffset) {\n        return false;\n    }\n    if (moveSemantics === 1 /* MarkerMoveSemantics.ForceMove */) {\n        return false;\n    }\n    if (moveSemantics === 2 /* MarkerMoveSemantics.ForceStay */) {\n        return true;\n    }\n    return markerStickToPreviousCharacter;\n}\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n    const nodeStickiness = getNodeStickiness(node);\n    const startStickToPreviousCharacter = (nodeStickiness === 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const endStickToPreviousCharacter = (nodeStickiness === 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const deletingCnt = (end - start);\n    const insertingCnt = textLength;\n    const commonLength = Math.min(deletingCnt, insertingCnt);\n    const nodeStart = node.start;\n    let startDone = false;\n    const nodeEnd = node.end;\n    let endDone = false;\n    if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n        // This edit encompasses the entire decoration range\n        // and the decoration has asked to become collapsed\n        node.start = start;\n        startDone = true;\n        node.end = start;\n        endDone = true;\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : (deletingCnt > 0 ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    if (commonLength > 0 && !forceMoveMarkers) {\n        const moveSemantics = (deletingCnt > insertingCnt ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : 0 /* MarkerMoveSemantics.MarkerDefined */;\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n            node.start = start + insertingCnt;\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n            node.end = start + insertingCnt;\n            endDone = true;\n        }\n    }\n    // Finish\n    const deltaColumn = (insertingCnt - deletingCnt);\n    if (!startDone) {\n        node.start = Math.max(0, nodeStart + deltaColumn);\n    }\n    if (!endDone) {\n        node.end = Math.max(0, nodeEnd + deltaColumn);\n    }\n    if (node.start > node.end) {\n        node.end = node.start;\n    }\n}\nfunction searchForEditing(T, start, end) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= start) {\n            node.setCachedOffsets(nodeStart, nodeEnd, 0);\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction noOverlapReplace(T, start, end, textLength) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    const editDelta = (textLength - (end - start));\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            recomputeMaxEnd(node);\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            node.start += editDelta;\n            node.end += editDelta;\n            node.delta += editDelta;\n            if (node.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || node.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n                T.requestNormalizeDelta = true;\n            }\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n}\n//#endregion\n//#region Searching\nfunction collectNodesFromOwner(T, ownerId) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        if (node.ownerId === ownerId) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction collectNodesPostOrder(T) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        result[resultLen++] = node;\n        setNodeIsVisited(node, true);\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId) {\n    let node = T.root;\n    let delta = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        nodeEnd = delta + node.end;\n        node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n        let include = true;\n        if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n            include = false;\n        }\n        if (filterOutValidation && getNodeIsForValidation(node)) {\n            include = false;\n        }\n        if (include) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < intervalStart) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > intervalEnd) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= intervalStart) {\n            // There is overlap\n            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n            let include = true;\n            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n                include = false;\n            }\n            if (filterOutValidation && getNodeIsForValidation(node)) {\n                include = false;\n            }\n            if (include) {\n                result[resultLen++] = node;\n            }\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\n//#endregion\n//#region Insertion\nfunction rbTreeInsert(T, newNode) {\n    if (T.root === SENTINEL) {\n        newNode.parent = SENTINEL;\n        newNode.left = SENTINEL;\n        newNode.right = SENTINEL;\n        setNodeColor(newNode, 0 /* NodeColor.Black */);\n        T.root = newNode;\n        return T.root;\n    }\n    treeInsert(T, newNode);\n    recomputeMaxEndWalkToRoot(newNode.parent);\n    // repair tree\n    let x = newNode;\n    while (x !== T.root && getNodeColor(x.parent) === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent.parent);\n            }\n        }\n    }\n    setNodeColor(T.root, 0 /* NodeColor.Black */);\n    return newNode;\n}\nfunction treeInsert(T, z) {\n    let delta = 0;\n    let x = T.root;\n    const zAbsoluteStart = z.start;\n    const zAbsoluteEnd = z.end;\n    while (true) {\n        const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n        if (cmp < 0) {\n            // this node should be inserted to the left\n            // => it is not affected by the node's delta\n            if (x.left === SENTINEL) {\n                z.start -= delta;\n                z.end -= delta;\n                z.maxEnd -= delta;\n                x.left = z;\n                break;\n            }\n            else {\n                x = x.left;\n            }\n        }\n        else {\n            // this node should be inserted to the right\n            // => it is not affected by the node's delta\n            if (x.right === SENTINEL) {\n                z.start -= (delta + x.delta);\n                z.end -= (delta + x.delta);\n                z.maxEnd -= (delta + x.delta);\n                x.right = z;\n                break;\n            }\n            else {\n                delta += x.delta;\n                x = x.right;\n            }\n        }\n    }\n    z.parent = x;\n    z.left = SENTINEL;\n    z.right = SENTINEL;\n    setNodeColor(z, 1 /* NodeColor.Red */);\n}\n//#endregion\n//#region Deletion\nfunction rbTreeDelete(T, z) {\n    let x;\n    let y;\n    // RB-DELETE except we don't swap z and y in case c)\n    // i.e. we always delete what's pointed at by z.\n    if (z.left === SENTINEL) {\n        x = z.right;\n        y = z;\n        // x's delta is no longer influenced by z's delta\n        x.delta += z.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        x.start += z.delta;\n        x.end += z.delta;\n    }\n    else if (z.right === SENTINEL) {\n        x = z.left;\n        y = z;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n        // y's delta is no longer influenced by z's delta,\n        // but we don't want to walk the entire right-hand-side subtree of x.\n        // we therefore maintain z's delta in y, and adjust only x\n        x.start += y.delta;\n        x.end += y.delta;\n        x.delta += y.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        y.start += z.delta;\n        y.end += z.delta;\n        y.delta = z.delta;\n        if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n    }\n    if (y === T.root) {\n        T.root = x;\n        setNodeColor(x, 0 /* NodeColor.Black */);\n        z.detach();\n        resetSentinel();\n        recomputeMaxEnd(x);\n        T.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (getNodeColor(y) === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        setNodeColor(y, getNodeColor(z));\n        if (z === T.root) {\n            T.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n    }\n    z.detach();\n    if (yWasRed) {\n        recomputeMaxEndWalkToRoot(x.parent);\n        if (y !== z) {\n            recomputeMaxEndWalkToRoot(y);\n            recomputeMaxEndWalkToRoot(y.parent);\n        }\n        resetSentinel();\n        return;\n    }\n    recomputeMaxEndWalkToRoot(x);\n    recomputeMaxEndWalkToRoot(x.parent);\n    if (y !== z) {\n        recomputeMaxEndWalkToRoot(y);\n        recomputeMaxEndWalkToRoot(y.parent);\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== T.root && getNodeColor(x) === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent);\n                w = x.parent.right;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.left, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    rightRotate(T, w);\n                    w = x.parent.right;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.right, 0 /* NodeColor.Black */);\n                leftRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent);\n                w = x.parent.left;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.left) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.right, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    leftRotate(T, w);\n                    w = x.parent.left;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.left, 0 /* NodeColor.Black */);\n                rightRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n    }\n    setNodeColor(x, 0 /* NodeColor.Black */);\n    resetSentinel();\n}\nfunction leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n    SENTINEL.delta = 0; // optional\n    SENTINEL.start = 0; // optional\n    SENTINEL.end = 0; // optional\n}\n//#endregion\n//#region Rotations\nfunction leftRotate(T, x) {\n    const y = x.right; // set y.\n    y.delta += x.delta; // y's delta is no longer influenced by x's delta\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start += x.delta;\n    y.end += x.delta;\n    x.right = y.left; // turn y's left subtree into x's right subtree.\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent; // link x's parent to y.\n    if (x.parent === SENTINEL) {\n        T.root = y;\n    }\n    else if (x === x.parent.left) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x; // put x on y's left.\n    x.parent = y;\n    recomputeMaxEnd(x);\n    recomputeMaxEnd(y);\n}\nfunction rightRotate(T, y) {\n    const x = y.left;\n    y.delta -= x.delta;\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start -= x.delta;\n    y.end -= x.delta;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    if (y.parent === SENTINEL) {\n        T.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n    recomputeMaxEnd(y);\n    recomputeMaxEnd(x);\n}\n//#endregion\n//#region max end computation\nfunction computeMaxEnd(node) {\n    let maxEnd = node.end;\n    if (node.left !== SENTINEL) {\n        const leftMaxEnd = node.left.maxEnd;\n        if (leftMaxEnd > maxEnd) {\n            maxEnd = leftMaxEnd;\n        }\n    }\n    if (node.right !== SENTINEL) {\n        const rightMaxEnd = node.right.maxEnd + node.delta;\n        if (rightMaxEnd > maxEnd) {\n            maxEnd = rightMaxEnd;\n        }\n    }\n    return maxEnd;\n}\nexport function recomputeMaxEnd(node) {\n    node.maxEnd = computeMaxEnd(node);\n}\nfunction recomputeMaxEndWalkToRoot(node) {\n    while (node !== SENTINEL) {\n        const maxEnd = computeMaxEnd(node);\n        if (node.maxEnd === maxEnd) {\n            // no need to go further\n            return;\n        }\n        node.maxEnd = maxEnd;\n        node = node.parent;\n    }\n}\n//#endregion\n//#region utils\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\n    if (aStart === bStart) {\n        return aEnd - bEnd;\n    }\n    return aStart - bStart;\n}\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertNever } from '../../base/common/types.js';\nimport { Position } from './core/position.js';\nimport { InjectedTextCursorStops } from './model.js';\n/**\n * *input*:\n * ```\n * xxxxxxxxxxxxxxxxxxxxxxxxxxx\n * ```\n *\n * -> Applying injections `[i...i]`, *inputWithInjections*:\n * ```\n * xxxxxx[iiiiiiiiii]xxxxxxxxxxxxxxxxx[ii]xxxx\n * ```\n *\n * -> breaking at offsets `|` in `xxxxxx[iiiiiii|iii]xxxxxxxxxxx|xxxxxx[ii]xxxx|`:\n * ```\n * xxxxxx[iiiiiii\n * iii]xxxxxxxxxxx\n * xxxxxx[ii]xxxx\n * ```\n *\n * -> applying wrappedTextIndentLength, *output*:\n * ```\n * xxxxxx[iiiiiii\n *    iii]xxxxxxxxxxx\n *    xxxxxx[ii]xxxx\n * ```\n */\nexport class ModelLineProjectionData {\n    constructor(injectionOffsets, \n    /**\n     * `injectionOptions.length` must equal `injectionOffsets.length`\n     */\n    injectionOptions, \n    /**\n     * Refers to offsets after applying injections to the source.\n     * The last break offset indicates the length of the source after applying injections.\n     */\n    breakOffsets, \n    /**\n     * Refers to offsets after applying injections\n     */\n    breakOffsetsVisibleColumn, wrappedTextIndentLength) {\n        this.injectionOffsets = injectionOffsets;\n        this.injectionOptions = injectionOptions;\n        this.breakOffsets = breakOffsets;\n        this.breakOffsetsVisibleColumn = breakOffsetsVisibleColumn;\n        this.wrappedTextIndentLength = wrappedTextIndentLength;\n    }\n    getOutputLineCount() {\n        return this.breakOffsets.length;\n    }\n    getMinOutputOffset(outputLineIndex) {\n        if (outputLineIndex > 0) {\n            return this.wrappedTextIndentLength;\n        }\n        return 0;\n    }\n    getLineLength(outputLineIndex) {\n        // These offsets refer to model text with injected text.\n        const startOffset = outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0;\n        const endOffset = this.breakOffsets[outputLineIndex];\n        let lineLength = endOffset - startOffset;\n        if (outputLineIndex > 0) {\n            lineLength += this.wrappedTextIndentLength;\n        }\n        return lineLength;\n    }\n    getMaxOutputOffset(outputLineIndex) {\n        return this.getLineLength(outputLineIndex);\n    }\n    translateToInputOffset(outputLineIndex, outputOffset) {\n        if (outputLineIndex > 0) {\n            outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n        }\n        const offsetInInputWithInjection = outputLineIndex === 0 ? outputOffset : this.breakOffsets[outputLineIndex - 1] + outputOffset;\n        let offsetInInput = offsetInInputWithInjection;\n        if (this.injectionOffsets !== null) {\n            for (let i = 0; i < this.injectionOffsets.length; i++) {\n                if (offsetInInput > this.injectionOffsets[i]) {\n                    if (offsetInInput < this.injectionOffsets[i] + this.injectionOptions[i].content.length) {\n                        // `inputOffset` is within injected text\n                        offsetInInput = this.injectionOffsets[i];\n                    }\n                    else {\n                        offsetInInput -= this.injectionOptions[i].content.length;\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        return offsetInInput;\n    }\n    translateToOutputPosition(inputOffset, affinity = 2 /* PositionAffinity.None */) {\n        let inputOffsetInInputWithInjection = inputOffset;\n        if (this.injectionOffsets !== null) {\n            for (let i = 0; i < this.injectionOffsets.length; i++) {\n                if (inputOffset < this.injectionOffsets[i]) {\n                    break;\n                }\n                if (affinity !== 1 /* PositionAffinity.Right */ && inputOffset === this.injectionOffsets[i]) {\n                    break;\n                }\n                inputOffsetInInputWithInjection += this.injectionOptions[i].content.length;\n            }\n        }\n        return this.offsetInInputWithInjectionsToOutputPosition(inputOffsetInInputWithInjection, affinity);\n    }\n    offsetInInputWithInjectionsToOutputPosition(offsetInInputWithInjections, affinity = 2 /* PositionAffinity.None */) {\n        let low = 0;\n        let high = this.breakOffsets.length - 1;\n        let mid = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            const midStop = this.breakOffsets[mid];\n            midStart = mid > 0 ? this.breakOffsets[mid - 1] : 0;\n            if (affinity === 0 /* PositionAffinity.Left */) {\n                if (offsetInInputWithInjections <= midStart) {\n                    high = mid - 1;\n                }\n                else if (offsetInInputWithInjections > midStop) {\n                    low = mid + 1;\n                }\n                else {\n                    break;\n                }\n            }\n            else {\n                if (offsetInInputWithInjections < midStart) {\n                    high = mid - 1;\n                }\n                else if (offsetInInputWithInjections >= midStop) {\n                    low = mid + 1;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        let outputOffset = offsetInInputWithInjections - midStart;\n        if (mid > 0) {\n            outputOffset += this.wrappedTextIndentLength;\n        }\n        return new OutputPosition(mid, outputOffset);\n    }\n    normalizeOutputPosition(outputLineIndex, outputOffset, affinity) {\n        if (this.injectionOffsets !== null) {\n            const offsetInInputWithInjections = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n            const normalizedOffsetInUnwrappedLine = this.normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity);\n            if (normalizedOffsetInUnwrappedLine !== offsetInInputWithInjections) {\n                // injected text caused a change\n                return this.offsetInInputWithInjectionsToOutputPosition(normalizedOffsetInUnwrappedLine, affinity);\n            }\n        }\n        if (affinity === 0 /* PositionAffinity.Left */) {\n            if (outputLineIndex > 0 && outputOffset === this.getMinOutputOffset(outputLineIndex)) {\n                return new OutputPosition(outputLineIndex - 1, this.getMaxOutputOffset(outputLineIndex - 1));\n            }\n        }\n        else if (affinity === 1 /* PositionAffinity.Right */) {\n            const maxOutputLineIndex = this.getOutputLineCount() - 1;\n            if (outputLineIndex < maxOutputLineIndex && outputOffset === this.getMaxOutputOffset(outputLineIndex)) {\n                return new OutputPosition(outputLineIndex + 1, this.getMinOutputOffset(outputLineIndex + 1));\n            }\n        }\n        return new OutputPosition(outputLineIndex, outputOffset);\n    }\n    outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset) {\n        if (outputLineIndex > 0) {\n            outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n        }\n        const result = (outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0) + outputOffset;\n        return result;\n    }\n    normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity) {\n        const injectedText = this.getInjectedTextAtOffset(offsetInInputWithInjections);\n        if (!injectedText) {\n            return offsetInInputWithInjections;\n        }\n        if (affinity === 2 /* PositionAffinity.None */) {\n            if (offsetInInputWithInjections === injectedText.offsetInInputWithInjections + injectedText.length\n                && hasRightCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {\n                return injectedText.offsetInInputWithInjections + injectedText.length;\n            }\n            else {\n                let result = injectedText.offsetInInputWithInjections;\n                if (hasLeftCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {\n                    return result;\n                }\n                let index = injectedText.injectedTextIndex - 1;\n                while (index >= 0 && this.injectionOffsets[index] === this.injectionOffsets[injectedText.injectedTextIndex]) {\n                    if (hasRightCursorStop(this.injectionOptions[index].cursorStops)) {\n                        break;\n                    }\n                    result -= this.injectionOptions[index].content.length;\n                    if (hasLeftCursorStop(this.injectionOptions[index].cursorStops)) {\n                        break;\n                    }\n                    index--;\n                }\n                return result;\n            }\n        }\n        else if (affinity === 1 /* PositionAffinity.Right */ || affinity === 4 /* PositionAffinity.RightOfInjectedText */) {\n            let result = injectedText.offsetInInputWithInjections + injectedText.length;\n            let index = injectedText.injectedTextIndex;\n            // traverse all injected text that touch each other\n            while (index + 1 < this.injectionOffsets.length && this.injectionOffsets[index + 1] === this.injectionOffsets[index]) {\n                result += this.injectionOptions[index + 1].content.length;\n                index++;\n            }\n            return result;\n        }\n        else if (affinity === 0 /* PositionAffinity.Left */ || affinity === 3 /* PositionAffinity.LeftOfInjectedText */) {\n            // affinity is left\n            let result = injectedText.offsetInInputWithInjections;\n            let index = injectedText.injectedTextIndex;\n            // traverse all injected text that touch each other\n            while (index - 1 >= 0 && this.injectionOffsets[index - 1] === this.injectionOffsets[index]) {\n                result -= this.injectionOptions[index - 1].content.length;\n                index--;\n            }\n            return result;\n        }\n        assertNever(affinity);\n    }\n    getInjectedText(outputLineIndex, outputOffset) {\n        const offset = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n        const injectedText = this.getInjectedTextAtOffset(offset);\n        if (!injectedText) {\n            return null;\n        }\n        return {\n            options: this.injectionOptions[injectedText.injectedTextIndex]\n        };\n    }\n    getInjectedTextAtOffset(offsetInInputWithInjections) {\n        const injectionOffsets = this.injectionOffsets;\n        const injectionOptions = this.injectionOptions;\n        if (injectionOffsets !== null) {\n            let totalInjectedTextLengthBefore = 0;\n            for (let i = 0; i < injectionOffsets.length; i++) {\n                const length = injectionOptions[i].content.length;\n                const injectedTextStartOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore;\n                const injectedTextEndOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore + length;\n                if (injectedTextStartOffsetInInputWithInjections > offsetInInputWithInjections) {\n                    // Injected text starts later.\n                    break; // All later injected texts have an even larger offset.\n                }\n                if (offsetInInputWithInjections <= injectedTextEndOffsetInInputWithInjections) {\n                    // Injected text ends after or with the given position (but also starts with or before it).\n                    return {\n                        injectedTextIndex: i,\n                        offsetInInputWithInjections: injectedTextStartOffsetInInputWithInjections,\n                        length\n                    };\n                }\n                totalInjectedTextLengthBefore += length;\n            }\n        }\n        return undefined;\n    }\n}\nfunction hasRightCursorStop(cursorStop) {\n    if (cursorStop === null || cursorStop === undefined) {\n        return true;\n    }\n    return cursorStop === InjectedTextCursorStops.Right || cursorStop === InjectedTextCursorStops.Both;\n}\nfunction hasLeftCursorStop(cursorStop) {\n    if (cursorStop === null || cursorStop === undefined) {\n        return true;\n    }\n    return cursorStop === InjectedTextCursorStops.Left || cursorStop === InjectedTextCursorStops.Both;\n}\nexport class InjectedText {\n    constructor(options) {\n        this.options = options;\n    }\n}\nexport class OutputPosition {\n    constructor(outputLineIndex, outputOffset) {\n        this.outputLineIndex = outputLineIndex;\n        this.outputOffset = outputOffset;\n    }\n    toString() {\n        return `${this.outputLineIndex}:${this.outputOffset}`;\n    }\n    toPosition(baseLineNumber) {\n        return new Position(baseLineNumber + this.outputLineIndex, this.outputOffset + 1);\n    }\n}\n"],"names":["TokenMetadata","metadata","className","this","getForeground","fontStyle","getFontStyle","colorMap","foreground","result","textDecoration","italic","Boolean","bold","underline","strikethrough","score","selector","candidateUri","candidateLanguage","candidateIsSynchronized","candidateNotebookUri","candidateNotebookType","Array","isArray","ret","value","language","pattern","scheme","hasAccessToAllModels","notebookType","Math","max","undefined","normalizedPattern","Object","assign","base","normalize","fsPath","matchGlobPattern","isExclusive","every","exclusive","MatchCandidate","uri","languageId","notebookUri","other","_a","_b","toString","LanguageFeatureRegistry","_notebookInfoResolver","_clock","_entries","_onDidChange","Emitter","onDidChange","event","provider","entry","_score","_time","push","_lastCandidate","fire","length","toDisposable","idx","indexOf","splice","model","all","_updateScores","_orderedForEach","lastBucket","lastBucketScore","callback","notebookInfo","call","candidate","getLanguageId","type","equals","shouldSynchronizeModel","sort","_compareByScoreAndTime","a","b","CompletionItemKinds","InlineCompletionTriggerKind","SignatureHelpTriggerKind","DocumentHighlightKind","SymbolKinds","Token","offset","_tokenBrand","TokenizationResult","tokens","endState","_tokenizationResultBrand","EncodedTokenizationResult","_encodedTokenizationResultBrand","isLocationLink","thing","URI","Range","range","originSelectionRange","targetSelectionRange","byKind","Map","set","Codicon","toIcon","kind","codicon","get","console","info","data","fromString","strict","res","icon","Command","InlayHintKind","FoldingRangeKind","Comment","Imports","Region","is","obj","id","title","TokenizationRegistry","TokenizationRegistryImpl","getPrecedingValidLine","lineNumber","indentRulesSupport","tokenization","getLanguageIdAtPosition","lastLineNumber","resultLineNumber","text","getLineContent","shouldIgnore","test","getInheritIndentForLine","autoIndent","honorIntentialIndent","languageConfigurationService","getLanguageConfiguration","indentation","action","precedingUnIgnoredLine","precedingUnIgnoredLineContent","shouldIncrease","shouldIndentNextLine","strings","IndentAction","line","shouldDecrease","previousLine","previousLineIndentMetadata","getIndentMetadata","stopLine","i","lineContent","j","getGoodIndentForLine","virtualModel","indentConverter","richEditSupport","indent","inheritLine","enterResult","onEnter","removeText","substring","indentAction","shiftIndent","unshiftIndent","appendText","getIndentForEnter","forceTokenization","startLineNumber","beforeEnterText","afterEnterText","lineTokens","getLineTokens","scopedLineTokens","createScopedLineTokens","startColumn","scopedLineText","embeddedLanguage","firstCharOffset","substr","isEmpty","getScopedLineTokens","endLineNumber","endColumn","beforeEnterResult","beforeEnterIndent","column","currentLineIndent","afterEnterAction","beforeEnter","afterEnter","afterEnterIndent","getIndentActionForType","ch","afterTypeText","beforeTypeText","r","getLineCount","getEnterAction","previousLineText","oneLineAboveScopedLineTokens","getIndentationAtPosition","ILanguageService","createDecorator","StandardAutoClosingPairConditional","source","_neutralCharacter","_neutralCharacterSearched","open","close","_inString","_inComment","_inRegEx","notIn","len","standardToken","context","getTokenCount","tokenIndex","findTokenIndexAtOffset","standardTokenType","getStandardTokenType","isOK","fromCharCode","toCharCode","charCode","character","String","includes","_findNeutralCharacterInRange","AutoClosingPairs","autoClosingPairs","autoClosingPairsOpenByStart","autoClosingPairsOpenByEnd","autoClosingPairsCloseByStart","autoClosingPairsCloseByEnd","autoClosingPairsCloseSingleChar","pair","appendEntry","charAt","target","key","has","CharacterPairSupport","config","_autoClosingPairs","map","el","brackets","__electricCharacterSupport","docComment","_autoCloseBefore","autoCloseBefore","DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED","_surroundingPairs","surroundingPairs","BracketElectricCharacterSupport","richEditBrackets","_richEditBrackets","bracket","lastChar","distinct","ignoreBracketsInToken","reversedBracketRegex","reversedRegex","BracketsUtils","bracketText","toLowerCase","textIsOpenBracket","textBeforeBracket","getActualLineContentBefore","matchOpenBracket","resetGlobalRegex","reg","global","lastIndex","IndentRulesSupport","indentationRules","_indentationRules","increaseIndentPattern","decreaseIndentPattern","indentNextLinePattern","unIndentedLinePattern","OnEnterSupport","opts","_brackets","forEach","openRegExp","_createOpenBracketRegExp","closeRegExp","_createCloseBracketRegExp","_regExpRules","onEnterRules","rule","beforeText","afterText","str","_safeRegExp","def","RegExp","err","onUnexpectedError","LanguageBracketsConfiguration","colorizedBracketPairs","filterValidBrackets","filter","p","openingBracketInfos","CachedFunction","closing","Set","OpeningBracketKind","closingBracketInfos","opening","ClosingBracketKind","add","_openingBrackets","cachedValues","_closingBrackets","values","getOpeningBracketInfo","getClosingBracketInfo","bracketPairs","BracketKindBase","openedBrackets","isOpeningBracket","closedBrackets","BugIndicatingError","__decorate","decorators","desc","d","c","arguments","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__param","paramIndex","decorator","LanguageConfigurationServiceChangeEvent","ILanguageConfigurationService","LanguageConfigurationService","configurationService","languageService","_registry","_register","LanguageConfigurationRegistry","onDidChangeEmitter","configurations","languageConfigKeys","customizedLanguageConfigKeys","onDidChangeConfiguration","e","globalConfigChanged","change","keys","some","k","localConfigChanged","overrides","clear","isRegisteredLanguageId","delete","configuration","priority","register","registry","languageConfig","Error","ResolvedLanguageConfiguration","customizedConfig","getValue","overrideIdentifier","validateBracketPairs","getCustomizedLanguageConfig","combineLanguageConfigurations","underlyingConfig","computeConfig","Disposable","IConfigurationService","lineText","columnNumber","getLineMaxColumn","ComposedLanguageConfiguration","_resolved","_order","LanguageConfigurationContribution","_resolve","cmp","configs","comments","wordPattern","folding","order","LanguageConfigurationChangeEvent","PLAINTEXT_LANGUAGE_ID","offSide","entries","disposable","dispose","getResolvedConfiguration","_electricCharacter","_onEnterSupport","_handleComments","characterPair","wordDefinition","DEFAULT_WORD_REGEXP","foldingRules","bracketsNew","ensureValidWordDefinition","RichEditBrackets","getAutoClosingPairs","getAutoCloseBeforeSet","getSurroundingPairs","conf","commentRule","lineComment","lineCommentToken","blockComment","blockStart","blockEnd","blockCommentStartToken","blockCommentEndToken","registerSingleton","Uint8Matrix","rows","cols","defaultValue","Uint8Array","_data","row","col","StateMachine","edges","maxCharCode","maxState","from","chCode","to","states","_states","_maxCharCode","currentState","_stateMachine","getStateMachine","_classifier","getClassifier","CharacterClassifier","FORCE_TERMINATION_CHARACTERS","charCodeAt","CANNOT_END_WITH_CHARACTERS","LinkComputer","classifier","linkBeginIndex","linkEndIndex","lastIncludedCharIndex","charCodeBeforeLink","lastCharCodeInLink","url","stateMachine","lineCount","linkBeginChCode","state","hasOpenParens","hasOpenSquareBracket","inSquareBrackets","hasOpenCurlyBracket","resetStateMachine","chClass","_createLink","nextState","computeLinks","ModesRegistry","_onDidChangeLanguages","onDidChangeLanguages","_languages","Registry","registerLanguage","extensions","aliases","nls","mimetypes","Mimes","ConfigurationExtensions","registerDefaultConfigurations","NullState","nullTokenize","nullTokenizeEncoded","Uint32Array","tokenCount","getCount","desiredLanguageId","lastTokenIndex","firstTokenIndex","ScopedLineTokens","getStartOffset","getEndOffset","actual","lastCharOffset","_scopedLineTokensBrand","_actual","_firstTokenIndex","_lastTokenIndex","_lastCharOffset","BasicInplaceReplace","_defaultValueSet","range1","text1","range2","text2","up","doNavigateValueSet","numberResult","numberReplace","textReplace","precision","pow","lastIndexOf","n1","Number","n2","parseFloat","isNaN","floor","valueSetsReplace","valueSets","valueSetReplace","valueSet","INSTANCE","RichEditBracket","index","forwardRegex","_richEditBracketBrand","_openSet","_toSet","_closeSet","arr","element","_richEditBracketsBrand","N","group","areOverlapping","aOpen","aClose","bOpen","bClose","mergeGroups","g1","g2","newG","min","oldG","g","currentOpen","currentClose","groupFuzzyBrackets","currentIndex","pieces","concat","collectSuperstrings","unique","lengthcmp","reverse","createBracketOrRegExp","getRegexForBracketPair","toReversedString","getReversedRegexForBracketPair","getRegexForBrackets","getReversedRegexForBrackets","textIsBracket","maxBracketLength","dest","seen","prepareBracketForRegExp","insertWordBoundaries","regexStr","join","lastInput","lastOutput","stringBuilder","Uint16Array","decode","resultLen","reversedText","m","match","matchOffset","matchLength","absoluteMatchOffset","startOffset","endOffset","reversedSubstr","_findPrevBracketInText","bracketRegex","findNextBracketInText","ParsedTokenThemeRule","token","background","_parsedThemeRuleBrand","resolveParsedTokenThemeRules","parsedThemeRules","customTokenColors","strcmp","defaultFontStyle","defaultForeground","defaultBackground","incomingDefaults","shift","ColorMap","color","getId","foregroundColorId","backgroundColorId","defaults","ThemeTrieElementRule","root","ThemeTrieElement","insert","TokenTheme","colorRegExp","_lastColorId","_id2color","_color2id","toUpperCase","Color","slice","_colorMap","_root","_cache","getColorMap","_match","tokenType","STANDARD_TOKEN_TYPE_REGEXP","toStandardTokenType","createFromParsedTokenTheme","segments","split","lenJ","parseTokenTheme","_themeTrieElementRuleBrand","_fontStyle","_foreground","_background","mainRule","_themeTrieElementBrand","_mainRule","_children","head","tail","dotIndex","child","clone","acceptOverwrite","generateTokensCSSForColorMap","rules","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","rejected","done","then","apply","fallback","getInitialState","tokenizeEncoded","buffer","hasEOL","tokenizeToString","_tokenizeToString","languageIdCodec","tokenizationSupport","tokenizeLineToHTML","viewLineTokens","tabSize","useNbsp","charIndex","tabsCharDelta","prevIsSpace","tokenEndIndex","partContent","insertSpacesCount","getInlineStyle","lines","tokenizationResult","LineTokens","inflate","getClassName","endIndex","OverviewRulerLane","MinimapPosition","InjectedTextCursorStops","TextModelResolvedOptions","src","_textModelResolvedOptionsBrand","indentSize","insertSpaces","defaultEOL","trimAutoWhitespace","bracketPairColorizationOptions","newOpts","FindMatch","matches","_findMatchBrand","isITextSnapshot","read","ValidAnnotatedEditOperation","identifier","forceMoveMarkers","isAutoWhitespaceEdit","_isTracked","SearchData","regex","wordSeparators","simpleSearch","ApplyEditsResult","reverseEdits","changes","trimAutoWhitespaceLineNumbers","isTooLargeForSyncing","isForSimpleWidget","BracketPairsTree","textModel","didChangeEmitter","denseKeyProvider","DenseKeyProvider","LanguageAgnosticBracketTokens","backgroundTokenizationState","getSingleLanguageBracketTokens","tokenizer","FastTokenizer","initialAstWithoutTokens","parseDocument","astWithTokens","parseDocumentFromTextBuffer","didLanguageChange","wasUndefined","edits","ranges","TextEditInfo","toLength","fromLineNumber","toLineNumber","positionToLength","getStartPosition","getEndPosition","lengthOfString","previousAst","immutable","previousAstClone","TextBufferTokenizer","node","collectBrackets","lengthZero","includeMinIndentation","startLength","endLength","CollectBracketPairsContext","collectBracketPairs","position","getFirstBracketAfter","getFirstBracketBefore","nodeOffsetStart","nodeOffsetEnd","lengths","children","lengthAdd","lengthLessThan","lengthsToRange","bracketInfo","level","levelPerBracketType","lengthLessThanEqual","lengthGreaterThanEqual","levelPerBracket","existing","openingBracket","BracketInfo","closingBracket","openingBracketEnd","minIndentation","computeMinIndentation","BracketPairWithMinIndentationInfo","curOffset","childOffset","BracketPairsTextModelPart","bracketPairsTree","MutableDisposable","bracketsRequested","object","updateBracketPairsTree","getValueLength","handleContentChanged","handleDidChangeBackgroundTokenizationState","handleDidChangeTokens","canBuildAST","store","DisposableStore","getBracketPairsInRange","getBracketsInRange","_bracket","_position","maxDuration","validatePosition","closingBracketInfo","bracketPair","findLast","closes","openingBracketInfo","openingBracketRange","bracketsSupport","stripBracketSearchCanceled","_findMatchingBracketUp","createTimeBasedContinueBracketSearchPredicate","findLastMaxBy","item","closingBracketRange","containsPosition","compareBy","continueSearchPredicate","_matchBracket","modeBrackets","currentLanguageId","searchStartOffset","tokenEndOffset","searchEndOffset","tokenStartOffset","currentModeBrackets","_establishBracketSearchOffsets","bestResult","foundBracket","foundBracketText","_matchFoundBracket","BracketSearchCanceled","prevTokenIndex","prevModeBrackets","isOpen","matched","_findMatchingBracketDown","count","totalCallCount","searchPrevMatchingBracketInRange","hitText","isClose","prevSearchInToken","searchInToken","searchNextMatchingBracketInRange","bracketConfig","tokenLanguageId","_toFoundBracket","strictContainsRange","savedCounts","counts","resetCounts","tmp","searchInRange","getValueInRange","getBracketInfo","startTime","Date","now","_searchCanceledBrand","BaseAstNode","_length","PairAstNode","missingOpeningBracketIds","openBracketIds","intersects","deepClone","MAX_SAFE_INTEGER","SmallImmutableSet","ListAstNode","listHeight","_missingOpeningBracketIds","cachedMinIndentation","throwIfImmutable","childCount","childrenLength","lastChild","getChild","mutable","toMutable","setChild","firstChild","lastLength","canBeReused","unopenedBrackets","merge","item1","item2","item3","missingBracketIds","Immutable23ListAstNode","TwoThreeListAstNode","ImmutableArrayListAstNode","_item1","_item2","_item3","handleChildrenChanged","ArrayListAstNode","pop","unshift","emptyArray","ImmutableLeafAstNode","TextAstNode","_openedBracketIds","start","lengthToObj","columnCount","lengthGetLineCount","firstNonWsColumn","getLineFirstNonWhitespaceColumn","visibleColumn","CursorColumns","getOptions","BracketAstNode","bracketIds","InvalidBracketAstNode","closingBrackets","openedBracketIds","newLength","BeforeEditPositionMapper","documentLength","nextEditIdx","deltaOldToNewLineCount","deltaOldToNewColumnCount","deltaLineIdxInOld","edit","TextEditInfoCache","adjustNextEdit","translateCurToOld","nextEdit","nextChangeOffset","translateOldToCur","offsetObj","lengthDiffNonNegative","oldOffsetObj","newOffset","nextEditEndOffsetInCur","endOffsetAfterObj","nextEditEndOffsetInCurObj","nextEditEndOffsetBeforeInCurObj","endOffsetBeforeObj","lineDelta","previousColumnDelta","columnDelta","textLength","BracketTokens","hasRegExp","_regExpGlobal","escaped","escapeRegExpCharacters","regExpStr","getRegExpStr","openingBracketIds","closingText","size","getKey","openingBrackets","openingTextId","identityKeyProvider","getClosedBrackets","languageIdToBracketTokens","singleLanguageBracketTokens","createFromLanguage","LengthObj","lengthDiff","startLineCount","startColumnCount","endLineCount","endColumnCount","zero","lengthIsZero","factor","l","lengthGetColumnCountIfZeroLineCount","l1","l2","length1","length2","lineCount1","lineCount2","colCount2","lengthStart","lengthEnd","colCount","splitLines","concat23TreesOfSameHeight","items","createImmutableLists","heightDiff","node1","node2","abs","list","nodeToAppend","nodeToAppendOfCorrectHeight","curNode","parents","makeLastElementMutable","parent","unappendChild","appendChildOfSameHeight","append","makeFirstElementMutable","nodeToPrependOfCorrectHeight","unprependChild","prependChildOfSameHeight","prepend","NodeReader","lastOffset","nextNodes","offsets","idxs","predicate","lastOrUndefined","curNodeOffset","nextNodeAfterCurrent","nextChildIdx","getNextChildIdx","currentOffset","currentNode","curIdx","oldNode","Parser","_itemsConstructed","_itemsFromCache","oldNodeReader","positionMapper","parseList","peek","parseChild","readNode","height","first","second","concat23Trees","maxCacheableLength","getDistanceToNextChange","cachedNode","readLongestNodeAt","getOffsetBeforeChange","skip","astNode","nextToken","bracketId","emptyArr","additionalItems","keyProvider","newItem","create","newItems","merged","cached","cache","empty","bracketTokens","reader","NonPeekableTextBufferTokenizer","_offset","didPeek","peeked","textBufferLineCount","textBufferLastLineLength","getLineLength","setPosition","lineIdx","lineCharOffset","lineTokenOffset","peekedToken","startLineIdx","startLineCharOffset","lengthHeuristic","peekedBracketToken","tokenMetadata","getMetadata","isOther","containsBracketType","regexp","regExpGlobal","exec","getToken","curLineCount","lastLineBreakOffset","lastTokenEndOffset","lastTokenEndLine","smallTextTokens0Line","smallTextTokens1Line","NotSupportedError","ColorizedBracketPairsDecorationProvider","colorProvider","ColorProvider","colorizationOptions","ownerId","filterOutValidation","enabled","bracketsInRange","nestingLevel","options","description","inlineClassName","getInlineClassName","independentColorPoolPerBracketType","getDecorationsInRange","unexpectedClosingBracketClassName","isInvalid","getInlineClassNameOfLevel","nestingLevelOfEqualBracketType","registerThemingParticipant","theme","collector","colors","editorBracketHighlightingForeground1","editorBracketHighlightingForeground2","editorBracketHighlightingForeground3","editorBracketHighlightingForeground4","editorBracketHighlightingForeground5","editorBracketHighlightingForeground6","addRule","getColor","editorBracketHighlightingUnexpectedBracketForeground","colorValues","isTransparent","fixBracketsInLine","StaticTokenizerSource","processNode","closingTokenText","findClosingTokenText","uriGetComparisonKey","resource","SingleModelEditStackData","beforeVersionId","afterVersionId","beforeEOL","afterEOL","beforeCursorState","afterCursorState","textChanges","compressConsecutiveTextChanges","necessarySize","_writeSelectionsSize","writeSize","_writeSelections","write","alternativeVersionId","getAlternativeVersionId","eol","getModelEOL","selections","selection","selectionStartLineNumber","selectionStartColumn","positionLineNumber","positionColumn","Selection","_readSelections","changeCount","TextChange","SingleModelEditStackElement","label","code","deserialize","serialize","_applyUndo","_applyRedo","byteLength","MultiModelEditStackElement","editStackElements","_isOpen","_editStackElementsArr","_editStackElementsMap","editStackElement","_delegate","prepareUndoRedo","setModel","canAppend","undo","redo","heapSize","basename","getEOL","isEditStackElement","EditStack","undoRedoService","_model","_undoRedoService","lastElement","getLastElement","removeElements","newElement","pushElement","_getOrCreateEditStackElement","setEOL","editOperations","cursorStateComputer","inverseEditOperations","applyEdits","_computeCursorState","op","textChange","oldPosition","GuidesTextModelPart","lineIndex","computeIndentLevel","minLineNumber","maxLineNumber","assertNotDisposed","up_aboveContentLineIndex","up_aboveContentLineIndent","up_belowContentLineIndex","up_belowContentLineIndent","up_resolveIndents","_computeIndentLevel","down_aboveContentLineIndex","down_aboveContentLineIndent","down_belowContentLineIndex","down_belowContentLineIndent","down_resolveIndents","goUp","goDown","initialIndent","distance","upLineNumber","downLineNumber","upLineIndentLevel","currentIndent","ceil","_getIndentLevelForWhitespaceLine","downLineIndentLevel","activePosition","getBracketPairsInRangeWithMinIndentation","activeBracketPairRange","bracketsContainingActivePosition","bp","BracketPairGuidesClassNames","isActive","equalsRange","includeInactive","highlightActive","activeClassName","end","horizontalGuides","HorizontalGuidesState","endVisibleColumn","getVisibleColumnFromPosition","startVisibleColumn","guideVisibleColumn","minVisibleColumnIndentation","renderHorizontalEndLineAtTheBottom","visibleGuideStartLineNumber","visibleGuideEndLineNumber","IndentGuide","IndentGuideHorizontalLine","aboveContentLineIndex","aboveContentLineIndent","belowContentLineIndex","belowContentLineIndent","resultIndex","TextModelPart","SpacesDiffResult","spacesDiff","looksLikeAlignment","aLength","bLength","aSpacesCnt","aTabsCount","bSpacesCnt","bTabsCount","tabsDiff","guessIndentation","defaultTabSize","defaultInsertSpaces","linesCount","linesIndentedWithTabsCount","linesIndentedWithSpacesCount","previousLineIndentation","spacesDiffCount","currentLineLength","currentLineText","useCurrentLineText","currentLineHasContent","currentLineIndentation","currentLineSpacesCount","currentLineTabsCount","getLineCharCode","currentSpacesDiff","tabSizeScore","possibleTabSize","possibleTabSizeScore","getNodeColor","setNodeColor","getNodeIsVisited","setNodeIsVisited","getNodeIsForValidation","setNodeIsForValidation","_setNodeStickiness","stickiness","setCollapseOnReplaceEdit","IntervalNode","left","right","delta","maxEnd","cachedVersionId","cachedAbsoluteStart","cachedAbsoluteEnd","versionId","collapseOnReplaceEdit","absoluteStart","absoluteEnd","SENTINEL","IntervalTree","requestNormalizeDelta","filterOwnerId","T","intervalStart","intervalEnd","nodeStart","nodeEnd","setCachedOffsets","include","intervalSearch","search","collectNodesFromOwner","collectNodesPostOrder","rbTreeInsert","_normalizeDeltaIfNecessary","rbTreeDelete","initialNode","nodesOfInterest","searchForEditing","editDelta","recomputeMaxEnd","noOverlapReplace","nodeAcceptEdit","normalizeDelta","adjustMarkerBeforeColumn","markerOffset","markerStickToPreviousCharacter","checkOffset","moveSemantics","nodeStickiness","getNodeStickiness","startStickToPreviousCharacter","endStickToPreviousCharacter","deletingCnt","insertingCnt","commonLength","startDone","endDone","getCollapseOnReplaceEdit","deltaColumn","newNode","z","x","zAbsoluteStart","zAbsoluteEnd","intervalCompare","treeInsert","recomputeMaxEndWalkToRoot","y","leftRotate","rightRotate","leftest","detach","resetSentinel","w","yWasRed","computeMaxEnd","leftMaxEnd","rightMaxEnd","aStart","aEnd","bStart","bEnd","ModelLineProjectionData","injectionOffsets","injectionOptions","breakOffsets","breakOffsetsVisibleColumn","wrappedTextIndentLength","outputLineIndex","lineLength","outputOffset","offsetInInput","content","inputOffset","affinity","inputOffsetInInputWithInjection","offsetInInputWithInjectionsToOutputPosition","offsetInInputWithInjections","low","high","mid","midStart","midStop","OutputPosition","outputPositionToOffsetInInputWithInjections","normalizedOffsetInUnwrappedLine","normalizeOffsetInInputWithInjectionsAroundInjections","getMinOutputOffset","getMaxOutputOffset","getOutputLineCount","injectedText","getInjectedTextAtOffset","hasRightCursorStop","injectedTextIndex","cursorStops","hasLeftCursorStop","assertNever","totalInjectedTextLengthBefore","injectedTextStartOffsetInInputWithInjections","injectedTextEndOffsetInInputWithInjections","cursorStop","baseLineNumber","Position"],"sourceRoot":""}