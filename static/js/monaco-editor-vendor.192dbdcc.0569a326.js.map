{"version":3,"file":"static/js/monaco-editor-vendor.192dbdcc.0569a326.js","mappings":"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","sources":["../node_modules/monaco-editor/esm/vs/editor/common/textModelBracketPairs.js","../node_modules/monaco-editor/esm/vs/editor/common/textModelEvents.js","../node_modules/monaco-editor/esm/vs/editor/common/textModelGuides.js","../node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokens.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensEditing.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensStore.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/lineTokens.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseMultilineTokens.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseTokensStore.js","../node_modules/monaco-editor/esm/vs/editor/common/viewEventHandler.js","../node_modules/monaco-editor/esm/vs/editor/common/viewEvents.js","../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/lineDecorations.js","../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/linePart.js","../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLineRenderer.js","../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLinesViewportData.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/minimapTokensColorTracker.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/monospaceLineBreaksComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/overviewZoneManager.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewContext.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelDecorations.js","../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/linesLayout.js","../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLayout.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/modelLineProjection.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelLines.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelImpl.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModelEventDispatcher.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class BracketInfo {\n    constructor(range, \n    /** 0-based level */\n    nestingLevel, nestingLevelOfEqualBracketType, isInvalid) {\n        this.range = range;\n        this.nestingLevel = nestingLevel;\n        this.nestingLevelOfEqualBracketType = nestingLevelOfEqualBracketType;\n        this.isInvalid = isInvalid;\n    }\n}\nexport class BracketPairInfo {\n    constructor(range, openingBracketRange, closingBracketRange, \n    /** 0-based */\n    nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode) {\n        this.range = range;\n        this.openingBracketRange = openingBracketRange;\n        this.closingBracketRange = closingBracketRange;\n        this.nestingLevel = nestingLevel;\n        this.nestingLevelOfEqualBracketType = nestingLevelOfEqualBracketType;\n        this.bracketPairNode = bracketPairNode;\n    }\n    get openingBracketInfo() {\n        return this.bracketPairNode.openingBracket.bracketInfo;\n    }\n}\nexport class BracketPairWithMinIndentationInfo extends BracketPairInfo {\n    constructor(range, openingBracketRange, closingBracketRange, \n    /**\n     * 0-based\n    */\n    nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode, \n    /**\n     * -1 if not requested, otherwise the size of the minimum indentation in the bracket pair in terms of visible columns.\n    */\n    minVisibleColumnIndentation) {\n        super(range, openingBracketRange, closingBracketRange, nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode);\n        this.minVisibleColumnIndentation = minVisibleColumnIndentation;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * An event describing that a model has been reset to a new value.\n * @internal\n */\nexport class ModelRawFlush {\n    constructor() {\n        this.changeType = 1 /* RawContentChangedType.Flush */;\n    }\n}\n/**\n * Represents text injected on a line\n * @internal\n */\nexport class LineInjectedText {\n    constructor(ownerId, lineNumber, column, options, order) {\n        this.ownerId = ownerId;\n        this.lineNumber = lineNumber;\n        this.column = column;\n        this.options = options;\n        this.order = order;\n    }\n    static applyInjectedText(lineText, injectedTexts) {\n        if (!injectedTexts || injectedTexts.length === 0) {\n            return lineText;\n        }\n        let result = '';\n        let lastOriginalOffset = 0;\n        for (const injectedText of injectedTexts) {\n            result += lineText.substring(lastOriginalOffset, injectedText.column - 1);\n            lastOriginalOffset = injectedText.column - 1;\n            result += injectedText.options.content;\n        }\n        result += lineText.substring(lastOriginalOffset);\n        return result;\n    }\n    static fromDecorations(decorations) {\n        const result = [];\n        for (const decoration of decorations) {\n            if (decoration.options.before && decoration.options.before.content.length > 0) {\n                result.push(new LineInjectedText(decoration.ownerId, decoration.range.startLineNumber, decoration.range.startColumn, decoration.options.before, 0));\n            }\n            if (decoration.options.after && decoration.options.after.content.length > 0) {\n                result.push(new LineInjectedText(decoration.ownerId, decoration.range.endLineNumber, decoration.range.endColumn, decoration.options.after, 1));\n            }\n        }\n        result.sort((a, b) => {\n            if (a.lineNumber === b.lineNumber) {\n                if (a.column === b.column) {\n                    return a.order - b.order;\n                }\n                return a.column - b.column;\n            }\n            return a.lineNumber - b.lineNumber;\n        });\n        return result;\n    }\n}\n/**\n * An event describing that a line has changed in a model.\n * @internal\n */\nexport class ModelRawLineChanged {\n    constructor(lineNumber, detail, injectedText) {\n        this.changeType = 2 /* RawContentChangedType.LineChanged */;\n        this.lineNumber = lineNumber;\n        this.detail = detail;\n        this.injectedText = injectedText;\n    }\n}\n/**\n * An event describing that line(s) have been deleted in a model.\n * @internal\n */\nexport class ModelRawLinesDeleted {\n    constructor(fromLineNumber, toLineNumber) {\n        this.changeType = 3 /* RawContentChangedType.LinesDeleted */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n    }\n}\n/**\n * An event describing that line(s) have been inserted in a model.\n * @internal\n */\nexport class ModelRawLinesInserted {\n    constructor(fromLineNumber, toLineNumber, detail, injectedTexts) {\n        this.changeType = 4 /* RawContentChangedType.LinesInserted */;\n        this.injectedTexts = injectedTexts;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n        this.detail = detail;\n    }\n}\n/**\n * An event describing that a model has had its EOL changed.\n * @internal\n */\nexport class ModelRawEOLChanged {\n    constructor() {\n        this.changeType = 5 /* RawContentChangedType.EOLChanged */;\n    }\n}\n/**\n * An event describing a change in the text of a model.\n * @internal\n */\nexport class ModelRawContentChangedEvent {\n    constructor(changes, versionId, isUndoing, isRedoing) {\n        this.changes = changes;\n        this.versionId = versionId;\n        this.isUndoing = isUndoing;\n        this.isRedoing = isRedoing;\n        this.resultingSelection = null;\n    }\n    containsEvent(type) {\n        for (let i = 0, len = this.changes.length; i < len; i++) {\n            const change = this.changes[i];\n            if (change.changeType === type) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static merge(a, b) {\n        const changes = [].concat(a.changes).concat(b.changes);\n        const versionId = b.versionId;\n        const isUndoing = (a.isUndoing || b.isUndoing);\n        const isRedoing = (a.isRedoing || b.isRedoing);\n        return new ModelRawContentChangedEvent(changes, versionId, isUndoing, isRedoing);\n    }\n}\n/**\n * An event describing a change in injected text.\n * @internal\n */\nexport class ModelInjectedTextChangedEvent {\n    constructor(changes) {\n        this.changes = changes;\n    }\n}\n/**\n * @internal\n */\nexport class InternalModelContentChangeEvent {\n    constructor(rawContentChangedEvent, contentChangedEvent) {\n        this.rawContentChangedEvent = rawContentChangedEvent;\n        this.contentChangedEvent = contentChangedEvent;\n    }\n    merge(other) {\n        const rawContentChangedEvent = ModelRawContentChangedEvent.merge(this.rawContentChangedEvent, other.rawContentChangedEvent);\n        const contentChangedEvent = InternalModelContentChangeEvent._mergeChangeEvents(this.contentChangedEvent, other.contentChangedEvent);\n        return new InternalModelContentChangeEvent(rawContentChangedEvent, contentChangedEvent);\n    }\n    static _mergeChangeEvents(a, b) {\n        const changes = [].concat(a.changes).concat(b.changes);\n        const eol = b.eol;\n        const versionId = b.versionId;\n        const isUndoing = (a.isUndoing || b.isUndoing);\n        const isRedoing = (a.isRedoing || b.isRedoing);\n        const isFlush = (a.isFlush || b.isFlush);\n        return {\n            changes: changes,\n            eol: eol,\n            versionId: versionId,\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport var HorizontalGuidesState;\n(function (HorizontalGuidesState) {\n    HorizontalGuidesState[HorizontalGuidesState[\"Disabled\"] = 0] = \"Disabled\";\n    HorizontalGuidesState[HorizontalGuidesState[\"EnabledForActive\"] = 1] = \"EnabledForActive\";\n    HorizontalGuidesState[HorizontalGuidesState[\"Enabled\"] = 2] = \"Enabled\";\n})(HorizontalGuidesState || (HorizontalGuidesState = {}));\nexport class IndentGuide {\n    constructor(visibleColumn, column, className, \n    /**\n     * If set, this indent guide is a horizontal guide (no vertical part).\n     * It starts at visibleColumn and continues until endColumn.\n    */\n    horizontalLine, \n    /**\n     * If set (!= -1), only show this guide for wrapped lines that don't contain this model column, but are after it.\n    */\n    forWrappedLinesAfterColumn, forWrappedLinesBeforeOrAtColumn) {\n        this.visibleColumn = visibleColumn;\n        this.column = column;\n        this.className = className;\n        this.horizontalLine = horizontalLine;\n        this.forWrappedLinesAfterColumn = forWrappedLinesAfterColumn;\n        this.forWrappedLinesBeforeOrAtColumn = forWrappedLinesBeforeOrAtColumn;\n        if ((visibleColumn !== -1) === (column !== -1)) {\n            throw new Error();\n        }\n    }\n}\nexport class IndentGuideHorizontalLine {\n    constructor(top, endColumn) {\n        this.top = top;\n        this.endColumn = endColumn;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Emitter } from '../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../base/common/lifecycle.js';\nexport class TokenizationRegistry {\n    constructor() {\n        this._map = new Map();\n        this._factories = new Map();\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n        this._colorMap = null;\n    }\n    fire(languages) {\n        this._onDidChange.fire({\n            changedLanguages: languages,\n            changedColorMap: false\n        });\n    }\n    register(language, support) {\n        this._map.set(language, support);\n        this.fire([language]);\n        return toDisposable(() => {\n            if (this._map.get(language) !== support) {\n                return;\n            }\n            this._map.delete(language);\n            this.fire([language]);\n        });\n    }\n    registerFactory(languageId, factory) {\n        var _a;\n        (_a = this._factories.get(languageId)) === null || _a === void 0 ? void 0 : _a.dispose();\n        const myData = new TokenizationSupportFactoryData(this, languageId, factory);\n        this._factories.set(languageId, myData);\n        return toDisposable(() => {\n            const v = this._factories.get(languageId);\n            if (!v || v !== myData) {\n                return;\n            }\n            this._factories.delete(languageId);\n            v.dispose();\n        });\n    }\n    getOrCreate(languageId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // check first if the support is already set\n            const tokenizationSupport = this.get(languageId);\n            if (tokenizationSupport) {\n                return tokenizationSupport;\n            }\n            const factory = this._factories.get(languageId);\n            if (!factory || factory.isResolved) {\n                // no factory or factory.resolve already finished\n                return null;\n            }\n            yield factory.resolve();\n            return this.get(languageId);\n        });\n    }\n    get(language) {\n        return (this._map.get(language) || null);\n    }\n    isResolved(languageId) {\n        const tokenizationSupport = this.get(languageId);\n        if (tokenizationSupport) {\n            return true;\n        }\n        const factory = this._factories.get(languageId);\n        if (!factory || factory.isResolved) {\n            return true;\n        }\n        return false;\n    }\n    setColorMap(colorMap) {\n        this._colorMap = colorMap;\n        this._onDidChange.fire({\n            changedLanguages: Array.from(this._map.keys()),\n            changedColorMap: true\n        });\n    }\n    getColorMap() {\n        return this._colorMap;\n    }\n    getDefaultBackground() {\n        if (this._colorMap && this._colorMap.length > 2 /* ColorId.DefaultBackground */) {\n            return this._colorMap[2 /* ColorId.DefaultBackground */];\n        }\n        return null;\n    }\n}\nclass TokenizationSupportFactoryData extends Disposable {\n    constructor(_registry, _languageId, _factory) {\n        super();\n        this._registry = _registry;\n        this._languageId = _languageId;\n        this._factory = _factory;\n        this._isDisposed = false;\n        this._resolvePromise = null;\n        this._isResolved = false;\n    }\n    get isResolved() {\n        return this._isResolved;\n    }\n    dispose() {\n        this._isDisposed = true;\n        super.dispose();\n    }\n    resolve() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this._resolvePromise) {\n                this._resolvePromise = this._create();\n            }\n            return this._resolvePromise;\n        });\n    }\n    _create() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const value = yield Promise.resolve(this._factory.createTokenizationSupport());\n            this._isResolved = true;\n            if (value && !this._isDisposed) {\n                this._register(this._registry.register(this._languageId, value));\n            }\n        });\n    }\n}\n","/**\n * Represents contiguous tokens over a contiguous range of lines.\n */\nexport class ContiguousMultilineTokens {\n    constructor(startLineNumber, tokens) {\n        this._startLineNumber = startLineNumber;\n        this._tokens = tokens;\n    }\n    /**\n     * (Inclusive) start line number for these tokens.\n     */\n    get startLineNumber() {\n        return this._startLineNumber;\n    }\n    /**\n     * (Inclusive) end line number for these tokens.\n     */\n    get endLineNumber() {\n        return this._startLineNumber + this._tokens.length - 1;\n    }\n    /**\n     * @see {@link _tokens}\n     */\n    getLineTokens(lineNumber) {\n        return this._tokens[lineNumber - this._startLineNumber];\n    }\n    appendLineTokens(lineTokens) {\n        this._tokens.push(lineTokens);\n    }\n}\n","import { ContiguousMultilineTokens } from './contiguousMultilineTokens.js';\nexport class ContiguousMultilineTokensBuilder {\n    constructor() {\n        this._tokens = [];\n    }\n    add(lineNumber, lineTokens) {\n        if (this._tokens.length > 0) {\n            const last = this._tokens[this._tokens.length - 1];\n            if (last.endLineNumber + 1 === lineNumber) {\n                // append\n                last.appendLineTokens(lineTokens);\n                return;\n            }\n        }\n        this._tokens.push(new ContiguousMultilineTokens(lineNumber, [lineTokens]));\n    }\n    finalize() {\n        return this._tokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineTokens } from './lineTokens.js';\nexport const EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;\nexport class ContiguousTokensEditing {\n    static deleteBeginning(lineTokens, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        return ContiguousTokensEditing.delete(lineTokens, 0, toChIndex);\n    }\n    static deleteEnding(lineTokens, fromChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const lineTextLength = tokens[tokens.length - 2];\n        return ContiguousTokensEditing.delete(lineTokens, fromChIndex, lineTextLength);\n    }\n    static delete(lineTokens, fromChIndex, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        // special case: deleting everything\n        if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\n            return EMPTY_LINE_TOKENS;\n        }\n        const fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\n        const fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);\n        const fromTokenEndOffset = tokens[fromTokenIndex << 1];\n        if (toChIndex < fromTokenEndOffset) {\n            // the delete range is inside a single token\n            const delta = (toChIndex - fromChIndex);\n            for (let i = fromTokenIndex; i < tokensCount; i++) {\n                tokens[i << 1] -= delta;\n            }\n            return lineTokens;\n        }\n        let dest;\n        let lastEnd;\n        if (fromTokenStartOffset !== fromChIndex) {\n            tokens[fromTokenIndex << 1] = fromChIndex;\n            dest = ((fromTokenIndex + 1) << 1);\n            lastEnd = fromChIndex;\n        }\n        else {\n            dest = (fromTokenIndex << 1);\n            lastEnd = fromTokenStartOffset;\n        }\n        const delta = (toChIndex - fromChIndex);\n        for (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\n            const tokenEndOffset = tokens[tokenIndex << 1] - delta;\n            if (tokenEndOffset > lastEnd) {\n                tokens[dest++] = tokenEndOffset;\n                tokens[dest++] = tokens[(tokenIndex << 1) + 1];\n                lastEnd = tokenEndOffset;\n            }\n        }\n        if (dest === tokens.length) {\n            // nothing to trim\n            return lineTokens;\n        }\n        const tmp = new Uint32Array(dest);\n        tmp.set(tokens.subarray(0, dest), 0);\n        return tmp.buffer;\n    }\n    static append(lineTokens, _otherTokens) {\n        if (_otherTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        if (lineTokens === EMPTY_LINE_TOKENS) {\n            return _otherTokens;\n        }\n        if (lineTokens === null) {\n            return lineTokens;\n        }\n        if (_otherTokens === null) {\n            // cannot determine combined line length...\n            return null;\n        }\n        const myTokens = toUint32Array(lineTokens);\n        const otherTokens = toUint32Array(_otherTokens);\n        const otherTokensCount = (otherTokens.length >>> 1);\n        const result = new Uint32Array(myTokens.length + otherTokens.length);\n        result.set(myTokens, 0);\n        let dest = myTokens.length;\n        const delta = myTokens[myTokens.length - 2];\n        for (let i = 0; i < otherTokensCount; i++) {\n            result[dest++] = otherTokens[(i << 1)] + delta;\n            result[dest++] = otherTokens[(i << 1) + 1];\n        }\n        return result.buffer;\n    }\n    static insert(lineTokens, chIndex, textLength) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            // nothing to do\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        let fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\n        if (fromTokenIndex > 0) {\n            const fromTokenStartOffset = tokens[(fromTokenIndex - 1) << 1];\n            if (fromTokenStartOffset === chIndex) {\n                fromTokenIndex--;\n            }\n        }\n        for (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\n            tokens[tokenIndex << 1] += textLength;\n        }\n        return lineTokens;\n    }\n}\nexport function toUint32Array(arr) {\n    if (arr instanceof Uint32Array) {\n        return arr;\n    }\n    else {\n        return new Uint32Array(arr);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { ContiguousTokensEditing, EMPTY_LINE_TOKENS, toUint32Array } from './contiguousTokensEditing.js';\nimport { LineTokens } from './lineTokens.js';\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\n/**\n * Represents contiguous tokens in a text model.\n */\nexport class ContiguousTokensStore {\n    constructor(languageIdCodec) {\n        this._lineTokens = [];\n        this._len = 0;\n        this._languageIdCodec = languageIdCodec;\n    }\n    flush() {\n        this._lineTokens = [];\n        this._len = 0;\n    }\n    getTokens(topLevelLanguageId, lineIndex, lineText) {\n        let rawLineTokens = null;\n        if (lineIndex < this._len) {\n            rawLineTokens = this._lineTokens[lineIndex];\n        }\n        if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n            return new LineTokens(toUint32Array(rawLineTokens), lineText, this._languageIdCodec);\n        }\n        const lineTokens = new Uint32Array(2);\n        lineTokens[0] = lineText.length;\n        lineTokens[1] = getDefaultMetadata(this._languageIdCodec.encodeLanguageId(topLevelLanguageId));\n        return new LineTokens(lineTokens, lineText, this._languageIdCodec);\n    }\n    static _massageTokens(topLevelLanguageId, lineTextLength, _tokens) {\n        const tokens = _tokens ? toUint32Array(_tokens) : null;\n        if (lineTextLength === 0) {\n            let hasDifferentLanguageId = false;\n            if (tokens && tokens.length > 1) {\n                hasDifferentLanguageId = (TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId);\n            }\n            if (!hasDifferentLanguageId) {\n                return EMPTY_LINE_TOKENS;\n            }\n        }\n        if (!tokens || tokens.length === 0) {\n            const tokens = new Uint32Array(2);\n            tokens[0] = lineTextLength;\n            tokens[1] = getDefaultMetadata(topLevelLanguageId);\n            return tokens.buffer;\n        }\n        // Ensure the last token covers the end of the text\n        tokens[tokens.length - 2] = lineTextLength;\n        if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\n            // Store directly the ArrayBuffer pointer to save an object\n            return tokens.buffer;\n        }\n        return tokens;\n    }\n    _ensureLine(lineIndex) {\n        while (lineIndex >= this._len) {\n            this._lineTokens[this._len] = null;\n            this._len++;\n        }\n    }\n    _deleteLines(start, deleteCount) {\n        if (deleteCount === 0) {\n            return;\n        }\n        if (start + deleteCount > this._len) {\n            deleteCount = this._len - start;\n        }\n        this._lineTokens.splice(start, deleteCount);\n        this._len -= deleteCount;\n    }\n    _insertLines(insertIndex, insertCount) {\n        if (insertCount === 0) {\n            return;\n        }\n        const lineTokens = [];\n        for (let i = 0; i < insertCount; i++) {\n            lineTokens[i] = null;\n        }\n        this._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\n        this._len += insertCount;\n    }\n    setTokens(topLevelLanguageId, lineIndex, lineTextLength, _tokens, checkEquality) {\n        const tokens = ContiguousTokensStore._massageTokens(this._languageIdCodec.encodeLanguageId(topLevelLanguageId), lineTextLength, _tokens);\n        this._ensureLine(lineIndex);\n        const oldTokens = this._lineTokens[lineIndex];\n        this._lineTokens[lineIndex] = tokens;\n        if (checkEquality) {\n            return !ContiguousTokensStore._equals(oldTokens, tokens);\n        }\n        return false;\n    }\n    static _equals(_a, _b) {\n        if (!_a || !_b) {\n            return !_a && !_b;\n        }\n        const a = toUint32Array(_a);\n        const b = toUint32Array(_b);\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    //#region Editing\n    acceptEdit(range, eolCount, firstLineLength) {\n        this._acceptDeleteRange(range);\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n    }\n    _acceptDeleteRange(range) {\n        const firstLineIndex = range.startLineNumber - 1;\n        if (firstLineIndex >= this._len) {\n            return;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            if (range.startColumn === range.endColumn) {\n                // Nothing to delete\n                return;\n            }\n            this._lineTokens[firstLineIndex] = ContiguousTokensEditing.delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n            return;\n        }\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\n        const lastLineIndex = range.endLineNumber - 1;\n        let lastLineTokens = null;\n        if (lastLineIndex < this._len) {\n            lastLineTokens = ContiguousTokensEditing.deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\n        }\n        // Take remaining text on last line and append it to remaining text on first line\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.append(this._lineTokens[firstLineIndex], lastLineTokens);\n        // Delete middle lines\n        this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n    }\n    _acceptInsertText(position, eolCount, firstLineLength) {\n        if (eolCount === 0 && firstLineLength === 0) {\n            // Nothing to insert\n            return;\n        }\n        const lineIndex = position.lineNumber - 1;\n        if (lineIndex >= this._len) {\n            return;\n        }\n        if (eolCount === 0) {\n            // Inserting text on one line\n            this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n            return;\n        }\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[lineIndex], position.column - 1);\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n        this._insertLines(position.lineNumber, eolCount);\n    }\n}\nfunction getDefaultMetadata(topLevelLanguageId) {\n    return ((topLevelLanguageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)\n        | (0 /* StandardTokenType.Other */ << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)\n        | (0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)\n        // If there is no grammar, we just take a guess and try to match brackets.\n        | (1024 /* MetadataConsts.BALANCED_BRACKETS_MASK */)) >>> 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\nexport class LineTokens {\n    constructor(tokens, text, decoder) {\n        this._lineTokensBrand = undefined;\n        this._tokens = tokens;\n        this._tokensCount = (this._tokens.length >>> 1);\n        this._text = text;\n        this._languageIdCodec = decoder;\n    }\n    static createEmpty(lineContent, decoder) {\n        const defaultMetadata = LineTokens.defaultTokenMetadata;\n        const tokens = new Uint32Array(2);\n        tokens[0] = lineContent.length;\n        tokens[1] = defaultMetadata;\n        return new LineTokens(tokens, lineContent, decoder);\n    }\n    equals(other) {\n        if (other instanceof LineTokens) {\n            return this.slicedEquals(other, 0, this._tokensCount);\n        }\n        return false;\n    }\n    slicedEquals(other, sliceFromTokenIndex, sliceTokenCount) {\n        if (this._text !== other._text) {\n            return false;\n        }\n        if (this._tokensCount !== other._tokensCount) {\n            return false;\n        }\n        const from = (sliceFromTokenIndex << 1);\n        const to = from + (sliceTokenCount << 1);\n        for (let i = from; i < to; i++) {\n            if (this._tokens[i] !== other._tokens[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    getLineContent() {\n        return this._text;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getStartOffset(tokenIndex) {\n        if (tokenIndex > 0) {\n            return this._tokens[(tokenIndex - 1) << 1];\n        }\n        return 0;\n    }\n    getMetadata(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return metadata;\n    }\n    getLanguageId(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        const languageId = TokenMetadata.getLanguageId(metadata);\n        return this._languageIdCodec.decodeLanguageId(languageId);\n    }\n    getStandardTokenType(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getTokenType(metadata);\n    }\n    getForeground(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getForeground(metadata);\n    }\n    getClassName(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getClassNameFromMetadata(metadata);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getPresentationFromMetadata(metadata);\n    }\n    getEndOffset(tokenIndex) {\n        return this._tokens[tokenIndex << 1];\n    }\n    /**\n     * Find the token containing offset `offset`.\n     * @param offset The search offset\n     * @return The index of the token containing the offset.\n     */\n    findTokenIndexAtOffset(offset) {\n        return LineTokens.findIndexInTokensArray(this._tokens, offset);\n    }\n    inflate() {\n        return this;\n    }\n    sliceAndInflate(startOffset, endOffset, deltaOffset) {\n        return new SliceLineTokens(this, startOffset, endOffset, deltaOffset);\n    }\n    static convertToEndOffset(tokens, lineTextLength) {\n        const tokenCount = (tokens.length >>> 1);\n        const lastTokenIndex = tokenCount - 1;\n        for (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n            tokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];\n        }\n        tokens[lastTokenIndex << 1] = lineTextLength;\n    }\n    static findIndexInTokensArray(tokens, desiredIndex) {\n        if (tokens.length <= 2) {\n            return 0;\n        }\n        let low = 0;\n        let high = (tokens.length >>> 1) - 1;\n        while (low < high) {\n            const mid = low + Math.floor((high - low) / 2);\n            const endOffset = tokens[(mid << 1)];\n            if (endOffset === desiredIndex) {\n                return mid + 1;\n            }\n            else if (endOffset < desiredIndex) {\n                low = mid + 1;\n            }\n            else if (endOffset > desiredIndex) {\n                high = mid;\n            }\n        }\n        return low;\n    }\n    /**\n     * @pure\n     * @param insertTokens Must be sorted by offset.\n    */\n    withInserted(insertTokens) {\n        if (insertTokens.length === 0) {\n            return this;\n        }\n        let nextOriginalTokenIdx = 0;\n        let nextInsertTokenIdx = 0;\n        let text = '';\n        const newTokens = new Array();\n        let originalEndOffset = 0;\n        while (true) {\n            const nextOriginalTokenEndOffset = nextOriginalTokenIdx < this._tokensCount ? this._tokens[nextOriginalTokenIdx << 1] : -1;\n            const nextInsertToken = nextInsertTokenIdx < insertTokens.length ? insertTokens[nextInsertTokenIdx] : null;\n            if (nextOriginalTokenEndOffset !== -1 && (nextInsertToken === null || nextOriginalTokenEndOffset <= nextInsertToken.offset)) {\n                // original token ends before next insert token\n                text += this._text.substring(originalEndOffset, nextOriginalTokenEndOffset);\n                const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                newTokens.push(text.length, metadata);\n                nextOriginalTokenIdx++;\n                originalEndOffset = nextOriginalTokenEndOffset;\n            }\n            else if (nextInsertToken) {\n                if (nextInsertToken.offset > originalEndOffset) {\n                    // insert token is in the middle of the next token.\n                    text += this._text.substring(originalEndOffset, nextInsertToken.offset);\n                    const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                    newTokens.push(text.length, metadata);\n                    originalEndOffset = nextInsertToken.offset;\n                }\n                text += nextInsertToken.text;\n                newTokens.push(text.length, nextInsertToken.tokenMetadata);\n                nextInsertTokenIdx++;\n            }\n            else {\n                break;\n            }\n        }\n        return new LineTokens(new Uint32Array(newTokens), text, this._languageIdCodec);\n    }\n}\nLineTokens.defaultTokenMetadata = ((0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n    | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n    | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\nclass SliceLineTokens {\n    constructor(source, startOffset, endOffset, deltaOffset) {\n        this._source = source;\n        this._startOffset = startOffset;\n        this._endOffset = endOffset;\n        this._deltaOffset = deltaOffset;\n        this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n        this._tokensCount = 0;\n        for (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n            const tokenStartOffset = source.getStartOffset(i);\n            if (tokenStartOffset >= endOffset) {\n                break;\n            }\n            this._tokensCount++;\n        }\n    }\n    getMetadata(tokenIndex) {\n        return this._source.getMetadata(this._firstTokenIndex + tokenIndex);\n    }\n    getLanguageId(tokenIndex) {\n        return this._source.getLanguageId(this._firstTokenIndex + tokenIndex);\n    }\n    getLineContent() {\n        return this._source.getLineContent().substring(this._startOffset, this._endOffset);\n    }\n    equals(other) {\n        if (other instanceof SliceLineTokens) {\n            return (this._startOffset === other._startOffset\n                && this._endOffset === other._endOffset\n                && this._deltaOffset === other._deltaOffset\n                && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount));\n        }\n        return false;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getForeground(tokenIndex) {\n        return this._source.getForeground(this._firstTokenIndex + tokenIndex);\n    }\n    getEndOffset(tokenIndex) {\n        const tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n        return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n    }\n    getClassName(tokenIndex) {\n        return this._source.getClassName(this._firstTokenIndex + tokenIndex);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        return this._source.getPresentation(this._firstTokenIndex + tokenIndex);\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { countEOL } from '../core/eolCounter.js';\n/**\n * Represents sparse tokens over a contiguous range of lines.\n */\nexport class SparseMultilineTokens {\n    constructor(startLineNumber, tokens) {\n        this._startLineNumber = startLineNumber;\n        this._tokens = tokens;\n        this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();\n    }\n    static create(startLineNumber, tokens) {\n        return new SparseMultilineTokens(startLineNumber, new SparseMultilineTokensStorage(tokens));\n    }\n    /**\n     * (Inclusive) start line number for these tokens.\n     */\n    get startLineNumber() {\n        return this._startLineNumber;\n    }\n    /**\n     * (Inclusive) end line number for these tokens.\n     */\n    get endLineNumber() {\n        return this._endLineNumber;\n    }\n    toString() {\n        return this._tokens.toString(this._startLineNumber);\n    }\n    _updateEndLineNumber() {\n        this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();\n    }\n    isEmpty() {\n        return this._tokens.isEmpty();\n    }\n    getLineTokens(lineNumber) {\n        if (this._startLineNumber <= lineNumber && lineNumber <= this._endLineNumber) {\n            return this._tokens.getLineTokens(lineNumber - this._startLineNumber);\n        }\n        return null;\n    }\n    getRange() {\n        const deltaRange = this._tokens.getRange();\n        if (!deltaRange) {\n            return deltaRange;\n        }\n        return new Range(this._startLineNumber + deltaRange.startLineNumber, deltaRange.startColumn, this._startLineNumber + deltaRange.endLineNumber, deltaRange.endColumn);\n    }\n    removeTokens(range) {\n        const startLineIndex = range.startLineNumber - this._startLineNumber;\n        const endLineIndex = range.endLineNumber - this._startLineNumber;\n        this._startLineNumber += this._tokens.removeTokens(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n        this._updateEndLineNumber();\n    }\n    split(range) {\n        // split tokens to two:\n        // a) all the tokens before `range`\n        // b) all the tokens after `range`\n        const startLineIndex = range.startLineNumber - this._startLineNumber;\n        const endLineIndex = range.endLineNumber - this._startLineNumber;\n        const [a, b, bDeltaLine] = this._tokens.split(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n        return [new SparseMultilineTokens(this._startLineNumber, a), new SparseMultilineTokens(this._startLineNumber + bDeltaLine, b)];\n    }\n    applyEdit(range, text) {\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        this.acceptEdit(range, eolCount, firstLineLength, lastLineLength, text.length > 0 ? text.charCodeAt(0) : 0 /* CharCode.Null */);\n    }\n    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        this._acceptDeleteRange(range);\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength, lastLineLength, firstCharCode);\n        this._updateEndLineNumber();\n    }\n    _acceptDeleteRange(range) {\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n            // Nothing to delete\n            return;\n        }\n        const firstLineIndex = range.startLineNumber - this._startLineNumber;\n        const lastLineIndex = range.endLineNumber - this._startLineNumber;\n        if (lastLineIndex < 0) {\n            // this deletion occurs entirely before this block, so we only need to adjust line numbers\n            const deletedLinesCount = lastLineIndex - firstLineIndex;\n            this._startLineNumber -= deletedLinesCount;\n            return;\n        }\n        const tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();\n        if (firstLineIndex >= tokenMaxDeltaLine + 1) {\n            // this deletion occurs entirely after this block, so there is nothing to do\n            return;\n        }\n        if (firstLineIndex < 0 && lastLineIndex >= tokenMaxDeltaLine + 1) {\n            // this deletion completely encompasses this block\n            this._startLineNumber = 0;\n            this._tokens.clear();\n            return;\n        }\n        if (firstLineIndex < 0) {\n            const deletedBefore = -firstLineIndex;\n            this._startLineNumber -= deletedBefore;\n            this._tokens.acceptDeleteRange(range.startColumn - 1, 0, 0, lastLineIndex, range.endColumn - 1);\n        }\n        else {\n            this._tokens.acceptDeleteRange(0, firstLineIndex, range.startColumn - 1, lastLineIndex, range.endColumn - 1);\n        }\n    }\n    _acceptInsertText(position, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        if (eolCount === 0 && firstLineLength === 0) {\n            // Nothing to insert\n            return;\n        }\n        const lineIndex = position.lineNumber - this._startLineNumber;\n        if (lineIndex < 0) {\n            // this insertion occurs before this block, so we only need to adjust line numbers\n            this._startLineNumber += eolCount;\n            return;\n        }\n        const tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();\n        if (lineIndex >= tokenMaxDeltaLine + 1) {\n            // this insertion occurs after this block, so there is nothing to do\n            return;\n        }\n        this._tokens.acceptInsertText(lineIndex, position.column - 1, eolCount, firstLineLength, lastLineLength, firstCharCode);\n    }\n}\nclass SparseMultilineTokensStorage {\n    constructor(tokens) {\n        this._tokens = tokens;\n        this._tokenCount = tokens.length / 4;\n    }\n    toString(startLineNumber) {\n        const pieces = [];\n        for (let i = 0; i < this._tokenCount; i++) {\n            pieces.push(`(${this._getDeltaLine(i) + startLineNumber},${this._getStartCharacter(i)}-${this._getEndCharacter(i)})`);\n        }\n        return `[${pieces.join(',')}]`;\n    }\n    getMaxDeltaLine() {\n        const tokenCount = this._getTokenCount();\n        if (tokenCount === 0) {\n            return -1;\n        }\n        return this._getDeltaLine(tokenCount - 1);\n    }\n    getRange() {\n        const tokenCount = this._getTokenCount();\n        if (tokenCount === 0) {\n            return null;\n        }\n        const startChar = this._getStartCharacter(0);\n        const maxDeltaLine = this._getDeltaLine(tokenCount - 1);\n        const endChar = this._getEndCharacter(tokenCount - 1);\n        return new Range(0, startChar + 1, maxDeltaLine, endChar + 1);\n    }\n    _getTokenCount() {\n        return this._tokenCount;\n    }\n    _getDeltaLine(tokenIndex) {\n        return this._tokens[4 * tokenIndex];\n    }\n    _getStartCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 1];\n    }\n    _getEndCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 2];\n    }\n    isEmpty() {\n        return (this._getTokenCount() === 0);\n    }\n    getLineTokens(deltaLine) {\n        let low = 0;\n        let high = this._getTokenCount() - 1;\n        while (low < high) {\n            const mid = low + Math.floor((high - low) / 2);\n            const midDeltaLine = this._getDeltaLine(mid);\n            if (midDeltaLine < deltaLine) {\n                low = mid + 1;\n            }\n            else if (midDeltaLine > deltaLine) {\n                high = mid - 1;\n            }\n            else {\n                let min = mid;\n                while (min > low && this._getDeltaLine(min - 1) === deltaLine) {\n                    min--;\n                }\n                let max = mid;\n                while (max < high && this._getDeltaLine(max + 1) === deltaLine) {\n                    max++;\n                }\n                return new SparseLineTokens(this._tokens.subarray(4 * min, 4 * max + 4));\n            }\n        }\n        if (this._getDeltaLine(low) === deltaLine) {\n            return new SparseLineTokens(this._tokens.subarray(4 * low, 4 * low + 4));\n        }\n        return null;\n    }\n    clear() {\n        this._tokenCount = 0;\n    }\n    removeTokens(startDeltaLine, startChar, endDeltaLine, endChar) {\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        let newTokenCount = 0;\n        let hasDeletedTokens = false;\n        let firstDeltaLine = 0;\n        for (let i = 0; i < tokenCount; i++) {\n            const srcOffset = 4 * i;\n            const tokenDeltaLine = tokens[srcOffset];\n            const tokenStartCharacter = tokens[srcOffset + 1];\n            const tokenEndCharacter = tokens[srcOffset + 2];\n            const tokenMetadata = tokens[srcOffset + 3];\n            if ((tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))\n                && (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))) {\n                hasDeletedTokens = true;\n            }\n            else {\n                if (newTokenCount === 0) {\n                    firstDeltaLine = tokenDeltaLine;\n                }\n                if (hasDeletedTokens) {\n                    // must move the token to the left\n                    const destOffset = 4 * newTokenCount;\n                    tokens[destOffset] = tokenDeltaLine - firstDeltaLine;\n                    tokens[destOffset + 1] = tokenStartCharacter;\n                    tokens[destOffset + 2] = tokenEndCharacter;\n                    tokens[destOffset + 3] = tokenMetadata;\n                }\n                newTokenCount++;\n            }\n        }\n        this._tokenCount = newTokenCount;\n        return firstDeltaLine;\n    }\n    split(startDeltaLine, startChar, endDeltaLine, endChar) {\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        const aTokens = [];\n        const bTokens = [];\n        let destTokens = aTokens;\n        let destOffset = 0;\n        let destFirstDeltaLine = 0;\n        for (let i = 0; i < tokenCount; i++) {\n            const srcOffset = 4 * i;\n            const tokenDeltaLine = tokens[srcOffset];\n            const tokenStartCharacter = tokens[srcOffset + 1];\n            const tokenEndCharacter = tokens[srcOffset + 2];\n            const tokenMetadata = tokens[srcOffset + 3];\n            if ((tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))) {\n                if ((tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))) {\n                    // this token is touching the range\n                    continue;\n                }\n                else {\n                    // this token is after the range\n                    if (destTokens !== bTokens) {\n                        // this token is the first token after the range\n                        destTokens = bTokens;\n                        destOffset = 0;\n                        destFirstDeltaLine = tokenDeltaLine;\n                    }\n                }\n            }\n            destTokens[destOffset++] = tokenDeltaLine - destFirstDeltaLine;\n            destTokens[destOffset++] = tokenStartCharacter;\n            destTokens[destOffset++] = tokenEndCharacter;\n            destTokens[destOffset++] = tokenMetadata;\n        }\n        return [new SparseMultilineTokensStorage(new Uint32Array(aTokens)), new SparseMultilineTokensStorage(new Uint32Array(bTokens)), destFirstDeltaLine];\n    }\n    acceptDeleteRange(horizontalShiftForFirstLineTokens, startDeltaLine, startCharacter, endDeltaLine, endCharacter) {\n        // This is a bit complex, here are the cases I used to think about this:\n        //\n        // 1. The token starts before the deletion range\n        // 1a. The token is completely before the deletion range\n        //               -----------\n        //                          xxxxxxxxxxx\n        // 1b. The token starts before, the deletion range ends after the token\n        //               -----------\n        //                      xxxxxxxxxxx\n        // 1c. The token starts before, the deletion range ends precisely with the token\n        //               ---------------\n        //                      xxxxxxxx\n        // 1d. The token starts before, the deletion range is inside the token\n        //               ---------------\n        //                    xxxxx\n        //\n        // 2. The token starts at the same position with the deletion range\n        // 2a. The token starts at the same position, and ends inside the deletion range\n        //               -------\n        //               xxxxxxxxxxx\n        // 2b. The token starts at the same position, and ends at the same position as the deletion range\n        //               ----------\n        //               xxxxxxxxxx\n        // 2c. The token starts at the same position, and ends after the deletion range\n        //               -------------\n        //               xxxxxxx\n        //\n        // 3. The token starts inside the deletion range\n        // 3a. The token is inside the deletion range\n        //                -------\n        //             xxxxxxxxxxxxx\n        // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n        //                ----------\n        //             xxxxxxxxxxxxx\n        // 3c. The token starts inside the deletion range, and ends after the deletion range\n        //                ------------\n        //             xxxxxxxxxxx\n        //\n        // 4. The token starts after the deletion range\n        //                  -----------\n        //          xxxxxxxx\n        //\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        const deletedLineCount = (endDeltaLine - startDeltaLine);\n        let newTokenCount = 0;\n        let hasDeletedTokens = false;\n        for (let i = 0; i < tokenCount; i++) {\n            const srcOffset = 4 * i;\n            let tokenDeltaLine = tokens[srcOffset];\n            let tokenStartCharacter = tokens[srcOffset + 1];\n            let tokenEndCharacter = tokens[srcOffset + 2];\n            const tokenMetadata = tokens[srcOffset + 3];\n            if (tokenDeltaLine < startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter <= startCharacter)) {\n                // 1a. The token is completely before the deletion range\n                // => nothing to do\n                newTokenCount++;\n                continue;\n            }\n            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter < startCharacter) {\n                // 1b, 1c, 1d\n                // => the token survives, but it needs to shrink\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n                    // 1d. The token starts before, the deletion range is inside the token\n                    // => the token shrinks by the deletion character count\n                    tokenEndCharacter -= (endCharacter - startCharacter);\n                }\n                else {\n                    // 1b. The token starts before, the deletion range ends after the token\n                    // 1c. The token starts before, the deletion range ends precisely with the token\n                    // => the token shrinks its ending to the deletion start\n                    tokenEndCharacter = startCharacter;\n                }\n            }\n            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter === startCharacter) {\n                // 2a, 2b, 2c\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n                    // 2c. The token starts at the same position, and ends after the deletion range\n                    // => the token shrinks by the deletion character count\n                    tokenEndCharacter -= (endCharacter - startCharacter);\n                }\n                else {\n                    // 2a. The token starts at the same position, and ends inside the deletion range\n                    // 2b. The token starts at the same position, and ends at the same position as the deletion range\n                    // => the token is deleted\n                    hasDeletedTokens = true;\n                    continue;\n                }\n            }\n            else if (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter < endCharacter)) {\n                // 3a, 3b, 3c\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n                    // 3c. The token starts inside the deletion range, and ends after the deletion range\n                    // => the token moves left and shrinks\n                    if (tokenDeltaLine === startDeltaLine) {\n                        // the deletion started on the same line as the token\n                        // => the token moves left and shrinks\n                        tokenStartCharacter = startCharacter;\n                        tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n                    }\n                    else {\n                        // the deletion started on a line above the token\n                        // => the token moves to the beginning of the line\n                        tokenStartCharacter = 0;\n                        tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n                    }\n                }\n                else {\n                    // 3a. The token is inside the deletion range\n                    // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n                    // => the token is deleted\n                    hasDeletedTokens = true;\n                    continue;\n                }\n            }\n            else if (tokenDeltaLine > endDeltaLine) {\n                // 4. (partial) The token starts after the deletion range, on a line below...\n                if (deletedLineCount === 0 && !hasDeletedTokens) {\n                    // early stop, there is no need to walk all the tokens and do nothing...\n                    newTokenCount = tokenCount;\n                    break;\n                }\n                tokenDeltaLine -= deletedLineCount;\n            }\n            else if (tokenDeltaLine === endDeltaLine && tokenStartCharacter >= endCharacter) {\n                // 4. (continued) The token starts after the deletion range, on the last line where a deletion occurs\n                if (horizontalShiftForFirstLineTokens && tokenDeltaLine === 0) {\n                    tokenStartCharacter += horizontalShiftForFirstLineTokens;\n                    tokenEndCharacter += horizontalShiftForFirstLineTokens;\n                }\n                tokenDeltaLine -= deletedLineCount;\n                tokenStartCharacter -= (endCharacter - startCharacter);\n                tokenEndCharacter -= (endCharacter - startCharacter);\n            }\n            else {\n                throw new Error(`Not possible!`);\n            }\n            const destOffset = 4 * newTokenCount;\n            tokens[destOffset] = tokenDeltaLine;\n            tokens[destOffset + 1] = tokenStartCharacter;\n            tokens[destOffset + 2] = tokenEndCharacter;\n            tokens[destOffset + 3] = tokenMetadata;\n            newTokenCount++;\n        }\n        this._tokenCount = newTokenCount;\n    }\n    acceptInsertText(deltaLine, character, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        // Here are the cases I used to think about this:\n        //\n        // 1. The token is completely before the insertion point\n        //            -----------   |\n        // 2. The token ends precisely at the insertion point\n        //            -----------|\n        // 3. The token contains the insertion point\n        //            -----|------\n        // 4. The token starts precisely at the insertion point\n        //            |-----------\n        // 5. The token is completely after the insertion point\n        //            |   -----------\n        //\n        const isInsertingPreciselyOneWordCharacter = (eolCount === 0\n            && firstLineLength === 1\n            && ((firstCharCode >= 48 /* CharCode.Digit0 */ && firstCharCode <= 57 /* CharCode.Digit9 */)\n                || (firstCharCode >= 65 /* CharCode.A */ && firstCharCode <= 90 /* CharCode.Z */)\n                || (firstCharCode >= 97 /* CharCode.a */ && firstCharCode <= 122 /* CharCode.z */)));\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        for (let i = 0; i < tokenCount; i++) {\n            const offset = 4 * i;\n            let tokenDeltaLine = tokens[offset];\n            let tokenStartCharacter = tokens[offset + 1];\n            let tokenEndCharacter = tokens[offset + 2];\n            if (tokenDeltaLine < deltaLine || (tokenDeltaLine === deltaLine && tokenEndCharacter < character)) {\n                // 1. The token is completely before the insertion point\n                // => nothing to do\n                continue;\n            }\n            else if (tokenDeltaLine === deltaLine && tokenEndCharacter === character) {\n                // 2. The token ends precisely at the insertion point\n                // => expand the end character only if inserting precisely one character that is a word character\n                if (isInsertingPreciselyOneWordCharacter) {\n                    tokenEndCharacter += 1;\n                }\n                else {\n                    continue;\n                }\n            }\n            else if (tokenDeltaLine === deltaLine && tokenStartCharacter < character && character < tokenEndCharacter) {\n                // 3. The token contains the insertion point\n                if (eolCount === 0) {\n                    // => just expand the end character\n                    tokenEndCharacter += firstLineLength;\n                }\n                else {\n                    // => cut off the token\n                    tokenEndCharacter = character;\n                }\n            }\n            else {\n                // 4. or 5.\n                if (tokenDeltaLine === deltaLine && tokenStartCharacter === character) {\n                    // 4. The token starts precisely at the insertion point\n                    // => grow the token (by keeping its start constant) only if inserting precisely one character that is a word character\n                    // => otherwise behave as in case 5.\n                    if (isInsertingPreciselyOneWordCharacter) {\n                        continue;\n                    }\n                }\n                // => the token must move and keep its size constant\n                if (tokenDeltaLine === deltaLine) {\n                    tokenDeltaLine += eolCount;\n                    // this token is on the line where the insertion is taking place\n                    if (eolCount === 0) {\n                        tokenStartCharacter += firstLineLength;\n                        tokenEndCharacter += firstLineLength;\n                    }\n                    else {\n                        const tokenLength = tokenEndCharacter - tokenStartCharacter;\n                        tokenStartCharacter = lastLineLength + (tokenStartCharacter - character);\n                        tokenEndCharacter = tokenStartCharacter + tokenLength;\n                    }\n                }\n                else {\n                    tokenDeltaLine += eolCount;\n                }\n            }\n            tokens[offset] = tokenDeltaLine;\n            tokens[offset + 1] = tokenStartCharacter;\n            tokens[offset + 2] = tokenEndCharacter;\n        }\n    }\n}\nexport class SparseLineTokens {\n    constructor(tokens) {\n        this._tokens = tokens;\n    }\n    getCount() {\n        return this._tokens.length / 4;\n    }\n    getStartCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 1];\n    }\n    getEndCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 2];\n    }\n    getMetadata(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 3];\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { LineTokens } from './lineTokens.js';\n/**\n * Represents sparse tokens in a text model.\n */\nexport class SparseTokensStore {\n    constructor(languageIdCodec) {\n        this._pieces = [];\n        this._isComplete = false;\n        this._languageIdCodec = languageIdCodec;\n    }\n    flush() {\n        this._pieces = [];\n        this._isComplete = false;\n    }\n    isEmpty() {\n        return (this._pieces.length === 0);\n    }\n    set(pieces, isComplete) {\n        this._pieces = pieces || [];\n        this._isComplete = isComplete;\n    }\n    setPartial(_range, pieces) {\n        // console.log(`setPartial ${_range} ${pieces.map(p => p.toString()).join(', ')}`);\n        let range = _range;\n        if (pieces.length > 0) {\n            const _firstRange = pieces[0].getRange();\n            const _lastRange = pieces[pieces.length - 1].getRange();\n            if (!_firstRange || !_lastRange) {\n                return _range;\n            }\n            range = _range.plusRange(_firstRange).plusRange(_lastRange);\n        }\n        let insertPosition = null;\n        for (let i = 0, len = this._pieces.length; i < len; i++) {\n            const piece = this._pieces[i];\n            if (piece.endLineNumber < range.startLineNumber) {\n                // this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // this piece is after the range, so mark the spot before this piece\n                // as a good insertion position and stop looping\n                insertPosition = insertPosition || { index: i };\n                break;\n            }\n            // this piece might intersect with the range\n            piece.removeTokens(range);\n            if (piece.isEmpty()) {\n                // remove the piece if it became empty\n                this._pieces.splice(i, 1);\n                i--;\n                len--;\n                continue;\n            }\n            if (piece.endLineNumber < range.startLineNumber) {\n                // after removal, this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // after removal, this piece is after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            // after removal, this piece contains the range\n            const [a, b] = piece.split(range);\n            if (a.isEmpty()) {\n                // this piece is actually after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            if (b.isEmpty()) {\n                // this piece is actually before the range\n                continue;\n            }\n            this._pieces.splice(i, 1, a, b);\n            i++;\n            len++;\n            insertPosition = insertPosition || { index: i };\n        }\n        insertPosition = insertPosition || { index: this._pieces.length };\n        if (pieces.length > 0) {\n            this._pieces = arrays.arrayInsert(this._pieces, insertPosition.index, pieces);\n        }\n        // console.log(`I HAVE ${this._pieces.length} pieces`);\n        // console.log(`${this._pieces.map(p => p.toString()).join('\\n')}`);\n        return range;\n    }\n    isComplete() {\n        return this._isComplete;\n    }\n    addSparseTokens(lineNumber, aTokens) {\n        if (aTokens.getLineContent().length === 0) {\n            // Don't do anything for empty lines\n            return aTokens;\n        }\n        const pieces = this._pieces;\n        if (pieces.length === 0) {\n            return aTokens;\n        }\n        const pieceIndex = SparseTokensStore._findFirstPieceWithLine(pieces, lineNumber);\n        const bTokens = pieces[pieceIndex].getLineTokens(lineNumber);\n        if (!bTokens) {\n            return aTokens;\n        }\n        const aLen = aTokens.getCount();\n        const bLen = bTokens.getCount();\n        let aIndex = 0;\n        const result = [];\n        let resultLen = 0;\n        let lastEndOffset = 0;\n        const emitToken = (endOffset, metadata) => {\n            if (endOffset === lastEndOffset) {\n                return;\n            }\n            lastEndOffset = endOffset;\n            result[resultLen++] = endOffset;\n            result[resultLen++] = metadata;\n        };\n        for (let bIndex = 0; bIndex < bLen; bIndex++) {\n            const bStartCharacter = bTokens.getStartCharacter(bIndex);\n            const bEndCharacter = bTokens.getEndCharacter(bIndex);\n            const bMetadata = bTokens.getMetadata(bIndex);\n            const bMask = (((bMetadata & 1 /* MetadataConsts.SEMANTIC_USE_ITALIC */) ? 2048 /* MetadataConsts.ITALIC_MASK */ : 0)\n                | ((bMetadata & 2 /* MetadataConsts.SEMANTIC_USE_BOLD */) ? 4096 /* MetadataConsts.BOLD_MASK */ : 0)\n                | ((bMetadata & 4 /* MetadataConsts.SEMANTIC_USE_UNDERLINE */) ? 8192 /* MetadataConsts.UNDERLINE_MASK */ : 0)\n                | ((bMetadata & 8 /* MetadataConsts.SEMANTIC_USE_STRIKETHROUGH */) ? 16384 /* MetadataConsts.STRIKETHROUGH_MASK */ : 0)\n                | ((bMetadata & 16 /* MetadataConsts.SEMANTIC_USE_FOREGROUND */) ? 16744448 /* MetadataConsts.FOREGROUND_MASK */ : 0)\n                | ((bMetadata & 32 /* MetadataConsts.SEMANTIC_USE_BACKGROUND */) ? 4278190080 /* MetadataConsts.BACKGROUND_MASK */ : 0)) >>> 0;\n            const aMask = (~bMask) >>> 0;\n            // push any token from `a` that is before `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n                aIndex++;\n            }\n            // push the token from `a` if it intersects the token from `b`\n            if (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\n                emitToken(bStartCharacter, aTokens.getMetadata(aIndex));\n            }\n            // skip any tokens from `a` that are contained inside `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                aIndex++;\n            }\n            if (aIndex < aLen) {\n                emitToken(bEndCharacter, (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                if (aTokens.getEndOffset(aIndex) === bEndCharacter) {\n                    // `a` ends exactly at the same spot as `b`!\n                    aIndex++;\n                }\n            }\n            else {\n                const aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);\n                // push the token from `b`\n                emitToken(bEndCharacter, (aTokens.getMetadata(aMergeIndex) & aMask) | (bMetadata & bMask));\n            }\n        }\n        // push the remaining tokens from `a`\n        while (aIndex < aLen) {\n            emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n            aIndex++;\n        }\n        return new LineTokens(new Uint32Array(result), aTokens.getLineContent(), this._languageIdCodec);\n    }\n    static _findFirstPieceWithLine(pieces, lineNumber) {\n        let low = 0;\n        let high = pieces.length - 1;\n        while (low < high) {\n            let mid = low + Math.floor((high - low) / 2);\n            if (pieces[mid].endLineNumber < lineNumber) {\n                low = mid + 1;\n            }\n            else if (pieces[mid].startLineNumber > lineNumber) {\n                high = mid - 1;\n            }\n            else {\n                while (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\n                    mid--;\n                }\n                return mid;\n            }\n        }\n        return low;\n    }\n    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        for (const piece of this._pieces) {\n            piece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Disposable } from '../../base/common/lifecycle.js';\nexport class ViewEventHandler extends Disposable {\n    constructor() {\n        super();\n        this._shouldRender = true;\n    }\n    shouldRender() {\n        return this._shouldRender;\n    }\n    forceShouldRender() {\n        this._shouldRender = true;\n    }\n    setShouldRender() {\n        this._shouldRender = true;\n    }\n    onDidRender() {\n        this._shouldRender = false;\n    }\n    // --- begin event handlers\n    onCompositionStart(e) {\n        return false;\n    }\n    onCompositionEnd(e) {\n        return false;\n    }\n    onConfigurationChanged(e) {\n        return false;\n    }\n    onCursorStateChanged(e) {\n        return false;\n    }\n    onDecorationsChanged(e) {\n        return false;\n    }\n    onFlushed(e) {\n        return false;\n    }\n    onFocusChanged(e) {\n        return false;\n    }\n    onLanguageConfigurationChanged(e) {\n        return false;\n    }\n    onLineMappingChanged(e) {\n        return false;\n    }\n    onLinesChanged(e) {\n        return false;\n    }\n    onLinesDeleted(e) {\n        return false;\n    }\n    onLinesInserted(e) {\n        return false;\n    }\n    onRevealRangeRequest(e) {\n        return false;\n    }\n    onScrollChanged(e) {\n        return false;\n    }\n    onThemeChanged(e) {\n        return false;\n    }\n    onTokensChanged(e) {\n        return false;\n    }\n    onTokensColorsChanged(e) {\n        return false;\n    }\n    onZonesChanged(e) {\n        return false;\n    }\n    // --- end event handlers\n    handleEvents(events) {\n        let shouldRender = false;\n        for (let i = 0, len = events.length; i < len; i++) {\n            const e = events[i];\n            switch (e.type) {\n                case 0 /* viewEvents.ViewEventType.ViewCompositionStart */:\n                    if (this.onCompositionStart(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 1 /* viewEvents.ViewEventType.ViewCompositionEnd */:\n                    if (this.onCompositionEnd(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 2 /* viewEvents.ViewEventType.ViewConfigurationChanged */:\n                    if (this.onConfigurationChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 3 /* viewEvents.ViewEventType.ViewCursorStateChanged */:\n                    if (this.onCursorStateChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 4 /* viewEvents.ViewEventType.ViewDecorationsChanged */:\n                    if (this.onDecorationsChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 5 /* viewEvents.ViewEventType.ViewFlushed */:\n                    if (this.onFlushed(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 6 /* viewEvents.ViewEventType.ViewFocusChanged */:\n                    if (this.onFocusChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 7 /* viewEvents.ViewEventType.ViewLanguageConfigurationChanged */:\n                    if (this.onLanguageConfigurationChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 8 /* viewEvents.ViewEventType.ViewLineMappingChanged */:\n                    if (this.onLineMappingChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 9 /* viewEvents.ViewEventType.ViewLinesChanged */:\n                    if (this.onLinesChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 10 /* viewEvents.ViewEventType.ViewLinesDeleted */:\n                    if (this.onLinesDeleted(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 11 /* viewEvents.ViewEventType.ViewLinesInserted */:\n                    if (this.onLinesInserted(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 12 /* viewEvents.ViewEventType.ViewRevealRangeRequest */:\n                    if (this.onRevealRangeRequest(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 13 /* viewEvents.ViewEventType.ViewScrollChanged */:\n                    if (this.onScrollChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 15 /* viewEvents.ViewEventType.ViewTokensChanged */:\n                    if (this.onTokensChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 14 /* viewEvents.ViewEventType.ViewThemeChanged */:\n                    if (this.onThemeChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 16 /* viewEvents.ViewEventType.ViewTokensColorsChanged */:\n                    if (this.onTokensColorsChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 17 /* viewEvents.ViewEventType.ViewZonesChanged */:\n                    if (this.onZonesChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                default:\n                    console.info('View received unknown event: ');\n                    console.info(e);\n            }\n        }\n        if (shouldRender) {\n            this._shouldRender = true;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class ViewCompositionStartEvent {\n    constructor() {\n        this.type = 0 /* ViewEventType.ViewCompositionStart */;\n    }\n}\nexport class ViewCompositionEndEvent {\n    constructor() {\n        this.type = 1 /* ViewEventType.ViewCompositionEnd */;\n    }\n}\nexport class ViewConfigurationChangedEvent {\n    constructor(source) {\n        this.type = 2 /* ViewEventType.ViewConfigurationChanged */;\n        this._source = source;\n    }\n    hasChanged(id) {\n        return this._source.hasChanged(id);\n    }\n}\nexport class ViewCursorStateChangedEvent {\n    constructor(selections, modelSelections) {\n        this.type = 3 /* ViewEventType.ViewCursorStateChanged */;\n        this.selections = selections;\n        this.modelSelections = modelSelections;\n    }\n}\nexport class ViewDecorationsChangedEvent {\n    constructor(source) {\n        this.type = 4 /* ViewEventType.ViewDecorationsChanged */;\n        if (source) {\n            this.affectsMinimap = source.affectsMinimap;\n            this.affectsOverviewRuler = source.affectsOverviewRuler;\n        }\n        else {\n            this.affectsMinimap = true;\n            this.affectsOverviewRuler = true;\n        }\n    }\n}\nexport class ViewFlushedEvent {\n    constructor() {\n        this.type = 5 /* ViewEventType.ViewFlushed */;\n        // Nothing to do\n    }\n}\nexport class ViewFocusChangedEvent {\n    constructor(isFocused) {\n        this.type = 6 /* ViewEventType.ViewFocusChanged */;\n        this.isFocused = isFocused;\n    }\n}\nexport class ViewLanguageConfigurationEvent {\n    constructor() {\n        this.type = 7 /* ViewEventType.ViewLanguageConfigurationChanged */;\n    }\n}\nexport class ViewLineMappingChangedEvent {\n    constructor() {\n        this.type = 8 /* ViewEventType.ViewLineMappingChanged */;\n        // Nothing to do\n    }\n}\nexport class ViewLinesChangedEvent {\n    constructor(\n    /**\n     * The first line that has changed.\n     */\n    fromLineNumber, \n    /**\n     * The number of lines that have changed.\n     */\n    count) {\n        this.fromLineNumber = fromLineNumber;\n        this.count = count;\n        this.type = 9 /* ViewEventType.ViewLinesChanged */;\n    }\n}\nexport class ViewLinesDeletedEvent {\n    constructor(fromLineNumber, toLineNumber) {\n        this.type = 10 /* ViewEventType.ViewLinesDeleted */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n    }\n}\nexport class ViewLinesInsertedEvent {\n    constructor(fromLineNumber, toLineNumber) {\n        this.type = 11 /* ViewEventType.ViewLinesInserted */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n    }\n}\nexport class ViewRevealRangeRequestEvent {\n    constructor(\n    /**\n     * Source of the call that caused the event.\n     */\n    source, \n    /**\n     * Reduce the revealing to a minimum (e.g. avoid scrolling if the bounding box is visible and near the viewport edge).\n     */\n    minimalReveal, \n    /**\n     * Range to be reavealed.\n     */\n    range, \n    /**\n     * Selections to be revealed.\n     */\n    selections, \n    /**\n     * The vertical reveal strategy.\n     */\n    verticalType, \n    /**\n     * If true: there should be a horizontal & vertical revealing.\n     * If false: there should be just a vertical revealing.\n     */\n    revealHorizontal, \n    /**\n     * The scroll type.\n     */\n    scrollType) {\n        this.source = source;\n        this.minimalReveal = minimalReveal;\n        this.range = range;\n        this.selections = selections;\n        this.verticalType = verticalType;\n        this.revealHorizontal = revealHorizontal;\n        this.scrollType = scrollType;\n        this.type = 12 /* ViewEventType.ViewRevealRangeRequest */;\n    }\n}\nexport class ViewScrollChangedEvent {\n    constructor(source) {\n        this.type = 13 /* ViewEventType.ViewScrollChanged */;\n        this.scrollWidth = source.scrollWidth;\n        this.scrollLeft = source.scrollLeft;\n        this.scrollHeight = source.scrollHeight;\n        this.scrollTop = source.scrollTop;\n        this.scrollWidthChanged = source.scrollWidthChanged;\n        this.scrollLeftChanged = source.scrollLeftChanged;\n        this.scrollHeightChanged = source.scrollHeightChanged;\n        this.scrollTopChanged = source.scrollTopChanged;\n    }\n}\nexport class ViewThemeChangedEvent {\n    constructor(theme) {\n        this.theme = theme;\n        this.type = 14 /* ViewEventType.ViewThemeChanged */;\n    }\n}\nexport class ViewTokensChangedEvent {\n    constructor(ranges) {\n        this.type = 15 /* ViewEventType.ViewTokensChanged */;\n        this.ranges = ranges;\n    }\n}\nexport class ViewTokensColorsChangedEvent {\n    constructor() {\n        this.type = 16 /* ViewEventType.ViewTokensColorsChanged */;\n        // Nothing to do\n    }\n}\nexport class ViewZonesChangedEvent {\n    constructor() {\n        this.type = 17 /* ViewEventType.ViewZonesChanged */;\n        // Nothing to do\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nexport class LineDecoration {\n    constructor(startColumn, endColumn, className, type) {\n        this.startColumn = startColumn;\n        this.endColumn = endColumn;\n        this.className = className;\n        this.type = type;\n        this._lineDecorationBrand = undefined;\n    }\n    static _equals(a, b) {\n        return (a.startColumn === b.startColumn\n            && a.endColumn === b.endColumn\n            && a.className === b.className\n            && a.type === b.type);\n    }\n    static equalsArr(a, b) {\n        const aLen = a.length;\n        const bLen = b.length;\n        if (aLen !== bLen) {\n            return false;\n        }\n        for (let i = 0; i < aLen; i++) {\n            if (!LineDecoration._equals(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static extractWrapped(arr, startOffset, endOffset) {\n        if (arr.length === 0) {\n            return arr;\n        }\n        const startColumn = startOffset + 1;\n        const endColumn = endOffset + 1;\n        const lineLength = endOffset - startOffset;\n        const r = [];\n        let rLength = 0;\n        for (const dec of arr) {\n            if (dec.endColumn <= startColumn || dec.startColumn >= endColumn) {\n                continue;\n            }\n            r[rLength++] = new LineDecoration(Math.max(1, dec.startColumn - startColumn + 1), Math.min(lineLength + 1, dec.endColumn - startColumn + 1), dec.className, dec.type);\n        }\n        return r;\n    }\n    static filter(lineDecorations, lineNumber, minLineColumn, maxLineColumn) {\n        if (lineDecorations.length === 0) {\n            return [];\n        }\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = lineDecorations.length; i < len; i++) {\n            const d = lineDecorations[i];\n            const range = d.range;\n            if (range.endLineNumber < lineNumber || range.startLineNumber > lineNumber) {\n                // Ignore decorations that sit outside this line\n                continue;\n            }\n            if (range.isEmpty() && (d.type === 0 /* InlineDecorationType.Regular */ || d.type === 3 /* InlineDecorationType.RegularAffectingLetterSpacing */)) {\n                // Ignore empty range decorations\n                continue;\n            }\n            const startColumn = (range.startLineNumber === lineNumber ? range.startColumn : minLineColumn);\n            const endColumn = (range.endLineNumber === lineNumber ? range.endColumn : maxLineColumn);\n            result[resultLen++] = new LineDecoration(startColumn, endColumn, d.inlineClassName, d.type);\n        }\n        return result;\n    }\n    static _typeCompare(a, b) {\n        const ORDER = [2, 0, 1, 3];\n        return ORDER[a] - ORDER[b];\n    }\n    static compare(a, b) {\n        if (a.startColumn !== b.startColumn) {\n            return a.startColumn - b.startColumn;\n        }\n        if (a.endColumn !== b.endColumn) {\n            return a.endColumn - b.endColumn;\n        }\n        const typeCmp = LineDecoration._typeCompare(a.type, b.type);\n        if (typeCmp !== 0) {\n            return typeCmp;\n        }\n        if (a.className !== b.className) {\n            return a.className < b.className ? -1 : 1;\n        }\n        return 0;\n    }\n}\nexport class DecorationSegment {\n    constructor(startOffset, endOffset, className, metadata) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.className = className;\n        this.metadata = metadata;\n    }\n}\nclass Stack {\n    constructor() {\n        this.stopOffsets = [];\n        this.classNames = [];\n        this.metadata = [];\n        this.count = 0;\n    }\n    static _metadata(metadata) {\n        let result = 0;\n        for (let i = 0, len = metadata.length; i < len; i++) {\n            result |= metadata[i];\n        }\n        return result;\n    }\n    consumeLowerThan(maxStopOffset, nextStartOffset, result) {\n        while (this.count > 0 && this.stopOffsets[0] < maxStopOffset) {\n            let i = 0;\n            // Take all equal stopping offsets\n            while (i + 1 < this.count && this.stopOffsets[i] === this.stopOffsets[i + 1]) {\n                i++;\n            }\n            // Basically we are consuming the first i + 1 elements of the stack\n            result.push(new DecorationSegment(nextStartOffset, this.stopOffsets[i], this.classNames.join(' '), Stack._metadata(this.metadata)));\n            nextStartOffset = this.stopOffsets[i] + 1;\n            // Consume them\n            this.stopOffsets.splice(0, i + 1);\n            this.classNames.splice(0, i + 1);\n            this.metadata.splice(0, i + 1);\n            this.count -= (i + 1);\n        }\n        if (this.count > 0 && nextStartOffset < maxStopOffset) {\n            result.push(new DecorationSegment(nextStartOffset, maxStopOffset - 1, this.classNames.join(' '), Stack._metadata(this.metadata)));\n            nextStartOffset = maxStopOffset;\n        }\n        return nextStartOffset;\n    }\n    insert(stopOffset, className, metadata) {\n        if (this.count === 0 || this.stopOffsets[this.count - 1] <= stopOffset) {\n            // Insert at the end\n            this.stopOffsets.push(stopOffset);\n            this.classNames.push(className);\n            this.metadata.push(metadata);\n        }\n        else {\n            // Find the insertion position for `stopOffset`\n            for (let i = 0; i < this.count; i++) {\n                if (this.stopOffsets[i] >= stopOffset) {\n                    this.stopOffsets.splice(i, 0, stopOffset);\n                    this.classNames.splice(i, 0, className);\n                    this.metadata.splice(i, 0, metadata);\n                    break;\n                }\n            }\n        }\n        this.count++;\n        return;\n    }\n}\nexport class LineDecorationsNormalizer {\n    /**\n     * Normalize line decorations. Overlapping decorations will generate multiple segments\n     */\n    static normalize(lineContent, lineDecorations) {\n        if (lineDecorations.length === 0) {\n            return [];\n        }\n        const result = [];\n        const stack = new Stack();\n        let nextStartOffset = 0;\n        for (let i = 0, len = lineDecorations.length; i < len; i++) {\n            const d = lineDecorations[i];\n            let startColumn = d.startColumn;\n            let endColumn = d.endColumn;\n            const className = d.className;\n            const metadata = (d.type === 1 /* InlineDecorationType.Before */\n                ? 2 /* LinePartMetadata.PSEUDO_BEFORE */\n                : d.type === 2 /* InlineDecorationType.After */\n                    ? 4 /* LinePartMetadata.PSEUDO_AFTER */\n                    : 0);\n            // If the position would end up in the middle of a high-low surrogate pair, we move it to before the pair\n            if (startColumn > 1) {\n                const charCodeBefore = lineContent.charCodeAt(startColumn - 2);\n                if (strings.isHighSurrogate(charCodeBefore)) {\n                    startColumn--;\n                }\n            }\n            if (endColumn > 1) {\n                const charCodeBefore = lineContent.charCodeAt(endColumn - 2);\n                if (strings.isHighSurrogate(charCodeBefore)) {\n                    endColumn--;\n                }\n            }\n            const currentStartOffset = startColumn - 1;\n            const currentEndOffset = endColumn - 2;\n            nextStartOffset = stack.consumeLowerThan(currentStartOffset, nextStartOffset, result);\n            if (stack.count === 0) {\n                nextStartOffset = currentStartOffset;\n            }\n            stack.insert(currentEndOffset, className, metadata);\n        }\n        stack.consumeLowerThan(1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */, nextStartOffset, result);\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class LinePart {\n    constructor(\n    /**\n     * last char index of this token (not inclusive).\n     */\n    endIndex, type, metadata, containsRTL) {\n        this.endIndex = endIndex;\n        this.type = type;\n        this.metadata = metadata;\n        this.containsRTL = containsRTL;\n        this._linePartBrand = undefined;\n    }\n    isWhitespace() {\n        return (this.metadata & 1 /* LinePartMetadata.IS_WHITESPACE_MASK */ ? true : false);\n    }\n    isPseudoAfter() {\n        return (this.metadata & 4 /* LinePartMetadata.PSEUDO_AFTER_MASK */ ? true : false);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { createStringBuilder } from '../core/stringBuilder.js';\nimport { LineDecoration, LineDecorationsNormalizer } from './lineDecorations.js';\nimport { LinePart } from './linePart.js';\nexport class LineRange {\n    constructor(startIndex, endIndex) {\n        this.startOffset = startIndex;\n        this.endOffset = endIndex;\n    }\n    equals(otherLineRange) {\n        return this.startOffset === otherLineRange.startOffset\n            && this.endOffset === otherLineRange.endOffset;\n    }\n}\nexport class RenderLineInput {\n    constructor(useMonospaceOptimizations, canUseHalfwidthRightwardsArrow, lineContent, continuesWithWrappedLine, isBasicASCII, containsRTL, fauxIndentLength, lineTokens, lineDecorations, tabSize, startVisibleColumn, spaceWidth, middotWidth, wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, selectionsOnLine) {\n        this.useMonospaceOptimizations = useMonospaceOptimizations;\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n        this.lineContent = lineContent;\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\n        this.isBasicASCII = isBasicASCII;\n        this.containsRTL = containsRTL;\n        this.fauxIndentLength = fauxIndentLength;\n        this.lineTokens = lineTokens;\n        this.lineDecorations = lineDecorations.sort(LineDecoration.compare);\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n        this.spaceWidth = spaceWidth;\n        this.stopRenderingLineAfter = stopRenderingLineAfter;\n        this.renderWhitespace = (renderWhitespace === 'all'\n            ? 4 /* RenderWhitespace.All */\n            : renderWhitespace === 'boundary'\n                ? 1 /* RenderWhitespace.Boundary */\n                : renderWhitespace === 'selection'\n                    ? 2 /* RenderWhitespace.Selection */\n                    : renderWhitespace === 'trailing'\n                        ? 3 /* RenderWhitespace.Trailing */\n                        : 0 /* RenderWhitespace.None */);\n        this.renderControlCharacters = renderControlCharacters;\n        this.fontLigatures = fontLigatures;\n        this.selectionsOnLine = selectionsOnLine && selectionsOnLine.sort((a, b) => a.startOffset < b.startOffset ? -1 : 1);\n        const wsmiddotDiff = Math.abs(wsmiddotWidth - spaceWidth);\n        const middotDiff = Math.abs(middotWidth - spaceWidth);\n        if (wsmiddotDiff < middotDiff) {\n            this.renderSpaceWidth = wsmiddotWidth;\n            this.renderSpaceCharCode = 0x2E31; // U+2E31 - WORD SEPARATOR MIDDLE DOT\n        }\n        else {\n            this.renderSpaceWidth = middotWidth;\n            this.renderSpaceCharCode = 0xB7; // U+00B7 - MIDDLE DOT\n        }\n    }\n    sameSelection(otherSelections) {\n        if (this.selectionsOnLine === null) {\n            return otherSelections === null;\n        }\n        if (otherSelections === null) {\n            return false;\n        }\n        if (otherSelections.length !== this.selectionsOnLine.length) {\n            return false;\n        }\n        for (let i = 0; i < this.selectionsOnLine.length; i++) {\n            if (!this.selectionsOnLine[i].equals(otherSelections[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    equals(other) {\n        return (this.useMonospaceOptimizations === other.useMonospaceOptimizations\n            && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow\n            && this.lineContent === other.lineContent\n            && this.continuesWithWrappedLine === other.continuesWithWrappedLine\n            && this.isBasicASCII === other.isBasicASCII\n            && this.containsRTL === other.containsRTL\n            && this.fauxIndentLength === other.fauxIndentLength\n            && this.tabSize === other.tabSize\n            && this.startVisibleColumn === other.startVisibleColumn\n            && this.spaceWidth === other.spaceWidth\n            && this.renderSpaceWidth === other.renderSpaceWidth\n            && this.renderSpaceCharCode === other.renderSpaceCharCode\n            && this.stopRenderingLineAfter === other.stopRenderingLineAfter\n            && this.renderWhitespace === other.renderWhitespace\n            && this.renderControlCharacters === other.renderControlCharacters\n            && this.fontLigatures === other.fontLigatures\n            && LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations)\n            && this.lineTokens.equals(other.lineTokens)\n            && this.sameSelection(other.selectionsOnLine));\n    }\n}\nexport class DomPosition {\n    constructor(partIndex, charIndex) {\n        this.partIndex = partIndex;\n        this.charIndex = charIndex;\n    }\n}\n/**\n * Provides a both direction mapping between a line's character and its rendered position.\n */\nexport class CharacterMapping {\n    constructor(length, partCount) {\n        this.length = length;\n        this._data = new Uint32Array(this.length);\n        this._horizontalOffset = new Uint32Array(this.length);\n    }\n    static getPartIndex(partData) {\n        return (partData & 4294901760 /* CharacterMappingConstants.PART_INDEX_MASK */) >>> 16 /* CharacterMappingConstants.PART_INDEX_OFFSET */;\n    }\n    static getCharIndex(partData) {\n        return (partData & 65535 /* CharacterMappingConstants.CHAR_INDEX_MASK */) >>> 0 /* CharacterMappingConstants.CHAR_INDEX_OFFSET */;\n    }\n    setColumnInfo(column, partIndex, charIndex, horizontalOffset) {\n        const partData = ((partIndex << 16 /* CharacterMappingConstants.PART_INDEX_OFFSET */)\n            | (charIndex << 0 /* CharacterMappingConstants.CHAR_INDEX_OFFSET */)) >>> 0;\n        this._data[column - 1] = partData;\n        this._horizontalOffset[column - 1] = horizontalOffset;\n    }\n    getHorizontalOffset(column) {\n        if (this._horizontalOffset.length === 0) {\n            // No characters on this line\n            return 0;\n        }\n        return this._horizontalOffset[column - 1];\n    }\n    charOffsetToPartData(charOffset) {\n        if (this.length === 0) {\n            return 0;\n        }\n        if (charOffset < 0) {\n            return this._data[0];\n        }\n        if (charOffset >= this.length) {\n            return this._data[this.length - 1];\n        }\n        return this._data[charOffset];\n    }\n    getDomPosition(column) {\n        const partData = this.charOffsetToPartData(column - 1);\n        const partIndex = CharacterMapping.getPartIndex(partData);\n        const charIndex = CharacterMapping.getCharIndex(partData);\n        return new DomPosition(partIndex, charIndex);\n    }\n    getColumn(domPosition, partLength) {\n        const charOffset = this.partDataToCharOffset(domPosition.partIndex, partLength, domPosition.charIndex);\n        return charOffset + 1;\n    }\n    partDataToCharOffset(partIndex, partLength, charIndex) {\n        if (this.length === 0) {\n            return 0;\n        }\n        const searchEntry = ((partIndex << 16 /* CharacterMappingConstants.PART_INDEX_OFFSET */)\n            | (charIndex << 0 /* CharacterMappingConstants.CHAR_INDEX_OFFSET */)) >>> 0;\n        let min = 0;\n        let max = this.length - 1;\n        while (min + 1 < max) {\n            const mid = ((min + max) >>> 1);\n            const midEntry = this._data[mid];\n            if (midEntry === searchEntry) {\n                return mid;\n            }\n            else if (midEntry > searchEntry) {\n                max = mid;\n            }\n            else {\n                min = mid;\n            }\n        }\n        if (min === max) {\n            return min;\n        }\n        const minEntry = this._data[min];\n        const maxEntry = this._data[max];\n        if (minEntry === searchEntry) {\n            return min;\n        }\n        if (maxEntry === searchEntry) {\n            return max;\n        }\n        const minPartIndex = CharacterMapping.getPartIndex(minEntry);\n        const minCharIndex = CharacterMapping.getCharIndex(minEntry);\n        const maxPartIndex = CharacterMapping.getPartIndex(maxEntry);\n        let maxCharIndex;\n        if (minPartIndex !== maxPartIndex) {\n            // sitting between parts\n            maxCharIndex = partLength;\n        }\n        else {\n            maxCharIndex = CharacterMapping.getCharIndex(maxEntry);\n        }\n        const minEntryDistance = charIndex - minCharIndex;\n        const maxEntryDistance = maxCharIndex - charIndex;\n        if (minEntryDistance <= maxEntryDistance) {\n            return min;\n        }\n        return max;\n    }\n}\nexport class RenderLineOutput {\n    constructor(characterMapping, containsRTL, containsForeignElements) {\n        this._renderLineOutputBrand = undefined;\n        this.characterMapping = characterMapping;\n        this.containsRTL = containsRTL;\n        this.containsForeignElements = containsForeignElements;\n    }\n}\nexport function renderViewLine(input, sb) {\n    if (input.lineContent.length === 0) {\n        if (input.lineDecorations.length > 0) {\n            // This line is empty, but it contains inline decorations\n            sb.appendASCIIString(`<span>`);\n            let beforeCount = 0;\n            let afterCount = 0;\n            let containsForeignElements = 0 /* ForeignElementType.None */;\n            for (const lineDecoration of input.lineDecorations) {\n                if (lineDecoration.type === 1 /* InlineDecorationType.Before */ || lineDecoration.type === 2 /* InlineDecorationType.After */) {\n                    sb.appendASCIIString(`<span class=\"`);\n                    sb.appendASCIIString(lineDecoration.className);\n                    sb.appendASCIIString(`\"></span>`);\n                    if (lineDecoration.type === 1 /* InlineDecorationType.Before */) {\n                        containsForeignElements |= 1 /* ForeignElementType.Before */;\n                        beforeCount++;\n                    }\n                    if (lineDecoration.type === 2 /* InlineDecorationType.After */) {\n                        containsForeignElements |= 2 /* ForeignElementType.After */;\n                        afterCount++;\n                    }\n                }\n            }\n            sb.appendASCIIString(`</span>`);\n            const characterMapping = new CharacterMapping(1, beforeCount + afterCount);\n            characterMapping.setColumnInfo(1, beforeCount, 0, 0);\n            return new RenderLineOutput(characterMapping, false, containsForeignElements);\n        }\n        // completely empty line\n        sb.appendASCIIString('<span><span></span></span>');\n        return new RenderLineOutput(new CharacterMapping(0, 0), false, 0 /* ForeignElementType.None */);\n    }\n    return _renderLine(resolveRenderLineInput(input), sb);\n}\nexport class RenderLineOutput2 {\n    constructor(characterMapping, html, containsRTL, containsForeignElements) {\n        this.characterMapping = characterMapping;\n        this.html = html;\n        this.containsRTL = containsRTL;\n        this.containsForeignElements = containsForeignElements;\n    }\n}\nexport function renderViewLine2(input) {\n    const sb = createStringBuilder(10000);\n    const out = renderViewLine(input, sb);\n    return new RenderLineOutput2(out.characterMapping, sb.build(), out.containsRTL, out.containsForeignElements);\n}\nclass ResolvedRenderLineInput {\n    constructor(fontIsMonospace, canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, parts, containsForeignElements, fauxIndentLength, tabSize, startVisibleColumn, containsRTL, spaceWidth, renderSpaceCharCode, renderWhitespace, renderControlCharacters) {\n        this.fontIsMonospace = fontIsMonospace;\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n        this.lineContent = lineContent;\n        this.len = len;\n        this.isOverflowing = isOverflowing;\n        this.parts = parts;\n        this.containsForeignElements = containsForeignElements;\n        this.fauxIndentLength = fauxIndentLength;\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n        this.containsRTL = containsRTL;\n        this.spaceWidth = spaceWidth;\n        this.renderSpaceCharCode = renderSpaceCharCode;\n        this.renderWhitespace = renderWhitespace;\n        this.renderControlCharacters = renderControlCharacters;\n        //\n    }\n}\nfunction resolveRenderLineInput(input) {\n    const lineContent = input.lineContent;\n    let isOverflowing;\n    let len;\n    if (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {\n        isOverflowing = true;\n        len = input.stopRenderingLineAfter;\n    }\n    else {\n        isOverflowing = false;\n        len = lineContent.length;\n    }\n    let tokens = transformAndRemoveOverflowing(lineContent, input.containsRTL, input.lineTokens, input.fauxIndentLength, len);\n    if (input.renderControlCharacters && !input.isBasicASCII) {\n        // Calling `extractControlCharacters` before adding (possibly empty) line parts\n        // for inline decorations. `extractControlCharacters` removes empty line parts.\n        tokens = extractControlCharacters(lineContent, tokens);\n    }\n    if (input.renderWhitespace === 4 /* RenderWhitespace.All */ ||\n        input.renderWhitespace === 1 /* RenderWhitespace.Boundary */ ||\n        (input.renderWhitespace === 2 /* RenderWhitespace.Selection */ && !!input.selectionsOnLine) ||\n        input.renderWhitespace === 3 /* RenderWhitespace.Trailing */) {\n        tokens = _applyRenderWhitespace(input, lineContent, len, tokens);\n    }\n    let containsForeignElements = 0 /* ForeignElementType.None */;\n    if (input.lineDecorations.length > 0) {\n        for (let i = 0, len = input.lineDecorations.length; i < len; i++) {\n            const lineDecoration = input.lineDecorations[i];\n            if (lineDecoration.type === 3 /* InlineDecorationType.RegularAffectingLetterSpacing */) {\n                // Pretend there are foreign elements... although not 100% accurate.\n                containsForeignElements |= 1 /* ForeignElementType.Before */;\n            }\n            else if (lineDecoration.type === 1 /* InlineDecorationType.Before */) {\n                containsForeignElements |= 1 /* ForeignElementType.Before */;\n            }\n            else if (lineDecoration.type === 2 /* InlineDecorationType.After */) {\n                containsForeignElements |= 2 /* ForeignElementType.After */;\n            }\n        }\n        tokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);\n    }\n    if (!input.containsRTL) {\n        // We can never split RTL text, as it ruins the rendering\n        tokens = splitLargeTokens(lineContent, tokens, !input.isBasicASCII || input.fontLigatures);\n    }\n    return new ResolvedRenderLineInput(input.useMonospaceOptimizations, input.canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, tokens, containsForeignElements, input.fauxIndentLength, input.tabSize, input.startVisibleColumn, input.containsRTL, input.spaceWidth, input.renderSpaceCharCode, input.renderWhitespace, input.renderControlCharacters);\n}\n/**\n * In the rendering phase, characters are always looped until token.endIndex.\n * Ensure that all tokens end before `len` and the last one ends precisely at `len`.\n */\nfunction transformAndRemoveOverflowing(lineContent, lineContainsRTL, tokens, fauxIndentLength, len) {\n    const result = [];\n    let resultLen = 0;\n    // The faux indent part of the line should have no token type\n    if (fauxIndentLength > 0) {\n        result[resultLen++] = new LinePart(fauxIndentLength, '', 0, false);\n    }\n    let startOffset = fauxIndentLength;\n    for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n        const endIndex = tokens.getEndOffset(tokenIndex);\n        if (endIndex <= fauxIndentLength) {\n            // The faux indent part of the line should have no token type\n            continue;\n        }\n        const type = tokens.getClassName(tokenIndex);\n        if (endIndex >= len) {\n            const tokenContainsRTL = (lineContainsRTL ? strings.containsRTL(lineContent.substring(startOffset, len)) : false);\n            result[resultLen++] = new LinePart(len, type, 0, tokenContainsRTL);\n            break;\n        }\n        const tokenContainsRTL = (lineContainsRTL ? strings.containsRTL(lineContent.substring(startOffset, endIndex)) : false);\n        result[resultLen++] = new LinePart(endIndex, type, 0, tokenContainsRTL);\n        startOffset = endIndex;\n    }\n    return result;\n}\n/**\n * See https://github.com/microsoft/vscode/issues/6885.\n * It appears that having very large spans causes very slow reading of character positions.\n * So here we try to avoid that.\n */\nfunction splitLargeTokens(lineContent, tokens, onlyAtSpaces) {\n    let lastTokenEndIndex = 0;\n    const result = [];\n    let resultLen = 0;\n    if (onlyAtSpaces) {\n        // Split only at spaces => we need to walk each character\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const token = tokens[i];\n            const tokenEndIndex = token.endIndex;\n            if (lastTokenEndIndex + 50 /* Constants.LongToken */ < tokenEndIndex) {\n                const tokenType = token.type;\n                const tokenMetadata = token.metadata;\n                const tokenContainsRTL = token.containsRTL;\n                let lastSpaceOffset = -1;\n                let currTokenStart = lastTokenEndIndex;\n                for (let j = lastTokenEndIndex; j < tokenEndIndex; j++) {\n                    if (lineContent.charCodeAt(j) === 32 /* CharCode.Space */) {\n                        lastSpaceOffset = j;\n                    }\n                    if (lastSpaceOffset !== -1 && j - currTokenStart >= 50 /* Constants.LongToken */) {\n                        // Split at `lastSpaceOffset` + 1\n                        result[resultLen++] = new LinePart(lastSpaceOffset + 1, tokenType, tokenMetadata, tokenContainsRTL);\n                        currTokenStart = lastSpaceOffset + 1;\n                        lastSpaceOffset = -1;\n                    }\n                }\n                if (currTokenStart !== tokenEndIndex) {\n                    result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n                }\n            }\n            else {\n                result[resultLen++] = token;\n            }\n            lastTokenEndIndex = tokenEndIndex;\n        }\n    }\n    else {\n        // Split anywhere => we don't need to walk each character\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const token = tokens[i];\n            const tokenEndIndex = token.endIndex;\n            const diff = (tokenEndIndex - lastTokenEndIndex);\n            if (diff > 50 /* Constants.LongToken */) {\n                const tokenType = token.type;\n                const tokenMetadata = token.metadata;\n                const tokenContainsRTL = token.containsRTL;\n                const piecesCount = Math.ceil(diff / 50 /* Constants.LongToken */);\n                for (let j = 1; j < piecesCount; j++) {\n                    const pieceEndIndex = lastTokenEndIndex + (j * 50 /* Constants.LongToken */);\n                    result[resultLen++] = new LinePart(pieceEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n                }\n                result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n            }\n            else {\n                result[resultLen++] = token;\n            }\n            lastTokenEndIndex = tokenEndIndex;\n        }\n    }\n    return result;\n}\nfunction isControlCharacter(charCode) {\n    if (charCode < 32) {\n        return (charCode !== 9 /* CharCode.Tab */);\n    }\n    if (charCode === 127) {\n        // DEL\n        return true;\n    }\n    if ((charCode >= 0x202A && charCode <= 0x202E)\n        || (charCode >= 0x2066 && charCode <= 0x2069)\n        || (charCode >= 0x200E && charCode <= 0x200F)\n        || charCode === 0x061C) {\n        // Unicode Directional Formatting Characters\n        // LRE\tU+202A\tLEFT-TO-RIGHT EMBEDDING\n        // RLE\tU+202B\tRIGHT-TO-LEFT EMBEDDING\n        // PDF\tU+202C\tPOP DIRECTIONAL FORMATTING\n        // LRO\tU+202D\tLEFT-TO-RIGHT OVERRIDE\n        // RLO\tU+202E\tRIGHT-TO-LEFT OVERRIDE\n        // LRI\tU+2066\tLEFT-TO-RIGHT ISOLATE\n        // RLI\tU+2067\tRIGHT-TO-LEFT ISOLATE\n        // FSI\tU+2068\tFIRST STRONG ISOLATE\n        // PDI\tU+2069\tPOP DIRECTIONAL ISOLATE\n        // LRM\tU+200E\tLEFT-TO-RIGHT MARK\n        // RLM\tU+200F\tRIGHT-TO-LEFT MARK\n        // ALM\tU+061C\tARABIC LETTER MARK\n        return true;\n    }\n    return false;\n}\nfunction extractControlCharacters(lineContent, tokens) {\n    const result = [];\n    let lastLinePart = new LinePart(0, '', 0, false);\n    let charOffset = 0;\n    for (const token of tokens) {\n        const tokenEndIndex = token.endIndex;\n        for (; charOffset < tokenEndIndex; charOffset++) {\n            const charCode = lineContent.charCodeAt(charOffset);\n            if (isControlCharacter(charCode)) {\n                if (charOffset > lastLinePart.endIndex) {\n                    // emit previous part if it has text\n                    lastLinePart = new LinePart(charOffset, token.type, token.metadata, token.containsRTL);\n                    result.push(lastLinePart);\n                }\n                lastLinePart = new LinePart(charOffset + 1, 'mtkcontrol', token.metadata, false);\n                result.push(lastLinePart);\n            }\n        }\n        if (charOffset > lastLinePart.endIndex) {\n            // emit previous part if it has text\n            lastLinePart = new LinePart(tokenEndIndex, token.type, token.metadata, token.containsRTL);\n            result.push(lastLinePart);\n        }\n    }\n    return result;\n}\n/**\n * Whitespace is rendered by \"replacing\" tokens with a special-purpose `mtkw` type that is later recognized in the rendering phase.\n * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.\n * The rendering phase will generate `style=\"width:...\"` for these tokens.\n */\nfunction _applyRenderWhitespace(input, lineContent, len, tokens) {\n    const continuesWithWrappedLine = input.continuesWithWrappedLine;\n    const fauxIndentLength = input.fauxIndentLength;\n    const tabSize = input.tabSize;\n    const startVisibleColumn = input.startVisibleColumn;\n    const useMonospaceOptimizations = input.useMonospaceOptimizations;\n    const selections = input.selectionsOnLine;\n    const onlyBoundary = (input.renderWhitespace === 1 /* RenderWhitespace.Boundary */);\n    const onlyTrailing = (input.renderWhitespace === 3 /* RenderWhitespace.Trailing */);\n    const generateLinePartForEachWhitespace = (input.renderSpaceWidth !== input.spaceWidth);\n    const result = [];\n    let resultLen = 0;\n    let tokenIndex = 0;\n    let tokenType = tokens[tokenIndex].type;\n    let tokenContainsRTL = tokens[tokenIndex].containsRTL;\n    let tokenEndIndex = tokens[tokenIndex].endIndex;\n    const tokensLength = tokens.length;\n    let lineIsEmptyOrWhitespace = false;\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n    let lastNonWhitespaceIndex;\n    if (firstNonWhitespaceIndex === -1) {\n        lineIsEmptyOrWhitespace = true;\n        firstNonWhitespaceIndex = len;\n        lastNonWhitespaceIndex = len;\n    }\n    else {\n        lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\n    }\n    let wasInWhitespace = false;\n    let currentSelectionIndex = 0;\n    let currentSelection = selections && selections[currentSelectionIndex];\n    let tmpIndent = startVisibleColumn % tabSize;\n    for (let charIndex = fauxIndentLength; charIndex < len; charIndex++) {\n        const chCode = lineContent.charCodeAt(charIndex);\n        if (currentSelection && charIndex >= currentSelection.endOffset) {\n            currentSelectionIndex++;\n            currentSelection = selections && selections[currentSelectionIndex];\n        }\n        let isInWhitespace;\n        if (charIndex < firstNonWhitespaceIndex || charIndex > lastNonWhitespaceIndex) {\n            // in leading or trailing whitespace\n            isInWhitespace = true;\n        }\n        else if (chCode === 9 /* CharCode.Tab */) {\n            // a tab character is rendered both in all and boundary cases\n            isInWhitespace = true;\n        }\n        else if (chCode === 32 /* CharCode.Space */) {\n            // hit a space character\n            if (onlyBoundary) {\n                // rendering only boundary whitespace\n                if (wasInWhitespace) {\n                    isInWhitespace = true;\n                }\n                else {\n                    const nextChCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* CharCode.Null */);\n                    isInWhitespace = (nextChCode === 32 /* CharCode.Space */ || nextChCode === 9 /* CharCode.Tab */);\n                }\n            }\n            else {\n                isInWhitespace = true;\n            }\n        }\n        else {\n            isInWhitespace = false;\n        }\n        // If rendering whitespace on selection, check that the charIndex falls within a selection\n        if (isInWhitespace && selections) {\n            isInWhitespace = !!currentSelection && currentSelection.startOffset <= charIndex && currentSelection.endOffset > charIndex;\n        }\n        // If rendering only trailing whitespace, check that the charIndex points to trailing whitespace.\n        if (isInWhitespace && onlyTrailing) {\n            isInWhitespace = lineIsEmptyOrWhitespace || charIndex > lastNonWhitespaceIndex;\n        }\n        if (isInWhitespace && tokenContainsRTL) {\n            // If the token contains RTL text, breaking it up into multiple line parts\n            // to render whitespace might affect the browser's bidi layout.\n            //\n            // We render whitespace in such tokens only if the whitespace\n            // is the leading or the trailing whitespace of the line,\n            // which doesn't affect the browser's bidi layout.\n            if (charIndex >= firstNonWhitespaceIndex && charIndex <= lastNonWhitespaceIndex) {\n                isInWhitespace = false;\n            }\n        }\n        if (wasInWhitespace) {\n            // was in whitespace token\n            if (!isInWhitespace || (!useMonospaceOptimizations && tmpIndent >= tabSize)) {\n                // leaving whitespace token or entering a new indent\n                if (generateLinePartForEachWhitespace) {\n                    const lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\n                    for (let i = lastEndIndex + 1; i <= charIndex; i++) {\n                        result[resultLen++] = new LinePart(i, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n                    }\n                }\n                else {\n                    result[resultLen++] = new LinePart(charIndex, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n                }\n                tmpIndent = tmpIndent % tabSize;\n            }\n        }\n        else {\n            // was in regular token\n            if (charIndex === tokenEndIndex || (isInWhitespace && charIndex > fauxIndentLength)) {\n                result[resultLen++] = new LinePart(charIndex, tokenType, 0, tokenContainsRTL);\n                tmpIndent = tmpIndent % tabSize;\n            }\n        }\n        if (chCode === 9 /* CharCode.Tab */) {\n            tmpIndent = tabSize;\n        }\n        else if (strings.isFullWidthCharacter(chCode)) {\n            tmpIndent += 2;\n        }\n        else {\n            tmpIndent++;\n        }\n        wasInWhitespace = isInWhitespace;\n        while (charIndex === tokenEndIndex) {\n            tokenIndex++;\n            if (tokenIndex < tokensLength) {\n                tokenType = tokens[tokenIndex].type;\n                tokenContainsRTL = tokens[tokenIndex].containsRTL;\n                tokenEndIndex = tokens[tokenIndex].endIndex;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    let generateWhitespace = false;\n    if (wasInWhitespace) {\n        // was in whitespace token\n        if (continuesWithWrappedLine && onlyBoundary) {\n            const lastCharCode = (len > 0 ? lineContent.charCodeAt(len - 1) : 0 /* CharCode.Null */);\n            const prevCharCode = (len > 1 ? lineContent.charCodeAt(len - 2) : 0 /* CharCode.Null */);\n            const isSingleTrailingSpace = (lastCharCode === 32 /* CharCode.Space */ && (prevCharCode !== 32 /* CharCode.Space */ && prevCharCode !== 9 /* CharCode.Tab */));\n            if (!isSingleTrailingSpace) {\n                generateWhitespace = true;\n            }\n        }\n        else {\n            generateWhitespace = true;\n        }\n    }\n    if (generateWhitespace) {\n        if (generateLinePartForEachWhitespace) {\n            const lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\n            for (let i = lastEndIndex + 1; i <= len; i++) {\n                result[resultLen++] = new LinePart(i, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n            }\n        }\n        else {\n            result[resultLen++] = new LinePart(len, 'mtkw', 1 /* LinePartMetadata.IS_WHITESPACE */, false);\n        }\n    }\n    else {\n        result[resultLen++] = new LinePart(len, tokenType, 0, tokenContainsRTL);\n    }\n    return result;\n}\n/**\n * Inline decorations are \"merged\" on top of tokens.\n * Special care must be taken when multiple inline decorations are at play and they overlap.\n */\nfunction _applyInlineDecorations(lineContent, len, tokens, _lineDecorations) {\n    _lineDecorations.sort(LineDecoration.compare);\n    const lineDecorations = LineDecorationsNormalizer.normalize(lineContent, _lineDecorations);\n    const lineDecorationsLen = lineDecorations.length;\n    let lineDecorationIndex = 0;\n    const result = [];\n    let resultLen = 0;\n    let lastResultEndIndex = 0;\n    for (let tokenIndex = 0, len = tokens.length; tokenIndex < len; tokenIndex++) {\n        const token = tokens[tokenIndex];\n        const tokenEndIndex = token.endIndex;\n        const tokenType = token.type;\n        const tokenMetadata = token.metadata;\n        const tokenContainsRTL = token.containsRTL;\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {\n            const lineDecoration = lineDecorations[lineDecorationIndex];\n            if (lineDecoration.startOffset > lastResultEndIndex) {\n                lastResultEndIndex = lineDecoration.startOffset;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n            }\n            if (lineDecoration.endOffset + 1 <= tokenEndIndex) {\n                // This line decoration ends before this token ends\n                lastResultEndIndex = lineDecoration.endOffset + 1;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata, tokenContainsRTL);\n                lineDecorationIndex++;\n            }\n            else {\n                // This line decoration continues on to the next token\n                lastResultEndIndex = tokenEndIndex;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata, tokenContainsRTL);\n                break;\n            }\n        }\n        if (tokenEndIndex > lastResultEndIndex) {\n            lastResultEndIndex = tokenEndIndex;\n            result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata, tokenContainsRTL);\n        }\n    }\n    const lastTokenEndIndex = tokens[tokens.length - 1].endIndex;\n    if (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n            const lineDecoration = lineDecorations[lineDecorationIndex];\n            result[resultLen++] = new LinePart(lastResultEndIndex, lineDecoration.className, lineDecoration.metadata, false);\n            lineDecorationIndex++;\n        }\n    }\n    return result;\n}\n/**\n * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).\n * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).\n */\nfunction _renderLine(input, sb) {\n    const fontIsMonospace = input.fontIsMonospace;\n    const canUseHalfwidthRightwardsArrow = input.canUseHalfwidthRightwardsArrow;\n    const containsForeignElements = input.containsForeignElements;\n    const lineContent = input.lineContent;\n    const len = input.len;\n    const isOverflowing = input.isOverflowing;\n    const parts = input.parts;\n    const fauxIndentLength = input.fauxIndentLength;\n    const tabSize = input.tabSize;\n    const startVisibleColumn = input.startVisibleColumn;\n    const containsRTL = input.containsRTL;\n    const spaceWidth = input.spaceWidth;\n    const renderSpaceCharCode = input.renderSpaceCharCode;\n    const renderWhitespace = input.renderWhitespace;\n    const renderControlCharacters = input.renderControlCharacters;\n    const characterMapping = new CharacterMapping(len + 1, parts.length);\n    let lastCharacterMappingDefined = false;\n    let charIndex = 0;\n    let visibleColumn = startVisibleColumn;\n    let charOffsetInPart = 0; // the character offset in the current part\n    let charHorizontalOffset = 0; // the character horizontal position in terms of chars relative to line start\n    let partDisplacement = 0;\n    if (containsRTL) {\n        sb.appendASCIIString('<span dir=\"ltr\">');\n    }\n    else {\n        sb.appendASCIIString('<span>');\n    }\n    for (let partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {\n        const part = parts[partIndex];\n        const partEndIndex = part.endIndex;\n        const partType = part.type;\n        const partContainsRTL = part.containsRTL;\n        const partRendersWhitespace = (renderWhitespace !== 0 /* RenderWhitespace.None */ && part.isWhitespace());\n        const partRendersWhitespaceWithWidth = partRendersWhitespace && !fontIsMonospace && (partType === 'mtkw' /*only whitespace*/ || !containsForeignElements);\n        const partIsEmptyAndHasPseudoAfter = (charIndex === partEndIndex && part.isPseudoAfter());\n        charOffsetInPart = 0;\n        sb.appendASCIIString('<span ');\n        if (partContainsRTL) {\n            sb.appendASCIIString('style=\"unicode-bidi:isolate\" ');\n        }\n        sb.appendASCIIString('class=\"');\n        sb.appendASCIIString(partRendersWhitespaceWithWidth ? 'mtkz' : partType);\n        sb.appendASCII(34 /* CharCode.DoubleQuote */);\n        if (partRendersWhitespace) {\n            let partWidth = 0;\n            {\n                let _charIndex = charIndex;\n                let _visibleColumn = visibleColumn;\n                for (; _charIndex < partEndIndex; _charIndex++) {\n                    const charCode = lineContent.charCodeAt(_charIndex);\n                    const charWidth = (charCode === 9 /* CharCode.Tab */ ? (tabSize - (_visibleColumn % tabSize)) : 1) | 0;\n                    partWidth += charWidth;\n                    if (_charIndex >= fauxIndentLength) {\n                        _visibleColumn += charWidth;\n                    }\n                }\n            }\n            if (partRendersWhitespaceWithWidth) {\n                sb.appendASCIIString(' style=\"width:');\n                sb.appendASCIIString(String(spaceWidth * partWidth));\n                sb.appendASCIIString('px\"');\n            }\n            sb.appendASCII(62 /* CharCode.GreaterThan */);\n            for (; charIndex < partEndIndex; charIndex++) {\n                characterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, charHorizontalOffset);\n                partDisplacement = 0;\n                const charCode = lineContent.charCodeAt(charIndex);\n                let producedCharacters;\n                let charWidth;\n                if (charCode === 9 /* CharCode.Tab */) {\n                    producedCharacters = (tabSize - (visibleColumn % tabSize)) | 0;\n                    charWidth = producedCharacters;\n                    if (!canUseHalfwidthRightwardsArrow || charWidth > 1) {\n                        sb.write1(0x2192); // RIGHTWARDS ARROW\n                    }\n                    else {\n                        sb.write1(0xFFEB); // HALFWIDTH RIGHTWARDS ARROW\n                    }\n                    for (let space = 2; space <= charWidth; space++) {\n                        sb.write1(0xA0); // &nbsp;\n                    }\n                }\n                else { // must be CharCode.Space\n                    producedCharacters = 2;\n                    charWidth = 1;\n                    sb.write1(renderSpaceCharCode); // &middot; or word separator middle dot\n                    sb.write1(0x200C); // ZERO WIDTH NON-JOINER\n                }\n                charOffsetInPart += producedCharacters;\n                charHorizontalOffset += charWidth;\n                if (charIndex >= fauxIndentLength) {\n                    visibleColumn += charWidth;\n                }\n            }\n        }\n        else {\n            sb.appendASCII(62 /* CharCode.GreaterThan */);\n            for (; charIndex < partEndIndex; charIndex++) {\n                characterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, charHorizontalOffset);\n                partDisplacement = 0;\n                const charCode = lineContent.charCodeAt(charIndex);\n                let producedCharacters = 1;\n                let charWidth = 1;\n                switch (charCode) {\n                    case 9 /* CharCode.Tab */:\n                        producedCharacters = (tabSize - (visibleColumn % tabSize));\n                        charWidth = producedCharacters;\n                        for (let space = 1; space <= producedCharacters; space++) {\n                            sb.write1(0xA0); // &nbsp;\n                        }\n                        break;\n                    case 32 /* CharCode.Space */:\n                        sb.write1(0xA0); // &nbsp;\n                        break;\n                    case 60 /* CharCode.LessThan */:\n                        sb.appendASCIIString('&lt;');\n                        break;\n                    case 62 /* CharCode.GreaterThan */:\n                        sb.appendASCIIString('&gt;');\n                        break;\n                    case 38 /* CharCode.Ampersand */:\n                        sb.appendASCIIString('&amp;');\n                        break;\n                    case 0 /* CharCode.Null */:\n                        if (renderControlCharacters) {\n                            // See https://unicode-table.com/en/blocks/control-pictures/\n                            sb.write1(9216);\n                        }\n                        else {\n                            sb.appendASCIIString('&#00;');\n                        }\n                        break;\n                    case 65279 /* CharCode.UTF8_BOM */:\n                    case 8232 /* CharCode.LINE_SEPARATOR */:\n                    case 8233 /* CharCode.PARAGRAPH_SEPARATOR */:\n                    case 133 /* CharCode.NEXT_LINE */:\n                        sb.write1(0xFFFD);\n                        break;\n                    default:\n                        if (strings.isFullWidthCharacter(charCode)) {\n                            charWidth++;\n                        }\n                        // See https://unicode-table.com/en/blocks/control-pictures/\n                        if (renderControlCharacters && charCode < 32) {\n                            sb.write1(9216 + charCode);\n                        }\n                        else if (renderControlCharacters && charCode === 127) {\n                            // DEL\n                            sb.write1(9249);\n                        }\n                        else if (renderControlCharacters && isControlCharacter(charCode)) {\n                            sb.appendASCIIString('[U+');\n                            sb.appendASCIIString(to4CharHex(charCode));\n                            sb.appendASCIIString(']');\n                            producedCharacters = 8;\n                            charWidth = producedCharacters;\n                        }\n                        else {\n                            sb.write1(charCode);\n                        }\n                }\n                charOffsetInPart += producedCharacters;\n                charHorizontalOffset += charWidth;\n                if (charIndex >= fauxIndentLength) {\n                    visibleColumn += charWidth;\n                }\n            }\n        }\n        if (partIsEmptyAndHasPseudoAfter) {\n            partDisplacement++;\n        }\n        else {\n            partDisplacement = 0;\n        }\n        if (charIndex >= len && !lastCharacterMappingDefined && part.isPseudoAfter()) {\n            lastCharacterMappingDefined = true;\n            characterMapping.setColumnInfo(charIndex + 1, partIndex, charOffsetInPart, charHorizontalOffset);\n        }\n        sb.appendASCIIString('</span>');\n    }\n    if (!lastCharacterMappingDefined) {\n        // When getting client rects for the last character, we will position the\n        // text range at the end of the span, insteaf of at the beginning of next span\n        characterMapping.setColumnInfo(len + 1, parts.length - 1, charOffsetInPart, charHorizontalOffset);\n    }\n    if (isOverflowing) {\n        sb.appendASCIIString('<span>&hellip;</span>');\n    }\n    sb.appendASCIIString('</span>');\n    return new RenderLineOutput(characterMapping, containsRTL, containsForeignElements);\n}\nfunction to4CharHex(n) {\n    return n.toString(16).toUpperCase().padStart(4, '0');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../core/range.js';\n/**\n * Contains all data needed to render at a specific viewport.\n */\nexport class ViewportData {\n    constructor(selections, partialData, whitespaceViewportData, model) {\n        this.selections = selections;\n        this.startLineNumber = partialData.startLineNumber | 0;\n        this.endLineNumber = partialData.endLineNumber | 0;\n        this.relativeVerticalOffset = partialData.relativeVerticalOffset;\n        this.bigNumbersDelta = partialData.bigNumbersDelta | 0;\n        this.whitespaceViewportData = whitespaceViewportData;\n        this._model = model;\n        this.visibleRange = new Range(partialData.startLineNumber, this._model.getLineMinColumn(partialData.startLineNumber), partialData.endLineNumber, this._model.getLineMaxColumn(partialData.endLineNumber));\n    }\n    getViewLineRenderingData(lineNumber) {\n        return this._model.getViewportViewLineRenderingData(this.visibleRange, lineNumber);\n    }\n    getDecorationsInViewport() {\n        return this._model.getDecorationsInViewport(this.visibleRange);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../base/common/strings.js';\nimport { Range } from './core/range.js';\nexport class Viewport {\n    constructor(top, left, width, height) {\n        this._viewportBrand = undefined;\n        this.top = top | 0;\n        this.left = left | 0;\n        this.width = width | 0;\n        this.height = height | 0;\n    }\n}\nexport class MinimapLinesRenderingData {\n    constructor(tabSize, data) {\n        this.tabSize = tabSize;\n        this.data = data;\n    }\n}\nexport class ViewLineData {\n    constructor(content, continuesWithWrappedLine, minColumn, maxColumn, startVisibleColumn, tokens, inlineDecorations) {\n        this._viewLineDataBrand = undefined;\n        this.content = content;\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\n        this.minColumn = minColumn;\n        this.maxColumn = maxColumn;\n        this.startVisibleColumn = startVisibleColumn;\n        this.tokens = tokens;\n        this.inlineDecorations = inlineDecorations;\n    }\n}\nexport class ViewLineRenderingData {\n    constructor(minColumn, maxColumn, content, continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, tokens, inlineDecorations, tabSize, startVisibleColumn) {\n        this.minColumn = minColumn;\n        this.maxColumn = maxColumn;\n        this.content = content;\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\n        this.isBasicASCII = ViewLineRenderingData.isBasicASCII(content, mightContainNonBasicASCII);\n        this.containsRTL = ViewLineRenderingData.containsRTL(content, this.isBasicASCII, mightContainRTL);\n        this.tokens = tokens;\n        this.inlineDecorations = inlineDecorations;\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n    }\n    static isBasicASCII(lineContent, mightContainNonBasicASCII) {\n        if (mightContainNonBasicASCII) {\n            return strings.isBasicASCII(lineContent);\n        }\n        return true;\n    }\n    static containsRTL(lineContent, isBasicASCII, mightContainRTL) {\n        if (!isBasicASCII && mightContainRTL) {\n            return strings.containsRTL(lineContent);\n        }\n        return false;\n    }\n}\nexport class InlineDecoration {\n    constructor(range, inlineClassName, type) {\n        this.range = range;\n        this.inlineClassName = inlineClassName;\n        this.type = type;\n    }\n}\nexport class SingleLineInlineDecoration {\n    constructor(startOffset, endOffset, inlineClassName, inlineClassNameAffectsLetterSpacing) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.inlineClassName = inlineClassName;\n        this.inlineClassNameAffectsLetterSpacing = inlineClassNameAffectsLetterSpacing;\n    }\n    toInlineDecoration(lineNumber) {\n        return new InlineDecoration(new Range(lineNumber, this.startOffset + 1, lineNumber, this.endOffset + 1), this.inlineClassName, this.inlineClassNameAffectsLetterSpacing ? 3 /* InlineDecorationType.RegularAffectingLetterSpacing */ : 0 /* InlineDecorationType.Regular */);\n    }\n}\nexport class ViewModelDecoration {\n    constructor(range, options) {\n        this._viewModelDecorationBrand = undefined;\n        this.range = range;\n        this.options = options;\n    }\n}\nexport class OverviewRulerDecorationsGroup {\n    constructor(color, zIndex, \n    /**\n     * Decorations are encoded in a number array using the following scheme:\n     *  - 3*i = lane\n     *  - 3*i+1 = startLineNumber\n     *  - 3*i+2 = endLineNumber\n     */\n    data) {\n        this.color = color;\n        this.zIndex = zIndex;\n        this.data = data;\n    }\n    static cmp(a, b) {\n        if (a.zIndex === b.zIndex) {\n            if (a.color < b.color) {\n                return -1;\n            }\n            if (a.color > b.color) {\n                return 1;\n            }\n            return 0;\n        }\n        return a.zIndex - b.zIndex;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, markAsSingleton } from '../../../base/common/lifecycle.js';\nimport { RGBA8 } from '../core/rgba.js';\nimport { TokenizationRegistry } from '../languages.js';\nexport class MinimapTokensColorTracker extends Disposable {\n    constructor() {\n        super();\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n        this._updateColorMap();\n        this._register(TokenizationRegistry.onDidChange(e => {\n            if (e.changedColorMap) {\n                this._updateColorMap();\n            }\n        }));\n    }\n    static getInstance() {\n        if (!this._INSTANCE) {\n            this._INSTANCE = markAsSingleton(new MinimapTokensColorTracker());\n        }\n        return this._INSTANCE;\n    }\n    _updateColorMap() {\n        const colorMap = TokenizationRegistry.getColorMap();\n        if (!colorMap) {\n            this._colors = [RGBA8.Empty];\n            this._backgroundIsLight = true;\n            return;\n        }\n        this._colors = [RGBA8.Empty];\n        for (let colorId = 1; colorId < colorMap.length; colorId++) {\n            const source = colorMap[colorId].rgba;\n            // Use a VM friendly data-type\n            this._colors[colorId] = new RGBA8(source.r, source.g, source.b, Math.round(source.a * 255));\n        }\n        const backgroundLuminosity = colorMap[2 /* ColorId.DefaultBackground */].getRelativeLuminance();\n        this._backgroundIsLight = backgroundLuminosity >= 0.5;\n        this._onDidChange.fire(undefined);\n    }\n    getColor(colorId) {\n        if (colorId < 1 || colorId >= this._colors.length) {\n            // background color (basically invisible)\n            colorId = 2 /* ColorId.DefaultBackground */;\n        }\n        return this._colors[colorId];\n    }\n    backgroundIsLight() {\n        return this._backgroundIsLight;\n    }\n}\nMinimapTokensColorTracker._INSTANCE = null;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CharacterClassifier } from '../core/characterClassifier.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport { ModelLineProjectionData } from '../modelLineProjectionData.js';\nexport class MonospaceLineBreaksComputerFactory {\n    constructor(breakBeforeChars, breakAfterChars) {\n        this.classifier = new WrappingCharacterClassifier(breakBeforeChars, breakAfterChars);\n    }\n    static create(options) {\n        return new MonospaceLineBreaksComputerFactory(options.get(122 /* EditorOption.wordWrapBreakBeforeCharacters */), options.get(121 /* EditorOption.wordWrapBreakAfterCharacters */));\n    }\n    createLineBreaksComputer(fontInfo, tabSize, wrappingColumn, wrappingIndent) {\n        const requests = [];\n        const injectedTexts = [];\n        const previousBreakingData = [];\n        return {\n            addRequest: (lineText, injectedText, previousLineBreakData) => {\n                requests.push(lineText);\n                injectedTexts.push(injectedText);\n                previousBreakingData.push(previousLineBreakData);\n            },\n            finalize: () => {\n                const columnsForFullWidthChar = fontInfo.typicalFullwidthCharacterWidth / fontInfo.typicalHalfwidthCharacterWidth;\n                const result = [];\n                for (let i = 0, len = requests.length; i < len; i++) {\n                    const injectedText = injectedTexts[i];\n                    const previousLineBreakData = previousBreakingData[i];\n                    if (previousLineBreakData && !previousLineBreakData.injectionOptions && !injectedText) {\n                        result[i] = createLineBreaksFromPreviousLineBreaks(this.classifier, previousLineBreakData, requests[i], tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent);\n                    }\n                    else {\n                        result[i] = createLineBreaks(this.classifier, requests[i], injectedText, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent);\n                    }\n                }\n                arrPool1.length = 0;\n                arrPool2.length = 0;\n                return result;\n            }\n        };\n    }\n}\nclass WrappingCharacterClassifier extends CharacterClassifier {\n    constructor(BREAK_BEFORE, BREAK_AFTER) {\n        super(0 /* CharacterClass.NONE */);\n        for (let i = 0; i < BREAK_BEFORE.length; i++) {\n            this.set(BREAK_BEFORE.charCodeAt(i), 1 /* CharacterClass.BREAK_BEFORE */);\n        }\n        for (let i = 0; i < BREAK_AFTER.length; i++) {\n            this.set(BREAK_AFTER.charCodeAt(i), 2 /* CharacterClass.BREAK_AFTER */);\n        }\n    }\n    get(charCode) {\n        if (charCode >= 0 && charCode < 256) {\n            return this._asciiMap[charCode];\n        }\n        else {\n            // Initialize CharacterClass.BREAK_IDEOGRAPHIC for these Unicode ranges:\n            // 1. CJK Unified Ideographs (0x4E00 -- 0x9FFF)\n            // 2. CJK Unified Ideographs Extension A (0x3400 -- 0x4DBF)\n            // 3. Hiragana and Katakana (0x3040 -- 0x30FF)\n            if ((charCode >= 0x3040 && charCode <= 0x30FF)\n                || (charCode >= 0x3400 && charCode <= 0x4DBF)\n                || (charCode >= 0x4E00 && charCode <= 0x9FFF)) {\n                return 3 /* CharacterClass.BREAK_IDEOGRAPHIC */;\n            }\n            return (this._map.get(charCode) || this._defaultValue);\n        }\n    }\n}\nlet arrPool1 = [];\nlet arrPool2 = [];\nfunction createLineBreaksFromPreviousLineBreaks(classifier, previousBreakingData, lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n    if (firstLineBreakColumn === -1) {\n        return null;\n    }\n    const len = lineText.length;\n    if (len <= 1) {\n        return null;\n    }\n    const prevBreakingOffsets = previousBreakingData.breakOffsets;\n    const prevBreakingOffsetsVisibleColumn = previousBreakingData.breakOffsetsVisibleColumn;\n    const wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n    const wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n    const breakingOffsets = arrPool1;\n    const breakingOffsetsVisibleColumn = arrPool2;\n    let breakingOffsetsCount = 0;\n    let lastBreakingOffset = 0;\n    let lastBreakingOffsetVisibleColumn = 0;\n    let breakingColumn = firstLineBreakColumn;\n    const prevLen = prevBreakingOffsets.length;\n    let prevIndex = 0;\n    if (prevIndex >= 0) {\n        let bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n        while (prevIndex + 1 < prevLen) {\n            const distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n            if (distance >= bestDistance) {\n                break;\n            }\n            bestDistance = distance;\n            prevIndex++;\n        }\n    }\n    while (prevIndex < prevLen) {\n        // Allow for prevIndex to be -1 (for the case where we hit a tab when walking backwards from the first break)\n        let prevBreakOffset = prevIndex < 0 ? 0 : prevBreakingOffsets[prevIndex];\n        let prevBreakOffsetVisibleColumn = prevIndex < 0 ? 0 : prevBreakingOffsetsVisibleColumn[prevIndex];\n        if (lastBreakingOffset > prevBreakOffset) {\n            prevBreakOffset = lastBreakingOffset;\n            prevBreakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn;\n        }\n        let breakOffset = 0;\n        let breakOffsetVisibleColumn = 0;\n        let forcedBreakOffset = 0;\n        let forcedBreakOffsetVisibleColumn = 0;\n        // initially, we search as much as possible to the right (if it fits)\n        if (prevBreakOffsetVisibleColumn <= breakingColumn) {\n            let visibleColumn = prevBreakOffsetVisibleColumn;\n            let prevCharCode = prevBreakOffset === 0 ? 0 /* CharCode.Null */ : lineText.charCodeAt(prevBreakOffset - 1);\n            let prevCharCodeClass = prevBreakOffset === 0 ? 0 /* CharacterClass.NONE */ : classifier.get(prevCharCode);\n            let entireLineFits = true;\n            for (let i = prevBreakOffset; i < len; i++) {\n                const charStartOffset = i;\n                const charCode = lineText.charCodeAt(i);\n                let charCodeClass;\n                let charWidth;\n                if (strings.isHighSurrogate(charCode)) {\n                    // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                    i++;\n                    charCodeClass = 0 /* CharacterClass.NONE */;\n                    charWidth = 2;\n                }\n                else {\n                    charCodeClass = classifier.get(charCode);\n                    charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n                }\n                if (charStartOffset > lastBreakingOffset && canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\n                    breakOffset = charStartOffset;\n                    breakOffsetVisibleColumn = visibleColumn;\n                }\n                visibleColumn += charWidth;\n                // check if adding character at `i` will go over the breaking column\n                if (visibleColumn > breakingColumn) {\n                    // We need to break at least before character at `i`:\n                    if (charStartOffset > lastBreakingOffset) {\n                        forcedBreakOffset = charStartOffset;\n                        forcedBreakOffsetVisibleColumn = visibleColumn - charWidth;\n                    }\n                    else {\n                        // we need to advance at least by one character\n                        forcedBreakOffset = i + 1;\n                        forcedBreakOffsetVisibleColumn = visibleColumn;\n                    }\n                    if (visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n                        // Cannot break at `breakOffset` => reset it if it was set\n                        breakOffset = 0;\n                    }\n                    entireLineFits = false;\n                    break;\n                }\n                prevCharCode = charCode;\n                prevCharCodeClass = charCodeClass;\n            }\n            if (entireLineFits) {\n                // there is no more need to break => stop the outer loop!\n                if (breakingOffsetsCount > 0) {\n                    // Add last segment, no need to assign to `lastBreakingOffset` and `lastBreakingOffsetVisibleColumn`\n                    breakingOffsets[breakingOffsetsCount] = prevBreakingOffsets[prevBreakingOffsets.length - 1];\n                    breakingOffsetsVisibleColumn[breakingOffsetsCount] = prevBreakingOffsetsVisibleColumn[prevBreakingOffsets.length - 1];\n                    breakingOffsetsCount++;\n                }\n                break;\n            }\n        }\n        if (breakOffset === 0) {\n            // must search left\n            let visibleColumn = prevBreakOffsetVisibleColumn;\n            let charCode = lineText.charCodeAt(prevBreakOffset);\n            let charCodeClass = classifier.get(charCode);\n            let hitATabCharacter = false;\n            for (let i = prevBreakOffset - 1; i >= lastBreakingOffset; i--) {\n                const charStartOffset = i + 1;\n                const prevCharCode = lineText.charCodeAt(i);\n                if (prevCharCode === 9 /* CharCode.Tab */) {\n                    // cannot determine the width of a tab when going backwards, so we must go forwards\n                    hitATabCharacter = true;\n                    break;\n                }\n                let prevCharCodeClass;\n                let prevCharWidth;\n                if (strings.isLowSurrogate(prevCharCode)) {\n                    // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                    i--;\n                    prevCharCodeClass = 0 /* CharacterClass.NONE */;\n                    prevCharWidth = 2;\n                }\n                else {\n                    prevCharCodeClass = classifier.get(prevCharCode);\n                    prevCharWidth = (strings.isFullWidthCharacter(prevCharCode) ? columnsForFullWidthChar : 1);\n                }\n                if (visibleColumn <= breakingColumn) {\n                    if (forcedBreakOffset === 0) {\n                        forcedBreakOffset = charStartOffset;\n                        forcedBreakOffsetVisibleColumn = visibleColumn;\n                    }\n                    if (visibleColumn <= breakingColumn - wrappedLineBreakColumn) {\n                        // went too far!\n                        break;\n                    }\n                    if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\n                        breakOffset = charStartOffset;\n                        breakOffsetVisibleColumn = visibleColumn;\n                        break;\n                    }\n                }\n                visibleColumn -= prevCharWidth;\n                charCode = prevCharCode;\n                charCodeClass = prevCharCodeClass;\n            }\n            if (breakOffset !== 0) {\n                const remainingWidthOfNextLine = wrappedLineBreakColumn - (forcedBreakOffsetVisibleColumn - breakOffsetVisibleColumn);\n                if (remainingWidthOfNextLine <= tabSize) {\n                    const charCodeAtForcedBreakOffset = lineText.charCodeAt(forcedBreakOffset);\n                    let charWidth;\n                    if (strings.isHighSurrogate(charCodeAtForcedBreakOffset)) {\n                        // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                        charWidth = 2;\n                    }\n                    else {\n                        charWidth = computeCharWidth(charCodeAtForcedBreakOffset, forcedBreakOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n                    }\n                    if (remainingWidthOfNextLine - charWidth < 0) {\n                        // it is not worth it to break at breakOffset, it just introduces an extra needless line!\n                        breakOffset = 0;\n                    }\n                }\n            }\n            if (hitATabCharacter) {\n                // cannot determine the width of a tab when going backwards, so we must go forwards from the previous break\n                prevIndex--;\n                continue;\n            }\n        }\n        if (breakOffset === 0) {\n            // Could not find a good breaking point\n            breakOffset = forcedBreakOffset;\n            breakOffsetVisibleColumn = forcedBreakOffsetVisibleColumn;\n        }\n        if (breakOffset <= lastBreakingOffset) {\n            // Make sure that we are advancing (at least one character)\n            const charCode = lineText.charCodeAt(lastBreakingOffset);\n            if (strings.isHighSurrogate(charCode)) {\n                // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                breakOffset = lastBreakingOffset + 2;\n                breakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn + 2;\n            }\n            else {\n                breakOffset = lastBreakingOffset + 1;\n                breakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn + computeCharWidth(charCode, lastBreakingOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n            }\n        }\n        lastBreakingOffset = breakOffset;\n        breakingOffsets[breakingOffsetsCount] = breakOffset;\n        lastBreakingOffsetVisibleColumn = breakOffsetVisibleColumn;\n        breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n        breakingOffsetsCount++;\n        breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n        while (prevIndex < 0 || (prevIndex < prevLen && prevBreakingOffsetsVisibleColumn[prevIndex] < breakOffsetVisibleColumn)) {\n            prevIndex++;\n        }\n        let bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n        while (prevIndex + 1 < prevLen) {\n            const distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n            if (distance >= bestDistance) {\n                break;\n            }\n            bestDistance = distance;\n            prevIndex++;\n        }\n    }\n    if (breakingOffsetsCount === 0) {\n        return null;\n    }\n    // Doing here some object reuse which ends up helping a huge deal with GC pauses!\n    breakingOffsets.length = breakingOffsetsCount;\n    breakingOffsetsVisibleColumn.length = breakingOffsetsCount;\n    arrPool1 = previousBreakingData.breakOffsets;\n    arrPool2 = previousBreakingData.breakOffsetsVisibleColumn;\n    previousBreakingData.breakOffsets = breakingOffsets;\n    previousBreakingData.breakOffsetsVisibleColumn = breakingOffsetsVisibleColumn;\n    previousBreakingData.wrappedTextIndentLength = wrappedTextIndentLength;\n    return previousBreakingData;\n}\nfunction createLineBreaks(classifier, _lineText, injectedTexts, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n    const lineText = LineInjectedText.applyInjectedText(_lineText, injectedTexts);\n    let injectionOptions;\n    let injectionOffsets;\n    if (injectedTexts && injectedTexts.length > 0) {\n        injectionOptions = injectedTexts.map(t => t.options);\n        injectionOffsets = injectedTexts.map(text => text.column - 1);\n    }\n    else {\n        injectionOptions = null;\n        injectionOffsets = null;\n    }\n    if (firstLineBreakColumn === -1) {\n        if (!injectionOptions) {\n            return null;\n        }\n        // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n        // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n        return new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n    }\n    const len = lineText.length;\n    if (len <= 1) {\n        if (!injectionOptions) {\n            return null;\n        }\n        // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n        // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n        return new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n    }\n    const wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n    const wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n    const breakingOffsets = [];\n    const breakingOffsetsVisibleColumn = [];\n    let breakingOffsetsCount = 0;\n    let breakOffset = 0;\n    let breakOffsetVisibleColumn = 0;\n    let breakingColumn = firstLineBreakColumn;\n    let prevCharCode = lineText.charCodeAt(0);\n    let prevCharCodeClass = classifier.get(prevCharCode);\n    let visibleColumn = computeCharWidth(prevCharCode, 0, tabSize, columnsForFullWidthChar);\n    let startOffset = 1;\n    if (strings.isHighSurrogate(prevCharCode)) {\n        // A surrogate pair must always be considered as a single unit, so it is never to be broken\n        visibleColumn += 1;\n        prevCharCode = lineText.charCodeAt(1);\n        prevCharCodeClass = classifier.get(prevCharCode);\n        startOffset++;\n    }\n    for (let i = startOffset; i < len; i++) {\n        const charStartOffset = i;\n        const charCode = lineText.charCodeAt(i);\n        let charCodeClass;\n        let charWidth;\n        if (strings.isHighSurrogate(charCode)) {\n            // A surrogate pair must always be considered as a single unit, so it is never to be broken\n            i++;\n            charCodeClass = 0 /* CharacterClass.NONE */;\n            charWidth = 2;\n        }\n        else {\n            charCodeClass = classifier.get(charCode);\n            charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n        }\n        if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\n            breakOffset = charStartOffset;\n            breakOffsetVisibleColumn = visibleColumn;\n        }\n        visibleColumn += charWidth;\n        // check if adding character at `i` will go over the breaking column\n        if (visibleColumn > breakingColumn) {\n            // We need to break at least before character at `i`:\n            if (breakOffset === 0 || visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n                // Cannot break at `breakOffset`, must break at `i`\n                breakOffset = charStartOffset;\n                breakOffsetVisibleColumn = visibleColumn - charWidth;\n            }\n            breakingOffsets[breakingOffsetsCount] = breakOffset;\n            breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n            breakingOffsetsCount++;\n            breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n            breakOffset = 0;\n        }\n        prevCharCode = charCode;\n        prevCharCodeClass = charCodeClass;\n    }\n    if (breakingOffsetsCount === 0 && (!injectedTexts || injectedTexts.length === 0)) {\n        return null;\n    }\n    // Add last segment\n    breakingOffsets[breakingOffsetsCount] = len;\n    breakingOffsetsVisibleColumn[breakingOffsetsCount] = visibleColumn;\n    return new ModelLineProjectionData(injectionOffsets, injectionOptions, breakingOffsets, breakingOffsetsVisibleColumn, wrappedTextIndentLength);\n}\nfunction computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar) {\n    if (charCode === 9 /* CharCode.Tab */) {\n        return (tabSize - (visibleColumn % tabSize));\n    }\n    if (strings.isFullWidthCharacter(charCode)) {\n        return columnsForFullWidthChar;\n    }\n    if (charCode < 32) {\n        // when using `editor.renderControlCharacters`, the substitutions are often wide\n        return columnsForFullWidthChar;\n    }\n    return 1;\n}\nfunction tabCharacterWidth(visibleColumn, tabSize) {\n    return (tabSize - (visibleColumn % tabSize));\n}\n/**\n * Kinsoku Shori : Don't break after a leading character, like an open bracket\n * Kinsoku Shori : Don't break before a trailing character, like a period\n */\nfunction canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass) {\n    return (charCode !== 32 /* CharCode.Space */\n        && ((prevCharCodeClass === 2 /* CharacterClass.BREAK_AFTER */ && charCodeClass !== 2 /* CharacterClass.BREAK_AFTER */) // break at the end of multiple BREAK_AFTER\n            || (prevCharCodeClass !== 1 /* CharacterClass.BREAK_BEFORE */ && charCodeClass === 1 /* CharacterClass.BREAK_BEFORE */) // break at the start of multiple BREAK_BEFORE\n            || (prevCharCodeClass === 3 /* CharacterClass.BREAK_IDEOGRAPHIC */ && charCodeClass !== 2 /* CharacterClass.BREAK_AFTER */)\n            || (charCodeClass === 3 /* CharacterClass.BREAK_IDEOGRAPHIC */ && prevCharCodeClass !== 1 /* CharacterClass.BREAK_BEFORE */)));\n}\nfunction computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n    let wrappedTextIndentLength = 0;\n    if (wrappingIndent !== 0 /* WrappingIndent.None */) {\n        const firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineText);\n        if (firstNonWhitespaceIndex !== -1) {\n            // Track existing indent\n            for (let i = 0; i < firstNonWhitespaceIndex; i++) {\n                const charWidth = (lineText.charCodeAt(i) === 9 /* CharCode.Tab */ ? tabCharacterWidth(wrappedTextIndentLength, tabSize) : 1);\n                wrappedTextIndentLength += charWidth;\n            }\n            // Increase indent of continuation lines, if desired\n            const numberOfAdditionalTabs = (wrappingIndent === 3 /* WrappingIndent.DeepIndent */ ? 2 : wrappingIndent === 2 /* WrappingIndent.Indent */ ? 1 : 0);\n            for (let i = 0; i < numberOfAdditionalTabs; i++) {\n                const charWidth = tabCharacterWidth(wrappedTextIndentLength, tabSize);\n                wrappedTextIndentLength += charWidth;\n            }\n            // Force sticking to beginning of line if no character would fit except for the indentation\n            if (wrappedTextIndentLength + columnsForFullWidthChar > firstLineBreakColumn) {\n                wrappedTextIndentLength = 0;\n            }\n        }\n    }\n    return wrappedTextIndentLength;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class ColorZone {\n    constructor(from, to, colorId) {\n        this._colorZoneBrand = undefined;\n        this.from = from | 0;\n        this.to = to | 0;\n        this.colorId = colorId | 0;\n    }\n    static compare(a, b) {\n        if (a.colorId === b.colorId) {\n            if (a.from === b.from) {\n                return a.to - b.to;\n            }\n            return a.from - b.from;\n        }\n        return a.colorId - b.colorId;\n    }\n}\n/**\n * A zone in the overview ruler\n */\nexport class OverviewRulerZone {\n    constructor(startLineNumber, endLineNumber, heightInLines, color) {\n        this._overviewRulerZoneBrand = undefined;\n        this.startLineNumber = startLineNumber;\n        this.endLineNumber = endLineNumber;\n        this.heightInLines = heightInLines;\n        this.color = color;\n        this._colorZone = null;\n    }\n    static compare(a, b) {\n        if (a.color === b.color) {\n            if (a.startLineNumber === b.startLineNumber) {\n                if (a.heightInLines === b.heightInLines) {\n                    return a.endLineNumber - b.endLineNumber;\n                }\n                return a.heightInLines - b.heightInLines;\n            }\n            return a.startLineNumber - b.startLineNumber;\n        }\n        return a.color < b.color ? -1 : 1;\n    }\n    setColorZone(colorZone) {\n        this._colorZone = colorZone;\n    }\n    getColorZones() {\n        return this._colorZone;\n    }\n}\nexport class OverviewZoneManager {\n    constructor(getVerticalOffsetForLine) {\n        this._getVerticalOffsetForLine = getVerticalOffsetForLine;\n        this._zones = [];\n        this._colorZonesInvalid = false;\n        this._lineHeight = 0;\n        this._domWidth = 0;\n        this._domHeight = 0;\n        this._outerHeight = 0;\n        this._pixelRatio = 1;\n        this._lastAssignedId = 0;\n        this._color2Id = Object.create(null);\n        this._id2Color = [];\n    }\n    getId2Color() {\n        return this._id2Color;\n    }\n    setZones(newZones) {\n        this._zones = newZones;\n        this._zones.sort(OverviewRulerZone.compare);\n    }\n    setLineHeight(lineHeight) {\n        if (this._lineHeight === lineHeight) {\n            return false;\n        }\n        this._lineHeight = lineHeight;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    setPixelRatio(pixelRatio) {\n        this._pixelRatio = pixelRatio;\n        this._colorZonesInvalid = true;\n    }\n    getDOMWidth() {\n        return this._domWidth;\n    }\n    getCanvasWidth() {\n        return this._domWidth * this._pixelRatio;\n    }\n    setDOMWidth(width) {\n        if (this._domWidth === width) {\n            return false;\n        }\n        this._domWidth = width;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    getDOMHeight() {\n        return this._domHeight;\n    }\n    getCanvasHeight() {\n        return this._domHeight * this._pixelRatio;\n    }\n    setDOMHeight(height) {\n        if (this._domHeight === height) {\n            return false;\n        }\n        this._domHeight = height;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    getOuterHeight() {\n        return this._outerHeight;\n    }\n    setOuterHeight(outerHeight) {\n        if (this._outerHeight === outerHeight) {\n            return false;\n        }\n        this._outerHeight = outerHeight;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    resolveColorZones() {\n        const colorZonesInvalid = this._colorZonesInvalid;\n        const lineHeight = Math.floor(this._lineHeight);\n        const totalHeight = Math.floor(this.getCanvasHeight());\n        const outerHeight = Math.floor(this._outerHeight);\n        const heightRatio = totalHeight / outerHeight;\n        const halfMinimumHeight = Math.floor(4 /* Constants.MINIMUM_HEIGHT */ * this._pixelRatio / 2);\n        const allColorZones = [];\n        for (let i = 0, len = this._zones.length; i < len; i++) {\n            const zone = this._zones[i];\n            if (!colorZonesInvalid) {\n                const colorZone = zone.getColorZones();\n                if (colorZone) {\n                    allColorZones.push(colorZone);\n                    continue;\n                }\n            }\n            const offset1 = this._getVerticalOffsetForLine(zone.startLineNumber);\n            const offset2 = (zone.heightInLines === 0\n                ? this._getVerticalOffsetForLine(zone.endLineNumber) + lineHeight\n                : offset1 + zone.heightInLines * lineHeight);\n            const y1 = Math.floor(heightRatio * offset1);\n            const y2 = Math.floor(heightRatio * offset2);\n            let ycenter = Math.floor((y1 + y2) / 2);\n            let halfHeight = (y2 - ycenter);\n            if (halfHeight < halfMinimumHeight) {\n                halfHeight = halfMinimumHeight;\n            }\n            if (ycenter - halfHeight < 0) {\n                ycenter = halfHeight;\n            }\n            if (ycenter + halfHeight > totalHeight) {\n                ycenter = totalHeight - halfHeight;\n            }\n            const color = zone.color;\n            let colorId = this._color2Id[color];\n            if (!colorId) {\n                colorId = (++this._lastAssignedId);\n                this._color2Id[color] = colorId;\n                this._id2Color[colorId] = color;\n            }\n            const colorZone = new ColorZone(ycenter - halfHeight, ycenter + halfHeight, colorId);\n            zone.setColorZone(colorZone);\n            allColorZones.push(colorZone);\n        }\n        this._colorZonesInvalid = false;\n        allColorZones.sort(ColorZone.compare);\n        return allColorZones;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { EditorTheme } from '../editorTheme.js';\nexport class ViewContext {\n    constructor(configuration, theme, model) {\n        this.configuration = configuration;\n        this.theme = new EditorTheme(theme);\n        this.viewModel = model;\n        this.viewLayout = model.viewLayout;\n    }\n    addEventHandler(eventHandler) {\n        this.viewModel.addViewEventHandler(eventHandler);\n    }\n    removeEventHandler(eventHandler) {\n        this.viewModel.removeViewEventHandler(eventHandler);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { InlineDecoration, ViewModelDecoration } from '../viewModel.js';\nimport { filterValidationDecorations } from '../config/editorOptions.js';\nexport class ViewModelDecorations {\n    constructor(editorId, model, configuration, linesCollection, coordinatesConverter) {\n        this.editorId = editorId;\n        this.model = model;\n        this.configuration = configuration;\n        this._linesCollection = linesCollection;\n        this._coordinatesConverter = coordinatesConverter;\n        this._decorationsCache = Object.create(null);\n        this._cachedModelDecorationsResolver = null;\n        this._cachedModelDecorationsResolverViewRange = null;\n    }\n    _clearCachedModelDecorationsResolver() {\n        this._cachedModelDecorationsResolver = null;\n        this._cachedModelDecorationsResolverViewRange = null;\n    }\n    dispose() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    reset() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    onModelDecorationsChanged() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    onLineMappingChanged() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    _getOrCreateViewModelDecoration(modelDecoration) {\n        const id = modelDecoration.id;\n        let r = this._decorationsCache[id];\n        if (!r) {\n            const modelRange = modelDecoration.range;\n            const options = modelDecoration.options;\n            let viewRange;\n            if (options.isWholeLine) {\n                const start = this._coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.startLineNumber, 1), 0 /* PositionAffinity.Left */);\n                const end = this._coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.endLineNumber, this.model.getLineMaxColumn(modelRange.endLineNumber)), 1 /* PositionAffinity.Right */);\n                viewRange = new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n            }\n            else {\n                // For backwards compatibility reasons, we want injected text before any decoration.\n                // Thus, move decorations to the right.\n                viewRange = this._coordinatesConverter.convertModelRangeToViewRange(modelRange, 1 /* PositionAffinity.Right */);\n            }\n            r = new ViewModelDecoration(viewRange, options);\n            this._decorationsCache[id] = r;\n        }\n        return r;\n    }\n    getDecorationsViewportData(viewRange) {\n        let cacheIsValid = (this._cachedModelDecorationsResolver !== null);\n        cacheIsValid = cacheIsValid && (viewRange.equalsRange(this._cachedModelDecorationsResolverViewRange));\n        if (!cacheIsValid) {\n            this._cachedModelDecorationsResolver = this._getDecorationsInRange(viewRange);\n            this._cachedModelDecorationsResolverViewRange = viewRange;\n        }\n        return this._cachedModelDecorationsResolver;\n    }\n    getInlineDecorationsOnLine(lineNumber) {\n        const range = new Range(lineNumber, this._linesCollection.getViewLineMinColumn(lineNumber), lineNumber, this._linesCollection.getViewLineMaxColumn(lineNumber));\n        return this._getDecorationsInRange(range).inlineDecorations[0];\n    }\n    _getDecorationsInRange(viewRange) {\n        const modelDecorations = this._linesCollection.getDecorationsInRange(viewRange, this.editorId, filterValidationDecorations(this.configuration.options));\n        const startLineNumber = viewRange.startLineNumber;\n        const endLineNumber = viewRange.endLineNumber;\n        const decorationsInViewport = [];\n        let decorationsInViewportLen = 0;\n        const inlineDecorations = [];\n        for (let j = startLineNumber; j <= endLineNumber; j++) {\n            inlineDecorations[j - startLineNumber] = [];\n        }\n        for (let i = 0, len = modelDecorations.length; i < len; i++) {\n            const modelDecoration = modelDecorations[i];\n            const decorationOptions = modelDecoration.options;\n            if (!isModelDecorationVisible(this.model, modelDecoration)) {\n                continue;\n            }\n            const viewModelDecoration = this._getOrCreateViewModelDecoration(modelDecoration);\n            const viewRange = viewModelDecoration.range;\n            decorationsInViewport[decorationsInViewportLen++] = viewModelDecoration;\n            if (decorationOptions.inlineClassName) {\n                const inlineDecoration = new InlineDecoration(viewRange, decorationOptions.inlineClassName, decorationOptions.inlineClassNameAffectsLetterSpacing ? 3 /* InlineDecorationType.RegularAffectingLetterSpacing */ : 0 /* InlineDecorationType.Regular */);\n                const intersectedStartLineNumber = Math.max(startLineNumber, viewRange.startLineNumber);\n                const intersectedEndLineNumber = Math.min(endLineNumber, viewRange.endLineNumber);\n                for (let j = intersectedStartLineNumber; j <= intersectedEndLineNumber; j++) {\n                    inlineDecorations[j - startLineNumber].push(inlineDecoration);\n                }\n            }\n            if (decorationOptions.beforeContentClassName) {\n                if (startLineNumber <= viewRange.startLineNumber && viewRange.startLineNumber <= endLineNumber) {\n                    const inlineDecoration = new InlineDecoration(new Range(viewRange.startLineNumber, viewRange.startColumn, viewRange.startLineNumber, viewRange.startColumn), decorationOptions.beforeContentClassName, 1 /* InlineDecorationType.Before */);\n                    inlineDecorations[viewRange.startLineNumber - startLineNumber].push(inlineDecoration);\n                }\n            }\n            if (decorationOptions.afterContentClassName) {\n                if (startLineNumber <= viewRange.endLineNumber && viewRange.endLineNumber <= endLineNumber) {\n                    const inlineDecoration = new InlineDecoration(new Range(viewRange.endLineNumber, viewRange.endColumn, viewRange.endLineNumber, viewRange.endColumn), decorationOptions.afterContentClassName, 2 /* InlineDecorationType.After */);\n                    inlineDecorations[viewRange.endLineNumber - startLineNumber].push(inlineDecoration);\n                }\n            }\n        }\n        return {\n            decorations: decorationsInViewport,\n            inlineDecorations: inlineDecorations\n        };\n    }\n}\nexport function isModelDecorationVisible(model, decoration) {\n    if (decoration.options.hideInCommentTokens && isModelDecorationInComment(model, decoration)) {\n        return false;\n    }\n    if (decoration.options.hideInStringTokens && isModelDecorationInString(model, decoration)) {\n        return false;\n    }\n    return true;\n}\nexport function isModelDecorationInComment(model, decoration) {\n    return testTokensInRange(model, decoration.range, (tokenType) => tokenType === 1 /* StandardTokenType.Comment */);\n}\nexport function isModelDecorationInString(model, decoration) {\n    return testTokensInRange(model, decoration.range, (tokenType) => tokenType === 2 /* StandardTokenType.String */);\n}\n/**\n * Calls the callback for every token that intersects the range.\n * If the callback returns `false`, iteration stops and `false` is returned.\n * Otherwise, `true` is returned.\n */\nfunction testTokensInRange(model, range, callback) {\n    for (let lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {\n        const lineTokens = model.tokenization.getLineTokens(lineNumber);\n        const isFirstLine = lineNumber === range.startLineNumber;\n        const isEndLine = lineNumber === range.endLineNumber;\n        let tokenIdx = isFirstLine ? lineTokens.findTokenIndexAtOffset(range.startColumn - 1) : 0;\n        while (tokenIdx < lineTokens.getCount()) {\n            if (isEndLine) {\n                const startOffset = lineTokens.getStartOffset(tokenIdx);\n                if (startOffset > range.endColumn - 1) {\n                    break;\n                }\n            }\n            const callbackResult = callback(lineTokens.getStandardTokenType(tokenIdx));\n            if (!callbackResult) {\n                return false;\n            }\n            tokenIdx++;\n        }\n    }\n    return true;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nclass PendingChanges {\n    constructor() {\n        this._hasPending = false;\n        this._inserts = [];\n        this._changes = [];\n        this._removes = [];\n    }\n    insert(x) {\n        this._hasPending = true;\n        this._inserts.push(x);\n    }\n    change(x) {\n        this._hasPending = true;\n        this._changes.push(x);\n    }\n    remove(x) {\n        this._hasPending = true;\n        this._removes.push(x);\n    }\n    mustCommit() {\n        return this._hasPending;\n    }\n    commit(linesLayout) {\n        if (!this._hasPending) {\n            return;\n        }\n        const inserts = this._inserts;\n        const changes = this._changes;\n        const removes = this._removes;\n        this._hasPending = false;\n        this._inserts = [];\n        this._changes = [];\n        this._removes = [];\n        linesLayout._commitPendingChanges(inserts, changes, removes);\n    }\n}\nexport class EditorWhitespace {\n    constructor(id, afterLineNumber, ordinal, height, minWidth) {\n        this.id = id;\n        this.afterLineNumber = afterLineNumber;\n        this.ordinal = ordinal;\n        this.height = height;\n        this.minWidth = minWidth;\n        this.prefixSum = 0;\n    }\n}\n/**\n * Layouting of objects that take vertical space (by having a height) and push down other objects.\n *\n * These objects are basically either text (lines) or spaces between those lines (whitespaces).\n * This provides commodity operations for working with lines that contain whitespace that pushes lines lower (vertically).\n */\nexport class LinesLayout {\n    constructor(lineCount, lineHeight, paddingTop, paddingBottom) {\n        this._instanceId = strings.singleLetterHash(++LinesLayout.INSTANCE_COUNT);\n        this._pendingChanges = new PendingChanges();\n        this._lastWhitespaceId = 0;\n        this._arr = [];\n        this._prefixSumValidIndex = -1;\n        this._minWidth = -1; /* marker for not being computed */\n        this._lineCount = lineCount;\n        this._lineHeight = lineHeight;\n        this._paddingTop = paddingTop;\n        this._paddingBottom = paddingBottom;\n    }\n    /**\n     * Find the insertion index for a new value inside a sorted array of values.\n     * If the value is already present in the sorted array, the insertion index will be after the already existing value.\n     */\n    static findInsertionIndex(arr, afterLineNumber, ordinal) {\n        let low = 0;\n        let high = arr.length;\n        while (low < high) {\n            const mid = ((low + high) >>> 1);\n            if (afterLineNumber === arr[mid].afterLineNumber) {\n                if (ordinal < arr[mid].ordinal) {\n                    high = mid;\n                }\n                else {\n                    low = mid + 1;\n                }\n            }\n            else if (afterLineNumber < arr[mid].afterLineNumber) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        return low;\n    }\n    /**\n     * Change the height of a line in pixels.\n     */\n    setLineHeight(lineHeight) {\n        this._checkPendingChanges();\n        this._lineHeight = lineHeight;\n    }\n    /**\n     * Changes the padding used to calculate vertical offsets.\n     */\n    setPadding(paddingTop, paddingBottom) {\n        this._paddingTop = paddingTop;\n        this._paddingBottom = paddingBottom;\n    }\n    /**\n     * Set the number of lines.\n     *\n     * @param lineCount New number of lines.\n     */\n    onFlushed(lineCount) {\n        this._checkPendingChanges();\n        this._lineCount = lineCount;\n    }\n    changeWhitespace(callback) {\n        let hadAChange = false;\n        try {\n            const accessor = {\n                insertWhitespace: (afterLineNumber, ordinal, heightInPx, minWidth) => {\n                    hadAChange = true;\n                    afterLineNumber = afterLineNumber | 0;\n                    ordinal = ordinal | 0;\n                    heightInPx = heightInPx | 0;\n                    minWidth = minWidth | 0;\n                    const id = this._instanceId + (++this._lastWhitespaceId);\n                    this._pendingChanges.insert(new EditorWhitespace(id, afterLineNumber, ordinal, heightInPx, minWidth));\n                    return id;\n                },\n                changeOneWhitespace: (id, newAfterLineNumber, newHeight) => {\n                    hadAChange = true;\n                    newAfterLineNumber = newAfterLineNumber | 0;\n                    newHeight = newHeight | 0;\n                    this._pendingChanges.change({ id, newAfterLineNumber, newHeight });\n                },\n                removeWhitespace: (id) => {\n                    hadAChange = true;\n                    this._pendingChanges.remove({ id });\n                }\n            };\n            callback(accessor);\n        }\n        finally {\n            this._pendingChanges.commit(this);\n        }\n        return hadAChange;\n    }\n    _commitPendingChanges(inserts, changes, removes) {\n        if (inserts.length > 0 || removes.length > 0) {\n            this._minWidth = -1; /* marker for not being computed */\n        }\n        if (inserts.length + changes.length + removes.length <= 1) {\n            // when only one thing happened, handle it \"delicately\"\n            for (const insert of inserts) {\n                this._insertWhitespace(insert);\n            }\n            for (const change of changes) {\n                this._changeOneWhitespace(change.id, change.newAfterLineNumber, change.newHeight);\n            }\n            for (const remove of removes) {\n                const index = this._findWhitespaceIndex(remove.id);\n                if (index === -1) {\n                    continue;\n                }\n                this._removeWhitespace(index);\n            }\n            return;\n        }\n        // simply rebuild the entire datastructure\n        const toRemove = new Set();\n        for (const remove of removes) {\n            toRemove.add(remove.id);\n        }\n        const toChange = new Map();\n        for (const change of changes) {\n            toChange.set(change.id, change);\n        }\n        const applyRemoveAndChange = (whitespaces) => {\n            const result = [];\n            for (const whitespace of whitespaces) {\n                if (toRemove.has(whitespace.id)) {\n                    continue;\n                }\n                if (toChange.has(whitespace.id)) {\n                    const change = toChange.get(whitespace.id);\n                    whitespace.afterLineNumber = change.newAfterLineNumber;\n                    whitespace.height = change.newHeight;\n                }\n                result.push(whitespace);\n            }\n            return result;\n        };\n        const result = applyRemoveAndChange(this._arr).concat(applyRemoveAndChange(inserts));\n        result.sort((a, b) => {\n            if (a.afterLineNumber === b.afterLineNumber) {\n                return a.ordinal - b.ordinal;\n            }\n            return a.afterLineNumber - b.afterLineNumber;\n        });\n        this._arr = result;\n        this._prefixSumValidIndex = -1;\n    }\n    _checkPendingChanges() {\n        if (this._pendingChanges.mustCommit()) {\n            this._pendingChanges.commit(this);\n        }\n    }\n    _insertWhitespace(whitespace) {\n        const insertIndex = LinesLayout.findInsertionIndex(this._arr, whitespace.afterLineNumber, whitespace.ordinal);\n        this._arr.splice(insertIndex, 0, whitespace);\n        this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, insertIndex - 1);\n    }\n    _findWhitespaceIndex(id) {\n        const arr = this._arr;\n        for (let i = 0, len = arr.length; i < len; i++) {\n            if (arr[i].id === id) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    _changeOneWhitespace(id, newAfterLineNumber, newHeight) {\n        const index = this._findWhitespaceIndex(id);\n        if (index === -1) {\n            return;\n        }\n        if (this._arr[index].height !== newHeight) {\n            this._arr[index].height = newHeight;\n            this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, index - 1);\n        }\n        if (this._arr[index].afterLineNumber !== newAfterLineNumber) {\n            // `afterLineNumber` changed for this whitespace\n            // Record old whitespace\n            const whitespace = this._arr[index];\n            // Since changing `afterLineNumber` can trigger a reordering, we're gonna remove this whitespace\n            this._removeWhitespace(index);\n            whitespace.afterLineNumber = newAfterLineNumber;\n            // And add it again\n            this._insertWhitespace(whitespace);\n        }\n    }\n    _removeWhitespace(removeIndex) {\n        this._arr.splice(removeIndex, 1);\n        this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, removeIndex - 1);\n    }\n    /**\n     * Notify the layouter that lines have been deleted (a continuous zone of lines).\n     *\n     * @param fromLineNumber The line number at which the deletion started, inclusive\n     * @param toLineNumber The line number at which the deletion ended, inclusive\n     */\n    onLinesDeleted(fromLineNumber, toLineNumber) {\n        this._checkPendingChanges();\n        fromLineNumber = fromLineNumber | 0;\n        toLineNumber = toLineNumber | 0;\n        this._lineCount -= (toLineNumber - fromLineNumber + 1);\n        for (let i = 0, len = this._arr.length; i < len; i++) {\n            const afterLineNumber = this._arr[i].afterLineNumber;\n            if (fromLineNumber <= afterLineNumber && afterLineNumber <= toLineNumber) {\n                // The line this whitespace was after has been deleted\n                //  => move whitespace to before first deleted line\n                this._arr[i].afterLineNumber = fromLineNumber - 1;\n            }\n            else if (afterLineNumber > toLineNumber) {\n                // The line this whitespace was after has been moved up\n                //  => move whitespace up\n                this._arr[i].afterLineNumber -= (toLineNumber - fromLineNumber + 1);\n            }\n        }\n    }\n    /**\n     * Notify the layouter that lines have been inserted (a continuous zone of lines).\n     *\n     * @param fromLineNumber The line number at which the insertion started, inclusive\n     * @param toLineNumber The line number at which the insertion ended, inclusive.\n     */\n    onLinesInserted(fromLineNumber, toLineNumber) {\n        this._checkPendingChanges();\n        fromLineNumber = fromLineNumber | 0;\n        toLineNumber = toLineNumber | 0;\n        this._lineCount += (toLineNumber - fromLineNumber + 1);\n        for (let i = 0, len = this._arr.length; i < len; i++) {\n            const afterLineNumber = this._arr[i].afterLineNumber;\n            if (fromLineNumber <= afterLineNumber) {\n                this._arr[i].afterLineNumber += (toLineNumber - fromLineNumber + 1);\n            }\n        }\n    }\n    /**\n     * Get the sum of all the whitespaces.\n     */\n    getWhitespacesTotalHeight() {\n        this._checkPendingChanges();\n        if (this._arr.length === 0) {\n            return 0;\n        }\n        return this.getWhitespacesAccumulatedHeight(this._arr.length - 1);\n    }\n    /**\n     * Return the sum of the heights of the whitespaces at [0..index].\n     * This includes the whitespace at `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.\n     */\n    getWhitespacesAccumulatedHeight(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        let startIndex = Math.max(0, this._prefixSumValidIndex + 1);\n        if (startIndex === 0) {\n            this._arr[0].prefixSum = this._arr[0].height;\n            startIndex++;\n        }\n        for (let i = startIndex; i <= index; i++) {\n            this._arr[i].prefixSum = this._arr[i - 1].prefixSum + this._arr[i].height;\n        }\n        this._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, index);\n        return this._arr[index].prefixSum;\n    }\n    /**\n     * Get the sum of heights for all objects.\n     *\n     * @return The sum of heights for all objects.\n     */\n    getLinesTotalHeight() {\n        this._checkPendingChanges();\n        const linesHeight = this._lineHeight * this._lineCount;\n        const whitespacesHeight = this.getWhitespacesTotalHeight();\n        return linesHeight + whitespacesHeight + this._paddingTop + this._paddingBottom;\n    }\n    /**\n     * Returns the accumulated height of whitespaces before the given line number.\n     *\n     * @param lineNumber The line number\n     */\n    getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        const lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n        if (lastWhitespaceBeforeLineNumber === -1) {\n            return 0;\n        }\n        return this.getWhitespacesAccumulatedHeight(lastWhitespaceBeforeLineNumber);\n    }\n    _findLastWhitespaceBeforeLineNumber(lineNumber) {\n        lineNumber = lineNumber | 0;\n        // Find the whitespace before line number\n        const arr = this._arr;\n        let low = 0;\n        let high = arr.length - 1;\n        while (low <= high) {\n            const delta = (high - low) | 0;\n            const halfDelta = (delta / 2) | 0;\n            const mid = (low + halfDelta) | 0;\n            if (arr[mid].afterLineNumber < lineNumber) {\n                if (mid + 1 >= arr.length || arr[mid + 1].afterLineNumber >= lineNumber) {\n                    return mid;\n                }\n                else {\n                    low = (mid + 1) | 0;\n                }\n            }\n            else {\n                high = (mid - 1) | 0;\n            }\n        }\n        return -1;\n    }\n    _findFirstWhitespaceAfterLineNumber(lineNumber) {\n        lineNumber = lineNumber | 0;\n        const lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n        const firstWhitespaceAfterLineNumber = lastWhitespaceBeforeLineNumber + 1;\n        if (firstWhitespaceAfterLineNumber < this._arr.length) {\n            return firstWhitespaceAfterLineNumber;\n        }\n        return -1;\n    }\n    /**\n     * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.\n     * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.\n     */\n    getFirstWhitespaceIndexAfterLineNumber(lineNumber) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        return this._findFirstWhitespaceAfterLineNumber(lineNumber);\n    }\n    /**\n     * Get the vertical offset (the sum of heights for all objects above) a certain line number.\n     *\n     * @param lineNumber The line number\n     * @return The sum of heights for all objects above `lineNumber`.\n     */\n    getVerticalOffsetForLineNumber(lineNumber, includeViewZones = false) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        let previousLinesHeight;\n        if (lineNumber > 1) {\n            previousLinesHeight = this._lineHeight * (lineNumber - 1);\n        }\n        else {\n            previousLinesHeight = 0;\n        }\n        const previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber - (includeViewZones ? 1 : 0));\n        return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    /**\n     * Get the vertical offset (the sum of heights for all objects above) a certain line number.\n     *\n     * @param lineNumber The line number\n     * @return The sum of heights for all objects above `lineNumber`.\n     */\n    getVerticalOffsetAfterLineNumber(lineNumber, includeViewZones = false) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        const previousLinesHeight = this._lineHeight * lineNumber;\n        const previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber + (includeViewZones ? 1 : 0));\n        return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    /**\n     * The maximum min width for all whitespaces.\n     */\n    getWhitespaceMinWidth() {\n        this._checkPendingChanges();\n        if (this._minWidth === -1) {\n            let minWidth = 0;\n            for (let i = 0, len = this._arr.length; i < len; i++) {\n                minWidth = Math.max(minWidth, this._arr[i].minWidth);\n            }\n            this._minWidth = minWidth;\n        }\n        return this._minWidth;\n    }\n    /**\n     * Check if `verticalOffset` is below all lines.\n     */\n    isAfterLines(verticalOffset) {\n        this._checkPendingChanges();\n        const totalHeight = this.getLinesTotalHeight();\n        return verticalOffset > totalHeight;\n    }\n    isInTopPadding(verticalOffset) {\n        if (this._paddingTop === 0) {\n            return false;\n        }\n        this._checkPendingChanges();\n        return (verticalOffset < this._paddingTop);\n    }\n    isInBottomPadding(verticalOffset) {\n        if (this._paddingBottom === 0) {\n            return false;\n        }\n        this._checkPendingChanges();\n        const totalHeight = this.getLinesTotalHeight();\n        return (verticalOffset >= totalHeight - this._paddingBottom);\n    }\n    /**\n     * Find the first line number that is at or after vertical offset `verticalOffset`.\n     * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then\n     * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.\n     *\n     * @param verticalOffset The vertical offset to search at.\n     * @return The line number at or after vertical offset `verticalOffset`.\n     */\n    getLineNumberAtOrAfterVerticalOffset(verticalOffset) {\n        this._checkPendingChanges();\n        verticalOffset = verticalOffset | 0;\n        if (verticalOffset < 0) {\n            return 1;\n        }\n        const linesCount = this._lineCount | 0;\n        const lineHeight = this._lineHeight;\n        let minLineNumber = 1;\n        let maxLineNumber = linesCount;\n        while (minLineNumber < maxLineNumber) {\n            const midLineNumber = ((minLineNumber + maxLineNumber) / 2) | 0;\n            const midLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(midLineNumber) | 0;\n            if (verticalOffset >= midLineNumberVerticalOffset + lineHeight) {\n                // vertical offset is after mid line number\n                minLineNumber = midLineNumber + 1;\n            }\n            else if (verticalOffset >= midLineNumberVerticalOffset) {\n                // Hit\n                return midLineNumber;\n            }\n            else {\n                // vertical offset is before mid line number, but mid line number could still be what we're searching for\n                maxLineNumber = midLineNumber;\n            }\n        }\n        if (minLineNumber > linesCount) {\n            return linesCount;\n        }\n        return minLineNumber;\n    }\n    /**\n     * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.\n     *\n     * @param verticalOffset1 The beginning of the viewport.\n     * @param verticalOffset2 The end of the viewport.\n     * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.\n     */\n    getLinesViewportData(verticalOffset1, verticalOffset2) {\n        this._checkPendingChanges();\n        verticalOffset1 = verticalOffset1 | 0;\n        verticalOffset2 = verticalOffset2 | 0;\n        const lineHeight = this._lineHeight;\n        // Find first line number\n        // We don't live in a perfect world, so the line number might start before or after verticalOffset1\n        const startLineNumber = this.getLineNumberAtOrAfterVerticalOffset(verticalOffset1) | 0;\n        const startLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(startLineNumber) | 0;\n        let endLineNumber = this._lineCount | 0;\n        // Also keep track of what whitespace we've got\n        let whitespaceIndex = this.getFirstWhitespaceIndexAfterLineNumber(startLineNumber) | 0;\n        const whitespaceCount = this.getWhitespacesCount() | 0;\n        let currentWhitespaceHeight;\n        let currentWhitespaceAfterLineNumber;\n        if (whitespaceIndex === -1) {\n            whitespaceIndex = whitespaceCount;\n            currentWhitespaceAfterLineNumber = endLineNumber + 1;\n            currentWhitespaceHeight = 0;\n        }\n        else {\n            currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n            currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n        }\n        let currentVerticalOffset = startLineNumberVerticalOffset;\n        let currentLineRelativeOffset = currentVerticalOffset;\n        // IE (all versions) cannot handle units above about 1,533,908 px, so every 500k pixels bring numbers down\n        const STEP_SIZE = 500000;\n        let bigNumbersDelta = 0;\n        if (startLineNumberVerticalOffset >= STEP_SIZE) {\n            // Compute a delta that guarantees that lines are positioned at `lineHeight` increments\n            bigNumbersDelta = Math.floor(startLineNumberVerticalOffset / STEP_SIZE) * STEP_SIZE;\n            bigNumbersDelta = Math.floor(bigNumbersDelta / lineHeight) * lineHeight;\n            currentLineRelativeOffset -= bigNumbersDelta;\n        }\n        const linesOffsets = [];\n        const verticalCenter = verticalOffset1 + (verticalOffset2 - verticalOffset1) / 2;\n        let centeredLineNumber = -1;\n        // Figure out how far the lines go\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            if (centeredLineNumber === -1) {\n                const currentLineTop = currentVerticalOffset;\n                const currentLineBottom = currentVerticalOffset + lineHeight;\n                if ((currentLineTop <= verticalCenter && verticalCenter < currentLineBottom) || currentLineTop > verticalCenter) {\n                    centeredLineNumber = lineNumber;\n                }\n            }\n            // Count current line height in the vertical offsets\n            currentVerticalOffset += lineHeight;\n            linesOffsets[lineNumber - startLineNumber] = currentLineRelativeOffset;\n            // Next line starts immediately after this one\n            currentLineRelativeOffset += lineHeight;\n            while (currentWhitespaceAfterLineNumber === lineNumber) {\n                // Push down next line with the height of the current whitespace\n                currentLineRelativeOffset += currentWhitespaceHeight;\n                // Count current whitespace in the vertical offsets\n                currentVerticalOffset += currentWhitespaceHeight;\n                whitespaceIndex++;\n                if (whitespaceIndex >= whitespaceCount) {\n                    currentWhitespaceAfterLineNumber = endLineNumber + 1;\n                }\n                else {\n                    currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n                    currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n                }\n            }\n            if (currentVerticalOffset >= verticalOffset2) {\n                // We have covered the entire viewport area, time to stop\n                endLineNumber = lineNumber;\n                break;\n            }\n        }\n        if (centeredLineNumber === -1) {\n            centeredLineNumber = endLineNumber;\n        }\n        const endLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(endLineNumber) | 0;\n        let completelyVisibleStartLineNumber = startLineNumber;\n        let completelyVisibleEndLineNumber = endLineNumber;\n        if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n            if (startLineNumberVerticalOffset < verticalOffset1) {\n                completelyVisibleStartLineNumber++;\n            }\n        }\n        if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n            if (endLineNumberVerticalOffset + lineHeight > verticalOffset2) {\n                completelyVisibleEndLineNumber--;\n            }\n        }\n        return {\n            bigNumbersDelta: bigNumbersDelta,\n            startLineNumber: startLineNumber,\n            endLineNumber: endLineNumber,\n            relativeVerticalOffset: linesOffsets,\n            centeredLineNumber: centeredLineNumber,\n            completelyVisibleStartLineNumber: completelyVisibleStartLineNumber,\n            completelyVisibleEndLineNumber: completelyVisibleEndLineNumber\n        };\n    }\n    getVerticalOffsetForWhitespaceIndex(whitespaceIndex) {\n        this._checkPendingChanges();\n        whitespaceIndex = whitespaceIndex | 0;\n        const afterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex);\n        let previousLinesHeight;\n        if (afterLineNumber >= 1) {\n            previousLinesHeight = this._lineHeight * afterLineNumber;\n        }\n        else {\n            previousLinesHeight = 0;\n        }\n        let previousWhitespacesHeight;\n        if (whitespaceIndex > 0) {\n            previousWhitespacesHeight = this.getWhitespacesAccumulatedHeight(whitespaceIndex - 1);\n        }\n        else {\n            previousWhitespacesHeight = 0;\n        }\n        return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset) {\n        this._checkPendingChanges();\n        verticalOffset = verticalOffset | 0;\n        let minWhitespaceIndex = 0;\n        let maxWhitespaceIndex = this.getWhitespacesCount() - 1;\n        if (maxWhitespaceIndex < 0) {\n            return -1;\n        }\n        // Special case: nothing to be found\n        const maxWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(maxWhitespaceIndex);\n        const maxWhitespaceHeight = this.getHeightForWhitespaceIndex(maxWhitespaceIndex);\n        if (verticalOffset >= maxWhitespaceVerticalOffset + maxWhitespaceHeight) {\n            return -1;\n        }\n        while (minWhitespaceIndex < maxWhitespaceIndex) {\n            const midWhitespaceIndex = Math.floor((minWhitespaceIndex + maxWhitespaceIndex) / 2);\n            const midWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(midWhitespaceIndex);\n            const midWhitespaceHeight = this.getHeightForWhitespaceIndex(midWhitespaceIndex);\n            if (verticalOffset >= midWhitespaceVerticalOffset + midWhitespaceHeight) {\n                // vertical offset is after whitespace\n                minWhitespaceIndex = midWhitespaceIndex + 1;\n            }\n            else if (verticalOffset >= midWhitespaceVerticalOffset) {\n                // Hit\n                return midWhitespaceIndex;\n            }\n            else {\n                // vertical offset is before whitespace, but midWhitespaceIndex might still be what we're searching for\n                maxWhitespaceIndex = midWhitespaceIndex;\n            }\n        }\n        return minWhitespaceIndex;\n    }\n    /**\n     * Get exactly the whitespace that is layouted at `verticalOffset`.\n     *\n     * @param verticalOffset The vertical offset.\n     * @return Precisely the whitespace that is layouted at `verticaloffset` or null.\n     */\n    getWhitespaceAtVerticalOffset(verticalOffset) {\n        this._checkPendingChanges();\n        verticalOffset = verticalOffset | 0;\n        const candidateIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset);\n        if (candidateIndex < 0) {\n            return null;\n        }\n        if (candidateIndex >= this.getWhitespacesCount()) {\n            return null;\n        }\n        const candidateTop = this.getVerticalOffsetForWhitespaceIndex(candidateIndex);\n        if (candidateTop > verticalOffset) {\n            return null;\n        }\n        const candidateHeight = this.getHeightForWhitespaceIndex(candidateIndex);\n        const candidateId = this.getIdForWhitespaceIndex(candidateIndex);\n        const candidateAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(candidateIndex);\n        return {\n            id: candidateId,\n            afterLineNumber: candidateAfterLineNumber,\n            verticalOffset: candidateTop,\n            height: candidateHeight\n        };\n    }\n    /**\n     * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.\n     *\n     * @param verticalOffset1 The beginning of the viewport.\n     * @param verticalOffset2 The end of the viewport.\n     * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.\n     */\n    getWhitespaceViewportData(verticalOffset1, verticalOffset2) {\n        this._checkPendingChanges();\n        verticalOffset1 = verticalOffset1 | 0;\n        verticalOffset2 = verticalOffset2 | 0;\n        const startIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset1);\n        const endIndex = this.getWhitespacesCount() - 1;\n        if (startIndex < 0) {\n            return [];\n        }\n        const result = [];\n        for (let i = startIndex; i <= endIndex; i++) {\n            const top = this.getVerticalOffsetForWhitespaceIndex(i);\n            const height = this.getHeightForWhitespaceIndex(i);\n            if (top >= verticalOffset2) {\n                break;\n            }\n            result.push({\n                id: this.getIdForWhitespaceIndex(i),\n                afterLineNumber: this.getAfterLineNumberForWhitespaceIndex(i),\n                verticalOffset: top,\n                height: height\n            });\n        }\n        return result;\n    }\n    /**\n     * Get all whitespaces.\n     */\n    getWhitespaces() {\n        this._checkPendingChanges();\n        return this._arr.slice(0);\n    }\n    /**\n     * The number of whitespaces.\n     */\n    getWhitespacesCount() {\n        this._checkPendingChanges();\n        return this._arr.length;\n    }\n    /**\n     * Get the `id` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `id` of whitespace at `index`.\n     */\n    getIdForWhitespaceIndex(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        return this._arr[index].id;\n    }\n    /**\n     * Get the `afterLineNumber` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `afterLineNumber` of whitespace at `index`.\n     */\n    getAfterLineNumberForWhitespaceIndex(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        return this._arr[index].afterLineNumber;\n    }\n    /**\n     * Get the `height` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `height` of whitespace at `index`.\n     */\n    getHeightForWhitespaceIndex(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        return this._arr[index].height;\n    }\n}\nLinesLayout.INSTANCE_COUNT = 0;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { Scrollable } from '../../../base/common/scrollable.js';\nimport { LinesLayout } from './linesLayout.js';\nimport { Viewport } from '../viewModel.js';\nimport { ContentSizeChangedEvent } from '../viewModelEventDispatcher.js';\nconst SMOOTH_SCROLLING_TIME = 125;\nclass EditorScrollDimensions {\n    constructor(width, contentWidth, height, contentHeight) {\n        width = width | 0;\n        contentWidth = contentWidth | 0;\n        height = height | 0;\n        contentHeight = contentHeight | 0;\n        if (width < 0) {\n            width = 0;\n        }\n        if (contentWidth < 0) {\n            contentWidth = 0;\n        }\n        if (height < 0) {\n            height = 0;\n        }\n        if (contentHeight < 0) {\n            contentHeight = 0;\n        }\n        this.width = width;\n        this.contentWidth = contentWidth;\n        this.scrollWidth = Math.max(width, contentWidth);\n        this.height = height;\n        this.contentHeight = contentHeight;\n        this.scrollHeight = Math.max(height, contentHeight);\n    }\n    equals(other) {\n        return (this.width === other.width\n            && this.contentWidth === other.contentWidth\n            && this.height === other.height\n            && this.contentHeight === other.contentHeight);\n    }\n}\nclass EditorScrollable extends Disposable {\n    constructor(smoothScrollDuration, scheduleAtNextAnimationFrame) {\n        super();\n        this._onDidContentSizeChange = this._register(new Emitter());\n        this.onDidContentSizeChange = this._onDidContentSizeChange.event;\n        this._dimensions = new EditorScrollDimensions(0, 0, 0, 0);\n        this._scrollable = this._register(new Scrollable({\n            forceIntegerValues: true,\n            smoothScrollDuration,\n            scheduleAtNextAnimationFrame\n        }));\n        this.onDidScroll = this._scrollable.onScroll;\n    }\n    getScrollable() {\n        return this._scrollable;\n    }\n    setSmoothScrollDuration(smoothScrollDuration) {\n        this._scrollable.setSmoothScrollDuration(smoothScrollDuration);\n    }\n    validateScrollPosition(scrollPosition) {\n        return this._scrollable.validateScrollPosition(scrollPosition);\n    }\n    getScrollDimensions() {\n        return this._dimensions;\n    }\n    setScrollDimensions(dimensions) {\n        if (this._dimensions.equals(dimensions)) {\n            return;\n        }\n        const oldDimensions = this._dimensions;\n        this._dimensions = dimensions;\n        this._scrollable.setScrollDimensions({\n            width: dimensions.width,\n            scrollWidth: dimensions.scrollWidth,\n            height: dimensions.height,\n            scrollHeight: dimensions.scrollHeight\n        }, true);\n        const contentWidthChanged = (oldDimensions.contentWidth !== dimensions.contentWidth);\n        const contentHeightChanged = (oldDimensions.contentHeight !== dimensions.contentHeight);\n        if (contentWidthChanged || contentHeightChanged) {\n            this._onDidContentSizeChange.fire(new ContentSizeChangedEvent(oldDimensions.contentWidth, oldDimensions.contentHeight, dimensions.contentWidth, dimensions.contentHeight));\n        }\n    }\n    getFutureScrollPosition() {\n        return this._scrollable.getFutureScrollPosition();\n    }\n    getCurrentScrollPosition() {\n        return this._scrollable.getCurrentScrollPosition();\n    }\n    setScrollPositionNow(update) {\n        this._scrollable.setScrollPositionNow(update);\n    }\n    setScrollPositionSmooth(update) {\n        this._scrollable.setScrollPositionSmooth(update);\n    }\n}\nexport class ViewLayout extends Disposable {\n    constructor(configuration, lineCount, scheduleAtNextAnimationFrame) {\n        super();\n        this._configuration = configuration;\n        const options = this._configuration.options;\n        const layoutInfo = options.get(133 /* EditorOption.layoutInfo */);\n        const padding = options.get(77 /* EditorOption.padding */);\n        this._linesLayout = new LinesLayout(lineCount, options.get(61 /* EditorOption.lineHeight */), padding.top, padding.bottom);\n        this._scrollable = this._register(new EditorScrollable(0, scheduleAtNextAnimationFrame));\n        this._configureSmoothScrollDuration();\n        this._scrollable.setScrollDimensions(new EditorScrollDimensions(layoutInfo.contentWidth, 0, layoutInfo.height, 0));\n        this.onDidScroll = this._scrollable.onDidScroll;\n        this.onDidContentSizeChange = this._scrollable.onDidContentSizeChange;\n        this._updateHeight();\n    }\n    dispose() {\n        super.dispose();\n    }\n    getScrollable() {\n        return this._scrollable.getScrollable();\n    }\n    onHeightMaybeChanged() {\n        this._updateHeight();\n    }\n    _configureSmoothScrollDuration() {\n        this._scrollable.setSmoothScrollDuration(this._configuration.options.get(105 /* EditorOption.smoothScrolling */) ? SMOOTH_SCROLLING_TIME : 0);\n    }\n    // ---- begin view event handlers\n    onConfigurationChanged(e) {\n        const options = this._configuration.options;\n        if (e.hasChanged(61 /* EditorOption.lineHeight */)) {\n            this._linesLayout.setLineHeight(options.get(61 /* EditorOption.lineHeight */));\n        }\n        if (e.hasChanged(77 /* EditorOption.padding */)) {\n            const padding = options.get(77 /* EditorOption.padding */);\n            this._linesLayout.setPadding(padding.top, padding.bottom);\n        }\n        if (e.hasChanged(133 /* EditorOption.layoutInfo */)) {\n            const layoutInfo = options.get(133 /* EditorOption.layoutInfo */);\n            const width = layoutInfo.contentWidth;\n            const height = layoutInfo.height;\n            const scrollDimensions = this._scrollable.getScrollDimensions();\n            const contentWidth = scrollDimensions.contentWidth;\n            this._scrollable.setScrollDimensions(new EditorScrollDimensions(width, scrollDimensions.contentWidth, height, this._getContentHeight(width, height, contentWidth)));\n        }\n        else {\n            this._updateHeight();\n        }\n        if (e.hasChanged(105 /* EditorOption.smoothScrolling */)) {\n            this._configureSmoothScrollDuration();\n        }\n    }\n    onFlushed(lineCount) {\n        this._linesLayout.onFlushed(lineCount);\n    }\n    onLinesDeleted(fromLineNumber, toLineNumber) {\n        this._linesLayout.onLinesDeleted(fromLineNumber, toLineNumber);\n    }\n    onLinesInserted(fromLineNumber, toLineNumber) {\n        this._linesLayout.onLinesInserted(fromLineNumber, toLineNumber);\n    }\n    // ---- end view event handlers\n    _getHorizontalScrollbarHeight(width, scrollWidth) {\n        const options = this._configuration.options;\n        const scrollbar = options.get(94 /* EditorOption.scrollbar */);\n        if (scrollbar.horizontal === 2 /* ScrollbarVisibility.Hidden */) {\n            // horizontal scrollbar not visible\n            return 0;\n        }\n        if (width >= scrollWidth) {\n            // horizontal scrollbar not visible\n            return 0;\n        }\n        return scrollbar.horizontalScrollbarSize;\n    }\n    _getContentHeight(width, height, contentWidth) {\n        const options = this._configuration.options;\n        let result = this._linesLayout.getLinesTotalHeight();\n        if (options.get(96 /* EditorOption.scrollBeyondLastLine */)) {\n            result += Math.max(0, height - options.get(61 /* EditorOption.lineHeight */) - options.get(77 /* EditorOption.padding */).bottom);\n        }\n        else {\n            result += this._getHorizontalScrollbarHeight(width, contentWidth);\n        }\n        return result;\n    }\n    _updateHeight() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        const width = scrollDimensions.width;\n        const height = scrollDimensions.height;\n        const contentWidth = scrollDimensions.contentWidth;\n        this._scrollable.setScrollDimensions(new EditorScrollDimensions(width, scrollDimensions.contentWidth, height, this._getContentHeight(width, height, contentWidth)));\n    }\n    // ---- Layouting logic\n    getCurrentViewport() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        return new Viewport(currentScrollPosition.scrollTop, currentScrollPosition.scrollLeft, scrollDimensions.width, scrollDimensions.height);\n    }\n    getFutureViewport() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        const currentScrollPosition = this._scrollable.getFutureScrollPosition();\n        return new Viewport(currentScrollPosition.scrollTop, currentScrollPosition.scrollLeft, scrollDimensions.width, scrollDimensions.height);\n    }\n    _computeContentWidth(maxLineWidth) {\n        const options = this._configuration.options;\n        const wrappingInfo = options.get(134 /* EditorOption.wrappingInfo */);\n        const fontInfo = options.get(46 /* EditorOption.fontInfo */);\n        const layoutInfo = options.get(133 /* EditorOption.layoutInfo */);\n        if (wrappingInfo.isViewportWrapping) {\n            const minimap = options.get(67 /* EditorOption.minimap */);\n            if (maxLineWidth > layoutInfo.contentWidth + fontInfo.typicalHalfwidthCharacterWidth) {\n                // This is a case where viewport wrapping is on, but the line extends above the viewport\n                if (minimap.enabled && minimap.side === 'right') {\n                    // We need to accomodate the scrollbar width\n                    return maxLineWidth + layoutInfo.verticalScrollbarWidth;\n                }\n            }\n            return maxLineWidth;\n        }\n        else {\n            const extraHorizontalSpace = options.get(95 /* EditorOption.scrollBeyondLastColumn */) * fontInfo.typicalHalfwidthCharacterWidth;\n            const whitespaceMinWidth = this._linesLayout.getWhitespaceMinWidth();\n            return Math.max(maxLineWidth + extraHorizontalSpace + layoutInfo.verticalScrollbarWidth, whitespaceMinWidth);\n        }\n    }\n    setMaxLineWidth(maxLineWidth) {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        // const newScrollWidth = ;\n        this._scrollable.setScrollDimensions(new EditorScrollDimensions(scrollDimensions.width, this._computeContentWidth(maxLineWidth), scrollDimensions.height, scrollDimensions.contentHeight));\n        // The height might depend on the fact that there is a horizontal scrollbar or not\n        this._updateHeight();\n    }\n    // ---- view state\n    saveState() {\n        const currentScrollPosition = this._scrollable.getFutureScrollPosition();\n        const scrollTop = currentScrollPosition.scrollTop;\n        const firstLineNumberInViewport = this._linesLayout.getLineNumberAtOrAfterVerticalOffset(scrollTop);\n        const whitespaceAboveFirstLine = this._linesLayout.getWhitespaceAccumulatedHeightBeforeLineNumber(firstLineNumberInViewport);\n        return {\n            scrollTop: scrollTop,\n            scrollTopWithoutViewZones: scrollTop - whitespaceAboveFirstLine,\n            scrollLeft: currentScrollPosition.scrollLeft\n        };\n    }\n    // ----\n    changeWhitespace(callback) {\n        const hadAChange = this._linesLayout.changeWhitespace(callback);\n        if (hadAChange) {\n            this.onHeightMaybeChanged();\n        }\n        return hadAChange;\n    }\n    getVerticalOffsetForLineNumber(lineNumber, includeViewZones = false) {\n        return this._linesLayout.getVerticalOffsetForLineNumber(lineNumber, includeViewZones);\n    }\n    getVerticalOffsetAfterLineNumber(lineNumber, includeViewZones = false) {\n        return this._linesLayout.getVerticalOffsetAfterLineNumber(lineNumber, includeViewZones);\n    }\n    isAfterLines(verticalOffset) {\n        return this._linesLayout.isAfterLines(verticalOffset);\n    }\n    isInTopPadding(verticalOffset) {\n        return this._linesLayout.isInTopPadding(verticalOffset);\n    }\n    isInBottomPadding(verticalOffset) {\n        return this._linesLayout.isInBottomPadding(verticalOffset);\n    }\n    getLineNumberAtVerticalOffset(verticalOffset) {\n        return this._linesLayout.getLineNumberAtOrAfterVerticalOffset(verticalOffset);\n    }\n    getWhitespaceAtVerticalOffset(verticalOffset) {\n        return this._linesLayout.getWhitespaceAtVerticalOffset(verticalOffset);\n    }\n    getLinesViewportData() {\n        const visibleBox = this.getCurrentViewport();\n        return this._linesLayout.getLinesViewportData(visibleBox.top, visibleBox.top + visibleBox.height);\n    }\n    getLinesViewportDataAtScrollTop(scrollTop) {\n        // do some minimal validations on scrollTop\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        if (scrollTop + scrollDimensions.height > scrollDimensions.scrollHeight) {\n            scrollTop = scrollDimensions.scrollHeight - scrollDimensions.height;\n        }\n        if (scrollTop < 0) {\n            scrollTop = 0;\n        }\n        return this._linesLayout.getLinesViewportData(scrollTop, scrollTop + scrollDimensions.height);\n    }\n    getWhitespaceViewportData() {\n        const visibleBox = this.getCurrentViewport();\n        return this._linesLayout.getWhitespaceViewportData(visibleBox.top, visibleBox.top + visibleBox.height);\n    }\n    getWhitespaces() {\n        return this._linesLayout.getWhitespaces();\n    }\n    // ----\n    getContentWidth() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.contentWidth;\n    }\n    getScrollWidth() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.scrollWidth;\n    }\n    getContentHeight() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.contentHeight;\n    }\n    getScrollHeight() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.scrollHeight;\n    }\n    getCurrentScrollLeft() {\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        return currentScrollPosition.scrollLeft;\n    }\n    getCurrentScrollTop() {\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        return currentScrollPosition.scrollTop;\n    }\n    validateScrollPosition(scrollPosition) {\n        return this._scrollable.validateScrollPosition(scrollPosition);\n    }\n    setScrollPosition(position, type) {\n        if (type === 1 /* ScrollType.Immediate */) {\n            this._scrollable.setScrollPositionNow(position);\n        }\n        else {\n            this._scrollable.setScrollPositionSmooth(position);\n        }\n    }\n    deltaScrollNow(deltaScrollLeft, deltaScrollTop) {\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        this._scrollable.setScrollPositionNow({\n            scrollLeft: currentScrollPosition.scrollLeft + deltaScrollLeft,\n            scrollTop: currentScrollPosition.scrollTop + deltaScrollTop\n        });\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { Position } from '../core/position.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport { SingleLineInlineDecoration, ViewLineData } from '../viewModel.js';\nexport function createModelLineProjection(lineBreakData, isVisible) {\n    if (lineBreakData === null) {\n        // No mapping needed\n        if (isVisible) {\n            return IdentityModelLineProjection.INSTANCE;\n        }\n        return HiddenModelLineProjection.INSTANCE;\n    }\n    else {\n        return new ModelLineProjection(lineBreakData, isVisible);\n    }\n}\n/**\n * This projection is used to\n * * wrap model lines\n * * inject text\n */\nclass ModelLineProjection {\n    constructor(lineBreakData, isVisible) {\n        this._projectionData = lineBreakData;\n        this._isVisible = isVisible;\n    }\n    isVisible() {\n        return this._isVisible;\n    }\n    setVisible(isVisible) {\n        this._isVisible = isVisible;\n        return this;\n    }\n    getProjectionData() {\n        return this._projectionData;\n    }\n    getViewLineCount() {\n        if (!this._isVisible) {\n            return 0;\n        }\n        return this._projectionData.getOutputLineCount();\n    }\n    getViewLineContent(model, modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        const startOffsetInInputWithInjections = outputLineIndex > 0 ? this._projectionData.breakOffsets[outputLineIndex - 1] : 0;\n        const endOffsetInInputWithInjections = this._projectionData.breakOffsets[outputLineIndex];\n        let r;\n        if (this._projectionData.injectionOffsets !== null) {\n            const injectedTexts = this._projectionData.injectionOffsets.map((offset, idx) => new LineInjectedText(0, 0, offset + 1, this._projectionData.injectionOptions[idx], 0));\n            const lineWithInjections = LineInjectedText.applyInjectedText(model.getLineContent(modelLineNumber), injectedTexts);\n            r = lineWithInjections.substring(startOffsetInInputWithInjections, endOffsetInInputWithInjections);\n        }\n        else {\n            r = model.getValueInRange({\n                startLineNumber: modelLineNumber,\n                startColumn: startOffsetInInputWithInjections + 1,\n                endLineNumber: modelLineNumber,\n                endColumn: endOffsetInInputWithInjections + 1\n            });\n        }\n        if (outputLineIndex > 0) {\n            r = spaces(this._projectionData.wrappedTextIndentLength) + r;\n        }\n        return r;\n    }\n    getViewLineLength(model, modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        return this._projectionData.getLineLength(outputLineIndex);\n    }\n    getViewLineMinColumn(_model, _modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        return this._projectionData.getMinOutputOffset(outputLineIndex) + 1;\n    }\n    getViewLineMaxColumn(model, modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        return this._projectionData.getMaxOutputOffset(outputLineIndex) + 1;\n    }\n    /**\n     * Try using {@link getViewLinesData} instead.\n    */\n    getViewLineData(model, modelLineNumber, outputLineIndex) {\n        const arr = new Array();\n        this.getViewLinesData(model, modelLineNumber, outputLineIndex, 1, 0, [true], arr);\n        return arr[0];\n    }\n    getViewLinesData(model, modelLineNumber, outputLineIdx, lineCount, globalStartIndex, needed, result) {\n        this._assertVisible();\n        const lineBreakData = this._projectionData;\n        const injectionOffsets = lineBreakData.injectionOffsets;\n        const injectionOptions = lineBreakData.injectionOptions;\n        let inlineDecorationsPerOutputLine = null;\n        if (injectionOffsets) {\n            inlineDecorationsPerOutputLine = [];\n            let totalInjectedTextLengthBefore = 0;\n            let currentInjectedOffset = 0;\n            for (let outputLineIndex = 0; outputLineIndex < lineBreakData.getOutputLineCount(); outputLineIndex++) {\n                const inlineDecorations = new Array();\n                inlineDecorationsPerOutputLine[outputLineIndex] = inlineDecorations;\n                const lineStartOffsetInInputWithInjections = outputLineIndex > 0 ? lineBreakData.breakOffsets[outputLineIndex - 1] : 0;\n                const lineEndOffsetInInputWithInjections = lineBreakData.breakOffsets[outputLineIndex];\n                while (currentInjectedOffset < injectionOffsets.length) {\n                    const length = injectionOptions[currentInjectedOffset].content.length;\n                    const injectedTextStartOffsetInInputWithInjections = injectionOffsets[currentInjectedOffset] + totalInjectedTextLengthBefore;\n                    const injectedTextEndOffsetInInputWithInjections = injectedTextStartOffsetInInputWithInjections + length;\n                    if (injectedTextStartOffsetInInputWithInjections > lineEndOffsetInInputWithInjections) {\n                        // Injected text only starts in later wrapped lines.\n                        break;\n                    }\n                    if (lineStartOffsetInInputWithInjections < injectedTextEndOffsetInInputWithInjections) {\n                        // Injected text ends after or in this line (but also starts in or before this line).\n                        const options = injectionOptions[currentInjectedOffset];\n                        if (options.inlineClassName) {\n                            const offset = (outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength : 0);\n                            const start = offset + Math.max(injectedTextStartOffsetInInputWithInjections - lineStartOffsetInInputWithInjections, 0);\n                            const end = offset + Math.min(injectedTextEndOffsetInInputWithInjections - lineStartOffsetInInputWithInjections, lineEndOffsetInInputWithInjections);\n                            if (start !== end) {\n                                inlineDecorations.push(new SingleLineInlineDecoration(start, end, options.inlineClassName, options.inlineClassNameAffectsLetterSpacing));\n                            }\n                        }\n                    }\n                    if (injectedTextEndOffsetInInputWithInjections <= lineEndOffsetInInputWithInjections) {\n                        totalInjectedTextLengthBefore += length;\n                        currentInjectedOffset++;\n                    }\n                    else {\n                        // injected text breaks into next line, process it again\n                        break;\n                    }\n                }\n            }\n        }\n        let lineWithInjections;\n        if (injectionOffsets) {\n            lineWithInjections = model.tokenization.getLineTokens(modelLineNumber).withInserted(injectionOffsets.map((offset, idx) => ({\n                offset,\n                text: injectionOptions[idx].content,\n                tokenMetadata: LineTokens.defaultTokenMetadata\n            })));\n        }\n        else {\n            lineWithInjections = model.tokenization.getLineTokens(modelLineNumber);\n        }\n        for (let outputLineIndex = outputLineIdx; outputLineIndex < outputLineIdx + lineCount; outputLineIndex++) {\n            const globalIndex = globalStartIndex + outputLineIndex - outputLineIdx;\n            if (!needed[globalIndex]) {\n                result[globalIndex] = null;\n                continue;\n            }\n            result[globalIndex] = this._getViewLineData(lineWithInjections, inlineDecorationsPerOutputLine ? inlineDecorationsPerOutputLine[outputLineIndex] : null, outputLineIndex);\n        }\n    }\n    _getViewLineData(lineWithInjections, inlineDecorations, outputLineIndex) {\n        this._assertVisible();\n        const lineBreakData = this._projectionData;\n        const deltaStartIndex = (outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength : 0);\n        const lineStartOffsetInInputWithInjections = outputLineIndex > 0 ? lineBreakData.breakOffsets[outputLineIndex - 1] : 0;\n        const lineEndOffsetInInputWithInjections = lineBreakData.breakOffsets[outputLineIndex];\n        const tokens = lineWithInjections.sliceAndInflate(lineStartOffsetInInputWithInjections, lineEndOffsetInInputWithInjections, deltaStartIndex);\n        let lineContent = tokens.getLineContent();\n        if (outputLineIndex > 0) {\n            lineContent = spaces(lineBreakData.wrappedTextIndentLength) + lineContent;\n        }\n        const minColumn = this._projectionData.getMinOutputOffset(outputLineIndex) + 1;\n        const maxColumn = lineContent.length + 1;\n        const continuesWithWrappedLine = (outputLineIndex + 1 < this.getViewLineCount());\n        const startVisibleColumn = (outputLineIndex === 0 ? 0 : lineBreakData.breakOffsetsVisibleColumn[outputLineIndex - 1]);\n        return new ViewLineData(lineContent, continuesWithWrappedLine, minColumn, maxColumn, startVisibleColumn, tokens, inlineDecorations);\n    }\n    getModelColumnOfViewPosition(outputLineIndex, outputColumn) {\n        this._assertVisible();\n        return this._projectionData.translateToInputOffset(outputLineIndex, outputColumn - 1) + 1;\n    }\n    getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity = 2 /* PositionAffinity.None */) {\n        this._assertVisible();\n        const r = this._projectionData.translateToOutputPosition(inputColumn - 1, affinity);\n        return r.toPosition(deltaLineNumber);\n    }\n    getViewLineNumberOfModelPosition(deltaLineNumber, inputColumn) {\n        this._assertVisible();\n        const r = this._projectionData.translateToOutputPosition(inputColumn - 1);\n        return deltaLineNumber + r.outputLineIndex;\n    }\n    normalizePosition(outputLineIndex, outputPosition, affinity) {\n        const baseViewLineNumber = outputPosition.lineNumber - outputLineIndex;\n        const normalizedOutputPosition = this._projectionData.normalizeOutputPosition(outputLineIndex, outputPosition.column - 1, affinity);\n        const result = normalizedOutputPosition.toPosition(baseViewLineNumber);\n        return result;\n    }\n    getInjectedTextAt(outputLineIndex, outputColumn) {\n        return this._projectionData.getInjectedText(outputLineIndex, outputColumn - 1);\n    }\n    _assertVisible() {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n    }\n}\n/**\n * This projection does not change the model line.\n*/\nclass IdentityModelLineProjection {\n    constructor() { }\n    isVisible() {\n        return true;\n    }\n    setVisible(isVisible) {\n        if (isVisible) {\n            return this;\n        }\n        return HiddenModelLineProjection.INSTANCE;\n    }\n    getProjectionData() {\n        return null;\n    }\n    getViewLineCount() {\n        return 1;\n    }\n    getViewLineContent(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineContent(modelLineNumber);\n    }\n    getViewLineLength(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineLength(modelLineNumber);\n    }\n    getViewLineMinColumn(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineMinColumn(modelLineNumber);\n    }\n    getViewLineMaxColumn(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineMaxColumn(modelLineNumber);\n    }\n    getViewLineData(model, modelLineNumber, _outputLineIndex) {\n        const lineTokens = model.tokenization.getLineTokens(modelLineNumber);\n        const lineContent = lineTokens.getLineContent();\n        return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate(), null);\n    }\n    getViewLinesData(model, modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, globalStartIndex, needed, result) {\n        if (!needed[globalStartIndex]) {\n            result[globalStartIndex] = null;\n            return;\n        }\n        result[globalStartIndex] = this.getViewLineData(model, modelLineNumber, 0);\n    }\n    getModelColumnOfViewPosition(_outputLineIndex, outputColumn) {\n        return outputColumn;\n    }\n    getViewPositionOfModelPosition(deltaLineNumber, inputColumn) {\n        return new Position(deltaLineNumber, inputColumn);\n    }\n    getViewLineNumberOfModelPosition(deltaLineNumber, _inputColumn) {\n        return deltaLineNumber;\n    }\n    normalizePosition(outputLineIndex, outputPosition, affinity) {\n        return outputPosition;\n    }\n    getInjectedTextAt(_outputLineIndex, _outputColumn) {\n        return null;\n    }\n}\nIdentityModelLineProjection.INSTANCE = new IdentityModelLineProjection();\n/**\n * This projection hides the model line.\n */\nclass HiddenModelLineProjection {\n    constructor() { }\n    isVisible() {\n        return false;\n    }\n    setVisible(isVisible) {\n        if (!isVisible) {\n            return this;\n        }\n        return IdentityModelLineProjection.INSTANCE;\n    }\n    getProjectionData() {\n        return null;\n    }\n    getViewLineCount() {\n        return 0;\n    }\n    getViewLineContent(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineLength(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineMinColumn(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineMaxColumn(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineData(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLinesData(_model, _modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, _globalStartIndex, _needed, _result) {\n        throw new Error('Not supported');\n    }\n    getModelColumnOfViewPosition(_outputLineIndex, _outputColumn) {\n        throw new Error('Not supported');\n    }\n    getViewPositionOfModelPosition(_deltaLineNumber, _inputColumn) {\n        throw new Error('Not supported');\n    }\n    getViewLineNumberOfModelPosition(_deltaLineNumber, _inputColumn) {\n        throw new Error('Not supported');\n    }\n    normalizePosition(outputLineIndex, outputPosition, affinity) {\n        throw new Error('Not supported');\n    }\n    getInjectedTextAt(_outputLineIndex, _outputColumn) {\n        throw new Error('Not supported');\n    }\n}\nHiddenModelLineProjection.INSTANCE = new HiddenModelLineProjection();\nconst _spaces = [''];\nfunction spaces(count) {\n    if (count >= _spaces.length) {\n        for (let i = 1; i <= count; i++) {\n            _spaces[i] = _makeSpaces(i);\n        }\n    }\n    return _spaces[count];\n}\nfunction _makeSpaces(count) {\n    return new Array(count + 1).join(' ');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { ModelDecorationOptions } from '../model/textModel.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport * as viewEvents from '../viewEvents.js';\nimport { createModelLineProjection } from './modelLineProjection.js';\nimport { ConstantTimePrefixSumComputer } from '../model/prefixSumComputer.js';\nimport { ViewLineData } from '../viewModel.js';\nexport class ViewModelLinesFromProjectedModel {\n    constructor(editorId, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, tabSize, wrappingStrategy, wrappingColumn, wrappingIndent) {\n        this._editorId = editorId;\n        this.model = model;\n        this._validModelVersionId = -1;\n        this._domLineBreaksComputerFactory = domLineBreaksComputerFactory;\n        this._monospaceLineBreaksComputerFactory = monospaceLineBreaksComputerFactory;\n        this.fontInfo = fontInfo;\n        this.tabSize = tabSize;\n        this.wrappingStrategy = wrappingStrategy;\n        this.wrappingColumn = wrappingColumn;\n        this.wrappingIndent = wrappingIndent;\n        this._constructLines(/*resetHiddenAreas*/ true, null);\n    }\n    dispose() {\n        this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n    }\n    createCoordinatesConverter() {\n        return new CoordinatesConverter(this);\n    }\n    _constructLines(resetHiddenAreas, previousLineBreaks) {\n        this.modelLineProjections = [];\n        if (resetHiddenAreas) {\n            this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n        }\n        const linesContent = this.model.getLinesContent();\n        const injectedTextDecorations = this.model.getInjectedTextDecorations(this._editorId);\n        const lineCount = linesContent.length;\n        const lineBreaksComputer = this.createLineBreaksComputer();\n        const injectedTextQueue = new arrays.ArrayQueue(LineInjectedText.fromDecorations(injectedTextDecorations));\n        for (let i = 0; i < lineCount; i++) {\n            const lineInjectedText = injectedTextQueue.takeWhile(t => t.lineNumber === i + 1);\n            lineBreaksComputer.addRequest(linesContent[i], lineInjectedText, previousLineBreaks ? previousLineBreaks[i] : null);\n        }\n        const linesBreaks = lineBreaksComputer.finalize();\n        const values = [];\n        const hiddenAreas = this.hiddenAreasDecorationIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n        let hiddenAreaStart = 1, hiddenAreaEnd = 0;\n        let hiddenAreaIdx = -1;\n        let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n        for (let i = 0; i < lineCount; i++) {\n            const lineNumber = i + 1;\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n                hiddenAreaIdx++;\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n            }\n            const isInHiddenArea = (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd);\n            const line = createModelLineProjection(linesBreaks[i], !isInHiddenArea);\n            values[i] = line.getViewLineCount();\n            this.modelLineProjections[i] = line;\n        }\n        this._validModelVersionId = this.model.getVersionId();\n        this.projectedModelLineLineCounts = new ConstantTimePrefixSumComputer(values);\n    }\n    getHiddenAreas() {\n        return this.hiddenAreasDecorationIds.map((decId) => this.model.getDecorationRange(decId));\n    }\n    setHiddenAreas(_ranges) {\n        const validatedRanges = _ranges.map(r => this.model.validateRange(r));\n        const newRanges = normalizeLineRanges(validatedRanges);\n        // TODO@Martin: Please stop calling this method on each model change!\n        // This checks if there really was a change\n        const oldRanges = this.hiddenAreasDecorationIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n        if (newRanges.length === oldRanges.length) {\n            let hasDifference = false;\n            for (let i = 0; i < newRanges.length; i++) {\n                if (!newRanges[i].equalsRange(oldRanges[i])) {\n                    hasDifference = true;\n                    break;\n                }\n            }\n            if (!hasDifference) {\n                return false;\n            }\n        }\n        const newDecorations = newRanges.map((r) => ({\n            range: r,\n            options: ModelDecorationOptions.EMPTY,\n        }));\n        this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, newDecorations);\n        const hiddenAreas = newRanges;\n        let hiddenAreaStart = 1, hiddenAreaEnd = 0;\n        let hiddenAreaIdx = -1;\n        let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n        let hasVisibleLine = false;\n        for (let i = 0; i < this.modelLineProjections.length; i++) {\n            const lineNumber = i + 1;\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n                hiddenAreaIdx++;\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n            }\n            let lineChanged = false;\n            if (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {\n                // Line should be hidden\n                if (this.modelLineProjections[i].isVisible()) {\n                    this.modelLineProjections[i] = this.modelLineProjections[i].setVisible(false);\n                    lineChanged = true;\n                }\n            }\n            else {\n                hasVisibleLine = true;\n                // Line should be visible\n                if (!this.modelLineProjections[i].isVisible()) {\n                    this.modelLineProjections[i] = this.modelLineProjections[i].setVisible(true);\n                    lineChanged = true;\n                }\n            }\n            if (lineChanged) {\n                const newOutputLineCount = this.modelLineProjections[i].getViewLineCount();\n                this.projectedModelLineLineCounts.setValue(i, newOutputLineCount);\n            }\n        }\n        if (!hasVisibleLine) {\n            // Cannot have everything be hidden => reveal everything!\n            this.setHiddenAreas([]);\n        }\n        return true;\n    }\n    modelPositionIsVisible(modelLineNumber, _modelColumn) {\n        if (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n            // invalid arguments\n            return false;\n        }\n        return this.modelLineProjections[modelLineNumber - 1].isVisible();\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        if (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n            // invalid arguments\n            return 1;\n        }\n        return this.modelLineProjections[modelLineNumber - 1].getViewLineCount();\n    }\n    setTabSize(newTabSize) {\n        if (this.tabSize === newTabSize) {\n            return false;\n        }\n        this.tabSize = newTabSize;\n        this._constructLines(/*resetHiddenAreas*/ false, null);\n        return true;\n    }\n    setWrappingSettings(fontInfo, wrappingStrategy, wrappingColumn, wrappingIndent) {\n        const equalFontInfo = this.fontInfo.equals(fontInfo);\n        const equalWrappingStrategy = (this.wrappingStrategy === wrappingStrategy);\n        const equalWrappingColumn = (this.wrappingColumn === wrappingColumn);\n        const equalWrappingIndent = (this.wrappingIndent === wrappingIndent);\n        if (equalFontInfo && equalWrappingStrategy && equalWrappingColumn && equalWrappingIndent) {\n            return false;\n        }\n        const onlyWrappingColumnChanged = (equalFontInfo && equalWrappingStrategy && !equalWrappingColumn && equalWrappingIndent);\n        this.fontInfo = fontInfo;\n        this.wrappingStrategy = wrappingStrategy;\n        this.wrappingColumn = wrappingColumn;\n        this.wrappingIndent = wrappingIndent;\n        let previousLineBreaks = null;\n        if (onlyWrappingColumnChanged) {\n            previousLineBreaks = [];\n            for (let i = 0, len = this.modelLineProjections.length; i < len; i++) {\n                previousLineBreaks[i] = this.modelLineProjections[i].getProjectionData();\n            }\n        }\n        this._constructLines(/*resetHiddenAreas*/ false, previousLineBreaks);\n        return true;\n    }\n    createLineBreaksComputer() {\n        const lineBreaksComputerFactory = (this.wrappingStrategy === 'advanced'\n            ? this._domLineBreaksComputerFactory\n            : this._monospaceLineBreaksComputerFactory);\n        return lineBreaksComputerFactory.createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent);\n    }\n    onModelFlushed() {\n        this._constructLines(/*resetHiddenAreas*/ true, null);\n    }\n    onModelLinesDeleted(versionId, fromLineNumber, toLineNumber) {\n        if (!versionId || versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return null;\n        }\n        const outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1);\n        const outputToLineNumber = this.projectedModelLineLineCounts.getPrefixSum(toLineNumber);\n        this.modelLineProjections.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n        this.projectedModelLineLineCounts.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n        return new viewEvents.ViewLinesDeletedEvent(outputFromLineNumber, outputToLineNumber);\n    }\n    onModelLinesInserted(versionId, fromLineNumber, _toLineNumber, lineBreaks) {\n        if (!versionId || versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return null;\n        }\n        // cannot use this.getHiddenAreas() because those decorations have already seen the effect of this model change\n        const isInHiddenArea = (fromLineNumber > 2 && !this.modelLineProjections[fromLineNumber - 2].isVisible());\n        const outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1);\n        let totalOutputLineCount = 0;\n        const insertLines = [];\n        const insertPrefixSumValues = [];\n        for (let i = 0, len = lineBreaks.length; i < len; i++) {\n            const line = createModelLineProjection(lineBreaks[i], !isInHiddenArea);\n            insertLines.push(line);\n            const outputLineCount = line.getViewLineCount();\n            totalOutputLineCount += outputLineCount;\n            insertPrefixSumValues[i] = outputLineCount;\n        }\n        // TODO@Alex: use arrays.arrayInsert\n        this.modelLineProjections =\n            this.modelLineProjections.slice(0, fromLineNumber - 1)\n                .concat(insertLines)\n                .concat(this.modelLineProjections.slice(fromLineNumber - 1));\n        this.projectedModelLineLineCounts.insertValues(fromLineNumber - 1, insertPrefixSumValues);\n        return new viewEvents.ViewLinesInsertedEvent(outputFromLineNumber, outputFromLineNumber + totalOutputLineCount - 1);\n    }\n    onModelLineChanged(versionId, lineNumber, lineBreakData) {\n        if (versionId !== null && versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return [false, null, null, null];\n        }\n        const lineIndex = lineNumber - 1;\n        const oldOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n        const isVisible = this.modelLineProjections[lineIndex].isVisible();\n        const line = createModelLineProjection(lineBreakData, isVisible);\n        this.modelLineProjections[lineIndex] = line;\n        const newOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n        let lineMappingChanged = false;\n        let changeFrom = 0;\n        let changeTo = -1;\n        let insertFrom = 0;\n        let insertTo = -1;\n        let deleteFrom = 0;\n        let deleteTo = -1;\n        if (oldOutputLineCount > newOutputLineCount) {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + newOutputLineCount - 1;\n            deleteFrom = changeTo + 1;\n            deleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;\n            lineMappingChanged = true;\n        }\n        else if (oldOutputLineCount < newOutputLineCount) {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + oldOutputLineCount - 1;\n            insertFrom = changeTo + 1;\n            insertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;\n            lineMappingChanged = true;\n        }\n        else {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + newOutputLineCount - 1;\n        }\n        this.projectedModelLineLineCounts.setValue(lineIndex, newOutputLineCount);\n        const viewLinesChangedEvent = (changeFrom <= changeTo ? new viewEvents.ViewLinesChangedEvent(changeFrom, changeTo - changeFrom + 1) : null);\n        const viewLinesInsertedEvent = (insertFrom <= insertTo ? new viewEvents.ViewLinesInsertedEvent(insertFrom, insertTo) : null);\n        const viewLinesDeletedEvent = (deleteFrom <= deleteTo ? new viewEvents.ViewLinesDeletedEvent(deleteFrom, deleteTo) : null);\n        return [lineMappingChanged, viewLinesChangedEvent, viewLinesInsertedEvent, viewLinesDeletedEvent];\n    }\n    acceptVersionId(versionId) {\n        this._validModelVersionId = versionId;\n        if (this.modelLineProjections.length === 1 && !this.modelLineProjections[0].isVisible()) {\n            // At least one line must be visible => reset hidden areas\n            this.setHiddenAreas([]);\n        }\n    }\n    getViewLineCount() {\n        return this.projectedModelLineLineCounts.getTotalSum();\n    }\n    _toValidViewLineNumber(viewLineNumber) {\n        if (viewLineNumber < 1) {\n            return 1;\n        }\n        const viewLineCount = this.getViewLineCount();\n        if (viewLineNumber > viewLineCount) {\n            return viewLineCount;\n        }\n        return viewLineNumber | 0;\n    }\n    getActiveIndentGuide(viewLineNumber, minLineNumber, maxLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        minLineNumber = this._toValidViewLineNumber(minLineNumber);\n        maxLineNumber = this._toValidViewLineNumber(maxLineNumber);\n        const modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));\n        const modelMinPosition = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));\n        const modelMaxPosition = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));\n        const result = this.model.guides.getActiveIndentGuide(modelPosition.lineNumber, modelMinPosition.lineNumber, modelMaxPosition.lineNumber);\n        const viewStartPosition = this.convertModelPositionToViewPosition(result.startLineNumber, 1);\n        const viewEndPosition = this.convertModelPositionToViewPosition(result.endLineNumber, this.model.getLineMaxColumn(result.endLineNumber));\n        return {\n            startLineNumber: viewStartPosition.lineNumber,\n            endLineNumber: viewEndPosition.lineNumber,\n            indent: result.indent\n        };\n    }\n    // #region ViewLineInfo\n    getViewLineInfo(viewLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        const r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n        const lineIndex = r.index;\n        const remainder = r.remainder;\n        return new ViewLineInfo(lineIndex + 1, remainder);\n    }\n    getMinColumnOfViewLine(viewLineInfo) {\n        return this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n    }\n    getMaxColumnOfViewLine(viewLineInfo) {\n        return this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMaxColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n    }\n    getModelStartPositionOfViewLine(viewLineInfo) {\n        const line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n        const minViewColumn = line.getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n        const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, minViewColumn);\n        return new Position(viewLineInfo.modelLineNumber, column);\n    }\n    getModelEndPositionOfViewLine(viewLineInfo) {\n        const line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n        const maxViewColumn = line.getViewLineMaxColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n        const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, maxViewColumn);\n        return new Position(viewLineInfo.modelLineNumber, column);\n    }\n    getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber) {\n        const startViewLine = this.getViewLineInfo(viewStartLineNumber);\n        const endViewLine = this.getViewLineInfo(viewEndLineNumber);\n        const result = new Array();\n        let lastVisibleModelPos = this.getModelStartPositionOfViewLine(startViewLine);\n        let viewLines = new Array();\n        for (let curModelLine = startViewLine.modelLineNumber; curModelLine <= endViewLine.modelLineNumber; curModelLine++) {\n            const line = this.modelLineProjections[curModelLine - 1];\n            if (line.isVisible()) {\n                const startOffset = curModelLine === startViewLine.modelLineNumber\n                    ? startViewLine.modelLineWrappedLineIdx\n                    : 0;\n                const endOffset = curModelLine === endViewLine.modelLineNumber\n                    ? endViewLine.modelLineWrappedLineIdx + 1\n                    : line.getViewLineCount();\n                for (let i = startOffset; i < endOffset; i++) {\n                    viewLines.push(new ViewLineInfo(curModelLine, i));\n                }\n            }\n            if (!line.isVisible() && lastVisibleModelPos) {\n                const lastVisibleModelPos2 = new Position(curModelLine - 1, this.model.getLineMaxColumn(curModelLine - 1) + 1);\n                const modelRange = Range.fromPositions(lastVisibleModelPos, lastVisibleModelPos2);\n                result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n                viewLines = [];\n                lastVisibleModelPos = null;\n            }\n            else if (line.isVisible() && !lastVisibleModelPos) {\n                lastVisibleModelPos = new Position(curModelLine, 1);\n            }\n        }\n        if (lastVisibleModelPos) {\n            const modelRange = Range.fromPositions(lastVisibleModelPos, this.getModelEndPositionOfViewLine(endViewLine));\n            result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n        }\n        return result;\n    }\n    // #endregion\n    getViewLinesBracketGuides(viewStartLineNumber, viewEndLineNumber, activeViewPosition, options) {\n        const modelActivePosition = activeViewPosition ? this.convertViewPositionToModelPosition(activeViewPosition.lineNumber, activeViewPosition.column) : null;\n        const resultPerViewLine = [];\n        for (const group of this.getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber)) {\n            const modelRangeStartLineNumber = group.modelRange.startLineNumber;\n            const bracketGuidesPerModelLine = this.model.guides.getLinesBracketGuides(modelRangeStartLineNumber, group.modelRange.endLineNumber, modelActivePosition, options);\n            for (const viewLineInfo of group.viewLines) {\n                const bracketGuides = bracketGuidesPerModelLine[viewLineInfo.modelLineNumber - modelRangeStartLineNumber];\n                // visibleColumns stay as they are (this is a bug and needs to be fixed, but it is not a regression)\n                // model-columns must be converted to view-model columns.\n                const result = bracketGuides.map(g => {\n                    if (g.forWrappedLinesAfterColumn !== -1) {\n                        const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesAfterColumn);\n                        if (p.lineNumber >= viewLineInfo.modelLineWrappedLineIdx) {\n                            return undefined;\n                        }\n                    }\n                    if (g.forWrappedLinesBeforeOrAtColumn !== -1) {\n                        const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesBeforeOrAtColumn);\n                        if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n                            return undefined;\n                        }\n                    }\n                    if (!g.horizontalLine) {\n                        return g;\n                    }\n                    let column = -1;\n                    if (g.column !== -1) {\n                        const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.column);\n                        if (p.lineNumber === viewLineInfo.modelLineWrappedLineIdx) {\n                            column = p.column;\n                        }\n                        else if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n                            column = this.getMinColumnOfViewLine(viewLineInfo);\n                        }\n                        else if (p.lineNumber > viewLineInfo.modelLineWrappedLineIdx) {\n                            return undefined;\n                        }\n                    }\n                    const viewPosition = this.convertModelPositionToViewPosition(viewLineInfo.modelLineNumber, g.horizontalLine.endColumn);\n                    const p = this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.horizontalLine.endColumn);\n                    if (p.lineNumber === viewLineInfo.modelLineWrappedLineIdx) {\n                        return new IndentGuide(g.visibleColumn, column, g.className, new IndentGuideHorizontalLine(g.horizontalLine.top, viewPosition.column), -1, -1);\n                    }\n                    else if (p.lineNumber < viewLineInfo.modelLineWrappedLineIdx) {\n                        return undefined;\n                    }\n                    else {\n                        if (g.visibleColumn !== -1) {\n                            // Don't repeat horizontal lines that use visibleColumn for unrelated lines.\n                            return undefined;\n                        }\n                        return new IndentGuide(g.visibleColumn, column, g.className, new IndentGuideHorizontalLine(g.horizontalLine.top, this.getMaxColumnOfViewLine(viewLineInfo)), -1, -1);\n                    }\n                });\n                resultPerViewLine.push(result.filter((r) => !!r));\n            }\n        }\n        return resultPerViewLine;\n    }\n    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n        // TODO: Use the same code as in `getViewLinesBracketGuides`.\n        // Future TODO: Merge with `getViewLinesBracketGuides`.\n        // However, this requires more refactoring of indent guides.\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n        const modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber));\n        const modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));\n        let result = [];\n        const resultRepeatCount = [];\n        const resultRepeatOption = [];\n        const modelStartLineIndex = modelStart.lineNumber - 1;\n        const modelEndLineIndex = modelEnd.lineNumber - 1;\n        let reqStart = null;\n        for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (line.isVisible()) {\n                const viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n                const viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));\n                const count = viewLineEndIndex - viewLineStartIndex + 1;\n                let option = 0 /* IndentGuideRepeatOption.BlockNone */;\n                if (count > 1 && line.getViewLineMinColumn(this.model, modelLineIndex + 1, viewLineEndIndex) === 1) {\n                    // wrapped lines should block indent guides\n                    option = (viewLineStartIndex === 0 ? 1 /* IndentGuideRepeatOption.BlockSubsequent */ : 2 /* IndentGuideRepeatOption.BlockAll */);\n                }\n                resultRepeatCount.push(count);\n                resultRepeatOption.push(option);\n                // merge into previous request\n                if (reqStart === null) {\n                    reqStart = new Position(modelLineIndex + 1, 0);\n                }\n            }\n            else {\n                // hit invisible line => flush request\n                if (reqStart !== null) {\n                    result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex));\n                    reqStart = null;\n                }\n            }\n        }\n        if (reqStart !== null) {\n            result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber));\n            reqStart = null;\n        }\n        const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n        const viewIndents = new Array(viewLineCount);\n        let currIndex = 0;\n        for (let i = 0, len = result.length; i < len; i++) {\n            let value = result[i];\n            const count = Math.min(viewLineCount - currIndex, resultRepeatCount[i]);\n            const option = resultRepeatOption[i];\n            let blockAtIndex;\n            if (option === 2 /* IndentGuideRepeatOption.BlockAll */) {\n                blockAtIndex = 0;\n            }\n            else if (option === 1 /* IndentGuideRepeatOption.BlockSubsequent */) {\n                blockAtIndex = 1;\n            }\n            else {\n                blockAtIndex = count;\n            }\n            for (let j = 0; j < count; j++) {\n                if (j === blockAtIndex) {\n                    value = 0;\n                }\n                viewIndents[currIndex++] = value;\n            }\n        }\n        return viewIndents;\n    }\n    getViewLineContent(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineContent(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineLength(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineLength(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineMinColumn(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineMinColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineMaxColumn(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineMaxColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineData(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineData(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n        const start = this.projectedModelLineLineCounts.getIndexOf(viewStartLineNumber - 1);\n        let viewLineNumber = viewStartLineNumber;\n        const startModelLineIndex = start.index;\n        const startRemainder = start.remainder;\n        const result = [];\n        for (let modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (!line.isVisible()) {\n                continue;\n            }\n            const fromViewLineIndex = (modelLineIndex === startModelLineIndex ? startRemainder : 0);\n            let remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex;\n            let lastLine = false;\n            if (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {\n                lastLine = true;\n                remainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;\n            }\n            line.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, remainingViewLineCount, viewLineNumber - viewStartLineNumber, needed, result);\n            viewLineNumber += remainingViewLineCount;\n            if (lastLine) {\n                break;\n            }\n        }\n        return result;\n    }\n    validateViewPosition(viewLineNumber, viewColumn, expectedModelPosition) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        const r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n        const lineIndex = r.index;\n        const remainder = r.remainder;\n        const line = this.modelLineProjections[lineIndex];\n        const minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n        const maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n        if (viewColumn < minColumn) {\n            viewColumn = minColumn;\n        }\n        if (viewColumn > maxColumn) {\n            viewColumn = maxColumn;\n        }\n        const computedModelColumn = line.getModelColumnOfViewPosition(remainder, viewColumn);\n        const computedModelPosition = this.model.validatePosition(new Position(lineIndex + 1, computedModelColumn));\n        if (computedModelPosition.equals(expectedModelPosition)) {\n            return new Position(viewLineNumber, viewColumn);\n        }\n        return this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);\n    }\n    validateViewRange(viewRange, expectedModelRange) {\n        const validViewStart = this.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());\n        const validViewEnd = this.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());\n        return new Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);\n    }\n    convertViewPositionToModelPosition(viewLineNumber, viewColumn) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        const inputColumn = this.modelLineProjections[info.modelLineNumber - 1].getModelColumnOfViewPosition(info.modelLineWrappedLineIdx, viewColumn);\n        // console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);\n        return this.model.validatePosition(new Position(info.modelLineNumber, inputColumn));\n    }\n    convertViewRangeToModelRange(viewRange) {\n        const start = this.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);\n        const end = this.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    convertModelPositionToViewPosition(_modelLineNumber, _modelColumn, affinity = 2 /* PositionAffinity.None */) {\n        const validPosition = this.model.validatePosition(new Position(_modelLineNumber, _modelColumn));\n        const inputLineNumber = validPosition.lineNumber;\n        const inputColumn = validPosition.column;\n        let lineIndex = inputLineNumber - 1, lineIndexChanged = false;\n        while (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            lineIndex--;\n            lineIndexChanged = true;\n        }\n        if (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            // Could not reach a real line\n            // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);\n            return new Position(1, 1);\n        }\n        const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n        let r;\n        if (lineIndexChanged) {\n            r = this.modelLineProjections[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1), affinity);\n        }\n        else {\n            r = this.modelLineProjections[inputLineNumber - 1].getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity);\n        }\n        // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);\n        return r;\n    }\n    /**\n     * @param affinity The affinity in case of an empty range. Has no effect for non-empty ranges.\n    */\n    convertModelRangeToViewRange(modelRange, affinity = 0 /* PositionAffinity.Left */) {\n        if (modelRange.isEmpty()) {\n            const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, affinity);\n            return Range.fromPositions(start);\n        }\n        else {\n            const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, 1 /* PositionAffinity.Right */);\n            const end = this.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn, 0 /* PositionAffinity.Left */);\n            return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n        }\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        let lineIndex = modelLineNumber - 1;\n        if (this.modelLineProjections[lineIndex].isVisible()) {\n            // this model line is visible\n            const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n            return this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, modelColumn);\n        }\n        // this model line is not visible\n        while (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            lineIndex--;\n        }\n        if (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            // Could not reach a real line\n            return 1;\n        }\n        const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n        return this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n    }\n    getDecorationsInRange(range, ownerId, filterOutValidation) {\n        const modelStart = this.convertViewPositionToModelPosition(range.startLineNumber, range.startColumn);\n        const modelEnd = this.convertViewPositionToModelPosition(range.endLineNumber, range.endColumn);\n        if (modelEnd.lineNumber - modelStart.lineNumber <= range.endLineNumber - range.startLineNumber) {\n            // most likely there are no hidden lines => fast path\n            // fetch decorations from column 1 to cover the case of wrapped lines that have whole line decorations at column 1\n            return this.model.getDecorationsInRange(new Range(modelStart.lineNumber, 1, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation);\n        }\n        let result = [];\n        const modelStartLineIndex = modelStart.lineNumber - 1;\n        const modelEndLineIndex = modelEnd.lineNumber - 1;\n        let reqStart = null;\n        for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (line.isVisible()) {\n                // merge into previous request\n                if (reqStart === null) {\n                    reqStart = new Position(modelLineIndex + 1, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n                }\n            }\n            else {\n                // hit invisible line => flush request\n                if (reqStart !== null) {\n                    const maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);\n                    result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation));\n                    reqStart = null;\n                }\n            }\n        }\n        if (reqStart !== null) {\n            result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation));\n            reqStart = null;\n        }\n        result.sort((a, b) => {\n            const res = Range.compareRangesUsingStarts(a.range, b.range);\n            if (res === 0) {\n                if (a.id < b.id) {\n                    return -1;\n                }\n                if (a.id > b.id) {\n                    return 1;\n                }\n                return 0;\n            }\n            return res;\n        });\n        // Eliminate duplicate decorations that might have intersected our visible ranges multiple times\n        const finalResult = [];\n        let finalResultLen = 0;\n        let prevDecId = null;\n        for (const dec of result) {\n            const decId = dec.id;\n            if (prevDecId === decId) {\n                // skip\n                continue;\n            }\n            prevDecId = decId;\n            finalResult[finalResultLen++] = dec;\n        }\n        return finalResult;\n    }\n    getInjectedTextAt(position) {\n        const info = this.getViewLineInfo(position.lineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getInjectedTextAt(info.modelLineWrappedLineIdx, position.column);\n    }\n    normalizePosition(position, affinity) {\n        const info = this.getViewLineInfo(position.lineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].normalizePosition(info.modelLineWrappedLineIdx, position, affinity);\n    }\n    getLineIndentColumn(lineNumber) {\n        const info = this.getViewLineInfo(lineNumber);\n        if (info.modelLineWrappedLineIdx === 0) {\n            return this.model.getLineIndentColumn(info.modelLineNumber);\n        }\n        // wrapped lines have no indentation.\n        // We deliberately don't handle the case that indentation is wrapped\n        // to avoid two view lines reporting indentation for the very same model line.\n        return 0;\n    }\n}\n/**\n * Overlapping unsorted ranges:\n * [   )      [ )       [  )\n *    [    )      [       )\n * ->\n * Non overlapping sorted ranges:\n * [       )  [ ) [        )\n *\n * Note: This function only considers line information! Columns are ignored.\n*/\nfunction normalizeLineRanges(ranges) {\n    if (ranges.length === 0) {\n        return [];\n    }\n    const sortedRanges = ranges.slice();\n    sortedRanges.sort(Range.compareRangesUsingStarts);\n    const result = [];\n    let currentRangeStart = sortedRanges[0].startLineNumber;\n    let currentRangeEnd = sortedRanges[0].endLineNumber;\n    for (let i = 1, len = sortedRanges.length; i < len; i++) {\n        const range = sortedRanges[i];\n        if (range.startLineNumber > currentRangeEnd + 1) {\n            result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n            currentRangeStart = range.startLineNumber;\n            currentRangeEnd = range.endLineNumber;\n        }\n        else if (range.endLineNumber > currentRangeEnd) {\n            currentRangeEnd = range.endLineNumber;\n        }\n    }\n    result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n    return result;\n}\n/**\n * Represents a view line. Can be used to efficiently query more information about it.\n */\nclass ViewLineInfo {\n    constructor(modelLineNumber, modelLineWrappedLineIdx) {\n        this.modelLineNumber = modelLineNumber;\n        this.modelLineWrappedLineIdx = modelLineWrappedLineIdx;\n    }\n}\n/**\n * A list of view lines that have a contiguous span in the model.\n*/\nclass ViewLineInfoGroupedByModelRange {\n    constructor(modelRange, viewLines) {\n        this.modelRange = modelRange;\n        this.viewLines = viewLines;\n    }\n}\nclass CoordinatesConverter {\n    constructor(lines) {\n        this._lines = lines;\n    }\n    // View -> Model conversion and related methods\n    convertViewPositionToModelPosition(viewPosition) {\n        return this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);\n    }\n    convertViewRangeToModelRange(viewRange) {\n        return this._lines.convertViewRangeToModelRange(viewRange);\n    }\n    validateViewPosition(viewPosition, expectedModelPosition) {\n        return this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);\n    }\n    validateViewRange(viewRange, expectedModelRange) {\n        return this._lines.validateViewRange(viewRange, expectedModelRange);\n    }\n    // Model -> View conversion and related methods\n    convertModelPositionToViewPosition(modelPosition, affinity) {\n        return this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column, affinity);\n    }\n    convertModelRangeToViewRange(modelRange, affinity) {\n        return this._lines.convertModelRangeToViewRange(modelRange, affinity);\n    }\n    modelPositionIsVisible(modelPosition) {\n        return this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        return this._lines.getModelLineViewLineCount(modelLineNumber);\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        return this._lines.getViewLineNumberOfModelPosition(modelLineNumber, modelColumn);\n    }\n}\nexport class ViewModelLinesFromModelAsIs {\n    constructor(model) {\n        this.model = model;\n    }\n    dispose() {\n    }\n    createCoordinatesConverter() {\n        return new IdentityCoordinatesConverter(this);\n    }\n    getHiddenAreas() {\n        return [];\n    }\n    setHiddenAreas(_ranges) {\n        return false;\n    }\n    setTabSize(_newTabSize) {\n        return false;\n    }\n    setWrappingSettings(_fontInfo, _wrappingStrategy, _wrappingColumn, _wrappingIndent) {\n        return false;\n    }\n    createLineBreaksComputer() {\n        const result = [];\n        return {\n            addRequest: (lineText, injectedText, previousLineBreakData) => {\n                result.push(null);\n            },\n            finalize: () => {\n                return result;\n            }\n        };\n    }\n    onModelFlushed() {\n    }\n    onModelLinesDeleted(_versionId, fromLineNumber, toLineNumber) {\n        return new viewEvents.ViewLinesDeletedEvent(fromLineNumber, toLineNumber);\n    }\n    onModelLinesInserted(_versionId, fromLineNumber, toLineNumber, lineBreaks) {\n        return new viewEvents.ViewLinesInsertedEvent(fromLineNumber, toLineNumber);\n    }\n    onModelLineChanged(_versionId, lineNumber, lineBreakData) {\n        return [false, new viewEvents.ViewLinesChangedEvent(lineNumber, 1), null, null];\n    }\n    acceptVersionId(_versionId) {\n    }\n    getViewLineCount() {\n        return this.model.getLineCount();\n    }\n    getActiveIndentGuide(viewLineNumber, _minLineNumber, _maxLineNumber) {\n        return {\n            startLineNumber: viewLineNumber,\n            endLineNumber: viewLineNumber,\n            indent: 0\n        };\n    }\n    getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition) {\n        return new Array(endLineNumber - startLineNumber + 1).fill([]);\n    }\n    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n        const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n        const result = new Array(viewLineCount);\n        for (let i = 0; i < viewLineCount; i++) {\n            result[i] = 0;\n        }\n        return result;\n    }\n    getViewLineContent(viewLineNumber) {\n        return this.model.getLineContent(viewLineNumber);\n    }\n    getViewLineLength(viewLineNumber) {\n        return this.model.getLineLength(viewLineNumber);\n    }\n    getViewLineMinColumn(viewLineNumber) {\n        return this.model.getLineMinColumn(viewLineNumber);\n    }\n    getViewLineMaxColumn(viewLineNumber) {\n        return this.model.getLineMaxColumn(viewLineNumber);\n    }\n    getViewLineData(viewLineNumber) {\n        const lineTokens = this.model.tokenization.getLineTokens(viewLineNumber);\n        const lineContent = lineTokens.getLineContent();\n        return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate(), null);\n    }\n    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n        const lineCount = this.model.getLineCount();\n        viewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);\n        viewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);\n        const result = [];\n        for (let lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {\n            const idx = lineNumber - viewStartLineNumber;\n            result[idx] = needed[idx] ? this.getViewLineData(lineNumber) : null;\n        }\n        return result;\n    }\n    getDecorationsInRange(range, ownerId, filterOutValidation) {\n        return this.model.getDecorationsInRange(range, ownerId, filterOutValidation);\n    }\n    normalizePosition(position, affinity) {\n        return this.model.normalizePosition(position, affinity);\n    }\n    getLineIndentColumn(lineNumber) {\n        return this.model.getLineIndentColumn(lineNumber);\n    }\n    getInjectedTextAt(position) {\n        // Identity lines collection does not support injected text.\n        return null;\n    }\n}\nclass IdentityCoordinatesConverter {\n    constructor(lines) {\n        this._lines = lines;\n    }\n    _validPosition(pos) {\n        return this._lines.model.validatePosition(pos);\n    }\n    _validRange(range) {\n        return this._lines.model.validateRange(range);\n    }\n    // View -> Model conversion and related methods\n    convertViewPositionToModelPosition(viewPosition) {\n        return this._validPosition(viewPosition);\n    }\n    convertViewRangeToModelRange(viewRange) {\n        return this._validRange(viewRange);\n    }\n    validateViewPosition(_viewPosition, expectedModelPosition) {\n        return this._validPosition(expectedModelPosition);\n    }\n    validateViewRange(_viewRange, expectedModelRange) {\n        return this._validRange(expectedModelRange);\n    }\n    // Model -> View conversion and related methods\n    convertModelPositionToViewPosition(modelPosition) {\n        return this._validPosition(modelPosition);\n    }\n    convertModelRangeToViewRange(modelRange) {\n        return this._validRange(modelRange);\n    }\n    modelPositionIsVisible(modelPosition) {\n        const lineCount = this._lines.model.getLineCount();\n        if (modelPosition.lineNumber < 1 || modelPosition.lineNumber > lineCount) {\n            // invalid arguments\n            return false;\n        }\n        return true;\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        return 1;\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        return modelLineNumber;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue } from '../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Color } from '../../../base/common/color.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { EDITOR_FONT_DEFAULTS, filterValidationDecorations } from '../config/editorOptions.js';\nimport { CursorsController } from '../cursor/cursor.js';\nimport { CursorConfiguration } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport * as textModelEvents from '../textModelEvents.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { tokenizeLineToHTML } from '../languages/textToHtmlTokenizer.js';\nimport * as viewEvents from '../viewEvents.js';\nimport { ViewLayout } from '../viewLayout/viewLayout.js';\nimport { MinimapTokensColorTracker } from './minimapTokensColorTracker.js';\nimport { MinimapLinesRenderingData, OverviewRulerDecorationsGroup, ViewLineRenderingData } from '../viewModel.js';\nimport { ViewModelDecorations } from './viewModelDecorations.js';\nimport { FocusChangedEvent, HiddenAreasChangedEvent, ModelContentChangedEvent, ModelDecorationsChangedEvent, ModelLanguageChangedEvent, ModelLanguageConfigurationChangedEvent, ModelOptionsChangedEvent, ModelTokensChangedEvent, ReadOnlyEditAttemptEvent, ScrollChangedEvent, ViewModelEventDispatcher, ViewZonesChangedEvent } from '../viewModelEventDispatcher.js';\nimport { ViewModelLinesFromModelAsIs, ViewModelLinesFromProjectedModel } from './viewModelLines.js';\nconst USE_IDENTITY_LINES_COLLECTION = true;\nexport class ViewModel extends Disposable {\n    constructor(editorId, configuration, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, scheduleAtNextAnimationFrame, languageConfigurationService, _themeService) {\n        super();\n        this.languageConfigurationService = languageConfigurationService;\n        this._themeService = _themeService;\n        this._editorId = editorId;\n        this._configuration = configuration;\n        this.model = model;\n        this._eventDispatcher = new ViewModelEventDispatcher();\n        this.onEvent = this._eventDispatcher.onEvent;\n        this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n        this._tokenizeViewportSoon = this._register(new RunOnceScheduler(() => this.tokenizeViewport(), 50));\n        this._updateConfigurationViewLineCount = this._register(new RunOnceScheduler(() => this._updateConfigurationViewLineCountNow(), 0));\n        this._hasFocus = false;\n        this._viewportStart = ViewportStart.create(this.model);\n        if (USE_IDENTITY_LINES_COLLECTION && this.model.isTooLargeForTokenization()) {\n            this._lines = new ViewModelLinesFromModelAsIs(this.model);\n        }\n        else {\n            const options = this._configuration.options;\n            const fontInfo = options.get(46 /* EditorOption.fontInfo */);\n            const wrappingStrategy = options.get(127 /* EditorOption.wrappingStrategy */);\n            const wrappingInfo = options.get(134 /* EditorOption.wrappingInfo */);\n            const wrappingIndent = options.get(126 /* EditorOption.wrappingIndent */);\n            this._lines = new ViewModelLinesFromProjectedModel(this._editorId, this.model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, this.model.getOptions().tabSize, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent);\n        }\n        this.coordinatesConverter = this._lines.createCoordinatesConverter();\n        this._cursor = this._register(new CursorsController(model, this, this.coordinatesConverter, this.cursorConfig));\n        this.viewLayout = this._register(new ViewLayout(this._configuration, this.getLineCount(), scheduleAtNextAnimationFrame));\n        this._register(this.viewLayout.onDidScroll((e) => {\n            if (e.scrollTopChanged) {\n                this._tokenizeViewportSoon.schedule();\n            }\n            if (e.scrollTopChanged) {\n                this._viewportStart.invalidate();\n            }\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewScrollChangedEvent(e));\n            this._eventDispatcher.emitOutgoingEvent(new ScrollChangedEvent(e.oldScrollWidth, e.oldScrollLeft, e.oldScrollHeight, e.oldScrollTop, e.scrollWidth, e.scrollLeft, e.scrollHeight, e.scrollTop));\n        }));\n        this._register(this.viewLayout.onDidContentSizeChange((e) => {\n            this._eventDispatcher.emitOutgoingEvent(e);\n        }));\n        this._decorations = new ViewModelDecorations(this._editorId, this.model, this._configuration, this._lines, this.coordinatesConverter);\n        this._registerModelEvents();\n        this._register(this._configuration.onDidChangeFast((e) => {\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                this._onConfigurationChanged(eventsCollector, e);\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n        }));\n        this._register(MinimapTokensColorTracker.getInstance().onDidChange(() => {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensColorsChangedEvent());\n        }));\n        this._register(this._themeService.onDidColorThemeChange((theme) => {\n            this._invalidateDecorationsColorCache();\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewThemeChangedEvent(theme));\n        }));\n        this._updateConfigurationViewLineCountNow();\n    }\n    dispose() {\n        // First remove listeners, as disposing the lines might end up sending\n        // model decoration changed events ... and we no longer care about them ...\n        super.dispose();\n        this._decorations.dispose();\n        this._lines.dispose();\n        this._viewportStart.dispose();\n        this._eventDispatcher.dispose();\n    }\n    createLineBreaksComputer() {\n        return this._lines.createLineBreaksComputer();\n    }\n    addViewEventHandler(eventHandler) {\n        this._eventDispatcher.addViewEventHandler(eventHandler);\n    }\n    removeViewEventHandler(eventHandler) {\n        this._eventDispatcher.removeViewEventHandler(eventHandler);\n    }\n    _updateConfigurationViewLineCountNow() {\n        this._configuration.setViewLineCount(this._lines.getViewLineCount());\n    }\n    tokenizeViewport() {\n        const linesViewportData = this.viewLayout.getLinesViewportData();\n        const viewVisibleRange = new Range(linesViewportData.startLineNumber, this.getLineMinColumn(linesViewportData.startLineNumber), linesViewportData.endLineNumber, this.getLineMaxColumn(linesViewportData.endLineNumber));\n        const modelVisibleRanges = this._toModelVisibleRanges(viewVisibleRange);\n        for (const modelVisibleRange of modelVisibleRanges) {\n            this.model.tokenization.tokenizeViewport(modelVisibleRange.startLineNumber, modelVisibleRange.endLineNumber);\n        }\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n        this._cursor.setHasFocus(hasFocus);\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewFocusChangedEvent(hasFocus));\n        this._eventDispatcher.emitOutgoingEvent(new FocusChangedEvent(!hasFocus, hasFocus));\n    }\n    onCompositionStart() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionStartEvent());\n    }\n    onCompositionEnd() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionEndEvent());\n    }\n    _onConfigurationChanged(eventsCollector, e) {\n        // We might need to restore the current centered view range, so save it (if available)\n        let previousViewportStartModelPosition = null;\n        if (this._viewportStart.isValid) {\n            const previousViewportStartViewPosition = new Position(this._viewportStart.viewLineNumber, this.getLineMinColumn(this._viewportStart.viewLineNumber));\n            previousViewportStartModelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(previousViewportStartViewPosition);\n        }\n        let restorePreviousViewportStart = false;\n        const options = this._configuration.options;\n        const fontInfo = options.get(46 /* EditorOption.fontInfo */);\n        const wrappingStrategy = options.get(127 /* EditorOption.wrappingStrategy */);\n        const wrappingInfo = options.get(134 /* EditorOption.wrappingInfo */);\n        const wrappingIndent = options.get(126 /* EditorOption.wrappingIndent */);\n        if (this._lines.setWrappingSettings(fontInfo, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent)) {\n            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n            eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n            this._cursor.onLineMappingChanged(eventsCollector);\n            this._decorations.onLineMappingChanged();\n            this.viewLayout.onFlushed(this.getLineCount());\n            if (this.viewLayout.getCurrentScrollTop() !== 0) {\n                // Never change the scroll position from 0 to something else...\n                restorePreviousViewportStart = true;\n            }\n            this._updateConfigurationViewLineCount.schedule();\n        }\n        if (e.hasChanged(83 /* EditorOption.readOnly */)) {\n            // Must read again all decorations due to readOnly filtering\n            this._decorations.reset();\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n        }\n        eventsCollector.emitViewEvent(new viewEvents.ViewConfigurationChangedEvent(e));\n        this.viewLayout.onConfigurationChanged(e);\n        if (restorePreviousViewportStart && previousViewportStartModelPosition) {\n            const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(previousViewportStartModelPosition);\n            const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n            this.viewLayout.setScrollPosition({ scrollTop: viewPositionTop + this._viewportStart.startLineDelta }, 1 /* ScrollType.Immediate */);\n        }\n        if (CursorConfiguration.shouldRecreate(e)) {\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n        }\n    }\n    _registerModelEvents() {\n        this._register(this.model.onDidChangeContentOrInjectedText((e) => {\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                let hadOtherModelChange = false;\n                let hadModelLineChangeThatChangedLineMapping = false;\n                const changes = (e instanceof textModelEvents.InternalModelContentChangeEvent ? e.rawContentChangedEvent.changes : e.changes);\n                const versionId = (e instanceof textModelEvents.InternalModelContentChangeEvent ? e.rawContentChangedEvent.versionId : null);\n                // Do a first pass to compute line mappings, and a second pass to actually interpret them\n                const lineBreaksComputer = this._lines.createLineBreaksComputer();\n                for (const change of changes) {\n                    switch (change.changeType) {\n                        case 4 /* textModelEvents.RawContentChangedType.LinesInserted */: {\n                            for (let lineIdx = 0; lineIdx < change.detail.length; lineIdx++) {\n                                const line = change.detail[lineIdx];\n                                let injectedText = change.injectedTexts[lineIdx];\n                                if (injectedText) {\n                                    injectedText = injectedText.filter(element => (!element.ownerId || element.ownerId === this._editorId));\n                                }\n                                lineBreaksComputer.addRequest(line, injectedText, null);\n                            }\n                            break;\n                        }\n                        case 2 /* textModelEvents.RawContentChangedType.LineChanged */: {\n                            let injectedText = null;\n                            if (change.injectedText) {\n                                injectedText = change.injectedText.filter(element => (!element.ownerId || element.ownerId === this._editorId));\n                            }\n                            lineBreaksComputer.addRequest(change.detail, injectedText, null);\n                            break;\n                        }\n                    }\n                }\n                const lineBreaks = lineBreaksComputer.finalize();\n                const lineBreakQueue = new ArrayQueue(lineBreaks);\n                for (const change of changes) {\n                    switch (change.changeType) {\n                        case 1 /* textModelEvents.RawContentChangedType.Flush */: {\n                            this._lines.onModelFlushed();\n                            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                            this._decorations.reset();\n                            this.viewLayout.onFlushed(this.getLineCount());\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 3 /* textModelEvents.RawContentChangedType.LinesDeleted */: {\n                            const linesDeletedEvent = this._lines.onModelLinesDeleted(versionId, change.fromLineNumber, change.toLineNumber);\n                            if (linesDeletedEvent !== null) {\n                                eventsCollector.emitViewEvent(linesDeletedEvent);\n                                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                            }\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 4 /* textModelEvents.RawContentChangedType.LinesInserted */: {\n                            const insertedLineBreaks = lineBreakQueue.takeCount(change.detail.length);\n                            const linesInsertedEvent = this._lines.onModelLinesInserted(versionId, change.fromLineNumber, change.toLineNumber, insertedLineBreaks);\n                            if (linesInsertedEvent !== null) {\n                                eventsCollector.emitViewEvent(linesInsertedEvent);\n                                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                            }\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 2 /* textModelEvents.RawContentChangedType.LineChanged */: {\n                            const changedLineBreakData = lineBreakQueue.dequeue();\n                            const [lineMappingChanged, linesChangedEvent, linesInsertedEvent, linesDeletedEvent] = this._lines.onModelLineChanged(versionId, change.lineNumber, changedLineBreakData);\n                            hadModelLineChangeThatChangedLineMapping = lineMappingChanged;\n                            if (linesChangedEvent) {\n                                eventsCollector.emitViewEvent(linesChangedEvent);\n                            }\n                            if (linesInsertedEvent) {\n                                eventsCollector.emitViewEvent(linesInsertedEvent);\n                                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                            }\n                            if (linesDeletedEvent) {\n                                eventsCollector.emitViewEvent(linesDeletedEvent);\n                                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                            }\n                            break;\n                        }\n                        case 5 /* textModelEvents.RawContentChangedType.EOLChanged */: {\n                            // Nothing to do. The new version will be accepted below\n                            break;\n                        }\n                    }\n                }\n                if (versionId !== null) {\n                    this._lines.acceptVersionId(versionId);\n                }\n                this.viewLayout.onHeightMaybeChanged();\n                if (!hadOtherModelChange && hadModelLineChangeThatChangedLineMapping) {\n                    eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                    this._cursor.onLineMappingChanged(eventsCollector);\n                    this._decorations.onLineMappingChanged();\n                }\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n            // Update the configuration and reset the centered view line\n            const viewportStartWasValid = this._viewportStart.isValid;\n            this._viewportStart.invalidate();\n            this._configuration.setModelLineCount(this.model.getLineCount());\n            this._updateConfigurationViewLineCountNow();\n            // Recover viewport\n            if (!this._hasFocus && this.model.getAttachedEditorCount() >= 2 && viewportStartWasValid) {\n                const modelRange = this.model._getTrackedRange(this._viewportStart.modelTrackedRange);\n                if (modelRange) {\n                    const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelRange.getStartPosition());\n                    const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n                    this.viewLayout.setScrollPosition({ scrollTop: viewPositionTop + this._viewportStart.startLineDelta }, 1 /* ScrollType.Immediate */);\n                }\n            }\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                if (e instanceof textModelEvents.InternalModelContentChangeEvent) {\n                    eventsCollector.emitOutgoingEvent(new ModelContentChangedEvent(e.contentChangedEvent));\n                }\n                this._cursor.onModelContentChanged(eventsCollector, e);\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n            this._tokenizeViewportSoon.schedule();\n        }));\n        this._register(this.model.onDidChangeTokens((e) => {\n            const viewRanges = [];\n            for (let j = 0, lenJ = e.ranges.length; j < lenJ; j++) {\n                const modelRange = e.ranges[j];\n                const viewStartLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.fromLineNumber, 1)).lineNumber;\n                const viewEndLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.toLineNumber, this.model.getLineMaxColumn(modelRange.toLineNumber))).lineNumber;\n                viewRanges[j] = {\n                    fromLineNumber: viewStartLineNumber,\n                    toLineNumber: viewEndLineNumber\n                };\n            }\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensChangedEvent(viewRanges));\n            if (e.tokenizationSupportChanged) {\n                this._tokenizeViewportSoon.schedule();\n            }\n            this._eventDispatcher.emitOutgoingEvent(new ModelTokensChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeLanguageConfiguration((e) => {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewLanguageConfigurationEvent());\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n            this._eventDispatcher.emitOutgoingEvent(new ModelLanguageConfigurationChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeLanguage((e) => {\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n            this._eventDispatcher.emitOutgoingEvent(new ModelLanguageChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeOptions((e) => {\n            // A tab size change causes a line mapping changed event => all view parts will repaint OK, no further event needed here\n            if (this._lines.setTabSize(this.model.getOptions().tabSize)) {\n                try {\n                    const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                    eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                    this._cursor.onLineMappingChanged(eventsCollector);\n                    this._decorations.onLineMappingChanged();\n                    this.viewLayout.onFlushed(this.getLineCount());\n                }\n                finally {\n                    this._eventDispatcher.endEmitViewEvents();\n                }\n                this._updateConfigurationViewLineCount.schedule();\n            }\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n            this._eventDispatcher.emitOutgoingEvent(new ModelOptionsChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeDecorations((e) => {\n            this._decorations.onModelDecorationsChanged();\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewDecorationsChangedEvent(e));\n            this._eventDispatcher.emitOutgoingEvent(new ModelDecorationsChangedEvent(e));\n        }));\n    }\n    setHiddenAreas(ranges) {\n        let lineMappingChanged = false;\n        try {\n            const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n            lineMappingChanged = this._lines.setHiddenAreas(ranges);\n            if (lineMappingChanged) {\n                eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                this._cursor.onLineMappingChanged(eventsCollector);\n                this._decorations.onLineMappingChanged();\n                this.viewLayout.onFlushed(this.getLineCount());\n                this.viewLayout.onHeightMaybeChanged();\n            }\n        }\n        finally {\n            this._eventDispatcher.endEmitViewEvents();\n        }\n        this._updateConfigurationViewLineCount.schedule();\n        if (lineMappingChanged) {\n            this._eventDispatcher.emitOutgoingEvent(new HiddenAreasChangedEvent());\n        }\n    }\n    getVisibleRangesPlusViewportAboveBelow() {\n        const layoutInfo = this._configuration.options.get(133 /* EditorOption.layoutInfo */);\n        const lineHeight = this._configuration.options.get(61 /* EditorOption.lineHeight */);\n        const linesAround = Math.max(20, Math.round(layoutInfo.height / lineHeight));\n        const partialData = this.viewLayout.getLinesViewportData();\n        const startViewLineNumber = Math.max(1, partialData.completelyVisibleStartLineNumber - linesAround);\n        const endViewLineNumber = Math.min(this.getLineCount(), partialData.completelyVisibleEndLineNumber + linesAround);\n        return this._toModelVisibleRanges(new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber)));\n    }\n    getVisibleRanges() {\n        const visibleViewRange = this.getCompletelyVisibleViewRange();\n        return this._toModelVisibleRanges(visibleViewRange);\n    }\n    getHiddenAreas() {\n        return this._lines.getHiddenAreas();\n    }\n    _toModelVisibleRanges(visibleViewRange) {\n        const visibleRange = this.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n        const hiddenAreas = this._lines.getHiddenAreas();\n        if (hiddenAreas.length === 0) {\n            return [visibleRange];\n        }\n        const result = [];\n        let resultLen = 0;\n        let startLineNumber = visibleRange.startLineNumber;\n        let startColumn = visibleRange.startColumn;\n        const endLineNumber = visibleRange.endLineNumber;\n        const endColumn = visibleRange.endColumn;\n        for (let i = 0, len = hiddenAreas.length; i < len; i++) {\n            const hiddenStartLineNumber = hiddenAreas[i].startLineNumber;\n            const hiddenEndLineNumber = hiddenAreas[i].endLineNumber;\n            if (hiddenEndLineNumber < startLineNumber) {\n                continue;\n            }\n            if (hiddenStartLineNumber > endLineNumber) {\n                continue;\n            }\n            if (startLineNumber < hiddenStartLineNumber) {\n                result[resultLen++] = new Range(startLineNumber, startColumn, hiddenStartLineNumber - 1, this.model.getLineMaxColumn(hiddenStartLineNumber - 1));\n            }\n            startLineNumber = hiddenEndLineNumber + 1;\n            startColumn = 1;\n        }\n        if (startLineNumber < endLineNumber || (startLineNumber === endLineNumber && startColumn < endColumn)) {\n            result[resultLen++] = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        return result;\n    }\n    getCompletelyVisibleViewRange() {\n        const partialData = this.viewLayout.getLinesViewportData();\n        const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n        const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n    }\n    getCompletelyVisibleViewRangeAtScrollTop(scrollTop) {\n        const partialData = this.viewLayout.getLinesViewportDataAtScrollTop(scrollTop);\n        const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n        const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n    }\n    saveState() {\n        const compatViewState = this.viewLayout.saveState();\n        const scrollTop = compatViewState.scrollTop;\n        const firstViewLineNumber = this.viewLayout.getLineNumberAtVerticalOffset(scrollTop);\n        const firstPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(firstViewLineNumber, this.getLineMinColumn(firstViewLineNumber)));\n        const firstPositionDeltaTop = this.viewLayout.getVerticalOffsetForLineNumber(firstViewLineNumber) - scrollTop;\n        return {\n            scrollLeft: compatViewState.scrollLeft,\n            firstPosition: firstPosition,\n            firstPositionDeltaTop: firstPositionDeltaTop\n        };\n    }\n    reduceRestoreState(state) {\n        if (typeof state.firstPosition === 'undefined') {\n            // This is a view state serialized by an older version\n            return this._reduceRestoreStateCompatibility(state);\n        }\n        const modelPosition = this.model.validatePosition(state.firstPosition);\n        const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);\n        const scrollTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber) - state.firstPositionDeltaTop;\n        return {\n            scrollLeft: state.scrollLeft,\n            scrollTop: scrollTop\n        };\n    }\n    _reduceRestoreStateCompatibility(state) {\n        return {\n            scrollLeft: state.scrollLeft,\n            scrollTop: state.scrollTopWithoutViewZones\n        };\n    }\n    getTabSize() {\n        return this.model.getOptions().tabSize;\n    }\n    getLineCount() {\n        return this._lines.getViewLineCount();\n    }\n    /**\n     * Gives a hint that a lot of requests are about to come in for these line numbers.\n     */\n    setViewport(startLineNumber, endLineNumber, centeredLineNumber) {\n        this._viewportStart.update(this, startLineNumber);\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        return this._lines.getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        return this._lines.getViewLinesIndentGuides(startLineNumber, endLineNumber);\n    }\n    getBracketGuidesInRangeByLine(startLineNumber, endLineNumber, activePosition, options) {\n        return this._lines.getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options);\n    }\n    getLineContent(lineNumber) {\n        return this._lines.getViewLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        return this._lines.getViewLineLength(lineNumber);\n    }\n    getLineMinColumn(lineNumber) {\n        return this._lines.getViewLineMinColumn(lineNumber);\n    }\n    getLineMaxColumn(lineNumber) {\n        return this._lines.getViewLineMaxColumn(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    getDecorationsInViewport(visibleRange) {\n        return this._decorations.getDecorationsViewportData(visibleRange).decorations;\n    }\n    getInjectedTextAt(viewPosition) {\n        return this._lines.getInjectedTextAt(viewPosition);\n    }\n    getViewportViewLineRenderingData(visibleRange, lineNumber) {\n        const allInlineDecorations = this._decorations.getDecorationsViewportData(visibleRange).inlineDecorations;\n        const inlineDecorations = allInlineDecorations[lineNumber - visibleRange.startLineNumber];\n        return this._getViewLineRenderingData(lineNumber, inlineDecorations);\n    }\n    getViewLineRenderingData(lineNumber) {\n        const inlineDecorations = this._decorations.getInlineDecorationsOnLine(lineNumber);\n        return this._getViewLineRenderingData(lineNumber, inlineDecorations);\n    }\n    _getViewLineRenderingData(lineNumber, inlineDecorations) {\n        const mightContainRTL = this.model.mightContainRTL();\n        const mightContainNonBasicASCII = this.model.mightContainNonBasicASCII();\n        const tabSize = this.getTabSize();\n        const lineData = this._lines.getViewLineData(lineNumber);\n        if (lineData.inlineDecorations) {\n            inlineDecorations = [\n                ...inlineDecorations,\n                ...lineData.inlineDecorations.map(d => d.toInlineDecoration(lineNumber))\n            ];\n        }\n        return new ViewLineRenderingData(lineData.minColumn, lineData.maxColumn, lineData.content, lineData.continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, lineData.tokens, inlineDecorations, tabSize, lineData.startVisibleColumn);\n    }\n    getViewLineData(lineNumber) {\n        return this._lines.getViewLineData(lineNumber);\n    }\n    getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n        const result = this._lines.getViewLinesData(startLineNumber, endLineNumber, needed);\n        return new MinimapLinesRenderingData(this.getTabSize(), result);\n    }\n    getAllOverviewRulerDecorations(theme) {\n        const decorations = this.model.getOverviewRulerDecorations(this._editorId, filterValidationDecorations(this._configuration.options));\n        const result = new OverviewRulerDecorations();\n        for (const decoration of decorations) {\n            const decorationOptions = decoration.options;\n            const opts = decorationOptions.overviewRuler;\n            if (!opts) {\n                continue;\n            }\n            const lane = opts.position;\n            if (lane === 0) {\n                continue;\n            }\n            const color = opts.getColor(theme.value);\n            const viewStartLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.startLineNumber, decoration.range.startColumn);\n            const viewEndLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.endLineNumber, decoration.range.endColumn);\n            result.accept(color, decorationOptions.zIndex, viewStartLineNumber, viewEndLineNumber, lane);\n        }\n        return result.asArray;\n    }\n    _invalidateDecorationsColorCache() {\n        const decorations = this.model.getOverviewRulerDecorations();\n        for (const decoration of decorations) {\n            const opts1 = decoration.options.overviewRuler;\n            if (opts1) {\n                opts1.invalidateCachedColor();\n            }\n            const opts2 = decoration.options.minimap;\n            if (opts2) {\n                opts2.invalidateCachedColor();\n            }\n        }\n    }\n    getValueInRange(range, eol) {\n        const modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range);\n        return this.model.getValueInRange(modelRange, eol);\n    }\n    deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt) {\n        const modelAnchor = this.coordinatesConverter.convertViewPositionToModelPosition(viewAnchorPosition);\n        if (this.model.getEOL().length === 2) {\n            // This model uses CRLF, so the delta must take that into account\n            if (deltaOffset < 0) {\n                deltaOffset -= lineFeedCnt;\n            }\n            else {\n                deltaOffset += lineFeedCnt;\n            }\n        }\n        const modelAnchorOffset = this.model.getOffsetAt(modelAnchor);\n        const resultOffset = modelAnchorOffset + deltaOffset;\n        return this.model.getPositionAt(resultOffset);\n    }\n    getPlainTextToCopy(modelRanges, emptySelectionClipboard, forceCRLF) {\n        const newLineCharacter = forceCRLF ? '\\r\\n' : this.model.getEOL();\n        modelRanges = modelRanges.slice(0);\n        modelRanges.sort(Range.compareRangesUsingStarts);\n        let hasEmptyRange = false;\n        let hasNonEmptyRange = false;\n        for (const range of modelRanges) {\n            if (range.isEmpty()) {\n                hasEmptyRange = true;\n            }\n            else {\n                hasNonEmptyRange = true;\n            }\n        }\n        if (!hasNonEmptyRange) {\n            // all ranges are empty\n            if (!emptySelectionClipboard) {\n                return '';\n            }\n            const modelLineNumbers = modelRanges.map((r) => r.startLineNumber);\n            let result = '';\n            for (let i = 0; i < modelLineNumbers.length; i++) {\n                if (i > 0 && modelLineNumbers[i - 1] === modelLineNumbers[i]) {\n                    continue;\n                }\n                result += this.model.getLineContent(modelLineNumbers[i]) + newLineCharacter;\n            }\n            return result;\n        }\n        if (hasEmptyRange && emptySelectionClipboard) {\n            // mixed empty selections and non-empty selections\n            const result = [];\n            let prevModelLineNumber = 0;\n            for (const modelRange of modelRanges) {\n                const modelLineNumber = modelRange.startLineNumber;\n                if (modelRange.isEmpty()) {\n                    if (modelLineNumber !== prevModelLineNumber) {\n                        result.push(this.model.getLineContent(modelLineNumber));\n                    }\n                }\n                else {\n                    result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* EndOfLinePreference.CRLF */ : 0 /* EndOfLinePreference.TextDefined */));\n                }\n                prevModelLineNumber = modelLineNumber;\n            }\n            return result.length === 1 ? result[0] : result;\n        }\n        const result = [];\n        for (const modelRange of modelRanges) {\n            if (!modelRange.isEmpty()) {\n                result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* EndOfLinePreference.CRLF */ : 0 /* EndOfLinePreference.TextDefined */));\n            }\n        }\n        return result.length === 1 ? result[0] : result;\n    }\n    getRichTextToCopy(modelRanges, emptySelectionClipboard) {\n        const languageId = this.model.getLanguageId();\n        if (languageId === PLAINTEXT_LANGUAGE_ID) {\n            return null;\n        }\n        if (modelRanges.length !== 1) {\n            // no multiple selection support at this time\n            return null;\n        }\n        let range = modelRanges[0];\n        if (range.isEmpty()) {\n            if (!emptySelectionClipboard) {\n                // nothing to copy\n                return null;\n            }\n            const lineNumber = range.startLineNumber;\n            range = new Range(lineNumber, this.model.getLineMinColumn(lineNumber), lineNumber, this.model.getLineMaxColumn(lineNumber));\n        }\n        const fontInfo = this._configuration.options.get(46 /* EditorOption.fontInfo */);\n        const colorMap = this._getColorMap();\n        const hasBadChars = (/[:;\\\\\\/<>]/.test(fontInfo.fontFamily));\n        const useDefaultFontFamily = (hasBadChars || fontInfo.fontFamily === EDITOR_FONT_DEFAULTS.fontFamily);\n        let fontFamily;\n        if (useDefaultFontFamily) {\n            fontFamily = EDITOR_FONT_DEFAULTS.fontFamily;\n        }\n        else {\n            fontFamily = fontInfo.fontFamily;\n            fontFamily = fontFamily.replace(/\"/g, '\\'');\n            const hasQuotesOrIsList = /[,']/.test(fontFamily);\n            if (!hasQuotesOrIsList) {\n                const needsQuotes = /[+ ]/.test(fontFamily);\n                if (needsQuotes) {\n                    fontFamily = `'${fontFamily}'`;\n                }\n            }\n            fontFamily = `${fontFamily}, ${EDITOR_FONT_DEFAULTS.fontFamily}`;\n        }\n        return {\n            mode: languageId,\n            html: (`<div style=\"`\n                + `color: ${colorMap[1 /* ColorId.DefaultForeground */]};`\n                + `background-color: ${colorMap[2 /* ColorId.DefaultBackground */]};`\n                + `font-family: ${fontFamily};`\n                + `font-weight: ${fontInfo.fontWeight};`\n                + `font-size: ${fontInfo.fontSize}px;`\n                + `line-height: ${fontInfo.lineHeight}px;`\n                + `white-space: pre;`\n                + `\">`\n                + this._getHTMLToCopy(range, colorMap)\n                + '</div>')\n        };\n    }\n    _getHTMLToCopy(modelRange, colorMap) {\n        const startLineNumber = modelRange.startLineNumber;\n        const startColumn = modelRange.startColumn;\n        const endLineNumber = modelRange.endLineNumber;\n        const endColumn = modelRange.endColumn;\n        const tabSize = this.getTabSize();\n        let result = '';\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const lineTokens = this.model.tokenization.getLineTokens(lineNumber);\n            const lineContent = lineTokens.getLineContent();\n            const startOffset = (lineNumber === startLineNumber ? startColumn - 1 : 0);\n            const endOffset = (lineNumber === endLineNumber ? endColumn - 1 : lineContent.length);\n            if (lineContent === '') {\n                result += '<br>';\n            }\n            else {\n                result += tokenizeLineToHTML(lineContent, lineTokens.inflate(), colorMap, startOffset, endOffset, tabSize, platform.isWindows);\n            }\n        }\n        return result;\n    }\n    _getColorMap() {\n        const colorMap = TokenizationRegistry.getColorMap();\n        const result = ['#000000'];\n        if (colorMap) {\n            for (let i = 1, len = colorMap.length; i < len; i++) {\n                result[i] = Color.Format.CSS.formatHex(colorMap[i]);\n            }\n        }\n        return result;\n    }\n    //#region cursor operations\n    getPrimaryCursorState() {\n        return this._cursor.getPrimaryCursorState();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursor.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursor.getCursorStates();\n    }\n    setCursorStates(source, reason, states) {\n        return this._withViewEventsCollector(eventsCollector => this._cursor.setStates(eventsCollector, source, reason, states));\n    }\n    getCursorColumnSelectData() {\n        return this._cursor.getCursorColumnSelectData();\n    }\n    getCursorAutoClosedCharacters() {\n        return this._cursor.getAutoClosedCharacters();\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._cursor.setCursorColumnSelectData(columnSelectData);\n    }\n    getPrevEditOperationType() {\n        return this._cursor.getPrevEditOperationType();\n    }\n    setPrevEditOperationType(type) {\n        this._cursor.setPrevEditOperationType(type);\n    }\n    getSelection() {\n        return this._cursor.getSelection();\n    }\n    getSelections() {\n        return this._cursor.getSelections();\n    }\n    getPosition() {\n        return this._cursor.getPrimaryCursorState().modelState.position;\n    }\n    setSelections(source, selections, reason = 0 /* CursorChangeReason.NotSet */) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.setSelections(eventsCollector, source, selections, reason));\n    }\n    saveCursorState() {\n        return this._cursor.saveState();\n    }\n    restoreCursorState(states) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.restoreState(eventsCollector, states));\n    }\n    _executeCursorEdit(callback) {\n        if (this._cursor.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            this._eventDispatcher.emitOutgoingEvent(new ReadOnlyEditAttemptEvent());\n            return;\n        }\n        this._withViewEventsCollector(callback);\n    }\n    executeEdits(source, edits, cursorStateComputer) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeEdits(eventsCollector, source, edits, cursorStateComputer));\n    }\n    startComposition() {\n        this._executeCursorEdit(eventsCollector => this._cursor.startComposition(eventsCollector));\n    }\n    endComposition(source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.endComposition(eventsCollector, source));\n    }\n    type(text, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.type(eventsCollector, text, source));\n    }\n    compositionType(text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source));\n    }\n    paste(text, pasteOnNewLine, multicursorText, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.paste(eventsCollector, text, pasteOnNewLine, multicursorText, source));\n    }\n    cut(source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.cut(eventsCollector, source));\n    }\n    executeCommand(command, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeCommand(eventsCollector, command, source));\n    }\n    executeCommands(commands, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeCommands(eventsCollector, commands, source));\n    }\n    revealPrimaryCursor(source, revealHorizontal, minimalReveal = false) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.revealPrimary(eventsCollector, source, minimalReveal, 0 /* viewEvents.VerticalRevealType.Simple */, revealHorizontal, 0 /* ScrollType.Smooth */));\n    }\n    revealTopMostCursor(source) {\n        const viewPosition = this._cursor.getTopMostViewPosition();\n        const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, 0 /* viewEvents.VerticalRevealType.Simple */, true, 0 /* ScrollType.Smooth */)));\n    }\n    revealBottomMostCursor(source) {\n        const viewPosition = this._cursor.getBottomMostViewPosition();\n        const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, 0 /* viewEvents.VerticalRevealType.Simple */, true, 0 /* ScrollType.Smooth */)));\n    }\n    revealRange(source, revealHorizontal, viewRange, verticalType, scrollType) {\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, verticalType, revealHorizontal, scrollType)));\n    }\n    //#endregion\n    //#region viewLayout\n    changeWhitespace(callback) {\n        const hadAChange = this.viewLayout.changeWhitespace(callback);\n        if (hadAChange) {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewZonesChangedEvent());\n            this._eventDispatcher.emitOutgoingEvent(new ViewZonesChangedEvent());\n        }\n    }\n    //#endregion\n    _withViewEventsCollector(callback) {\n        try {\n            const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n            return callback(eventsCollector);\n        }\n        finally {\n            this._eventDispatcher.endEmitViewEvents();\n        }\n    }\n    normalizePosition(position, affinity) {\n        return this._lines.normalizePosition(position, affinity);\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        return this._lines.getLineIndentColumn(lineNumber);\n    }\n}\nclass ViewportStart {\n    constructor(_model, _viewLineNumber, _isValid, _modelTrackedRange, _startLineDelta) {\n        this._model = _model;\n        this._viewLineNumber = _viewLineNumber;\n        this._isValid = _isValid;\n        this._modelTrackedRange = _modelTrackedRange;\n        this._startLineDelta = _startLineDelta;\n    }\n    static create(model) {\n        const viewportStartLineTrackedRange = model._setTrackedRange(null, new Range(1, 1, 1, 1), 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        return new ViewportStart(model, 1, false, viewportStartLineTrackedRange, 0);\n    }\n    get viewLineNumber() {\n        return this._viewLineNumber;\n    }\n    get isValid() {\n        return this._isValid;\n    }\n    get modelTrackedRange() {\n        return this._modelTrackedRange;\n    }\n    get startLineDelta() {\n        return this._startLineDelta;\n    }\n    dispose() {\n        this._model._setTrackedRange(this._modelTrackedRange, null, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n    }\n    update(viewModel, startLineNumber) {\n        const position = viewModel.coordinatesConverter.convertViewPositionToModelPosition(new Position(startLineNumber, viewModel.getLineMinColumn(startLineNumber)));\n        const viewportStartLineTrackedRange = viewModel.model._setTrackedRange(this._modelTrackedRange, new Range(position.lineNumber, position.column, position.lineNumber, position.column), 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        const viewportStartLineTop = viewModel.viewLayout.getVerticalOffsetForLineNumber(startLineNumber);\n        const scrollTop = viewModel.viewLayout.getCurrentScrollTop();\n        this._viewLineNumber = startLineNumber;\n        this._isValid = true;\n        this._modelTrackedRange = viewportStartLineTrackedRange;\n        this._startLineDelta = scrollTop - viewportStartLineTop;\n    }\n    invalidate() {\n        this._isValid = false;\n    }\n}\nclass OverviewRulerDecorations {\n    constructor() {\n        this._asMap = Object.create(null);\n        this.asArray = [];\n    }\n    accept(color, zIndex, startLineNumber, endLineNumber, lane) {\n        const prevGroup = this._asMap[color];\n        if (prevGroup) {\n            const prevData = prevGroup.data;\n            const prevLane = prevData[prevData.length - 3];\n            const prevEndLineNumber = prevData[prevData.length - 1];\n            if (prevLane === lane && prevEndLineNumber + 1 >= startLineNumber) {\n                // merge into prev\n                if (endLineNumber > prevEndLineNumber) {\n                    prevData[prevData.length - 1] = endLineNumber;\n                }\n                return;\n            }\n            // push\n            prevData.push(lane, startLineNumber, endLineNumber);\n        }\n        else {\n            const group = new OverviewRulerDecorationsGroup(color, zIndex, [lane, startLineNumber, endLineNumber]);\n            this._asMap[color] = group;\n            this.asArray.push(group);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../base/common/event.js';\nimport { Disposable } from '../../base/common/lifecycle.js';\nexport class ViewModelEventDispatcher extends Disposable {\n    constructor() {\n        super();\n        this._onEvent = this._register(new Emitter());\n        this.onEvent = this._onEvent.event;\n        this._eventHandlers = [];\n        this._viewEventQueue = null;\n        this._isConsumingViewEventQueue = false;\n        this._collector = null;\n        this._collectorCnt = 0;\n        this._outgoingEvents = [];\n    }\n    emitOutgoingEvent(e) {\n        this._addOutgoingEvent(e);\n        this._emitOutgoingEvents();\n    }\n    _addOutgoingEvent(e) {\n        for (let i = 0, len = this._outgoingEvents.length; i < len; i++) {\n            const mergeResult = (this._outgoingEvents[i].kind === e.kind ? this._outgoingEvents[i].attemptToMerge(e) : null);\n            if (mergeResult) {\n                this._outgoingEvents[i] = mergeResult;\n                return;\n            }\n        }\n        // not merged\n        this._outgoingEvents.push(e);\n    }\n    _emitOutgoingEvents() {\n        while (this._outgoingEvents.length > 0) {\n            if (this._collector || this._isConsumingViewEventQueue) {\n                // right now collecting or emitting view events, so let's postpone emitting\n                return;\n            }\n            const event = this._outgoingEvents.shift();\n            if (event.isNoOp()) {\n                continue;\n            }\n            this._onEvent.fire(event);\n        }\n    }\n    addViewEventHandler(eventHandler) {\n        for (let i = 0, len = this._eventHandlers.length; i < len; i++) {\n            if (this._eventHandlers[i] === eventHandler) {\n                console.warn('Detected duplicate listener in ViewEventDispatcher', eventHandler);\n            }\n        }\n        this._eventHandlers.push(eventHandler);\n    }\n    removeViewEventHandler(eventHandler) {\n        for (let i = 0; i < this._eventHandlers.length; i++) {\n            if (this._eventHandlers[i] === eventHandler) {\n                this._eventHandlers.splice(i, 1);\n                break;\n            }\n        }\n    }\n    beginEmitViewEvents() {\n        this._collectorCnt++;\n        if (this._collectorCnt === 1) {\n            this._collector = new ViewModelEventsCollector();\n        }\n        return this._collector;\n    }\n    endEmitViewEvents() {\n        this._collectorCnt--;\n        if (this._collectorCnt === 0) {\n            const outgoingEvents = this._collector.outgoingEvents;\n            const viewEvents = this._collector.viewEvents;\n            this._collector = null;\n            for (const outgoingEvent of outgoingEvents) {\n                this._addOutgoingEvent(outgoingEvent);\n            }\n            if (viewEvents.length > 0) {\n                this._emitMany(viewEvents);\n            }\n        }\n        this._emitOutgoingEvents();\n    }\n    emitSingleViewEvent(event) {\n        try {\n            const eventsCollector = this.beginEmitViewEvents();\n            eventsCollector.emitViewEvent(event);\n        }\n        finally {\n            this.endEmitViewEvents();\n        }\n    }\n    _emitMany(events) {\n        if (this._viewEventQueue) {\n            this._viewEventQueue = this._viewEventQueue.concat(events);\n        }\n        else {\n            this._viewEventQueue = events;\n        }\n        if (!this._isConsumingViewEventQueue) {\n            this._consumeViewEventQueue();\n        }\n    }\n    _consumeViewEventQueue() {\n        try {\n            this._isConsumingViewEventQueue = true;\n            this._doConsumeQueue();\n        }\n        finally {\n            this._isConsumingViewEventQueue = false;\n        }\n    }\n    _doConsumeQueue() {\n        while (this._viewEventQueue) {\n            // Empty event queue, as events might come in while sending these off\n            const events = this._viewEventQueue;\n            this._viewEventQueue = null;\n            // Use a clone of the event handlers list, as they might remove themselves\n            const eventHandlers = this._eventHandlers.slice(0);\n            for (const eventHandler of eventHandlers) {\n                eventHandler.handleEvents(events);\n            }\n        }\n    }\n}\nexport class ViewModelEventsCollector {\n    constructor() {\n        this.viewEvents = [];\n        this.outgoingEvents = [];\n    }\n    emitViewEvent(event) {\n        this.viewEvents.push(event);\n    }\n    emitOutgoingEvent(e) {\n        this.outgoingEvents.push(e);\n    }\n}\nexport class ContentSizeChangedEvent {\n    constructor(oldContentWidth, oldContentHeight, contentWidth, contentHeight) {\n        this.kind = 0 /* OutgoingViewModelEventKind.ContentSizeChanged */;\n        this._oldContentWidth = oldContentWidth;\n        this._oldContentHeight = oldContentHeight;\n        this.contentWidth = contentWidth;\n        this.contentHeight = contentHeight;\n        this.contentWidthChanged = (this._oldContentWidth !== this.contentWidth);\n        this.contentHeightChanged = (this._oldContentHeight !== this.contentHeight);\n    }\n    isNoOp() {\n        return (!this.contentWidthChanged && !this.contentHeightChanged);\n    }\n    attemptToMerge(other) {\n        if (other.kind !== this.kind) {\n            return null;\n        }\n        return new ContentSizeChangedEvent(this._oldContentWidth, this._oldContentHeight, other.contentWidth, other.contentHeight);\n    }\n}\nexport class FocusChangedEvent {\n    constructor(oldHasFocus, hasFocus) {\n        this.kind = 1 /* OutgoingViewModelEventKind.FocusChanged */;\n        this.oldHasFocus = oldHasFocus;\n        this.hasFocus = hasFocus;\n    }\n    isNoOp() {\n        return (this.oldHasFocus === this.hasFocus);\n    }\n    attemptToMerge(other) {\n        if (other.kind !== this.kind) {\n            return null;\n        }\n        return new FocusChangedEvent(this.oldHasFocus, other.hasFocus);\n    }\n}\nexport class ScrollChangedEvent {\n    constructor(oldScrollWidth, oldScrollLeft, oldScrollHeight, oldScrollTop, scrollWidth, scrollLeft, scrollHeight, scrollTop) {\n        this.kind = 2 /* OutgoingViewModelEventKind.ScrollChanged */;\n        this._oldScrollWidth = oldScrollWidth;\n        this._oldScrollLeft = oldScrollLeft;\n        this._oldScrollHeight = oldScrollHeight;\n        this._oldScrollTop = oldScrollTop;\n        this.scrollWidth = scrollWidth;\n        this.scrollLeft = scrollLeft;\n        this.scrollHeight = scrollHeight;\n        this.scrollTop = scrollTop;\n        this.scrollWidthChanged = (this._oldScrollWidth !== this.scrollWidth);\n        this.scrollLeftChanged = (this._oldScrollLeft !== this.scrollLeft);\n        this.scrollHeightChanged = (this._oldScrollHeight !== this.scrollHeight);\n        this.scrollTopChanged = (this._oldScrollTop !== this.scrollTop);\n    }\n    isNoOp() {\n        return (!this.scrollWidthChanged && !this.scrollLeftChanged && !this.scrollHeightChanged && !this.scrollTopChanged);\n    }\n    attemptToMerge(other) {\n        if (other.kind !== this.kind) {\n            return null;\n        }\n        return new ScrollChangedEvent(this._oldScrollWidth, this._oldScrollLeft, this._oldScrollHeight, this._oldScrollTop, other.scrollWidth, other.scrollLeft, other.scrollHeight, other.scrollTop);\n    }\n}\nexport class ViewZonesChangedEvent {\n    constructor() {\n        this.kind = 3 /* OutgoingViewModelEventKind.ViewZonesChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        if (other.kind !== this.kind) {\n            return null;\n        }\n        return this;\n    }\n}\nexport class HiddenAreasChangedEvent {\n    constructor() {\n        this.kind = 4 /* OutgoingViewModelEventKind.HiddenAreasChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        if (other.kind !== this.kind) {\n            return null;\n        }\n        return this;\n    }\n}\nexport class CursorStateChangedEvent {\n    constructor(oldSelections, selections, oldModelVersionId, modelVersionId, source, reason, reachedMaxCursorCount) {\n        this.kind = 6 /* OutgoingViewModelEventKind.CursorStateChanged */;\n        this.oldSelections = oldSelections;\n        this.selections = selections;\n        this.oldModelVersionId = oldModelVersionId;\n        this.modelVersionId = modelVersionId;\n        this.source = source;\n        this.reason = reason;\n        this.reachedMaxCursorCount = reachedMaxCursorCount;\n    }\n    static _selectionsAreEqual(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        if (!a || !b) {\n            return false;\n        }\n        const aLen = a.length;\n        const bLen = b.length;\n        if (aLen !== bLen) {\n            return false;\n        }\n        for (let i = 0; i < aLen; i++) {\n            if (!a[i].equalsSelection(b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isNoOp() {\n        return (CursorStateChangedEvent._selectionsAreEqual(this.oldSelections, this.selections)\n            && this.oldModelVersionId === this.modelVersionId);\n    }\n    attemptToMerge(other) {\n        if (other.kind !== this.kind) {\n            return null;\n        }\n        return new CursorStateChangedEvent(this.oldSelections, other.selections, this.oldModelVersionId, other.modelVersionId, other.source, other.reason, this.reachedMaxCursorCount || other.reachedMaxCursorCount);\n    }\n}\nexport class ReadOnlyEditAttemptEvent {\n    constructor() {\n        this.kind = 5 /* OutgoingViewModelEventKind.ReadOnlyEditAttempt */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        if (other.kind !== this.kind) {\n            return null;\n        }\n        return this;\n    }\n}\nexport class ModelDecorationsChangedEvent {\n    constructor(event) {\n        this.event = event;\n        this.kind = 7 /* OutgoingViewModelEventKind.ModelDecorationsChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        return null;\n    }\n}\nexport class ModelLanguageChangedEvent {\n    constructor(event) {\n        this.event = event;\n        this.kind = 8 /* OutgoingViewModelEventKind.ModelLanguageChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        return null;\n    }\n}\nexport class ModelLanguageConfigurationChangedEvent {\n    constructor(event) {\n        this.event = event;\n        this.kind = 9 /* OutgoingViewModelEventKind.ModelLanguageConfigurationChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        return null;\n    }\n}\nexport class ModelContentChangedEvent {\n    constructor(event) {\n        this.event = event;\n        this.kind = 10 /* OutgoingViewModelEventKind.ModelContentChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        return null;\n    }\n}\nexport class ModelOptionsChangedEvent {\n    constructor(event) {\n        this.event = event;\n        this.kind = 11 /* OutgoingViewModelEventKind.ModelOptionsChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        return null;\n    }\n}\nexport class ModelTokensChangedEvent {\n    constructor(event) {\n        this.event = event;\n        this.kind = 12 /* OutgoingViewModelEventKind.ModelTokensChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    attemptToMerge(other) {\n        return null;\n    }\n}\n"],"names":["BracketInfo","range","nestingLevel","nestingLevelOfEqualBracketType","isInvalid","this","BracketPairWithMinIndentationInfo","openingBracketRange","closingBracketRange","bracketPairNode","minVisibleColumnIndentation","openingBracket","bracketInfo","ModelRawFlush","changeType","LineInjectedText","ownerId","lineNumber","column","options","order","lineText","injectedTexts","length","result","lastOriginalOffset","injectedText","substring","content","decorations","decoration","before","push","startLineNumber","startColumn","after","endLineNumber","endColumn","sort","a","b","ModelRawLineChanged","detail","ModelRawLinesDeleted","fromLineNumber","toLineNumber","ModelRawLinesInserted","ModelRawEOLChanged","ModelRawContentChangedEvent","changes","versionId","isUndoing","isRedoing","resultingSelection","type","i","len","concat","ModelInjectedTextChangedEvent","InternalModelContentChangeEvent","rawContentChangedEvent","contentChangedEvent","other","merge","_mergeChangeEvents","eol","isFlush","HorizontalGuidesState","IndentGuide","visibleColumn","className","horizontalLine","forWrappedLinesAfterColumn","forWrappedLinesBeforeOrAtColumn","Error","IndentGuideHorizontalLine","top","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","done","then","apply","TokenizationRegistry","_map","Map","_factories","_onDidChange","Emitter","onDidChange","event","_colorMap","languages","fire","changedLanguages","changedColorMap","language","support","set","toDisposable","get","delete","languageId","factory","_a","dispose","myData","TokenizationSupportFactoryData","v","tokenizationSupport","isResolved","colorMap","Array","from","keys","_registry","_languageId","_factory","_isDisposed","_resolvePromise","_isResolved","_create","createTokenizationSupport","_register","register","Disposable","ContiguousMultilineTokens","tokens","_startLineNumber","_tokens","lineTokens","ContiguousMultilineTokensBuilder","last","appendLineTokens","EMPTY_LINE_TOKENS","Uint32Array","buffer","ContiguousTokensEditing","toChIndex","fromChIndex","toUint32Array","lineTextLength","tokensCount","dest","lastEnd","fromTokenIndex","LineTokens","fromTokenStartOffset","delta","tokenIndex","tokenEndOffset","tmp","subarray","_otherTokens","myTokens","otherTokens","otherTokensCount","chIndex","textLength","arr","ContiguousTokensStore","languageIdCodec","_lineTokens","_len","_languageIdCodec","topLevelLanguageId","lineIndex","rawLineTokens","getDefaultMetadata","encodeLanguageId","start","deleteCount","splice","insertIndex","insertCount","arrays","checkEquality","_massageTokens","_ensureLine","oldTokens","_equals","eolCount","firstLineLength","_acceptDeleteRange","_acceptInsertText","Position","firstLineIndex","deleteEnding","lastLineIndex","lastLineTokens","deleteBeginning","append","_deleteLines","position","insert","_insertLines","hasDifferentLanguageId","TokenMetadata","byteOffset","byteLength","_b","text","decoder","_lineTokensBrand","undefined","_tokensCount","_text","slicedEquals","sliceFromTokenIndex","sliceTokenCount","to","metadata","decodeLanguageId","offset","findIndexInTokensArray","startOffset","endOffset","deltaOffset","SliceLineTokens","insertTokens","nextOriginalTokenIdx","nextInsertTokenIdx","newTokens","originalEndOffset","nextOriginalTokenEndOffset","nextInsertToken","tokenMetadata","lineContent","defaultMetadata","defaultTokenMetadata","lastTokenIndex","desiredIndex","low","high","mid","Math","floor","source","_source","_startOffset","_endOffset","_deltaOffset","_firstTokenIndex","findTokenIndexAtOffset","getCount","getStartOffset","getMetadata","getLanguageId","getLineContent","getForeground","getEndOffset","min","getClassName","getInlineStyle","getPresentation","SparseMultilineTokens","_endLineNumber","getMaxDeltaLine","toString","isEmpty","getLineTokens","deltaRange","getRange","Range","startLineIndex","endLineIndex","removeTokens","_updateEndLineNumber","split","bDeltaLine","countEOL","lastLineLength","acceptEdit","charCodeAt","firstCharCode","deletedLinesCount","tokenMaxDeltaLine","clear","deletedBefore","acceptDeleteRange","acceptInsertText","SparseMultilineTokensStorage","_tokenCount","pieces","_getDeltaLine","_getStartCharacter","_getEndCharacter","join","tokenCount","_getTokenCount","startChar","maxDeltaLine","endChar","deltaLine","midDeltaLine","max","SparseLineTokens","startDeltaLine","endDeltaLine","newTokenCount","hasDeletedTokens","firstDeltaLine","srcOffset","tokenDeltaLine","tokenStartCharacter","tokenEndCharacter","destOffset","aTokens","bTokens","destTokens","destFirstDeltaLine","horizontalShiftForFirstLineTokens","startCharacter","endCharacter","deletedLineCount","character","isInsertingPreciselyOneWordCharacter","tokenLength","SparseTokensStore","_pieces","_isComplete","isComplete","_range","_firstRange","_lastRange","plusRange","insertPosition","piece","index","_findFirstPieceWithLine","aLen","bLen","aIndex","resultLen","lastEndOffset","emitToken","bIndex","bStartCharacter","getStartCharacter","bEndCharacter","getEndCharacter","bMetadata","bMask","aMask","aMergeIndex","ViewEventHandler","_shouldRender","events","shouldRender","onCompositionStart","onCompositionEnd","onConfigurationChanged","onCursorStateChanged","onDecorationsChanged","onFlushed","onFocusChanged","onLanguageConfigurationChanged","onLineMappingChanged","onLinesChanged","onLinesDeleted","onLinesInserted","onRevealRangeRequest","onScrollChanged","onTokensChanged","onThemeChanged","onTokensColorsChanged","onZonesChanged","console","info","ViewCompositionStartEvent","ViewCompositionEndEvent","ViewConfigurationChangedEvent","id","hasChanged","ViewCursorStateChangedEvent","selections","modelSelections","ViewDecorationsChangedEvent","affectsMinimap","affectsOverviewRuler","ViewFlushedEvent","ViewFocusChangedEvent","isFocused","ViewLanguageConfigurationEvent","ViewLineMappingChangedEvent","ViewLinesChangedEvent","count","ViewLinesDeletedEvent","ViewLinesInsertedEvent","ViewRevealRangeRequestEvent","minimalReveal","verticalType","revealHorizontal","scrollType","ViewScrollChangedEvent","scrollWidth","scrollLeft","scrollHeight","scrollTop","scrollWidthChanged","scrollLeftChanged","scrollHeightChanged","scrollTopChanged","ViewThemeChangedEvent","theme","ViewTokensChangedEvent","ranges","ViewTokensColorsChangedEvent","ViewZonesChangedEvent","LineDecoration","_lineDecorationBrand","lineLength","r","rLength","dec","lineDecorations","minLineColumn","maxLineColumn","d","inlineClassName","ORDER","typeCmp","_typeCompare","DecorationSegment","Stack","stopOffsets","classNames","maxStopOffset","nextStartOffset","_metadata","stopOffset","LineDecorationsNormalizer","stack","charCodeBefore","strings","currentStartOffset","currentEndOffset","consumeLowerThan","LinePart","endIndex","containsRTL","_linePartBrand","LineRange","startIndex","otherLineRange","RenderLineInput","useMonospaceOptimizations","canUseHalfwidthRightwardsArrow","continuesWithWrappedLine","isBasicASCII","fauxIndentLength","tabSize","startVisibleColumn","spaceWidth","middotWidth","wsmiddotWidth","stopRenderingLineAfter","renderWhitespace","renderControlCharacters","fontLigatures","selectionsOnLine","abs","renderSpaceWidth","renderSpaceCharCode","otherSelections","equals","sameSelection","DomPosition","partIndex","charIndex","CharacterMapping","partCount","_data","_horizontalOffset","horizontalOffset","partData","charOffset","charOffsetToPartData","getPartIndex","getCharIndex","domPosition","partLength","partDataToCharOffset","searchEntry","midEntry","minEntry","maxEntry","minPartIndex","RenderLineOutput","characterMapping","containsForeignElements","_renderLineOutputBrand","renderViewLine","input","sb","appendASCIIString","beforeCount","afterCount","lineDecoration","setColumnInfo","fontIsMonospace","isOverflowing","parts","lastCharacterMappingDefined","charOffsetInPart","charHorizontalOffset","partDisplacement","tokensLen","part","partEndIndex","partType","partContainsRTL","partRendersWhitespace","isWhitespace","partRendersWhitespaceWithWidth","partIsEmptyAndHasPseudoAfter","isPseudoAfter","appendASCII","partWidth","_charIndex","_visibleColumn","charWidth","String","producedCharacters","write1","space","charCode","isControlCharacter","to4CharHex","_renderLine","lineContainsRTL","tokenContainsRTL","transformAndRemoveOverflowing","lastLinePart","token","tokenEndIndex","extractControlCharacters","lastNonWhitespaceIndex","onlyBoundary","onlyTrailing","generateLinePartForEachWhitespace","tokenType","tokensLength","lineIsEmptyOrWhitespace","firstNonWhitespaceIndex","wasInWhitespace","currentSelectionIndex","currentSelection","tmpIndent","chCode","isInWhitespace","nextChCode","generateWhitespace","lastCharCode","prevCharCode","_applyRenderWhitespace","_lineDecorations","lineDecorationsLen","lineDecorationIndex","lastResultEndIndex","lastTokenEndIndex","_applyInlineDecorations","onlyAtSpaces","lastSpaceOffset","currTokenStart","j","diff","piecesCount","ceil","pieceEndIndex","splitLargeTokens","ResolvedRenderLineInput","resolveRenderLineInput","RenderLineOutput2","html","renderViewLine2","createStringBuilder","out","build","n","toUpperCase","padStart","ViewportData","partialData","whitespaceViewportData","model","relativeVerticalOffset","bigNumbersDelta","_model","visibleRange","getLineMinColumn","getLineMaxColumn","getViewportViewLineRenderingData","getDecorationsInViewport","Viewport","left","width","height","_viewportBrand","MinimapLinesRenderingData","data","ViewLineData","minColumn","maxColumn","inlineDecorations","_viewLineDataBrand","ViewLineRenderingData","mightContainRTL","mightContainNonBasicASCII","InlineDecoration","SingleLineInlineDecoration","inlineClassNameAffectsLetterSpacing","ViewModelDecoration","_viewModelDecorationBrand","OverviewRulerDecorationsGroup","color","zIndex","MinimapTokensColorTracker","_updateColorMap","_colors","RGBA8","_backgroundIsLight","colorId","rgba","g","round","backgroundLuminosity","getRelativeLuminance","_INSTANCE","markAsSingleton","MonospaceLineBreaksComputerFactory","breakBeforeChars","breakAfterChars","classifier","WrappingCharacterClassifier","fontInfo","wrappingColumn","wrappingIndent","requests","previousBreakingData","addRequest","previousLineBreakData","finalize","columnsForFullWidthChar","typicalFullwidthCharacterWidth","typicalHalfwidthCharacterWidth","injectionOptions","createLineBreaks","createLineBreaksFromPreviousLineBreaks","arrPool1","arrPool2","BREAK_BEFORE","BREAK_AFTER","_asciiMap","_defaultValue","CharacterClassifier","firstLineBreakColumn","prevBreakingOffsets","breakOffsets","prevBreakingOffsetsVisibleColumn","breakOffsetsVisibleColumn","wrappedTextIndentLength","computeWrappedTextIndentLength","wrappedLineBreakColumn","breakingOffsets","breakingOffsetsVisibleColumn","breakingOffsetsCount","lastBreakingOffset","lastBreakingOffsetVisibleColumn","breakingColumn","prevLen","prevIndex","bestDistance","distance","prevBreakOffset","prevBreakOffsetVisibleColumn","breakOffset","breakOffsetVisibleColumn","forcedBreakOffset","forcedBreakOffsetVisibleColumn","prevCharCodeClass","entireLineFits","charStartOffset","charCodeClass","computeCharWidth","canBreak","hitATabCharacter","prevCharWidth","remainingWidthOfNextLine","charCodeAtForcedBreakOffset","_lineText","injectionOffsets","map","t","ModelLineProjectionData","tabCharacterWidth","numberOfAdditionalTabs","ColorZone","_colorZoneBrand","OverviewRulerZone","heightInLines","_overviewRulerZoneBrand","_colorZone","colorZone","OverviewZoneManager","getVerticalOffsetForLine","_getVerticalOffsetForLine","_zones","_colorZonesInvalid","_lineHeight","_domWidth","_domHeight","_outerHeight","_pixelRatio","_lastAssignedId","_color2Id","Object","create","_id2Color","newZones","compare","lineHeight","pixelRatio","outerHeight","colorZonesInvalid","totalHeight","getCanvasHeight","heightRatio","halfMinimumHeight","allColorZones","zone","getColorZones","offset1","offset2","y1","y2","ycenter","halfHeight","setColorZone","ViewContext","configuration","EditorTheme","viewModel","viewLayout","eventHandler","addViewEventHandler","removeViewEventHandler","ViewModelDecorations","editorId","linesCollection","coordinatesConverter","_linesCollection","_coordinatesConverter","_decorationsCache","_cachedModelDecorationsResolver","_cachedModelDecorationsResolverViewRange","_clearCachedModelDecorationsResolver","modelDecoration","viewRange","modelRange","isWholeLine","convertModelPositionToViewPosition","end","convertModelRangeToViewRange","cacheIsValid","equalsRange","_getDecorationsInRange","getViewLineMinColumn","getViewLineMaxColumn","modelDecorations","getDecorationsInRange","filterValidationDecorations","decorationsInViewport","decorationsInViewportLen","decorationOptions","isModelDecorationVisible","viewModelDecoration","_getOrCreateViewModelDecoration","inlineDecoration","intersectedStartLineNumber","intersectedEndLineNumber","beforeContentClassName","afterContentClassName","hideInCommentTokens","isModelDecorationInComment","hideInStringTokens","isModelDecorationInString","testTokensInRange","callback","tokenization","isFirstLine","isEndLine","tokenIdx","getStandardTokenType","PendingChanges","_hasPending","_inserts","_changes","_removes","x","linesLayout","inserts","removes","_commitPendingChanges","EditorWhitespace","afterLineNumber","ordinal","minWidth","prefixSum","LinesLayout","lineCount","paddingTop","paddingBottom","_instanceId","INSTANCE_COUNT","_pendingChanges","_lastWhitespaceId","_arr","_prefixSumValidIndex","_minWidth","_lineCount","_paddingTop","_paddingBottom","_checkPendingChanges","hadAChange","insertWhitespace","heightInPx","changeOneWhitespace","newAfterLineNumber","newHeight","change","removeWhitespace","remove","commit","_insertWhitespace","_changeOneWhitespace","_findWhitespaceIndex","_removeWhitespace","toRemove","Set","add","toChange","applyRemoveAndChange","whitespaces","whitespace","has","mustCommit","findInsertionIndex","removeIndex","getWhitespacesAccumulatedHeight","getWhitespacesTotalHeight","lastWhitespaceBeforeLineNumber","_findLastWhitespaceBeforeLineNumber","firstWhitespaceAfterLineNumber","_findFirstWhitespaceAfterLineNumber","previousLinesHeight","includeViewZones","previousWhitespacesHeight","getWhitespaceAccumulatedHeightBeforeLineNumber","verticalOffset","getLinesTotalHeight","linesCount","minLineNumber","maxLineNumber","midLineNumber","midLineNumberVerticalOffset","getVerticalOffsetForLineNumber","verticalOffset1","verticalOffset2","currentWhitespaceHeight","currentWhitespaceAfterLineNumber","getLineNumberAtOrAfterVerticalOffset","startLineNumberVerticalOffset","whitespaceIndex","getFirstWhitespaceIndexAfterLineNumber","whitespaceCount","getWhitespacesCount","getAfterLineNumberForWhitespaceIndex","getHeightForWhitespaceIndex","currentVerticalOffset","currentLineRelativeOffset","STEP_SIZE","linesOffsets","verticalCenter","centeredLineNumber","endLineNumberVerticalOffset","completelyVisibleStartLineNumber","completelyVisibleEndLineNumber","minWhitespaceIndex","maxWhitespaceIndex","getVerticalOffsetForWhitespaceIndex","midWhitespaceIndex","midWhitespaceVerticalOffset","candidateIndex","getWhitespaceIndexAtOrAfterVerticallOffset","candidateTop","candidateHeight","getIdForWhitespaceIndex","slice","EditorScrollDimensions","contentWidth","contentHeight","EditorScrollable","smoothScrollDuration","scheduleAtNextAnimationFrame","_onDidContentSizeChange","onDidContentSizeChange","_dimensions","_scrollable","Scrollable","forceIntegerValues","onDidScroll","onScroll","setSmoothScrollDuration","scrollPosition","validateScrollPosition","dimensions","oldDimensions","setScrollDimensions","contentWidthChanged","contentHeightChanged","ContentSizeChangedEvent","getFutureScrollPosition","getCurrentScrollPosition","update","setScrollPositionNow","setScrollPositionSmooth","ViewLayout","_configuration","layoutInfo","padding","_linesLayout","bottom","_configureSmoothScrollDuration","_updateHeight","getScrollable","setLineHeight","setPadding","scrollDimensions","getScrollDimensions","_getContentHeight","scrollbar","horizontal","horizontalScrollbarSize","_getHorizontalScrollbarHeight","currentScrollPosition","maxLineWidth","wrappingInfo","isViewportWrapping","minimap","enabled","side","verticalScrollbarWidth","extraHorizontalSpace","whitespaceMinWidth","getWhitespaceMinWidth","_computeContentWidth","firstLineNumberInViewport","scrollTopWithoutViewZones","changeWhitespace","onHeightMaybeChanged","getVerticalOffsetAfterLineNumber","isAfterLines","isInTopPadding","isInBottomPadding","getWhitespaceAtVerticalOffset","visibleBox","getCurrentViewport","getLinesViewportData","getWhitespaceViewportData","getWhitespaces","deltaScrollLeft","deltaScrollTop","createModelLineProjection","lineBreakData","isVisible","IdentityModelLineProjection","INSTANCE","HiddenModelLineProjection","ModelLineProjection","_projectionData","_isVisible","getOutputLineCount","modelLineNumber","outputLineIndex","_assertVisible","startOffsetInInputWithInjections","endOffsetInInputWithInjections","idx","getValueInRange","spaces","getLineLength","_modelLineNumber","getMinOutputOffset","getMaxOutputOffset","getViewLinesData","outputLineIdx","globalStartIndex","needed","lineWithInjections","inlineDecorationsPerOutputLine","totalInjectedTextLengthBefore","currentInjectedOffset","lineStartOffsetInInputWithInjections","lineEndOffsetInInputWithInjections","injectedTextStartOffsetInInputWithInjections","injectedTextEndOffsetInInputWithInjections","withInserted","globalIndex","_getViewLineData","deltaStartIndex","sliceAndInflate","getViewLineCount","outputColumn","translateToInputOffset","deltaLineNumber","inputColumn","affinity","translateToOutputPosition","toPosition","outputPosition","baseViewLineNumber","normalizeOutputPosition","getInjectedText","_outputLineIndex","inflate","_fromOuputLineIndex","_toOutputLineIndex","getViewLineData","_inputColumn","_outputColumn","_globalStartIndex","_needed","_result","_deltaLineNumber","_spaces","_makeSpaces","ViewModelLinesFromProjectedModel","domLineBreaksComputerFactory","monospaceLineBreaksComputerFactory","wrappingStrategy","_editorId","_validModelVersionId","_domLineBreaksComputerFactory","_monospaceLineBreaksComputerFactory","_constructLines","hiddenAreasDecorationIds","deltaDecorations","CoordinatesConverter","resetHiddenAreas","previousLineBreaks","modelLineProjections","linesContent","getLinesContent","injectedTextDecorations","getInjectedTextDecorations","lineBreaksComputer","createLineBreaksComputer","injectedTextQueue","lineInjectedText","takeWhile","linesBreaks","values","hiddenAreas","areaId","getDecorationRange","hiddenAreaStart","hiddenAreaEnd","hiddenAreaIdx","nextLineNumberToUpdateHiddenArea","isInHiddenArea","line","getVersionId","projectedModelLineLineCounts","ConstantTimePrefixSumComputer","decId","_ranges","newRanges","sortedRanges","currentRangeStart","currentRangeEnd","normalizeLineRanges","validateRange","oldRanges","hasDifference","newDecorations","ModelDecorationOptions","hasVisibleLine","lineChanged","setVisible","newOutputLineCount","setValue","setHiddenAreas","_modelColumn","newTabSize","equalFontInfo","equalWrappingStrategy","equalWrappingColumn","equalWrappingIndent","onlyWrappingColumnChanged","getProjectionData","outputFromLineNumber","getPrefixSum","outputToLineNumber","removeValues","viewEvents","_toLineNumber","lineBreaks","totalOutputLineCount","insertLines","insertPrefixSumValues","outputLineCount","insertValues","oldOutputLineCount","lineMappingChanged","changeFrom","changeTo","insertFrom","insertTo","deleteFrom","deleteTo","getTotalSum","viewLineNumber","viewLineCount","_toValidViewLineNumber","modelPosition","convertViewPositionToModelPosition","modelMinPosition","modelMaxPosition","guides","getActiveIndentGuide","viewStartPosition","viewEndPosition","indent","getIndexOf","remainder","ViewLineInfo","viewLineInfo","modelLineWrappedLineIdx","minViewColumn","getModelColumnOfViewPosition","maxViewColumn","viewStartLineNumber","viewEndLineNumber","startViewLine","getViewLineInfo","endViewLine","lastVisibleModelPos","getModelStartPositionOfViewLine","viewLines","curModelLine","lastVisibleModelPos2","ViewLineInfoGroupedByModelRange","getModelEndPositionOfViewLine","activeViewPosition","modelActivePosition","resultPerViewLine","getViewLineInfosGroupedByModelRanges","group","modelRangeStartLineNumber","bracketGuidesPerModelLine","getLinesBracketGuides","getViewPositionOfModelPosition","p","getMinColumnOfViewLine","viewPosition","getMaxColumnOfViewLine","filter","modelStart","modelEnd","resultRepeatCount","resultRepeatOption","modelStartLineIndex","modelEndLineIndex","reqStart","modelLineIndex","viewLineStartIndex","getViewLineNumberOfModelPosition","viewLineEndIndex","option","getLinesIndentGuides","viewIndents","currIndex","blockAtIndex","getViewLineContent","getViewLineLength","startModelLineIndex","startRemainder","getLineCount","fromViewLineIndex","remainingViewLineCount","lastLine","viewColumn","expectedModelPosition","computedModelColumn","validatePosition","expectedModelRange","validViewStart","validateViewPosition","getStartPosition","validViewEnd","getEndPosition","validPosition","inputLineNumber","lineIndexChanged","modelColumn","filterOutValidation","res","finalResult","finalResultLen","prevDecId","getInjectedTextAt","normalizePosition","getLineIndentColumn","lines","_lines","convertViewRangeToModelRange","validateViewRange","modelPositionIsVisible","getModelLineViewLineCount","ViewModelLinesFromModelAsIs","IdentityCoordinatesConverter","_newTabSize","_fontInfo","_wrappingStrategy","_wrappingColumn","_wrappingIndent","_versionId","_minLineNumber","_maxLineNumber","activePosition","fill","pos","_validPosition","_validRange","_viewPosition","_viewRange","ViewModel","languageConfigurationService","_themeService","_eventDispatcher","ViewModelEventDispatcher","onEvent","cursorConfig","CursorConfiguration","getOptions","_tokenizeViewportSoon","RunOnceScheduler","tokenizeViewport","_updateConfigurationViewLineCount","_updateConfigurationViewLineCountNow","_hasFocus","_viewportStart","ViewportStart","isTooLargeForTokenization","createCoordinatesConverter","_cursor","CursorsController","schedule","invalidate","emitSingleViewEvent","emitOutgoingEvent","ScrollChangedEvent","oldScrollWidth","oldScrollLeft","oldScrollHeight","oldScrollTop","_decorations","_registerModelEvents","onDidChangeFast","eventsCollector","beginEmitViewEvents","_onConfigurationChanged","endEmitViewEvents","onDidColorThemeChange","_invalidateDecorationsColorCache","setViewLineCount","linesViewportData","viewVisibleRange","modelVisibleRanges","_toModelVisibleRanges","modelVisibleRange","hasFocus","setHasFocus","FocusChangedEvent","previousViewportStartModelPosition","isValid","previousViewportStartViewPosition","restorePreviousViewportStart","setWrappingSettings","emitViewEvent","getCurrentScrollTop","reset","viewPositionTop","setScrollPosition","startLineDelta","updateConfiguration","onDidChangeContentOrInjectedText","hadOtherModelChange","hadModelLineChangeThatChangedLineMapping","textModelEvents","lineIdx","element","lineBreakQueue","ArrayQueue","onModelFlushed","linesDeletedEvent","onModelLinesDeleted","insertedLineBreaks","takeCount","linesInsertedEvent","onModelLinesInserted","changedLineBreakData","dequeue","onModelLineChanged","linesChangedEvent","acceptVersionId","viewportStartWasValid","setModelLineCount","getAttachedEditorCount","_getTrackedRange","modelTrackedRange","ModelContentChangedEvent","onModelContentChanged","onDidChangeTokens","viewRanges","lenJ","tokenizationSupportChanged","ModelTokensChangedEvent","onDidChangeLanguageConfiguration","ModelLanguageConfigurationChangedEvent","onDidChangeLanguage","ModelLanguageChangedEvent","onDidChangeOptions","setTabSize","ModelOptionsChangedEvent","onDidChangeDecorations","onModelDecorationsChanged","ModelDecorationsChangedEvent","HiddenAreasChangedEvent","linesAround","startViewLineNumber","endViewLineNumber","visibleViewRange","getCompletelyVisibleViewRange","getHiddenAreas","hiddenStartLineNumber","hiddenEndLineNumber","getLinesViewportDataAtScrollTop","compatViewState","saveState","firstViewLineNumber","getLineNumberAtVerticalOffset","firstPosition","firstPositionDeltaTop","state","_reduceRestoreStateCompatibility","getViewLinesIndentGuides","getViewLinesBracketGuides","getDecorationsViewportData","_getViewLineRenderingData","getInlineDecorationsOnLine","getTabSize","lineData","toInlineDecoration","getOverviewRulerDecorations","OverviewRulerDecorations","opts","overviewRuler","lane","getColor","accept","asArray","opts1","invalidateCachedColor","opts2","viewAnchorPosition","lineFeedCnt","modelAnchor","getEOL","resultOffset","getOffsetAt","getPositionAt","modelRanges","emptySelectionClipboard","forceCRLF","newLineCharacter","hasEmptyRange","hasNonEmptyRange","modelLineNumbers","prevModelLineNumber","PLAINTEXT_LANGUAGE_ID","fontFamily","_getColorMap","test","EDITOR_FONT_DEFAULTS","replace","mode","fontWeight","fontSize","_getHTMLToCopy","tokenizeLineToHTML","platform","Color","getPrimaryCursorState","getLastAddedCursorIndex","getCursorStates","reason","states","_withViewEventsCollector","setStates","getCursorColumnSelectData","getAutoClosedCharacters","columnSelectData","setCursorColumnSelectData","getPrevEditOperationType","setPrevEditOperationType","getSelection","getSelections","modelState","setSelections","restoreState","context","readOnly","ReadOnlyEditAttemptEvent","edits","cursorStateComputer","_executeCursorEdit","executeEdits","startComposition","endComposition","replacePrevCharCnt","replaceNextCharCnt","positionDelta","compositionType","pasteOnNewLine","multicursorText","paste","cut","command","executeCommand","commands","executeCommands","revealPrimary","getTopMostViewPosition","getBottomMostViewPosition","_viewLineNumber","_isValid","_modelTrackedRange","_startLineDelta","_setTrackedRange","viewportStartLineTrackedRange","viewportStartLineTop","_asMap","prevGroup","prevData","prevLane","prevEndLineNumber","_onEvent","_eventHandlers","_viewEventQueue","_isConsumingViewEventQueue","_collector","_collectorCnt","_outgoingEvents","_addOutgoingEvent","_emitOutgoingEvents","mergeResult","kind","attemptToMerge","shift","isNoOp","warn","ViewModelEventsCollector","outgoingEvents","outgoingEvent","_emitMany","_consumeViewEventQueue","_doConsumeQueue","eventHandlers","handleEvents","oldContentWidth","oldContentHeight","_oldContentWidth","_oldContentHeight","oldHasFocus","_oldScrollWidth","_oldScrollLeft","_oldScrollHeight","_oldScrollTop","CursorStateChangedEvent","oldSelections","oldModelVersionId","modelVersionId","reachedMaxCursorCount","_selectionsAreEqual","equalsSelection"],"sourceRoot":""}