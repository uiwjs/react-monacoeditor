{"version":3,"file":"static/js/monaco-editor-vendor.df546ea5.39c17381.js","mappings":"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","sources":["../node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js","../node_modules/monaco-editor/esm/vs/editor/common/core/cursorColumns.js","../node_modules/monaco-editor/esm/vs/editor/common/core/editOperation.js","../node_modules/monaco-editor/esm/vs/editor/common/core/editorColorRegistry.js","../node_modules/monaco-editor/esm/vs/editor/common/core/eolCounter.js","../node_modules/monaco-editor/esm/vs/editor/common/core/indentation.js","../node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js","../node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js","../node_modules/monaco-editor/esm/vs/editor/common/core/position.js","../node_modules/monaco-editor/esm/vs/editor/common/core/range.js","../node_modules/monaco-editor/esm/vs/editor/common/core/rgba.js","../node_modules/monaco-editor/esm/vs/editor/common/core/selection.js","../node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js","../node_modules/monaco-editor/esm/vs/editor/common/core/textChange.js","../node_modules/monaco-editor/esm/vs/editor/common/core/textModelDefaults.js","../node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js","../node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/oneCursor.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorCollection.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorContext.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursor.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorAtomicMoveOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorColumnSelection.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorDeleteOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorMoveCommands.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorMoveOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorTypeOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorWordOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursorCommon.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/smartLinesDiffComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/diffAlgorithm.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/utils.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/dynamicProgrammingDiffing.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/joinSequenceDiffs.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/myersDiffAlgorithm.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/standardLinesDiffComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js","../node_modules/monaco-editor/esm/vs/editor/common/editorAction.js","../node_modules/monaco-editor/esm/vs/editor/common/editorCommon.js","../node_modules/monaco-editor/esm/vs/editor/common/editorContextKeys.js","../node_modules/monaco-editor/esm/vs/editor/common/editorFeatures.js","../node_modules/monaco-editor/esm/vs/editor/common/editorTheme.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { toUint8 } from '../../../base/common/uint.js';\n/**\n * A fast character classifier that uses a compact array for ASCII values.\n */\nexport class CharacterClassifier {\n    constructor(_defaultValue) {\n        const defaultValue = toUint8(_defaultValue);\n        this._defaultValue = defaultValue;\n        this._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);\n        this._map = new Map();\n    }\n    static _createAsciiMap(defaultValue) {\n        const asciiMap = new Uint8Array(256);\n        asciiMap.fill(defaultValue);\n        return asciiMap;\n    }\n    set(charCode, _value) {\n        const value = toUint8(_value);\n        if (charCode >= 0 && charCode < 256) {\n            this._asciiMap[charCode] = value;\n        }\n        else {\n            this._map.set(charCode, value);\n        }\n    }\n    get(charCode) {\n        if (charCode >= 0 && charCode < 256) {\n            return this._asciiMap[charCode];\n        }\n        else {\n            return (this._map.get(charCode) || this._defaultValue);\n        }\n    }\n    clear() {\n        this._asciiMap.fill(this._defaultValue);\n        this._map.clear();\n    }\n}\nexport class CharacterSet {\n    constructor() {\n        this._actual = new CharacterClassifier(0 /* Boolean.False */);\n    }\n    add(charCode) {\n        this._actual.set(charCode, 1 /* Boolean.True */);\n    }\n    has(charCode) {\n        return (this._actual.get(charCode) === 1 /* Boolean.True */);\n    }\n    clear() {\n        return this._actual.clear();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\n/**\n * A column in a position is the gap between two adjacent characters. The methods here\n * work with a concept called \"visible column\". A visible column is a very rough approximation\n * of the horizontal screen position of a column. For example, using a tab size of 4:\n * ```txt\n * |<TAB>|<TAB>|T|ext\n * |     |     | \\---- column = 4, visible column = 9\n * |     |     \\------ column = 3, visible column = 8\n * |     \\------------ column = 2, visible column = 4\n * \\------------------ column = 1, visible column = 0\n * ```\n *\n * **NOTE**: Visual columns do not work well for RTL text or variable-width fonts or characters.\n *\n * **NOTE**: These methods work and make sense both on the model and on the view model.\n */\nexport class CursorColumns {\n    static _nextVisibleColumn(codePoint, visibleColumn, tabSize) {\n        if (codePoint === 9 /* CharCode.Tab */) {\n            return CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        }\n        if (strings.isFullWidthCharacter(codePoint) || strings.isEmojiImprecise(codePoint)) {\n            return visibleColumn + 2;\n        }\n        return visibleColumn + 1;\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    static visibleColumnFromColumn(lineContent, column, tabSize) {\n        const textLen = Math.min(column - 1, lineContent.length);\n        const text = lineContent.substring(0, textLen);\n        const iterator = new strings.GraphemeIterator(text);\n        let result = 0;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(text, textLen, iterator.offset);\n            iterator.nextGraphemeLength();\n            result = this._nextVisibleColumn(codePoint, result, tabSize);\n        }\n        return result;\n    }\n    /**\n     * Returns a column from a visible column.\n     * @see {@link CursorColumns}\n     */\n    static columnFromVisibleColumn(lineContent, visibleColumn, tabSize) {\n        if (visibleColumn <= 0) {\n            return 1;\n        }\n        const lineContentLength = lineContent.length;\n        const iterator = new strings.GraphemeIterator(lineContent);\n        let beforeVisibleColumn = 0;\n        let beforeColumn = 1;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(lineContent, lineContentLength, iterator.offset);\n            iterator.nextGraphemeLength();\n            const afterVisibleColumn = this._nextVisibleColumn(codePoint, beforeVisibleColumn, tabSize);\n            const afterColumn = iterator.offset + 1;\n            if (afterVisibleColumn >= visibleColumn) {\n                const beforeDelta = visibleColumn - beforeVisibleColumn;\n                const afterDelta = afterVisibleColumn - visibleColumn;\n                if (afterDelta < beforeDelta) {\n                    return afterColumn;\n                }\n                else {\n                    return beforeColumn;\n                }\n            }\n            beforeVisibleColumn = afterVisibleColumn;\n            beforeColumn = afterColumn;\n        }\n        // walked the entire string\n        return lineContentLength + 1;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextRenderTabStop(visibleColumn, tabSize) {\n        return visibleColumn + tabSize - visibleColumn % tabSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextIndentTabStop(visibleColumn, indentSize) {\n        return visibleColumn + indentSize - visibleColumn % indentSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevRenderTabStop(column, tabSize) {\n        return Math.max(0, column - 1 - (column - 1) % tabSize);\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevIndentTabStop(column, indentSize) {\n        return Math.max(0, column - 1 - (column - 1) % indentSize);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from './range.js';\nexport class EditOperation {\n    static insert(position, text) {\n        return {\n            range: new Range(position.lineNumber, position.column, position.lineNumber, position.column),\n            text: text,\n            forceMoveMarkers: true\n        };\n    }\n    static delete(range) {\n        return {\n            range: range,\n            text: null\n        };\n    }\n    static replace(range, text) {\n        return {\n            range: range,\n            text: text\n        };\n    }\n    static replaceMove(range, text) {\n        return {\n            range: range,\n            text: text,\n            forceMoveMarkers: true\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { Color, RGBA } from '../../../base/common/color.js';\nimport { activeContrastBorder, editorBackground, registerColor, editorWarningForeground, editorInfoForeground, editorWarningBorder, editorInfoBorder, contrastBorder, editorFindMatchHighlight } from '../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../platform/theme/common/themeService.js';\n/**\n * Definition of the editor colors\n */\nexport const editorLineHighlight = registerColor('editor.lineHighlightBackground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('lineHighlight', 'Background color for the highlight of line at the cursor position.'));\nexport const editorLineHighlightBorder = registerColor('editor.lineHighlightBorder', { dark: '#282828', light: '#eeeeee', hcDark: '#f38518', hcLight: contrastBorder }, nls.localize('lineHighlightBorderBox', 'Background color for the border around the line at the cursor position.'));\nexport const editorRangeHighlight = registerColor('editor.rangeHighlightBackground', { dark: '#ffffff0b', light: '#fdff0033', hcDark: null, hcLight: null }, nls.localize('rangeHighlight', 'Background color of highlighted ranges, like by quick open and find features. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorRangeHighlightBorder = registerColor('editor.rangeHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('rangeHighlightBorder', 'Background color of the border around highlighted ranges.'), true);\nexport const editorSymbolHighlight = registerColor('editor.symbolHighlightBackground', { dark: editorFindMatchHighlight, light: editorFindMatchHighlight, hcDark: null, hcLight: null }, nls.localize('symbolHighlight', 'Background color of highlighted symbol, like for go to definition or go next/previous symbol. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorSymbolHighlightBorder = registerColor('editor.symbolHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('symbolHighlightBorder', 'Background color of the border around highlighted symbols.'), true);\nexport const editorCursorForeground = registerColor('editorCursor.foreground', { dark: '#AEAFAD', light: Color.black, hcDark: Color.white, hcLight: '#0F4A85' }, nls.localize('caret', 'Color of the editor cursor.'));\nexport const editorCursorBackground = registerColor('editorCursor.background', null, nls.localize('editorCursorBackground', 'The background color of the editor cursor. Allows customizing the color of a character overlapped by a block cursor.'));\nexport const editorWhitespaces = registerColor('editorWhitespace.foreground', { dark: '#e3e4e229', light: '#33333333', hcDark: '#e3e4e229', hcLight: '#CCCCCC' }, nls.localize('editorWhitespaces', 'Color of whitespace characters in the editor.'));\nexport const editorIndentGuides = registerColor('editorIndentGuide.background', { dark: editorWhitespaces, light: editorWhitespaces, hcDark: editorWhitespaces, hcLight: editorWhitespaces }, nls.localize('editorIndentGuides', 'Color of the editor indentation guides.'));\nexport const editorActiveIndentGuides = registerColor('editorIndentGuide.activeBackground', { dark: editorWhitespaces, light: editorWhitespaces, hcDark: editorWhitespaces, hcLight: editorWhitespaces }, nls.localize('editorActiveIndentGuide', 'Color of the active editor indentation guides.'));\nexport const editorLineNumbers = registerColor('editorLineNumber.foreground', { dark: '#858585', light: '#237893', hcDark: Color.white, hcLight: '#292929' }, nls.localize('editorLineNumbers', 'Color of editor line numbers.'));\nconst deprecatedEditorActiveLineNumber = registerColor('editorActiveLineNumber.foreground', { dark: '#c6c6c6', light: '#0B216F', hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('editorActiveLineNumber', 'Color of editor active line number'), false, nls.localize('deprecatedEditorActiveLineNumber', 'Id is deprecated. Use \\'editorLineNumber.activeForeground\\' instead.'));\nexport const editorActiveLineNumber = registerColor('editorLineNumber.activeForeground', { dark: deprecatedEditorActiveLineNumber, light: deprecatedEditorActiveLineNumber, hcDark: deprecatedEditorActiveLineNumber, hcLight: deprecatedEditorActiveLineNumber }, nls.localize('editorActiveLineNumber', 'Color of editor active line number'));\nexport const editorDimmedLineNumber = registerColor('editorLineNumber.dimmedForeground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('editorDimmedLineNumber', 'Color of the final editor line when editor.renderFinalNewline is set to dimmed.'));\nexport const editorRuler = registerColor('editorRuler.foreground', { dark: '#5A5A5A', light: Color.lightgrey, hcDark: Color.white, hcLight: '#292929' }, nls.localize('editorRuler', 'Color of the editor rulers.'));\nexport const editorCodeLensForeground = registerColor('editorCodeLens.foreground', { dark: '#999999', light: '#919191', hcDark: '#999999', hcLight: '#292929' }, nls.localize('editorCodeLensForeground', 'Foreground color of editor CodeLens'));\nexport const editorBracketMatchBackground = registerColor('editorBracketMatch.background', { dark: '#0064001a', light: '#0064001a', hcDark: '#0064001a', hcLight: '#0000' }, nls.localize('editorBracketMatchBackground', 'Background color behind matching brackets'));\nexport const editorBracketMatchBorder = registerColor('editorBracketMatch.border', { dark: '#888', light: '#B9B9B9', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('editorBracketMatchBorder', 'Color for matching brackets boxes'));\nexport const editorOverviewRulerBorder = registerColor('editorOverviewRuler.border', { dark: '#7f7f7f4d', light: '#7f7f7f4d', hcDark: '#7f7f7f4d', hcLight: '#666666' }, nls.localize('editorOverviewRulerBorder', 'Color of the overview ruler border.'));\nexport const editorOverviewRulerBackground = registerColor('editorOverviewRuler.background', null, nls.localize('editorOverviewRulerBackground', 'Background color of the editor overview ruler.'));\nexport const editorGutter = registerColor('editorGutter.background', { dark: editorBackground, light: editorBackground, hcDark: editorBackground, hcLight: editorBackground }, nls.localize('editorGutter', 'Background color of the editor gutter. The gutter contains the glyph margins and the line numbers.'));\nexport const editorUnnecessaryCodeBorder = registerColor('editorUnnecessaryCode.border', { dark: null, light: null, hcDark: Color.fromHex('#fff').transparent(0.8), hcLight: contrastBorder }, nls.localize('unnecessaryCodeBorder', 'Border color of unnecessary (unused) source code in the editor.'));\nexport const editorUnnecessaryCodeOpacity = registerColor('editorUnnecessaryCode.opacity', { dark: Color.fromHex('#000a'), light: Color.fromHex('#0007'), hcDark: null, hcLight: null }, nls.localize('unnecessaryCodeOpacity', 'Opacity of unnecessary (unused) source code in the editor. For example, \"#000000c0\" will render the code with 75% opacity. For high contrast themes, use the  \\'editorUnnecessaryCode.border\\' theme color to underline unnecessary code instead of fading it out.'));\nexport const ghostTextBorder = registerColor('editorGhostText.border', { dark: null, light: null, hcDark: Color.fromHex('#fff').transparent(0.8), hcLight: Color.fromHex('#292929').transparent(0.8) }, nls.localize('editorGhostTextBorder', 'Border color of ghost text in the editor.'));\nexport const ghostTextForeground = registerColor('editorGhostText.foreground', { dark: Color.fromHex('#ffffff56'), light: Color.fromHex('#0007'), hcDark: null, hcLight: null }, nls.localize('editorGhostTextForeground', 'Foreground color of the ghost text in the editor.'));\nexport const ghostTextBackground = registerColor('editorGhostText.background', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('editorGhostTextBackground', 'Background color of the ghost text in the editor.'));\nconst rulerRangeDefault = new Color(new RGBA(0, 122, 204, 0.6));\nexport const overviewRulerRangeHighlight = registerColor('editorOverviewRuler.rangeHighlightForeground', { dark: rulerRangeDefault, light: rulerRangeDefault, hcDark: rulerRangeDefault, hcLight: rulerRangeDefault }, nls.localize('overviewRulerRangeHighlight', 'Overview ruler marker color for range highlights. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const overviewRulerError = registerColor('editorOverviewRuler.errorForeground', { dark: new Color(new RGBA(255, 18, 18, 0.7)), light: new Color(new RGBA(255, 18, 18, 0.7)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: '#B5200D' }, nls.localize('overviewRuleError', 'Overview ruler marker color for errors.'));\nexport const overviewRulerWarning = registerColor('editorOverviewRuler.warningForeground', { dark: editorWarningForeground, light: editorWarningForeground, hcDark: editorWarningBorder, hcLight: editorWarningBorder }, nls.localize('overviewRuleWarning', 'Overview ruler marker color for warnings.'));\nexport const overviewRulerInfo = registerColor('editorOverviewRuler.infoForeground', { dark: editorInfoForeground, light: editorInfoForeground, hcDark: editorInfoBorder, hcLight: editorInfoBorder }, nls.localize('overviewRuleInfo', 'Overview ruler marker color for infos.'));\nexport const editorBracketHighlightingForeground1 = registerColor('editorBracketHighlight.foreground1', { dark: '#FFD700', light: '#0431FAFF', hcDark: '#FFD700', hcLight: '#0431FAFF' }, nls.localize('editorBracketHighlightForeground1', 'Foreground color of brackets (1). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground2 = registerColor('editorBracketHighlight.foreground2', { dark: '#DA70D6', light: '#319331FF', hcDark: '#DA70D6', hcLight: '#319331FF' }, nls.localize('editorBracketHighlightForeground2', 'Foreground color of brackets (2). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground3 = registerColor('editorBracketHighlight.foreground3', { dark: '#179FFF', light: '#7B3814FF', hcDark: '#87CEFA', hcLight: '#7B3814FF' }, nls.localize('editorBracketHighlightForeground3', 'Foreground color of brackets (3). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground4 = registerColor('editorBracketHighlight.foreground4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketHighlightForeground4', 'Foreground color of brackets (4). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground5 = registerColor('editorBracketHighlight.foreground5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketHighlightForeground5', 'Foreground color of brackets (5). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground6 = registerColor('editorBracketHighlight.foreground6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketHighlightForeground6', 'Foreground color of brackets (6). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingUnexpectedBracketForeground = registerColor('editorBracketHighlight.unexpectedBracket.foreground', { dark: new Color(new RGBA(255, 18, 18, 0.8)), light: new Color(new RGBA(255, 18, 18, 0.8)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: '' }, nls.localize('editorBracketHighlightUnexpectedBracketForeground', 'Foreground color of unexpected brackets.'));\nexport const editorBracketPairGuideBackground1 = registerColor('editorBracketPairGuide.background1', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background1', 'Background color of inactive bracket pair guides (1). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground2 = registerColor('editorBracketPairGuide.background2', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background2', 'Background color of inactive bracket pair guides (2). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground3 = registerColor('editorBracketPairGuide.background3', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background3', 'Background color of inactive bracket pair guides (3). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground4 = registerColor('editorBracketPairGuide.background4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background4', 'Background color of inactive bracket pair guides (4). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground5 = registerColor('editorBracketPairGuide.background5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background5', 'Background color of inactive bracket pair guides (5). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground6 = registerColor('editorBracketPairGuide.background6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background6', 'Background color of inactive bracket pair guides (6). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground1 = registerColor('editorBracketPairGuide.activeBackground1', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground1', 'Background color of active bracket pair guides (1). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground2 = registerColor('editorBracketPairGuide.activeBackground2', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground2', 'Background color of active bracket pair guides (2). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground3 = registerColor('editorBracketPairGuide.activeBackground3', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground3', 'Background color of active bracket pair guides (3). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground4 = registerColor('editorBracketPairGuide.activeBackground4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground4', 'Background color of active bracket pair guides (4). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground5 = registerColor('editorBracketPairGuide.activeBackground5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground5', 'Background color of active bracket pair guides (5). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground6 = registerColor('editorBracketPairGuide.activeBackground6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground6', 'Background color of active bracket pair guides (6). Requires enabling bracket pair guides.'));\nexport const editorUnicodeHighlightBorder = registerColor('editorUnicodeHighlight.border', { dark: '#BD9B03', light: '#CEA33D', hcDark: '#ff0000', hcLight: '#CEA33D' }, nls.localize('editorUnicodeHighlight.border', 'Border color used to highlight unicode characters.'));\nexport const editorUnicodeHighlightBackground = registerColor('editorUnicodeHighlight.background', { dark: '#bd9b0326', light: '#cea33d14', hcDark: '#00000000', hcLight: '#cea33d14' }, nls.localize('editorUnicodeHighlight.background', 'Background color used to highlight unicode characters.'));\n// contains all color rules that used to defined in editor/browser/widget/editor.css\nregisterThemingParticipant((theme, collector) => {\n    const background = theme.getColor(editorBackground);\n    const lineHighlight = theme.getColor(editorLineHighlight);\n    const imeBackground = (lineHighlight && !lineHighlight.isTransparent() ? lineHighlight : background);\n    if (imeBackground) {\n        collector.addRule(`.monaco-editor .inputarea.ime-input { background-color: ${imeBackground}; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function countEOL(text) {\n    let eolCount = 0;\n    let firstLineLength = 0;\n    let lastLineStart = 0;\n    let eol = 0 /* StringEOL.Unknown */;\n    for (let i = 0, len = text.length; i < len; i++) {\n        const chr = text.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            if (i + 1 < len && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                eol |= 2 /* StringEOL.CRLF */;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                eol |= 3 /* StringEOL.Invalid */;\n            }\n            lastLineStart = i + 1;\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            // \\n... case\n            eol |= 1 /* StringEOL.LF */;\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            lastLineStart = i + 1;\n        }\n    }\n    if (eolCount === 0) {\n        firstLineLength = text.length;\n    }\n    return [eolCount, firstLineLength, text.length - lastLineStart, eol];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from './cursorColumns.js';\nfunction _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {\n    let spacesCnt = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str.charAt(i) === '\\t') {\n            spacesCnt = CursorColumns.nextIndentTabStop(spacesCnt, indentSize);\n        }\n        else {\n            spacesCnt++;\n        }\n    }\n    let result = '';\n    if (!insertSpaces) {\n        const tabsCnt = Math.floor(spacesCnt / indentSize);\n        spacesCnt = spacesCnt % indentSize;\n        for (let i = 0; i < tabsCnt; i++) {\n            result += '\\t';\n        }\n    }\n    for (let i = 0; i < spacesCnt; i++) {\n        result += ' ';\n    }\n    return result;\n}\nexport function normalizeIndentation(str, indentSize, insertSpaces) {\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\n    if (firstNonWhitespaceIndex === -1) {\n        firstNonWhitespaceIndex = str.length;\n    }\n    return _normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nimport { Range } from './range.js';\n/**\n * A range of lines (1-based).\n */\nexport class LineRange {\n    static fromRange(range) {\n        return new LineRange(range.startLineNumber, range.endLineNumber);\n    }\n    /**\n     * @param lineRanges An array of sorted line ranges.\n     */\n    static joinMany(lineRanges) {\n        if (lineRanges.length === 0) {\n            return [];\n        }\n        let result = lineRanges[0];\n        for (let i = 1; i < lineRanges.length; i++) {\n            result = this.join(result, lineRanges[i]);\n        }\n        return result;\n    }\n    /**\n     * @param lineRanges1 Must be sorted.\n     * @param lineRanges2 Must be sorted.\n     */\n    static join(lineRanges1, lineRanges2) {\n        if (lineRanges1.length === 0) {\n            return lineRanges2;\n        }\n        if (lineRanges2.length === 0) {\n            return lineRanges1;\n        }\n        const result = [];\n        let i1 = 0;\n        let i2 = 0;\n        let current = null;\n        while (i1 < lineRanges1.length || i2 < lineRanges2.length) {\n            let next = null;\n            if (i1 < lineRanges1.length && i2 < lineRanges2.length) {\n                const lineRange1 = lineRanges1[i1];\n                const lineRange2 = lineRanges2[i2];\n                if (lineRange1.startLineNumber < lineRange2.startLineNumber) {\n                    next = lineRange1;\n                    i1++;\n                }\n                else {\n                    next = lineRange2;\n                    i2++;\n                }\n            }\n            else if (i1 < lineRanges1.length) {\n                next = lineRanges1[i1];\n                i1++;\n            }\n            else {\n                next = lineRanges2[i2];\n                i2++;\n            }\n            if (current === null) {\n                current = next;\n            }\n            else {\n                if (current.endLineNumberExclusive >= next.startLineNumber) {\n                    // merge\n                    current = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));\n                }\n                else {\n                    // push\n                    result.push(current);\n                    current = next;\n                }\n            }\n        }\n        if (current !== null) {\n            result.push(current);\n        }\n        return result;\n    }\n    static ofLength(startLineNumber, length) {\n        return new LineRange(startLineNumber, startLineNumber + length);\n    }\n    constructor(startLineNumber, endLineNumberExclusive) {\n        if (startLineNumber > endLineNumberExclusive) {\n            throw new BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);\n        }\n        this.startLineNumber = startLineNumber;\n        this.endLineNumberExclusive = endLineNumberExclusive;\n    }\n    /**\n     * Indicates if this line range contains the given line number.\n     */\n    contains(lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n    }\n    /**\n     * Indicates if this line range is empty.\n     */\n    get isEmpty() {\n        return this.startLineNumber === this.endLineNumberExclusive;\n    }\n    /**\n     * Moves this line range by the given offset of line numbers.\n     */\n    delta(offset) {\n        return new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);\n    }\n    /**\n     * The number of lines this line range spans.\n     */\n    get length() {\n        return this.endLineNumberExclusive - this.startLineNumber;\n    }\n    /**\n     * Creates a line range that combines this and the given line range.\n     */\n    join(other) {\n        return new LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));\n    }\n    toString() {\n        return `[${this.startLineNumber},${this.endLineNumberExclusive})`;\n    }\n    /**\n     * The resulting range is empty if the ranges do not intersect, but touch.\n     * If the ranges don't even touch, the result is undefined.\n     */\n    intersect(other) {\n        const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);\n        const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);\n        if (startLineNumber <= endLineNumberExclusive) {\n            return new LineRange(startLineNumber, endLineNumberExclusive);\n        }\n        return undefined;\n    }\n    intersectsStrict(other) {\n        return this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;\n    }\n    overlapOrTouch(other) {\n        return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;\n    }\n    equals(b) {\n        return this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;\n    }\n    toInclusiveRange() {\n        if (this.isEmpty) {\n            return null;\n        }\n        return new Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);\n    }\n    toExclusiveRange() {\n        return new Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../base/common/errors.js';\n/**\n * A range of offsets (0-based).\n*/\nexport class OffsetRange {\n    static addRange(range, sortedRanges) {\n        let i = 0;\n        while (i < sortedRanges.length && sortedRanges[i].endExclusive < range.start) {\n            i++;\n        }\n        let j = i;\n        while (j < sortedRanges.length && sortedRanges[j].start <= range.endExclusive) {\n            j++;\n        }\n        if (i === j) {\n            sortedRanges.splice(i, 0, range);\n        }\n        else {\n            const start = Math.min(range.start, sortedRanges[i].start);\n            const end = Math.max(range.endExclusive, sortedRanges[j - 1].endExclusive);\n            sortedRanges.splice(i, j - i, new OffsetRange(start, end));\n        }\n    }\n    static tryCreate(start, endExclusive) {\n        if (start > endExclusive) {\n            return undefined;\n        }\n        return new OffsetRange(start, endExclusive);\n    }\n    constructor(start, endExclusive) {\n        this.start = start;\n        this.endExclusive = endExclusive;\n        if (start > endExclusive) {\n            throw new BugIndicatingError(`Invalid range: ${this.toString()}`);\n        }\n    }\n    get isEmpty() {\n        return this.start === this.endExclusive;\n    }\n    delta(offset) {\n        return new OffsetRange(this.start + offset, this.endExclusive + offset);\n    }\n    get length() {\n        return this.endExclusive - this.start;\n    }\n    toString() {\n        return `[${this.start}, ${this.endExclusive})`;\n    }\n    equals(other) {\n        return this.start === other.start && this.endExclusive === other.endExclusive;\n    }\n    containsRange(other) {\n        return this.start <= other.start && other.endExclusive <= this.endExclusive;\n    }\n    /**\n     * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)\n     * The joined range is the smallest range that contains both ranges.\n     */\n    join(other) {\n        return new OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));\n    }\n    /**\n     * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)\n     *\n     * The resulting range is empty if the ranges do not intersect, but touch.\n     * If the ranges don't even touch, the result is undefined.\n     */\n    intersect(other) {\n        const start = Math.max(this.start, other.start);\n        const end = Math.min(this.endExclusive, other.endExclusive);\n        if (start <= end) {\n            return new OffsetRange(start, end);\n        }\n        return undefined;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A position in the editor.\n */\nexport class Position {\n    constructor(lineNumber, column) {\n        this.lineNumber = lineNumber;\n        this.column = column;\n    }\n    /**\n     * Create a new position from this position.\n     *\n     * @param newLineNumber new line number\n     * @param newColumn new column\n     */\n    with(newLineNumber = this.lineNumber, newColumn = this.column) {\n        if (newLineNumber === this.lineNumber && newColumn === this.column) {\n            return this;\n        }\n        else {\n            return new Position(newLineNumber, newColumn);\n        }\n    }\n    /**\n     * Derive a new position from this position.\n     *\n     * @param deltaLineNumber line number delta\n     * @param deltaColumn column delta\n     */\n    delta(deltaLineNumber = 0, deltaColumn = 0) {\n        return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);\n    }\n    /**\n     * Test if this position equals other position\n     */\n    equals(other) {\n        return Position.equals(this, other);\n    }\n    /**\n     * Test if position `a` equals position `b`\n     */\n    static equals(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        return (!!a &&\n            !!b &&\n            a.lineNumber === b.lineNumber &&\n            a.column === b.column);\n    }\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be false.\n     */\n    isBefore(other) {\n        return Position.isBefore(this, other);\n    }\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be false.\n     */\n    static isBefore(a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column < b.column;\n    }\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be true.\n     */\n    isBeforeOrEqual(other) {\n        return Position.isBeforeOrEqual(this, other);\n    }\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be true.\n     */\n    static isBeforeOrEqual(a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column <= b.column;\n    }\n    /**\n     * A function that compares positions, useful for sorting\n     */\n    static compare(a, b) {\n        const aLineNumber = a.lineNumber | 0;\n        const bLineNumber = b.lineNumber | 0;\n        if (aLineNumber === bLineNumber) {\n            const aColumn = a.column | 0;\n            const bColumn = b.column | 0;\n            return aColumn - bColumn;\n        }\n        return aLineNumber - bLineNumber;\n    }\n    /**\n     * Clone this position.\n     */\n    clone() {\n        return new Position(this.lineNumber, this.column);\n    }\n    /**\n     * Convert to a human-readable representation.\n     */\n    toString() {\n        return '(' + this.lineNumber + ',' + this.column + ')';\n    }\n    // ---\n    /**\n     * Create a `Position` from an `IPosition`.\n     */\n    static lift(pos) {\n        return new Position(pos.lineNumber, pos.column);\n    }\n    /**\n     * Test if `obj` is an `IPosition`.\n     */\n    static isIPosition(obj) {\n        return (obj\n            && (typeof obj.lineNumber === 'number')\n            && (typeof obj.column === 'number'));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\n/**\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\n */\nexport class Range {\n    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {\n        if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\n            this.startLineNumber = endLineNumber;\n            this.startColumn = endColumn;\n            this.endLineNumber = startLineNumber;\n            this.endColumn = startColumn;\n        }\n        else {\n            this.startLineNumber = startLineNumber;\n            this.startColumn = startColumn;\n            this.endLineNumber = endLineNumber;\n            this.endColumn = endColumn;\n        }\n    }\n    /**\n     * Test if this range is empty.\n     */\n    isEmpty() {\n        return Range.isEmpty(this);\n    }\n    /**\n     * Test if `range` is empty.\n     */\n    static isEmpty(range) {\n        return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\n    }\n    /**\n     * Test if position is in this range. If the position is at the edges, will return true.\n     */\n    containsPosition(position) {\n        return Range.containsPosition(this, position);\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return true.\n     */\n    static containsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return false.\n     * @internal\n     */\n    static strictContainsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if range is in this range. If the range is equal to this range, will return true.\n     */\n    containsRange(range) {\n        return Range.containsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\n     */\n    static containsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\n     */\n    strictContainsRange(range) {\n        return Range.strictContainsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.\n     */\n    static strictContainsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    plusRange(range) {\n        return Range.plusRange(this, range);\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    static plusRange(a, b) {\n        let startLineNumber;\n        let startColumn;\n        let endLineNumber;\n        let endColumn;\n        if (b.startLineNumber < a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = b.startColumn;\n        }\n        else if (b.startLineNumber === a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = Math.min(b.startColumn, a.startColumn);\n        }\n        else {\n            startLineNumber = a.startLineNumber;\n            startColumn = a.startColumn;\n        }\n        if (b.endLineNumber > a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = b.endColumn;\n        }\n        else if (b.endLineNumber === a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = Math.max(b.endColumn, a.endColumn);\n        }\n        else {\n            endLineNumber = a.endLineNumber;\n            endColumn = a.endColumn;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    intersectRanges(range) {\n        return Range.intersectRanges(this, range);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    static intersectRanges(a, b) {\n        let resultStartLineNumber = a.startLineNumber;\n        let resultStartColumn = a.startColumn;\n        let resultEndLineNumber = a.endLineNumber;\n        let resultEndColumn = a.endColumn;\n        const otherStartLineNumber = b.startLineNumber;\n        const otherStartColumn = b.startColumn;\n        const otherEndLineNumber = b.endLineNumber;\n        const otherEndColumn = b.endColumn;\n        if (resultStartLineNumber < otherStartLineNumber) {\n            resultStartLineNumber = otherStartLineNumber;\n            resultStartColumn = otherStartColumn;\n        }\n        else if (resultStartLineNumber === otherStartLineNumber) {\n            resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n        }\n        if (resultEndLineNumber > otherEndLineNumber) {\n            resultEndLineNumber = otherEndLineNumber;\n            resultEndColumn = otherEndColumn;\n        }\n        else if (resultEndLineNumber === otherEndLineNumber) {\n            resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n        }\n        // Check if selection is now empty\n        if (resultStartLineNumber > resultEndLineNumber) {\n            return null;\n        }\n        if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n            return null;\n        }\n        return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n    }\n    /**\n     * Test if this range equals other.\n     */\n    equalsRange(other) {\n        return Range.equalsRange(this, other);\n    }\n    /**\n     * Test if range `a` equals `b`.\n     */\n    static equalsRange(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        return (!!a &&\n            !!b &&\n            a.startLineNumber === b.startLineNumber &&\n            a.startColumn === b.startColumn &&\n            a.endLineNumber === b.endLineNumber &&\n            a.endColumn === b.endColumn);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    getEndPosition() {\n        return Range.getEndPosition(this);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    static getEndPosition(range) {\n        return new Position(range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    getStartPosition() {\n        return Range.getStartPosition(this);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    static getStartPosition(range) {\n        return new Position(range.startLineNumber, range.startColumn);\n    }\n    /**\n     * Transform to a user presentable string representation.\n     */\n    toString() {\n        return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\n    }\n    /**\n     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    collapseToStart() {\n        return Range.collapseToStart(this);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    static collapseToStart(range) {\n        return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n    }\n    /**\n     * Create a new empty range using this range's end position.\n     */\n    collapseToEnd() {\n        return Range.collapseToEnd(this);\n    }\n    /**\n     * Create a new empty range using this range's end position.\n     */\n    static collapseToEnd(range) {\n        return new Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Moves the range by the given amount of lines.\n     */\n    delta(lineCount) {\n        return new Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);\n    }\n    // ---\n    static fromPositions(start, end = start) {\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    static lift(range) {\n        if (!range) {\n            return null;\n        }\n        return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Test if `obj` is an `IRange`.\n     */\n    static isIRange(obj) {\n        return (obj\n            && (typeof obj.startLineNumber === 'number')\n            && (typeof obj.startColumn === 'number')\n            && (typeof obj.endLineNumber === 'number')\n            && (typeof obj.endColumn === 'number'));\n    }\n    /**\n     * Test if the two ranges are touching in any way.\n     */\n    static areIntersectingOrTouching(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * Test if the two ranges are intersecting. If the ranges are touching it returns true.\n     */\n    static areIntersecting(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the startPosition and then on the endPosition\n     */\n    static compareRangesUsingStarts(a, b) {\n        if (a && b) {\n            const aStartLineNumber = a.startLineNumber | 0;\n            const bStartLineNumber = b.startLineNumber | 0;\n            if (aStartLineNumber === bStartLineNumber) {\n                const aStartColumn = a.startColumn | 0;\n                const bStartColumn = b.startColumn | 0;\n                if (aStartColumn === bStartColumn) {\n                    const aEndLineNumber = a.endLineNumber | 0;\n                    const bEndLineNumber = b.endLineNumber | 0;\n                    if (aEndLineNumber === bEndLineNumber) {\n                        const aEndColumn = a.endColumn | 0;\n                        const bEndColumn = b.endColumn | 0;\n                        return aEndColumn - bEndColumn;\n                    }\n                    return aEndLineNumber - bEndLineNumber;\n                }\n                return aStartColumn - bStartColumn;\n            }\n            return aStartLineNumber - bStartLineNumber;\n        }\n        const aExists = (a ? 1 : 0);\n        const bExists = (b ? 1 : 0);\n        return aExists - bExists;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the endPosition and then on the startPosition\n     */\n    static compareRangesUsingEnds(a, b) {\n        if (a.endLineNumber === b.endLineNumber) {\n            if (a.endColumn === b.endColumn) {\n                if (a.startLineNumber === b.startLineNumber) {\n                    return a.startColumn - b.startColumn;\n                }\n                return a.startLineNumber - b.startLineNumber;\n            }\n            return a.endColumn - b.endColumn;\n        }\n        return a.endLineNumber - b.endLineNumber;\n    }\n    /**\n     * Test if the range spans multiple lines.\n     */\n    static spansMultipleLines(range) {\n        return range.endLineNumber > range.startLineNumber;\n    }\n    toJSON() {\n        return this;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A very VM friendly rgba datastructure.\n * Please don't touch unless you take a look at the IR.\n */\nexport class RGBA8 {\n    constructor(r, g, b, a) {\n        this._rgba8Brand = undefined;\n        this.r = RGBA8._clamp(r);\n        this.g = RGBA8._clamp(g);\n        this.b = RGBA8._clamp(b);\n        this.a = RGBA8._clamp(a);\n    }\n    equals(other) {\n        return (this.r === other.r\n            && this.g === other.g\n            && this.b === other.b\n            && this.a === other.a);\n    }\n    static _clamp(c) {\n        if (c < 0) {\n            return 0;\n        }\n        if (c > 255) {\n            return 255;\n        }\n        return c | 0;\n    }\n}\nRGBA8.Empty = new RGBA8(0, 0, 0, 0);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\nimport { Range } from './range.js';\n/**\n * A selection in the editor.\n * The selection is a range that has an orientation.\n */\nexport class Selection extends Range {\n    constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {\n        super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);\n        this.selectionStartLineNumber = selectionStartLineNumber;\n        this.selectionStartColumn = selectionStartColumn;\n        this.positionLineNumber = positionLineNumber;\n        this.positionColumn = positionColumn;\n    }\n    /**\n     * Transform to a human-readable representation.\n     */\n    toString() {\n        return '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';\n    }\n    /**\n     * Test if equals other selection.\n     */\n    equalsSelection(other) {\n        return (Selection.selectionsEqual(this, other));\n    }\n    /**\n     * Test if the two selections are equal.\n     */\n    static selectionsEqual(a, b) {\n        return (a.selectionStartLineNumber === b.selectionStartLineNumber &&\n            a.selectionStartColumn === b.selectionStartColumn &&\n            a.positionLineNumber === b.positionLineNumber &&\n            a.positionColumn === b.positionColumn);\n    }\n    /**\n     * Get directions (LTR or RTL).\n     */\n    getDirection() {\n        if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {\n            return 0 /* SelectionDirection.LTR */;\n        }\n        return 1 /* SelectionDirection.RTL */;\n    }\n    /**\n     * Create a new selection with a different `positionLineNumber` and `positionColumn`.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        if (this.getDirection() === 0 /* SelectionDirection.LTR */) {\n            return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);\n    }\n    /**\n     * Get the position at `positionLineNumber` and `positionColumn`.\n     */\n    getPosition() {\n        return new Position(this.positionLineNumber, this.positionColumn);\n    }\n    /**\n     * Get the position at the start of the selection.\n    */\n    getSelectionStart() {\n        return new Position(this.selectionStartLineNumber, this.selectionStartColumn);\n    }\n    /**\n     * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        if (this.getDirection() === 0 /* SelectionDirection.LTR */) {\n            return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n        }\n        return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);\n    }\n    // ----\n    /**\n     * Create a `Selection` from one or two positions\n     */\n    static fromPositions(start, end = start) {\n        return new Selection(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    /**\n     * Creates a `Selection` from a range, given a direction.\n     */\n    static fromRange(range, direction) {\n        if (direction === 0 /* SelectionDirection.LTR */) {\n            return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n        }\n        else {\n            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n        }\n    }\n    /**\n     * Create a `Selection` from an `ISelection`.\n     */\n    static liftSelection(sel) {\n        return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);\n    }\n    /**\n     * `a` equals `b`.\n     */\n    static selectionsArrEqual(a, b) {\n        if (a && !b || !a && b) {\n            return false;\n        }\n        if (!a && !b) {\n            return true;\n        }\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (!this.selectionsEqual(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Test if `obj` is an `ISelection`.\n     */\n    static isISelection(obj) {\n        return (obj\n            && (typeof obj.selectionStartLineNumber === 'number')\n            && (typeof obj.selectionStartColumn === 'number')\n            && (typeof obj.positionLineNumber === 'number')\n            && (typeof obj.positionColumn === 'number'));\n    }\n    /**\n     * Create with a direction.\n     */\n    static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {\n        if (direction === 0 /* SelectionDirection.LTR */) {\n            return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as buffer from '../../../base/common/buffer.js';\nlet _utf16LE_TextDecoder;\nfunction getUTF16LE_TextDecoder() {\n    if (!_utf16LE_TextDecoder) {\n        _utf16LE_TextDecoder = new TextDecoder('UTF-16LE');\n    }\n    return _utf16LE_TextDecoder;\n}\nlet _utf16BE_TextDecoder;\nfunction getUTF16BE_TextDecoder() {\n    if (!_utf16BE_TextDecoder) {\n        _utf16BE_TextDecoder = new TextDecoder('UTF-16BE');\n    }\n    return _utf16BE_TextDecoder;\n}\nlet _platformTextDecoder;\nexport function getPlatformTextDecoder() {\n    if (!_platformTextDecoder) {\n        _platformTextDecoder = platform.isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n    }\n    return _platformTextDecoder;\n}\nexport function decodeUTF16LE(source, offset, len) {\n    const view = new Uint16Array(source.buffer, offset, len);\n    if (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n        // UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n        // It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n        // We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n        // So we use the manual decoder\n        return compatDecodeUTF16LE(source, offset, len);\n    }\n    return getUTF16LE_TextDecoder().decode(view);\n}\nfunction compatDecodeUTF16LE(source, offset, len) {\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0; i < len; i++) {\n        const charCode = buffer.readUInt16LE(source, offset);\n        offset += 2;\n        result[resultLen++] = String.fromCharCode(charCode);\n    }\n    return result.join('');\n}\nexport class StringBuilder {\n    constructor(capacity) {\n        this._capacity = capacity | 0;\n        this._buffer = new Uint16Array(this._capacity);\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    reset() {\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    build() {\n        if (this._completedStrings !== null) {\n            this._flushBuffer();\n            return this._completedStrings.join('');\n        }\n        return this._buildBuffer();\n    }\n    _buildBuffer() {\n        if (this._bufferLength === 0) {\n            return '';\n        }\n        const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);\n        return getPlatformTextDecoder().decode(view);\n    }\n    _flushBuffer() {\n        const bufferString = this._buildBuffer();\n        this._bufferLength = 0;\n        if (this._completedStrings === null) {\n            this._completedStrings = [bufferString];\n        }\n        else {\n            this._completedStrings[this._completedStrings.length] = bufferString;\n        }\n    }\n    /**\n     * Append a char code (<2^16)\n     */\n    appendCharCode(charCode) {\n        const remainingSpace = this._capacity - this._bufferLength;\n        if (remainingSpace <= 1) {\n            if (remainingSpace === 0 || strings.isHighSurrogate(charCode)) {\n                this._flushBuffer();\n            }\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    /**\n     * Append an ASCII char code (<2^8)\n     */\n    appendASCIICharCode(charCode) {\n        if (this._bufferLength === this._capacity) {\n            // buffer is full\n            this._flushBuffer();\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendString(str) {\n        const strLen = str.length;\n        if (this._bufferLength + strLen >= this._capacity) {\n            // This string does not fit in the remaining buffer space\n            this._flushBuffer();\n            this._completedStrings[this._completedStrings.length] = str;\n            return;\n        }\n        for (let i = 0; i < strLen; i++) {\n            this._buffer[this._bufferLength++] = str.charCodeAt(i);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as buffer from '../../../base/common/buffer.js';\nimport { decodeUTF16LE } from './stringBuilder.js';\nfunction escapeNewLine(str) {\n    return (str\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r'));\n}\nexport class TextChange {\n    get oldLength() {\n        return this.oldText.length;\n    }\n    get oldEnd() {\n        return this.oldPosition + this.oldText.length;\n    }\n    get newLength() {\n        return this.newText.length;\n    }\n    get newEnd() {\n        return this.newPosition + this.newText.length;\n    }\n    constructor(oldPosition, oldText, newPosition, newText) {\n        this.oldPosition = oldPosition;\n        this.oldText = oldText;\n        this.newPosition = newPosition;\n        this.newText = newText;\n    }\n    toString() {\n        if (this.oldText.length === 0) {\n            return `(insert@${this.oldPosition} \"${escapeNewLine(this.newText)}\")`;\n        }\n        if (this.newText.length === 0) {\n            return `(delete@${this.oldPosition} \"${escapeNewLine(this.oldText)}\")`;\n        }\n        return `(replace@${this.oldPosition} \"${escapeNewLine(this.oldText)}\" with \"${escapeNewLine(this.newText)}\")`;\n    }\n    static _writeStringSize(str) {\n        return (4 + 2 * str.length);\n    }\n    static _writeString(b, str, offset) {\n        const len = str.length;\n        buffer.writeUInt32BE(b, len, offset);\n        offset += 4;\n        for (let i = 0; i < len; i++) {\n            buffer.writeUInt16LE(b, str.charCodeAt(i), offset);\n            offset += 2;\n        }\n        return offset;\n    }\n    static _readString(b, offset) {\n        const len = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        return decodeUTF16LE(b, offset, len);\n    }\n    writeSize() {\n        return (+4 // oldPosition\n            + 4 // newPosition\n            + TextChange._writeStringSize(this.oldText)\n            + TextChange._writeStringSize(this.newText));\n    }\n    write(b, offset) {\n        buffer.writeUInt32BE(b, this.oldPosition, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.newPosition, offset);\n        offset += 4;\n        offset = TextChange._writeString(b, this.oldText, offset);\n        offset = TextChange._writeString(b, this.newText, offset);\n        return offset;\n    }\n    static read(b, offset, dest) {\n        const oldPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const newPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const oldText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(oldText);\n        const newText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(newText);\n        dest.push(new TextChange(oldPosition, oldText, newPosition, newText));\n        return offset;\n    }\n}\nexport function compressConsecutiveTextChanges(prevEdits, currEdits) {\n    if (prevEdits === null || prevEdits.length === 0) {\n        return currEdits;\n    }\n    const compressor = new TextChangeCompressor(prevEdits, currEdits);\n    return compressor.compress();\n}\nclass TextChangeCompressor {\n    constructor(prevEdits, currEdits) {\n        this._prevEdits = prevEdits;\n        this._currEdits = currEdits;\n        this._result = [];\n        this._resultLen = 0;\n        this._prevLen = this._prevEdits.length;\n        this._prevDeltaOffset = 0;\n        this._currLen = this._currEdits.length;\n        this._currDeltaOffset = 0;\n    }\n    compress() {\n        let prevIndex = 0;\n        let currIndex = 0;\n        let prevEdit = this._getPrev(prevIndex);\n        let currEdit = this._getCurr(currIndex);\n        while (prevIndex < this._prevLen || currIndex < this._currLen) {\n            if (prevEdit === null) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (currEdit === null) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldEnd <= prevEdit.newPosition) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (prevEdit.newEnd <= currEdit.oldPosition) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldPosition < prevEdit.newPosition) {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newPosition - currEdit.oldPosition);\n                this._acceptCurr(e1);\n                currEdit = e2;\n                continue;\n            }\n            if (prevEdit.newPosition < currEdit.oldPosition) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldPosition - prevEdit.newPosition);\n                this._acceptPrev(e1);\n                prevEdit = e2;\n                continue;\n            }\n            // At this point, currEdit.oldPosition === prevEdit.newPosition\n            let mergePrev;\n            let mergeCurr;\n            if (currEdit.oldEnd === prevEdit.newEnd) {\n                mergePrev = prevEdit;\n                mergeCurr = currEdit;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = this._getCurr(++currIndex);\n            }\n            else if (currEdit.oldEnd < prevEdit.newEnd) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldLength);\n                mergePrev = e1;\n                mergeCurr = currEdit;\n                prevEdit = e2;\n                currEdit = this._getCurr(++currIndex);\n            }\n            else {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newLength);\n                mergePrev = prevEdit;\n                mergeCurr = e1;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = e2;\n            }\n            this._result[this._resultLen++] = new TextChange(mergePrev.oldPosition, mergePrev.oldText, mergeCurr.newPosition, mergeCurr.newText);\n            this._prevDeltaOffset += mergePrev.newLength - mergePrev.oldLength;\n            this._currDeltaOffset += mergeCurr.newLength - mergeCurr.oldLength;\n        }\n        const merged = TextChangeCompressor._merge(this._result);\n        const cleaned = TextChangeCompressor._removeNoOps(merged);\n        return cleaned;\n    }\n    _acceptCurr(currEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebaseCurr(this._prevDeltaOffset, currEdit);\n        this._currDeltaOffset += currEdit.newLength - currEdit.oldLength;\n    }\n    _getCurr(currIndex) {\n        return (currIndex < this._currLen ? this._currEdits[currIndex] : null);\n    }\n    _acceptPrev(prevEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebasePrev(this._currDeltaOffset, prevEdit);\n        this._prevDeltaOffset += prevEdit.newLength - prevEdit.oldLength;\n    }\n    _getPrev(prevIndex) {\n        return (prevIndex < this._prevLen ? this._prevEdits[prevIndex] : null);\n    }\n    static _rebaseCurr(prevDeltaOffset, currEdit) {\n        return new TextChange(currEdit.oldPosition - prevDeltaOffset, currEdit.oldText, currEdit.newPosition, currEdit.newText);\n    }\n    static _rebasePrev(currDeltaOffset, prevEdit) {\n        return new TextChange(prevEdit.oldPosition, prevEdit.oldText, prevEdit.newPosition + currDeltaOffset, prevEdit.newText);\n    }\n    static _splitPrev(edit, offset) {\n        const preText = edit.newText.substr(0, offset);\n        const postText = edit.newText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, edit.oldText, edit.newPosition, preText),\n            new TextChange(edit.oldEnd, '', edit.newPosition + offset, postText)\n        ];\n    }\n    static _splitCurr(edit, offset) {\n        const preText = edit.oldText.substr(0, offset);\n        const postText = edit.oldText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, preText, edit.newPosition, edit.newText),\n            new TextChange(edit.oldPosition + offset, postText, edit.newEnd, '')\n        ];\n    }\n    static _merge(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        let prev = edits[0];\n        for (let i = 1; i < edits.length; i++) {\n            const curr = edits[i];\n            if (prev.oldEnd === curr.oldPosition) {\n                // Merge into `prev`\n                prev = new TextChange(prev.oldPosition, prev.oldText + curr.oldText, prev.newPosition, prev.newText + curr.newText);\n            }\n            else {\n                result[resultLen++] = prev;\n                prev = curr;\n            }\n        }\n        result[resultLen++] = prev;\n        return result;\n    }\n    static _removeNoOps(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0; i < edits.length; i++) {\n            const edit = edits[i];\n            if (edit.oldText === edit.newText) {\n                continue;\n            }\n            result[resultLen++] = edit;\n        }\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const EDITOR_MODEL_DEFAULTS = {\n    tabSize: 4,\n    indentSize: 4,\n    insertSpaces: true,\n    detectIndentation: true,\n    trimAutoWhitespace: true,\n    largeFileOptimizations: true,\n    bracketPairColorizationOptions: {\n        enabled: true,\n        independentColorPoolPerBracketType: false,\n    },\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CharacterClassifier } from './characterClassifier.js';\nexport class WordCharacterClassifier extends CharacterClassifier {\n    constructor(wordSeparators) {\n        super(0 /* WordCharacterClass.Regular */);\n        for (let i = 0, len = wordSeparators.length; i < len; i++) {\n            this.set(wordSeparators.charCodeAt(i), 2 /* WordCharacterClass.WordSeparator */);\n        }\n        this.set(32 /* CharCode.Space */, 1 /* WordCharacterClass.Whitespace */);\n        this.set(9 /* CharCode.Tab */, 1 /* WordCharacterClass.Whitespace */);\n    }\n}\nfunction once(computeFn) {\n    const cache = {}; // TODO@Alex unbounded cache\n    return (input) => {\n        if (!cache.hasOwnProperty(input)) {\n            cache[input] = computeFn(input);\n        }\n        return cache[input];\n    };\n}\nexport const getMapForWordSeparators = once((input) => new WordCharacterClassifier(input));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\nexport const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n/**\n * Create a word definition regular expression based on default word separators.\n * Optionally provide allowed separators that should be included in words.\n *\n * The default would look like this:\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n */\nfunction createWordRegExp(allowInWords = '') {\n    let source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n    for (const sep of USUAL_WORD_SEPARATORS) {\n        if (allowInWords.indexOf(sep) >= 0) {\n            continue;\n        }\n        source += '\\\\' + sep;\n    }\n    source += '\\\\s]+)';\n    return new RegExp(source, 'g');\n}\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\nexport const DEFAULT_WORD_REGEXP = createWordRegExp();\nexport function ensureValidWordDefinition(wordDefinition) {\n    let result = DEFAULT_WORD_REGEXP;\n    if (wordDefinition && (wordDefinition instanceof RegExp)) {\n        if (!wordDefinition.global) {\n            let flags = 'g';\n            if (wordDefinition.ignoreCase) {\n                flags += 'i';\n            }\n            if (wordDefinition.multiline) {\n                flags += 'm';\n            }\n            if (wordDefinition.unicode) {\n                flags += 'u';\n            }\n            result = new RegExp(wordDefinition.source, flags);\n        }\n        else {\n            result = wordDefinition;\n        }\n    }\n    result.lastIndex = 0;\n    return result;\n}\nconst _defaultConfig = new LinkedList();\n_defaultConfig.unshift({\n    maxLen: 1000,\n    windowSize: 15,\n    timeBudget: 150\n});\nexport function getWordAtText(column, wordDefinition, text, textOffset, config) {\n    if (!config) {\n        config = Iterable.first(_defaultConfig);\n    }\n    if (text.length > config.maxLen) {\n        // don't throw strings that long at the regexp\n        // but use a sub-string in which a word must occur\n        let start = column - config.maxLen / 2;\n        if (start < 0) {\n            start = 0;\n        }\n        else {\n            textOffset += start;\n        }\n        text = text.substring(start, column + config.maxLen / 2);\n        return getWordAtText(column, wordDefinition, text, textOffset, config);\n    }\n    const t1 = Date.now();\n    const pos = column - 1 - textOffset;\n    let prevRegexIndex = -1;\n    let match = null;\n    for (let i = 1;; i++) {\n        // check time budget\n        if (Date.now() - t1 >= config.timeBudget) {\n            break;\n        }\n        // reset the index at which the regexp should start matching, also know where it\n        // should stop so that subsequent search don't repeat previous searches\n        const regexIndex = pos - config.windowSize * i;\n        wordDefinition.lastIndex = Math.max(0, regexIndex);\n        const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\n        if (!thisMatch && match) {\n            // stop: we have something\n            break;\n        }\n        match = thisMatch;\n        // stop: searched at start\n        if (regexIndex <= 0) {\n            break;\n        }\n        prevRegexIndex = regexIndex;\n    }\n    if (match) {\n        const result = {\n            word: match[0],\n            startColumn: textOffset + 1 + match.index,\n            endColumn: textOffset + 1 + match.index + match[0].length\n        };\n        wordDefinition.lastIndex = 0;\n        return result;\n    }\n    return null;\n}\nfunction _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {\n    let match;\n    while (match = wordDefinition.exec(text)) {\n        const matchIndex = match.index || 0;\n        if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n            return match;\n        }\n        else if (stopPos > 0 && matchIndex > stopPos) {\n            return null;\n        }\n    }\n    return null;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorState, SingleCursorState } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\n/**\n * Represents a single cursor.\n*/\nexport class Cursor {\n    constructor(context) {\n        this._selTrackedRange = null;\n        this._trackSelection = true;\n        this._setState(context, new SingleCursorState(new Range(1, 1, 1, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(1, 1), 0), new SingleCursorState(new Range(1, 1, 1, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(1, 1), 0));\n    }\n    dispose(context) {\n        this._removeTrackedRange(context);\n    }\n    startTrackingSelection(context) {\n        this._trackSelection = true;\n        this._updateTrackedRange(context);\n    }\n    stopTrackingSelection(context) {\n        this._trackSelection = false;\n        this._removeTrackedRange(context);\n    }\n    _updateTrackedRange(context) {\n        if (!this._trackSelection) {\n            // don't track the selection\n            return;\n        }\n        this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, this.modelState.selection, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n    }\n    _removeTrackedRange(context) {\n        this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, null, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n    }\n    asCursorState() {\n        return new CursorState(this.modelState, this.viewState);\n    }\n    readSelectionFromMarkers(context) {\n        const range = context.model._getTrackedRange(this._selTrackedRange);\n        if (this.modelState.selection.isEmpty() && !range.isEmpty()) {\n            // Avoid selecting text when recovering from markers\n            return Selection.fromRange(range.collapseToEnd(), this.modelState.selection.getDirection());\n        }\n        return Selection.fromRange(range, this.modelState.selection.getDirection());\n    }\n    ensureValidState(context) {\n        this._setState(context, this.modelState, this.viewState);\n    }\n    setState(context, modelState, viewState) {\n        this._setState(context, modelState, viewState);\n    }\n    static _validatePositionWithCache(viewModel, position, cacheInput, cacheOutput) {\n        if (position.equals(cacheInput)) {\n            return cacheOutput;\n        }\n        return viewModel.normalizePosition(position, 2 /* PositionAffinity.None */);\n    }\n    static _validateViewState(viewModel, viewState) {\n        const position = viewState.position;\n        const sStartPosition = viewState.selectionStart.getStartPosition();\n        const sEndPosition = viewState.selectionStart.getEndPosition();\n        const validPosition = viewModel.normalizePosition(position, 2 /* PositionAffinity.None */);\n        const validSStartPosition = this._validatePositionWithCache(viewModel, sStartPosition, position, validPosition);\n        const validSEndPosition = this._validatePositionWithCache(viewModel, sEndPosition, sStartPosition, validSStartPosition);\n        if (position.equals(validPosition) && sStartPosition.equals(validSStartPosition) && sEndPosition.equals(validSEndPosition)) {\n            // fast path: the state is valid\n            return viewState;\n        }\n        return new SingleCursorState(Range.fromPositions(validSStartPosition, validSEndPosition), viewState.selectionStartKind, viewState.selectionStartLeftoverVisibleColumns + sStartPosition.column - validSStartPosition.column, validPosition, viewState.leftoverVisibleColumns + position.column - validPosition.column);\n    }\n    _setState(context, modelState, viewState) {\n        if (viewState) {\n            viewState = Cursor._validateViewState(context.viewModel, viewState);\n        }\n        if (!modelState) {\n            if (!viewState) {\n                return;\n            }\n            // We only have the view state => compute the model state\n            const selectionStart = context.model.validateRange(context.coordinatesConverter.convertViewRangeToModelRange(viewState.selectionStart));\n            const position = context.model.validatePosition(context.coordinatesConverter.convertViewPositionToModelPosition(viewState.position));\n            modelState = new SingleCursorState(selectionStart, viewState.selectionStartKind, viewState.selectionStartLeftoverVisibleColumns, position, viewState.leftoverVisibleColumns);\n        }\n        else {\n            // Validate new model state\n            const selectionStart = context.model.validateRange(modelState.selectionStart);\n            const selectionStartLeftoverVisibleColumns = modelState.selectionStart.equalsRange(selectionStart) ? modelState.selectionStartLeftoverVisibleColumns : 0;\n            const position = context.model.validatePosition(modelState.position);\n            const leftoverVisibleColumns = modelState.position.equals(position) ? modelState.leftoverVisibleColumns : 0;\n            modelState = new SingleCursorState(selectionStart, modelState.selectionStartKind, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns);\n        }\n        if (!viewState) {\n            // We only have the model state => compute the view state\n            const viewSelectionStart1 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.startLineNumber, modelState.selectionStart.startColumn));\n            const viewSelectionStart2 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.endLineNumber, modelState.selectionStart.endColumn));\n            const viewSelectionStart = new Range(viewSelectionStart1.lineNumber, viewSelectionStart1.column, viewSelectionStart2.lineNumber, viewSelectionStart2.column);\n            const viewPosition = context.coordinatesConverter.convertModelPositionToViewPosition(modelState.position);\n            viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartKind, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n        }\n        else {\n            // Validate new view state\n            const viewSelectionStart = context.coordinatesConverter.validateViewRange(viewState.selectionStart, modelState.selectionStart);\n            const viewPosition = context.coordinatesConverter.validateViewPosition(viewState.position, modelState.position);\n            viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartKind, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n        }\n        this.modelState = modelState;\n        this.viewState = viewState;\n        this._updateTrackedRange(context);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { compareBy, findLastMaxBy, findMinBy } from '../../../base/common/arrays.js';\nimport { CursorState } from '../cursorCommon.js';\nimport { Cursor } from './oneCursor.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nexport class CursorCollection {\n    constructor(context) {\n        this.context = context;\n        this.cursors = [new Cursor(context)];\n        this.lastAddedCursorIndex = 0;\n    }\n    dispose() {\n        for (const cursor of this.cursors) {\n            cursor.dispose(this.context);\n        }\n    }\n    startTrackingSelections() {\n        for (const cursor of this.cursors) {\n            cursor.startTrackingSelection(this.context);\n        }\n    }\n    stopTrackingSelections() {\n        for (const cursor of this.cursors) {\n            cursor.stopTrackingSelection(this.context);\n        }\n    }\n    updateContext(context) {\n        this.context = context;\n    }\n    ensureValidState() {\n        for (const cursor of this.cursors) {\n            cursor.ensureValidState(this.context);\n        }\n    }\n    readSelectionFromMarkers() {\n        return this.cursors.map(c => c.readSelectionFromMarkers(this.context));\n    }\n    getAll() {\n        return this.cursors.map(c => c.asCursorState());\n    }\n    getViewPositions() {\n        return this.cursors.map(c => c.viewState.position);\n    }\n    getTopMostViewPosition() {\n        return findMinBy(this.cursors, compareBy(c => c.viewState.position, Position.compare)).viewState.position;\n    }\n    getBottomMostViewPosition() {\n        return findLastMaxBy(this.cursors, compareBy(c => c.viewState.position, Position.compare)).viewState.position;\n    }\n    getSelections() {\n        return this.cursors.map(c => c.modelState.selection);\n    }\n    getViewSelections() {\n        return this.cursors.map(c => c.viewState.selection);\n    }\n    setSelections(selections) {\n        this.setStates(CursorState.fromModelSelections(selections));\n    }\n    getPrimaryCursor() {\n        return this.cursors[0].asCursorState();\n    }\n    setStates(states) {\n        if (states === null) {\n            return;\n        }\n        this.cursors[0].setState(this.context, states[0].modelState, states[0].viewState);\n        this._setSecondaryStates(states.slice(1));\n    }\n    /**\n     * Creates or disposes secondary cursors as necessary to match the number of `secondarySelections`.\n     */\n    _setSecondaryStates(secondaryStates) {\n        const secondaryCursorsLength = this.cursors.length - 1;\n        const secondaryStatesLength = secondaryStates.length;\n        if (secondaryCursorsLength < secondaryStatesLength) {\n            const createCnt = secondaryStatesLength - secondaryCursorsLength;\n            for (let i = 0; i < createCnt; i++) {\n                this._addSecondaryCursor();\n            }\n        }\n        else if (secondaryCursorsLength > secondaryStatesLength) {\n            const removeCnt = secondaryCursorsLength - secondaryStatesLength;\n            for (let i = 0; i < removeCnt; i++) {\n                this._removeSecondaryCursor(this.cursors.length - 2);\n            }\n        }\n        for (let i = 0; i < secondaryStatesLength; i++) {\n            this.cursors[i + 1].setState(this.context, secondaryStates[i].modelState, secondaryStates[i].viewState);\n        }\n    }\n    killSecondaryCursors() {\n        this._setSecondaryStates([]);\n    }\n    _addSecondaryCursor() {\n        this.cursors.push(new Cursor(this.context));\n        this.lastAddedCursorIndex = this.cursors.length - 1;\n    }\n    getLastAddedCursorIndex() {\n        if (this.cursors.length === 1 || this.lastAddedCursorIndex === 0) {\n            return 0;\n        }\n        return this.lastAddedCursorIndex;\n    }\n    _removeSecondaryCursor(removeIndex) {\n        if (this.lastAddedCursorIndex >= removeIndex + 1) {\n            this.lastAddedCursorIndex--;\n        }\n        this.cursors[removeIndex + 1].dispose(this.context);\n        this.cursors.splice(removeIndex + 1, 1);\n    }\n    normalize() {\n        if (this.cursors.length === 1) {\n            return;\n        }\n        const cursors = this.cursors.slice(0);\n        const sortedCursors = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            sortedCursors.push({\n                index: i,\n                selection: cursors[i].modelState.selection,\n            });\n        }\n        sortedCursors.sort(compareBy(s => s.selection, Range.compareRangesUsingStarts));\n        for (let sortedCursorIndex = 0; sortedCursorIndex < sortedCursors.length - 1; sortedCursorIndex++) {\n            const current = sortedCursors[sortedCursorIndex];\n            const next = sortedCursors[sortedCursorIndex + 1];\n            const currentSelection = current.selection;\n            const nextSelection = next.selection;\n            if (!this.context.cursorConfig.multiCursorMergeOverlapping) {\n                continue;\n            }\n            let shouldMergeCursors;\n            if (nextSelection.isEmpty() || currentSelection.isEmpty()) {\n                // Merge touching cursors if one of them is collapsed\n                shouldMergeCursors = nextSelection.getStartPosition().isBeforeOrEqual(currentSelection.getEndPosition());\n            }\n            else {\n                // Merge only overlapping cursors (i.e. allow touching ranges)\n                shouldMergeCursors = nextSelection.getStartPosition().isBefore(currentSelection.getEndPosition());\n            }\n            if (shouldMergeCursors) {\n                const winnerSortedCursorIndex = current.index < next.index ? sortedCursorIndex : sortedCursorIndex + 1;\n                const looserSortedCursorIndex = current.index < next.index ? sortedCursorIndex + 1 : sortedCursorIndex;\n                const looserIndex = sortedCursors[looserSortedCursorIndex].index;\n                const winnerIndex = sortedCursors[winnerSortedCursorIndex].index;\n                const looserSelection = sortedCursors[looserSortedCursorIndex].selection;\n                const winnerSelection = sortedCursors[winnerSortedCursorIndex].selection;\n                if (!looserSelection.equalsSelection(winnerSelection)) {\n                    const resultingRange = looserSelection.plusRange(winnerSelection);\n                    const looserSelectionIsLTR = (looserSelection.selectionStartLineNumber === looserSelection.startLineNumber && looserSelection.selectionStartColumn === looserSelection.startColumn);\n                    const winnerSelectionIsLTR = (winnerSelection.selectionStartLineNumber === winnerSelection.startLineNumber && winnerSelection.selectionStartColumn === winnerSelection.startColumn);\n                    // Give more importance to the last added cursor (think Ctrl-dragging + hitting another cursor)\n                    let resultingSelectionIsLTR;\n                    if (looserIndex === this.lastAddedCursorIndex) {\n                        resultingSelectionIsLTR = looserSelectionIsLTR;\n                        this.lastAddedCursorIndex = winnerIndex;\n                    }\n                    else {\n                        // Winner takes it all\n                        resultingSelectionIsLTR = winnerSelectionIsLTR;\n                    }\n                    let resultingSelection;\n                    if (resultingSelectionIsLTR) {\n                        resultingSelection = new Selection(resultingRange.startLineNumber, resultingRange.startColumn, resultingRange.endLineNumber, resultingRange.endColumn);\n                    }\n                    else {\n                        resultingSelection = new Selection(resultingRange.endLineNumber, resultingRange.endColumn, resultingRange.startLineNumber, resultingRange.startColumn);\n                    }\n                    sortedCursors[winnerSortedCursorIndex].selection = resultingSelection;\n                    const resultingState = CursorState.fromModelSelection(resultingSelection);\n                    cursors[winnerIndex].setState(this.context, resultingState.modelState, resultingState.viewState);\n                }\n                for (const sortedCursor of sortedCursors) {\n                    if (sortedCursor.index > looserIndex) {\n                        sortedCursor.index--;\n                    }\n                }\n                cursors.splice(looserIndex, 1);\n                sortedCursors.splice(looserSortedCursorIndex, 1);\n                this._removeSecondaryCursor(looserIndex - 1);\n                sortedCursorIndex--;\n            }\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class CursorContext {\n    constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n        this._cursorContextBrand = undefined;\n        this.model = model;\n        this.viewModel = viewModel;\n        this.coordinatesConverter = coordinatesConverter;\n        this.cursorConfig = cursorConfig;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorCollection } from './cursorCollection.js';\nimport { CursorState, EditOperationResult } from '../cursorCommon.js';\nimport { CursorContext } from './cursorContext.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { CompositionOutcome, TypeOperations, TypeWithAutoClosingCommand } from './cursorTypeOperations.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ModelInjectedTextChangedEvent } from '../textModelEvents.js';\nimport { ViewCursorStateChangedEvent, ViewRevealRangeRequestEvent } from '../viewEvents.js';\nimport { dispose, Disposable } from '../../../base/common/lifecycle.js';\nimport { CursorStateChangedEvent } from '../viewModelEventDispatcher.js';\nexport class CursorsController extends Disposable {\n    constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n        super();\n        this._model = model;\n        this._knownModelVersionId = this._model.getVersionId();\n        this._viewModel = viewModel;\n        this._coordinatesConverter = coordinatesConverter;\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors = new CursorCollection(this.context);\n        this._hasFocus = false;\n        this._isHandling = false;\n        this._compositionState = null;\n        this._columnSelectData = null;\n        this._autoClosedActions = [];\n        this._prevEditOperationType = 0 /* EditOperationType.Other */;\n    }\n    dispose() {\n        this._cursors.dispose();\n        this._autoClosedActions = dispose(this._autoClosedActions);\n        super.dispose();\n    }\n    updateConfiguration(cursorConfig) {\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors.updateContext(this.context);\n    }\n    onLineMappingChanged(eventsCollector) {\n        if (this._knownModelVersionId !== this._model.getVersionId()) {\n            // There are model change events that I didn't yet receive.\n            //\n            // This can happen when editing the model, and the view model receives the change events first,\n            // and the view model emits line mapping changed events, all before the cursor gets a chance to\n            // recover from markers.\n            //\n            // The model change listener above will be called soon and we'll ensure a valid cursor state there.\n            return;\n        }\n        // Ensure valid state\n        this.setStates(eventsCollector, 'viewModel', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n    }\n    _validateAutoClosedActions() {\n        if (this._autoClosedActions.length > 0) {\n            const selections = this._cursors.getSelections();\n            for (let i = 0; i < this._autoClosedActions.length; i++) {\n                const autoClosedAction = this._autoClosedActions[i];\n                if (!autoClosedAction.isValid(selections)) {\n                    autoClosedAction.dispose();\n                    this._autoClosedActions.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n    }\n    // ------ some getters/setters\n    getPrimaryCursorState() {\n        return this._cursors.getPrimaryCursor();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursors.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursors.getAll();\n    }\n    setStates(eventsCollector, source, reason, states) {\n        let reachedMaxCursorCount = false;\n        const multiCursorLimit = this.context.cursorConfig.multiCursorLimit;\n        if (states !== null && states.length > multiCursorLimit) {\n            states = states.slice(0, multiCursorLimit);\n            reachedMaxCursorCount = true;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.setStates(states);\n        this._cursors.normalize();\n        this._columnSelectData = null;\n        this._validateAutoClosedActions();\n        return this._emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount);\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._columnSelectData = columnSelectData;\n    }\n    revealPrimary(eventsCollector, source, minimalReveal, verticalType, revealHorizontal, scrollType) {\n        const viewPositions = this._cursors.getViewPositions();\n        let revealViewRange = null;\n        let revealViewSelections = null;\n        if (viewPositions.length > 1) {\n            revealViewSelections = this._cursors.getViewSelections();\n        }\n        else {\n            revealViewRange = Range.fromPositions(viewPositions[0], viewPositions[0]);\n        }\n        eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, revealViewRange, revealViewSelections, verticalType, revealHorizontal, scrollType));\n    }\n    saveState() {\n        const result = [];\n        const selections = this._cursors.getSelections();\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            result.push({\n                inSelectionMode: !selection.isEmpty(),\n                selectionStart: {\n                    lineNumber: selection.selectionStartLineNumber,\n                    column: selection.selectionStartColumn,\n                },\n                position: {\n                    lineNumber: selection.positionLineNumber,\n                    column: selection.positionColumn,\n                }\n            });\n        }\n        return result;\n    }\n    restoreState(eventsCollector, states) {\n        const desiredSelections = [];\n        for (let i = 0, len = states.length; i < len; i++) {\n            const state = states[i];\n            let positionLineNumber = 1;\n            let positionColumn = 1;\n            // Avoid missing properties on the literal\n            if (state.position && state.position.lineNumber) {\n                positionLineNumber = state.position.lineNumber;\n            }\n            if (state.position && state.position.column) {\n                positionColumn = state.position.column;\n            }\n            let selectionStartLineNumber = positionLineNumber;\n            let selectionStartColumn = positionColumn;\n            // Avoid missing properties on the literal\n            if (state.selectionStart && state.selectionStart.lineNumber) {\n                selectionStartLineNumber = state.selectionStart.lineNumber;\n            }\n            if (state.selectionStart && state.selectionStart.column) {\n                selectionStartColumn = state.selectionStart.column;\n            }\n            desiredSelections.push({\n                selectionStartLineNumber: selectionStartLineNumber,\n                selectionStartColumn: selectionStartColumn,\n                positionLineNumber: positionLineNumber,\n                positionColumn: positionColumn\n            });\n        }\n        this.setStates(eventsCollector, 'restoreState', 0 /* CursorChangeReason.NotSet */, CursorState.fromModelSelections(desiredSelections));\n        this.revealPrimary(eventsCollector, 'restoreState', false, 0 /* VerticalRevealType.Simple */, true, 1 /* editorCommon.ScrollType.Immediate */);\n    }\n    onModelContentChanged(eventsCollector, event) {\n        if (event instanceof ModelInjectedTextChangedEvent) {\n            // If injected texts change, the view positions of all cursors need to be updated.\n            if (this._isHandling) {\n                // The view positions will be updated when handling finishes\n                return;\n            }\n            // setStates might remove markers, which could trigger a decoration change.\n            // If there are injected text decorations for that line, `onModelContentChanged` is emitted again\n            // and an endless recursion happens.\n            // _isHandling prevents that.\n            this._isHandling = true;\n            try {\n                this.setStates(eventsCollector, 'modelChange', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n            }\n            finally {\n                this._isHandling = false;\n            }\n        }\n        else {\n            const e = event.rawContentChangedEvent;\n            this._knownModelVersionId = e.versionId;\n            if (this._isHandling) {\n                return;\n            }\n            const hadFlushEvent = e.containsEvent(1 /* RawContentChangedType.Flush */);\n            this._prevEditOperationType = 0 /* EditOperationType.Other */;\n            if (hadFlushEvent) {\n                // a model.setValue() was called\n                this._cursors.dispose();\n                this._cursors = new CursorCollection(this.context);\n                this._validateAutoClosedActions();\n                this._emitStateChangedIfNecessary(eventsCollector, 'model', 1 /* CursorChangeReason.ContentFlush */, null, false);\n            }\n            else {\n                if (this._hasFocus && e.resultingSelection && e.resultingSelection.length > 0) {\n                    const cursorState = CursorState.fromModelSelections(e.resultingSelection);\n                    if (this.setStates(eventsCollector, 'modelChange', e.isUndoing ? 5 /* CursorChangeReason.Undo */ : e.isRedoing ? 6 /* CursorChangeReason.Redo */ : 2 /* CursorChangeReason.RecoverFromMarkers */, cursorState)) {\n                        this.revealPrimary(eventsCollector, 'modelChange', false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n                    }\n                }\n                else {\n                    const selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\n                    this.setStates(eventsCollector, 'modelChange', 2 /* CursorChangeReason.RecoverFromMarkers */, CursorState.fromModelSelections(selectionsFromMarkers));\n                }\n            }\n        }\n    }\n    getSelection() {\n        return this._cursors.getPrimaryCursor().modelState.selection;\n    }\n    getTopMostViewPosition() {\n        return this._cursors.getTopMostViewPosition();\n    }\n    getBottomMostViewPosition() {\n        return this._cursors.getBottomMostViewPosition();\n    }\n    getCursorColumnSelectData() {\n        if (this._columnSelectData) {\n            return this._columnSelectData;\n        }\n        const primaryCursor = this._cursors.getPrimaryCursor();\n        const viewSelectionStart = primaryCursor.viewState.selectionStart.getStartPosition();\n        const viewPosition = primaryCursor.viewState.position;\n        return {\n            isReal: false,\n            fromViewLineNumber: viewSelectionStart.lineNumber,\n            fromViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewSelectionStart),\n            toViewLineNumber: viewPosition.lineNumber,\n            toViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewPosition),\n        };\n    }\n    getSelections() {\n        return this._cursors.getSelections();\n    }\n    setSelections(eventsCollector, source, selections, reason) {\n        this.setStates(eventsCollector, source, reason, CursorState.fromModelSelections(selections));\n    }\n    getPrevEditOperationType() {\n        return this._prevEditOperationType;\n    }\n    setPrevEditOperationType(type) {\n        this._prevEditOperationType = type;\n    }\n    // ------ auxiliary handling logic\n    _pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges) {\n        const autoClosedCharactersDeltaDecorations = [];\n        const autoClosedEnclosingDeltaDecorations = [];\n        for (let i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {\n            autoClosedCharactersDeltaDecorations.push({\n                range: autoClosedCharactersRanges[i],\n                options: {\n                    description: 'auto-closed-character',\n                    inlineClassName: 'auto-closed-character',\n                    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n                }\n            });\n            autoClosedEnclosingDeltaDecorations.push({\n                range: autoClosedEnclosingRanges[i],\n                options: {\n                    description: 'auto-closed-enclosing',\n                    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n                }\n            });\n        }\n        const autoClosedCharactersDecorations = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);\n        const autoClosedEnclosingDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);\n        this._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations));\n    }\n    _executeEditOperation(opResult) {\n        if (!opResult) {\n            // Nothing to execute\n            return;\n        }\n        if (opResult.shouldPushStackElementBefore) {\n            this._model.pushStackElement();\n        }\n        const result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);\n        if (result) {\n            // The commands were applied correctly\n            this._interpretCommandResult(result);\n            // Check for auto-closing closed characters\n            const autoClosedCharactersRanges = [];\n            const autoClosedEnclosingRanges = [];\n            for (let i = 0; i < opResult.commands.length; i++) {\n                const command = opResult.commands[i];\n                if (command instanceof TypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange) {\n                    autoClosedCharactersRanges.push(command.closeCharacterRange);\n                    autoClosedEnclosingRanges.push(command.enclosingRange);\n                }\n            }\n            if (autoClosedCharactersRanges.length > 0) {\n                this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n            }\n            this._prevEditOperationType = opResult.type;\n        }\n        if (opResult.shouldPushStackElementAfter) {\n            this._model.pushStackElement();\n        }\n    }\n    _interpretCommandResult(cursorState) {\n        if (!cursorState || cursorState.length === 0) {\n            cursorState = this._cursors.readSelectionFromMarkers();\n        }\n        this._columnSelectData = null;\n        this._cursors.setSelections(cursorState);\n        this._cursors.normalize();\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- emitting events\n    _emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount) {\n        const newState = CursorModelState.from(this._model, this);\n        if (newState.equals(oldState)) {\n            return false;\n        }\n        const selections = this._cursors.getSelections();\n        const viewSelections = this._cursors.getViewSelections();\n        // Let the view get the event first.\n        eventsCollector.emitViewEvent(new ViewCursorStateChangedEvent(viewSelections, selections, reason));\n        // Only after the view has been notified, let the rest of the world know...\n        if (!oldState\n            || oldState.cursorState.length !== newState.cursorState.length\n            || newState.cursorState.some((newCursorState, i) => !newCursorState.modelState.equals(oldState.cursorState[i].modelState))) {\n            const oldSelections = oldState ? oldState.cursorState.map(s => s.modelState.selection) : null;\n            const oldModelVersionId = oldState ? oldState.modelVersionId : 0;\n            eventsCollector.emitOutgoingEvent(new CursorStateChangedEvent(oldSelections, selections, oldModelVersionId, newState.modelVersionId, source || 'keyboard', reason, reachedMaxCursorCount));\n        }\n        return true;\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- handlers beyond this point\n    _findAutoClosingPairs(edits) {\n        if (!edits.length) {\n            return null;\n        }\n        const indices = [];\n        for (let i = 0, len = edits.length; i < len; i++) {\n            const edit = edits[i];\n            if (!edit.text || edit.text.indexOf('\\n') >= 0) {\n                return null;\n            }\n            const m = edit.text.match(/([)\\]}>'\"`])([^)\\]}>'\"`]*)$/);\n            if (!m) {\n                return null;\n            }\n            const closeChar = m[1];\n            const autoClosingPairsCandidates = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(closeChar);\n            if (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {\n                return null;\n            }\n            const openChar = autoClosingPairsCandidates[0].open;\n            const closeCharIndex = edit.text.length - m[2].length - 1;\n            const openCharIndex = edit.text.lastIndexOf(openChar, closeCharIndex - 1);\n            if (openCharIndex === -1) {\n                return null;\n            }\n            indices.push([openCharIndex, closeCharIndex]);\n        }\n        return indices;\n    }\n    executeEdits(eventsCollector, source, edits, cursorStateComputer) {\n        let autoClosingIndices = null;\n        if (source === 'snippet') {\n            autoClosingIndices = this._findAutoClosingPairs(edits);\n        }\n        if (autoClosingIndices) {\n            edits[0]._isTracked = true;\n        }\n        const autoClosedCharactersRanges = [];\n        const autoClosedEnclosingRanges = [];\n        const selections = this._model.pushEditOperations(this.getSelections(), edits, (undoEdits) => {\n            if (autoClosingIndices) {\n                for (let i = 0, len = autoClosingIndices.length; i < len; i++) {\n                    const [openCharInnerIndex, closeCharInnerIndex] = autoClosingIndices[i];\n                    const undoEdit = undoEdits[i];\n                    const lineNumber = undoEdit.range.startLineNumber;\n                    const openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;\n                    const closeCharIndex = undoEdit.range.startColumn - 1 + closeCharInnerIndex;\n                    autoClosedCharactersRanges.push(new Range(lineNumber, closeCharIndex + 1, lineNumber, closeCharIndex + 2));\n                    autoClosedEnclosingRanges.push(new Range(lineNumber, openCharIndex + 1, lineNumber, closeCharIndex + 2));\n                }\n            }\n            const selections = cursorStateComputer(undoEdits);\n            if (selections) {\n                // Don't recover the selection from markers because\n                // we know what it should be.\n                this._isHandling = true;\n            }\n            return selections;\n        });\n        if (selections) {\n            this._isHandling = false;\n            this.setSelections(eventsCollector, source, selections, 0 /* CursorChangeReason.NotSet */);\n        }\n        if (autoClosedCharactersRanges.length > 0) {\n            this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n        }\n    }\n    _executeEdit(callback, eventsCollector, source, cursorChangeReason = 0 /* CursorChangeReason.NotSet */) {\n        if (this.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            return;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.stopTrackingSelections();\n        this._isHandling = true;\n        try {\n            this._cursors.ensureValidState();\n            callback();\n        }\n        catch (err) {\n            onUnexpectedError(err);\n        }\n        this._isHandling = false;\n        this._cursors.startTrackingSelections();\n        this._validateAutoClosedActions();\n        if (this._emitStateChangedIfNecessary(eventsCollector, source, cursorChangeReason, oldState, false)) {\n            this.revealPrimary(eventsCollector, source, false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n        }\n    }\n    getAutoClosedCharacters() {\n        return AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\n    }\n    startComposition(eventsCollector) {\n        this._compositionState = new CompositionState(this._model, this.getSelections());\n    }\n    endComposition(eventsCollector, source) {\n        const compositionOutcome = this._compositionState ? this._compositionState.deduceOutcome(this._model, this.getSelections()) : null;\n        this._compositionState = null;\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // composition finishes, let's check if we need to auto complete if necessary.\n                this._executeEditOperation(TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, compositionOutcome, this.getSelections(), this.getAutoClosedCharacters()));\n            }\n        }, eventsCollector, source);\n    }\n    type(eventsCollector, text, source) {\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // If this event is coming straight from the keyboard, look for electric characters and enter\n                const len = text.length;\n                let offset = 0;\n                while (offset < len) {\n                    const charLength = strings.nextCharLength(text, offset);\n                    const chr = text.substr(offset, charLength);\n                    // Here we must interpret each typed character individually\n                    this._executeEditOperation(TypeOperations.typeWithInterceptors(!!this._compositionState, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), chr));\n                    offset += charLength;\n                }\n            }\n            else {\n                this._executeEditOperation(TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text));\n            }\n        }, eventsCollector, source);\n    }\n    compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        if (text.length === 0 && replacePrevCharCnt === 0 && replaceNextCharCnt === 0) {\n            // this edit is a no-op\n            if (positionDelta !== 0) {\n                // but it still wants to move the cursor\n                const newSelections = this.getSelections().map(selection => {\n                    const position = selection.getPosition();\n                    return new Selection(position.lineNumber, position.column + positionDelta, position.lineNumber, position.column + positionDelta);\n                });\n                this.setSelections(eventsCollector, source, newSelections, 0 /* CursorChangeReason.NotSet */);\n            }\n            return;\n        }\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        }, eventsCollector, source);\n    }\n    paste(eventsCollector, text, pasteOnNewLine, multicursorText, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.paste(this.context.cursorConfig, this._model, this.getSelections(), text, pasteOnNewLine, multicursorText || []));\n        }, eventsCollector, source, 4 /* CursorChangeReason.Paste */);\n    }\n    cut(eventsCollector, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(DeleteOperations.cut(this.context.cursorConfig, this._model, this.getSelections()));\n        }, eventsCollector, source);\n    }\n    executeCommand(eventsCollector, command, source) {\n        this._executeEdit(() => {\n            this._cursors.killSecondaryCursors();\n            this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, [command], {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n    executeCommands(eventsCollector, commands, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n}\n/**\n * A snapshot of the cursor and the model state\n */\nclass CursorModelState {\n    static from(model, cursor) {\n        return new CursorModelState(model.getVersionId(), cursor.getCursorStates());\n    }\n    constructor(modelVersionId, cursorState) {\n        this.modelVersionId = modelVersionId;\n        this.cursorState = cursorState;\n    }\n    equals(other) {\n        if (!other) {\n            return false;\n        }\n        if (this.modelVersionId !== other.modelVersionId) {\n            return false;\n        }\n        if (this.cursorState.length !== other.cursorState.length) {\n            return false;\n        }\n        for (let i = 0, len = this.cursorState.length; i < len; i++) {\n            if (!this.cursorState[i].equals(other.cursorState[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass AutoClosedAction {\n    static getAllAutoClosedCharacters(autoClosedActions) {\n        let autoClosedCharacters = [];\n        for (const autoClosedAction of autoClosedActions) {\n            autoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());\n        }\n        return autoClosedCharacters;\n    }\n    constructor(model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations) {\n        this._model = model;\n        this._autoClosedCharactersDecorations = autoClosedCharactersDecorations;\n        this._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;\n    }\n    dispose() {\n        this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);\n        this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);\n    }\n    getAutoClosedCharactersRanges() {\n        const result = [];\n        for (let i = 0; i < this._autoClosedCharactersDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);\n            if (decorationRange) {\n                result.push(decorationRange);\n            }\n        }\n        return result;\n    }\n    isValid(selections) {\n        const enclosingRanges = [];\n        for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);\n            if (decorationRange) {\n                enclosingRanges.push(decorationRange);\n                if (decorationRange.startLineNumber !== decorationRange.endLineNumber) {\n                    // Stop tracking if the range becomes multiline...\n                    return false;\n                }\n            }\n        }\n        enclosingRanges.sort(Range.compareRangesUsingStarts);\n        selections.sort(Range.compareRangesUsingStarts);\n        for (let i = 0; i < selections.length; i++) {\n            if (i >= enclosingRanges.length) {\n                return false;\n            }\n            if (!enclosingRanges[i].strictContainsRange(selections[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass CommandExecutor {\n    static executeCommands(model, selectionsBefore, commands) {\n        const ctx = {\n            model: model,\n            selectionsBefore: selectionsBefore,\n            trackedRanges: [],\n            trackedRangesDirection: []\n        };\n        const result = this._innerExecuteCommands(ctx, commands);\n        for (let i = 0, len = ctx.trackedRanges.length; i < len; i++) {\n            ctx.model._setTrackedRange(ctx.trackedRanges[i], null, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n        }\n        return result;\n    }\n    static _innerExecuteCommands(ctx, commands) {\n        if (this._arrayIsEmpty(commands)) {\n            return null;\n        }\n        const commandsData = this._getEditOperations(ctx, commands);\n        if (commandsData.operations.length === 0) {\n            return null;\n        }\n        const rawOperations = commandsData.operations;\n        const loserCursorsMap = this._getLoserCursorMap(rawOperations);\n        if (loserCursorsMap.hasOwnProperty('0')) {\n            // These commands are very messed up\n            console.warn('Ignoring commands');\n            return null;\n        }\n        // Remove operations belonging to losing cursors\n        const filteredOperations = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {\n                filteredOperations.push(rawOperations[i]);\n            }\n        }\n        // TODO@Alex: find a better way to do this.\n        // give the hint that edit operations are tracked to the model\n        if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\n            filteredOperations[0]._isTracked = true;\n        }\n        let selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, (inverseEditOperations) => {\n            const groupedInverseEditOperations = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                groupedInverseEditOperations[i] = [];\n            }\n            for (const op of inverseEditOperations) {\n                if (!op.identifier) {\n                    // perhaps auto whitespace trim edits\n                    continue;\n                }\n                groupedInverseEditOperations[op.identifier.major].push(op);\n            }\n            const minorBasedSorter = (a, b) => {\n                return a.identifier.minor - b.identifier.minor;\n            };\n            const cursorSelections = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                if (groupedInverseEditOperations[i].length > 0) {\n                    groupedInverseEditOperations[i].sort(minorBasedSorter);\n                    cursorSelections[i] = commands[i].computeCursorState(ctx.model, {\n                        getInverseEditOperations: () => {\n                            return groupedInverseEditOperations[i];\n                        },\n                        getTrackedSelection: (id) => {\n                            const idx = parseInt(id, 10);\n                            const range = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);\n                            if (ctx.trackedRangesDirection[idx] === 0 /* SelectionDirection.LTR */) {\n                                return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n                            }\n                            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n                        }\n                    });\n                }\n                else {\n                    cursorSelections[i] = ctx.selectionsBefore[i];\n                }\n            }\n            return cursorSelections;\n        });\n        if (!selectionsAfter) {\n            selectionsAfter = ctx.selectionsBefore;\n        }\n        // Extract losing cursors\n        const losingCursors = [];\n        for (const losingCursorIndex in loserCursorsMap) {\n            if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\n                losingCursors.push(parseInt(losingCursorIndex, 10));\n            }\n        }\n        // Sort losing cursors descending\n        losingCursors.sort((a, b) => {\n            return b - a;\n        });\n        // Remove losing cursors\n        for (const losingCursor of losingCursors) {\n            selectionsAfter.splice(losingCursor, 1);\n        }\n        return selectionsAfter;\n    }\n    static _arrayIsEmpty(commands) {\n        for (let i = 0, len = commands.length; i < len; i++) {\n            if (commands[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _getEditOperations(ctx, commands) {\n        let operations = [];\n        let hadTrackedEditOperation = false;\n        for (let i = 0, len = commands.length; i < len; i++) {\n            const command = commands[i];\n            if (command) {\n                const r = this._getEditOperationsFromCommand(ctx, i, command);\n                operations = operations.concat(r.operations);\n                hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\n            }\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getEditOperationsFromCommand(ctx, majorIdentifier, command) {\n        // This method acts as a transaction, if the command fails\n        // everything it has done is ignored\n        const operations = [];\n        let operationMinor = 0;\n        const addEditOperation = (range, text, forceMoveMarkers = false) => {\n            if (Range.isEmpty(range) && text === '') {\n                // This command wants to add a no-op => no thank you\n                return;\n            }\n            operations.push({\n                identifier: {\n                    major: majorIdentifier,\n                    minor: operationMinor++\n                },\n                range: range,\n                text: text,\n                forceMoveMarkers: forceMoveMarkers,\n                isAutoWhitespaceEdit: command.insertsAutoWhitespace\n            });\n        };\n        let hadTrackedEditOperation = false;\n        const addTrackedEditOperation = (selection, text, forceMoveMarkers) => {\n            hadTrackedEditOperation = true;\n            addEditOperation(selection, text, forceMoveMarkers);\n        };\n        const trackSelection = (_selection, trackPreviousOnEmpty) => {\n            const selection = Selection.liftSelection(_selection);\n            let stickiness;\n            if (selection.isEmpty()) {\n                if (typeof trackPreviousOnEmpty === 'boolean') {\n                    if (trackPreviousOnEmpty) {\n                        stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n                else {\n                    // Try to lock it with surrounding text\n                    const maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn === maxLineColumn) {\n                        stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n            }\n            else {\n                stickiness = 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */;\n            }\n            const l = ctx.trackedRanges.length;\n            const id = ctx.model._setTrackedRange(null, selection, stickiness);\n            ctx.trackedRanges[l] = id;\n            ctx.trackedRangesDirection[l] = selection.getDirection();\n            return l.toString();\n        };\n        const editOperationBuilder = {\n            addEditOperation: addEditOperation,\n            addTrackedEditOperation: addTrackedEditOperation,\n            trackSelection: trackSelection\n        };\n        try {\n            command.getEditOperations(ctx.model, editOperationBuilder);\n        }\n        catch (e) {\n            // TODO@Alex use notification service if this should be user facing\n            // e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\n            onUnexpectedError(e);\n            return {\n                operations: [],\n                hadTrackedEditOperation: false\n            };\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getLoserCursorMap(operations) {\n        // This is destructive on the array\n        operations = operations.slice(0);\n        // Sort operations with last one first\n        operations.sort((a, b) => {\n            // Note the minus!\n            return -(Range.compareRangesUsingEnds(a.range, b.range));\n        });\n        // Operations can not overlap!\n        const loserCursorsMap = {};\n        for (let i = 1; i < operations.length; i++) {\n            const previousOp = operations[i - 1];\n            const currentOp = operations[i];\n            if (Range.getStartPosition(previousOp.range).isBefore(Range.getEndPosition(currentOp.range))) {\n                let loserMajor;\n                if (previousOp.identifier.major > currentOp.identifier.major) {\n                    // previousOp loses the battle\n                    loserMajor = previousOp.identifier.major;\n                }\n                else {\n                    loserMajor = currentOp.identifier.major;\n                }\n                loserCursorsMap[loserMajor.toString()] = true;\n                for (let j = 0; j < operations.length; j++) {\n                    if (operations[j].identifier.major === loserMajor) {\n                        operations.splice(j, 1);\n                        if (j < i) {\n                            i--;\n                        }\n                        j--;\n                    }\n                }\n                if (i > 0) {\n                    i--;\n                }\n            }\n        }\n        return loserCursorsMap;\n    }\n}\nclass CompositionLineState {\n    constructor(text, startSelection, endSelection) {\n        this.text = text;\n        this.startSelection = startSelection;\n        this.endSelection = endSelection;\n    }\n}\nclass CompositionState {\n    static _capture(textModel, selections) {\n        const result = [];\n        for (const selection of selections) {\n            if (selection.startLineNumber !== selection.endLineNumber) {\n                return null;\n            }\n            result.push(new CompositionLineState(textModel.getLineContent(selection.startLineNumber), selection.startColumn - 1, selection.endColumn - 1));\n        }\n        return result;\n    }\n    constructor(textModel, selections) {\n        this._original = CompositionState._capture(textModel, selections);\n    }\n    /**\n     * Returns the inserted text during this composition.\n     * If the composition resulted in existing text being changed (i.e. not a pure insertion) it returns null.\n     */\n    deduceOutcome(textModel, selections) {\n        if (!this._original) {\n            return null;\n        }\n        const current = CompositionState._capture(textModel, selections);\n        if (!current) {\n            return null;\n        }\n        if (this._original.length !== current.length) {\n            return null;\n        }\n        const result = [];\n        for (let i = 0, len = this._original.length; i < len; i++) {\n            result.push(CompositionState._deduceOutcome(this._original[i], current[i]));\n        }\n        return result;\n    }\n    static _deduceOutcome(original, current) {\n        const commonPrefix = Math.min(original.startSelection, current.startSelection, strings.commonPrefixLength(original.text, current.text));\n        const commonSuffix = Math.min(original.text.length - original.endSelection, current.text.length - current.endSelection, strings.commonSuffixLength(original.text, current.text));\n        const deletedText = original.text.substring(commonPrefix, original.text.length - commonSuffix);\n        const insertedText = current.text.substring(commonPrefix, current.text.length - commonSuffix);\n        return new CompositionOutcome(deletedText, original.startSelection - commonPrefix, original.endSelection - commonPrefix, insertedText, current.startSelection - commonPrefix, current.endSelection - commonPrefix);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorColumns } from '../core/cursorColumns.js';\nexport class AtomicTabMoveOperations {\n    /**\n     * Get the visible column at the position. If we get to a non-whitespace character first\n     * or past the end of string then return -1.\n     *\n     * **Note** `position` and the return value are 0-based.\n     */\n    static whitespaceVisibleColumn(lineContent, position, tabSize) {\n        const lineLength = lineContent.length;\n        let visibleColumn = 0;\n        let prevTabStopPosition = -1;\n        let prevTabStopVisibleColumn = -1;\n        for (let i = 0; i < lineLength; i++) {\n            if (i === position) {\n                return [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn];\n            }\n            if (visibleColumn % tabSize === 0) {\n                prevTabStopPosition = i;\n                prevTabStopVisibleColumn = visibleColumn;\n            }\n            const chCode = lineContent.charCodeAt(i);\n            switch (chCode) {\n                case 32 /* CharCode.Space */:\n                    visibleColumn += 1;\n                    break;\n                case 9 /* CharCode.Tab */:\n                    // Skip to the next multiple of tabSize.\n                    visibleColumn = CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n                    break;\n                default:\n                    return [-1, -1, -1];\n            }\n        }\n        if (position === lineLength) {\n            return [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn];\n        }\n        return [-1, -1, -1];\n    }\n    /**\n     * Return the position that should result from a move left, right or to the\n     * nearest tab, if atomic tabs are enabled. Left and right are used for the\n     * arrow key movements, nearest is used for mouse selection. It returns\n     * -1 if atomic tabs are not relevant and you should fall back to normal\n     * behaviour.\n     *\n     * **Note**: `position` and the return value are 0-based.\n     */\n    static atomicPosition(lineContent, position, tabSize, direction) {\n        const lineLength = lineContent.length;\n        // Get the 0-based visible column corresponding to the position, or return\n        // -1 if it is not in the initial whitespace.\n        const [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn] = AtomicTabMoveOperations.whitespaceVisibleColumn(lineContent, position, tabSize);\n        if (visibleColumn === -1) {\n            return -1;\n        }\n        // Is the output left or right of the current position. The case for nearest\n        // where it is the same as the current position is handled in the switch.\n        let left;\n        switch (direction) {\n            case 0 /* Direction.Left */:\n                left = true;\n                break;\n            case 1 /* Direction.Right */:\n                left = false;\n                break;\n            case 2 /* Direction.Nearest */:\n                // The code below assumes the output position is either left or right\n                // of the input position. If it is the same, return immediately.\n                if (visibleColumn % tabSize === 0) {\n                    return position;\n                }\n                // Go to the nearest indentation.\n                left = visibleColumn % tabSize <= (tabSize / 2);\n                break;\n        }\n        // If going left, we can just use the info about the last tab stop position and\n        // last tab stop visible column that we computed in the first walk over the whitespace.\n        if (left) {\n            if (prevTabStopPosition === -1) {\n                return -1;\n            }\n            // If the direction is left, we need to keep scanning right to ensure\n            // that targetVisibleColumn + tabSize is before non-whitespace.\n            // This is so that when we press left at the end of a partial\n            // indentation it only goes one character. For example '      foo' with\n            // tabSize 4, should jump from position 6 to position 5, not 4.\n            let currentVisibleColumn = prevTabStopVisibleColumn;\n            for (let i = prevTabStopPosition; i < lineLength; ++i) {\n                if (currentVisibleColumn === prevTabStopVisibleColumn + tabSize) {\n                    // It is a full indentation.\n                    return prevTabStopPosition;\n                }\n                const chCode = lineContent.charCodeAt(i);\n                switch (chCode) {\n                    case 32 /* CharCode.Space */:\n                        currentVisibleColumn += 1;\n                        break;\n                    case 9 /* CharCode.Tab */:\n                        currentVisibleColumn = CursorColumns.nextRenderTabStop(currentVisibleColumn, tabSize);\n                        break;\n                    default:\n                        return -1;\n                }\n            }\n            if (currentVisibleColumn === prevTabStopVisibleColumn + tabSize) {\n                return prevTabStopPosition;\n            }\n            // It must have been a partial indentation.\n            return -1;\n        }\n        // We are going right.\n        const targetVisibleColumn = CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        // We can just continue from where whitespaceVisibleColumn got to.\n        let currentVisibleColumn = visibleColumn;\n        for (let i = position; i < lineLength; i++) {\n            if (currentVisibleColumn === targetVisibleColumn) {\n                return i;\n            }\n            const chCode = lineContent.charCodeAt(i);\n            switch (chCode) {\n                case 32 /* CharCode.Space */:\n                    currentVisibleColumn += 1;\n                    break;\n                case 9 /* CharCode.Tab */:\n                    currentVisibleColumn = CursorColumns.nextRenderTabStop(currentVisibleColumn, tabSize);\n                    break;\n                default:\n                    return -1;\n            }\n        }\n        // This condition handles when the target column is at the end of the line.\n        if (currentVisibleColumn === targetVisibleColumn) {\n            return lineLength;\n        }\n        return -1;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class ColumnSelection {\n    static columnSelect(config, model, fromLineNumber, fromVisibleColumn, toLineNumber, toVisibleColumn) {\n        const lineCount = Math.abs(toLineNumber - fromLineNumber) + 1;\n        const reversed = (fromLineNumber > toLineNumber);\n        const isRTL = (fromVisibleColumn > toVisibleColumn);\n        const isLTR = (fromVisibleColumn < toVisibleColumn);\n        const result = [];\n        // console.log(`fromVisibleColumn: ${fromVisibleColumn}, toVisibleColumn: ${toVisibleColumn}`);\n        for (let i = 0; i < lineCount; i++) {\n            const lineNumber = fromLineNumber + (reversed ? -i : i);\n            const startColumn = config.columnFromVisibleColumn(model, lineNumber, fromVisibleColumn);\n            const endColumn = config.columnFromVisibleColumn(model, lineNumber, toVisibleColumn);\n            const visibleStartColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, startColumn));\n            const visibleEndColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, endColumn));\n            // console.log(`lineNumber: ${lineNumber}: visibleStartColumn: ${visibleStartColumn}, visibleEndColumn: ${visibleEndColumn}`);\n            if (isLTR) {\n                if (visibleStartColumn > toVisibleColumn) {\n                    continue;\n                }\n                if (visibleEndColumn < fromVisibleColumn) {\n                    continue;\n                }\n            }\n            if (isRTL) {\n                if (visibleEndColumn > fromVisibleColumn) {\n                    continue;\n                }\n                if (visibleStartColumn < toVisibleColumn) {\n                    continue;\n                }\n            }\n            result.push(new SingleCursorState(new Range(lineNumber, startColumn, lineNumber, startColumn), 0 /* SelectionStartKind.Simple */, 0, new Position(lineNumber, endColumn), 0));\n        }\n        if (result.length === 0) {\n            // We are after all the lines, so add cursor at the end of each line\n            for (let i = 0; i < lineCount; i++) {\n                const lineNumber = fromLineNumber + (reversed ? -i : i);\n                const maxColumn = model.getLineMaxColumn(lineNumber);\n                result.push(new SingleCursorState(new Range(lineNumber, maxColumn, lineNumber, maxColumn), 0 /* SelectionStartKind.Simple */, 0, new Position(lineNumber, maxColumn), 0));\n            }\n        }\n        return {\n            viewStates: result,\n            reversed: reversed,\n            fromLineNumber: fromLineNumber,\n            fromVisualColumn: fromVisibleColumn,\n            toLineNumber: toLineNumber,\n            toVisualColumn: toVisibleColumn\n        };\n    }\n    static columnSelectLeft(config, model, prevColumnSelectData) {\n        let toViewVisualColumn = prevColumnSelectData.toViewVisualColumn;\n        if (toViewVisualColumn > 0) {\n            toViewVisualColumn--;\n        }\n        return ColumnSelection.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, prevColumnSelectData.toViewLineNumber, toViewVisualColumn);\n    }\n    static columnSelectRight(config, model, prevColumnSelectData) {\n        let maxVisualViewColumn = 0;\n        const minViewLineNumber = Math.min(prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.toViewLineNumber);\n        const maxViewLineNumber = Math.max(prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.toViewLineNumber);\n        for (let lineNumber = minViewLineNumber; lineNumber <= maxViewLineNumber; lineNumber++) {\n            const lineMaxViewColumn = model.getLineMaxColumn(lineNumber);\n            const lineMaxVisualViewColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, lineMaxViewColumn));\n            maxVisualViewColumn = Math.max(maxVisualViewColumn, lineMaxVisualViewColumn);\n        }\n        let toViewVisualColumn = prevColumnSelectData.toViewVisualColumn;\n        if (toViewVisualColumn < maxVisualViewColumn) {\n            toViewVisualColumn++;\n        }\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, prevColumnSelectData.toViewLineNumber, toViewVisualColumn);\n    }\n    static columnSelectUp(config, model, prevColumnSelectData, isPaged) {\n        const linesCount = isPaged ? config.pageSize : 1;\n        const toViewLineNumber = Math.max(1, prevColumnSelectData.toViewLineNumber - linesCount);\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, toViewLineNumber, prevColumnSelectData.toViewVisualColumn);\n    }\n    static columnSelectDown(config, model, prevColumnSelectData, isPaged) {\n        const linesCount = isPaged ? config.pageSize : 1;\n        const toViewLineNumber = Math.min(model.getLineCount(), prevColumnSelectData.toViewLineNumber + linesCount);\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, toViewLineNumber, prevColumnSelectData.toViewVisualColumn);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand } from '../commands/replaceCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nexport class DeleteOperations {\n    static deleteRight(prevEditOperationType, config, model, selections) {\n        const commands = [];\n        let shouldPushStackElementBefore = (prevEditOperationType !== 3 /* EditOperationType.DeletingRight */);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            let deleteSelection = selection;\n            if (deleteSelection.isEmpty()) {\n                const position = selection.getPosition();\n                const rightOfPosition = MoveOperations.right(config, model, position);\n                deleteSelection = new Range(rightOfPosition.lineNumber, rightOfPosition.column, position.lineNumber, position.column);\n            }\n            if (deleteSelection.isEmpty()) {\n                // Probably at end of file => ignore\n                commands[i] = null;\n                continue;\n            }\n            if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {\n                shouldPushStackElementBefore = true;\n            }\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n        }\n        return [shouldPushStackElementBefore, commands];\n    }\n    static isAutoClosingPairDelete(autoClosingDelete, autoClosingBrackets, autoClosingQuotes, autoClosingPairsOpen, model, selections, autoClosedCharacters) {\n        if (autoClosingBrackets === 'never' && autoClosingQuotes === 'never') {\n            return false;\n        }\n        if (autoClosingDelete === 'never') {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            if (!selection.isEmpty()) {\n                return false;\n            }\n            const lineText = model.getLineContent(position.lineNumber);\n            if (position.column < 2 || position.column >= lineText.length + 1) {\n                return false;\n            }\n            const character = lineText.charAt(position.column - 2);\n            const autoClosingPairCandidates = autoClosingPairsOpen.get(character);\n            if (!autoClosingPairCandidates) {\n                return false;\n            }\n            if (isQuote(character)) {\n                if (autoClosingQuotes === 'never') {\n                    return false;\n                }\n            }\n            else {\n                if (autoClosingBrackets === 'never') {\n                    return false;\n                }\n            }\n            const afterCharacter = lineText.charAt(position.column - 1);\n            let foundAutoClosingPair = false;\n            for (const autoClosingPairCandidate of autoClosingPairCandidates) {\n                if (autoClosingPairCandidate.open === character && autoClosingPairCandidate.close === afterCharacter) {\n                    foundAutoClosingPair = true;\n                }\n            }\n            if (!foundAutoClosingPair) {\n                return false;\n            }\n            // Must delete the pair only if it was automatically inserted by the editor\n            if (autoClosingDelete === 'auto') {\n                let found = false;\n                for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                    const autoClosedCharacter = autoClosedCharacters[j];\n                    if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runAutoClosingPairDelete(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const position = selections[i].getPosition();\n            const deleteSelection = new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n        }\n        return [true, commands];\n    }\n    static deleteLeft(prevEditOperationType, config, model, selections, autoClosedCharacters) {\n        if (this.isAutoClosingPairDelete(config.autoClosingDelete, config.autoClosingBrackets, config.autoClosingQuotes, config.autoClosingPairs.autoClosingPairsOpenByEnd, model, selections, autoClosedCharacters)) {\n            return this._runAutoClosingPairDelete(config, model, selections);\n        }\n        const commands = [];\n        let shouldPushStackElementBefore = (prevEditOperationType !== 2 /* EditOperationType.DeletingLeft */);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const deleteRange = DeleteOperations.getDeleteRange(selections[i], model, config);\n            // Ignore empty delete ranges, as they have no effect\n            // They happen if the cursor is at the beginning of the file.\n            if (deleteRange.isEmpty()) {\n                commands[i] = null;\n                continue;\n            }\n            if (deleteRange.startLineNumber !== deleteRange.endLineNumber) {\n                shouldPushStackElementBefore = true;\n            }\n            commands[i] = new ReplaceCommand(deleteRange, '');\n        }\n        return [shouldPushStackElementBefore, commands];\n    }\n    static getDeleteRange(selection, model, config) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = selection.getPosition();\n        // Unintend when using tab stops and cursor is within indentation\n        if (config.useTabStops && position.column > 1) {\n            const lineContent = model.getLineContent(position.lineNumber);\n            const firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n            const lastIndentationColumn = (firstNonWhitespaceIndex === -1\n                ? /* entire string is whitespace */ lineContent.length + 1\n                : firstNonWhitespaceIndex + 1);\n            if (position.column <= lastIndentationColumn) {\n                const fromVisibleColumn = config.visibleColumnFromColumn(model, position);\n                const toVisibleColumn = CursorColumns.prevIndentTabStop(fromVisibleColumn, config.indentSize);\n                const toColumn = config.columnFromVisibleColumn(model, position.lineNumber, toVisibleColumn);\n                return new Range(position.lineNumber, toColumn, position.lineNumber, position.column);\n            }\n        }\n        return Range.fromPositions(DeleteOperations.getPositionAfterDeleteLeft(position, model), position);\n    }\n    static getPositionAfterDeleteLeft(position, model) {\n        if (position.column > 1) {\n            // Convert 1-based columns to 0-based offsets and back.\n            const idx = strings.getLeftDeleteOffset(position.column - 1, model.getLineContent(position.lineNumber));\n            return position.with(undefined, idx + 1);\n        }\n        else if (position.lineNumber > 1) {\n            const newLine = position.lineNumber - 1;\n            return new Position(newLine, model.getLineMaxColumn(newLine));\n        }\n        else {\n            return position;\n        }\n    }\n    static cut(config, model, selections) {\n        const commands = [];\n        let lastCutRange = null;\n        selections.sort((a, b) => Position.compare(a.getStartPosition(), b.getEndPosition()));\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                if (config.emptySelectionClipboard) {\n                    // This is a full line cut\n                    const position = selection.getPosition();\n                    let startLineNumber, startColumn, endLineNumber, endColumn;\n                    if (position.lineNumber < model.getLineCount()) {\n                        // Cutting a line in the middle of the model\n                        startLineNumber = position.lineNumber;\n                        startColumn = 1;\n                        endLineNumber = position.lineNumber + 1;\n                        endColumn = 1;\n                    }\n                    else if (position.lineNumber > 1 && (lastCutRange === null || lastCutRange === void 0 ? void 0 : lastCutRange.endLineNumber) !== position.lineNumber) {\n                        // Cutting the last line & there are more than 1 lines in the model & a previous cut operation does not touch the current cut operation\n                        startLineNumber = position.lineNumber - 1;\n                        startColumn = model.getLineMaxColumn(position.lineNumber - 1);\n                        endLineNumber = position.lineNumber;\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\n                    }\n                    else {\n                        // Cutting the single line that the model contains\n                        startLineNumber = position.lineNumber;\n                        startColumn = 1;\n                        endLineNumber = position.lineNumber;\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\n                    }\n                    const deleteSelection = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n                    lastCutRange = deleteSelection;\n                    if (!deleteSelection.isEmpty()) {\n                        commands[i] = new ReplaceCommand(deleteSelection, '');\n                    }\n                    else {\n                        commands[i] = null;\n                    }\n                }\n                else {\n                    // Cannot cut empty selection\n                    commands[i] = null;\n                }\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, '');\n            }\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as types from '../../../base/common/types.js';\nimport { CursorState, SingleCursorState } from '../cursorCommon.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { WordOperations } from './cursorWordOperations.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class CursorMoveCommands {\n    static addCursorDown(viewModel, cursors, useLogicalLine) {\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n            if (useLogicalLine) {\n                result[resultLen++] = CursorState.fromModelState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n            }\n            else {\n                result[resultLen++] = CursorState.fromViewState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel, cursor.viewState));\n            }\n        }\n        return result;\n    }\n    static addCursorUp(viewModel, cursors, useLogicalLine) {\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n            if (useLogicalLine) {\n                result[resultLen++] = CursorState.fromModelState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n            }\n            else {\n                result[resultLen++] = CursorState.fromViewState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel, cursor.viewState));\n            }\n        }\n        return result;\n    }\n    static moveToBeginningOfLine(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = this._moveToLineStart(viewModel, cursor, inSelectionMode);\n        }\n        return result;\n    }\n    static _moveToLineStart(viewModel, cursor, inSelectionMode) {\n        const currentViewStateColumn = cursor.viewState.position.column;\n        const currentModelStateColumn = cursor.modelState.position.column;\n        const isFirstLineOfWrappedLine = currentViewStateColumn === currentModelStateColumn;\n        const currentViewStatelineNumber = cursor.viewState.position.lineNumber;\n        const firstNonBlankColumn = viewModel.getLineFirstNonWhitespaceColumn(currentViewStatelineNumber);\n        const isBeginningOfViewLine = currentViewStateColumn === firstNonBlankColumn;\n        if (!isFirstLineOfWrappedLine && !isBeginningOfViewLine) {\n            return this._moveToLineStartByView(viewModel, cursor, inSelectionMode);\n        }\n        else {\n            return this._moveToLineStartByModel(viewModel, cursor, inSelectionMode);\n        }\n    }\n    static _moveToLineStartByView(viewModel, cursor, inSelectionMode) {\n        return CursorState.fromViewState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode));\n    }\n    static _moveToLineStartByModel(viewModel, cursor, inSelectionMode) {\n        return CursorState.fromModelState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n    }\n    static moveToEndOfLine(viewModel, cursors, inSelectionMode, sticky) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = this._moveToLineEnd(viewModel, cursor, inSelectionMode, sticky);\n        }\n        return result;\n    }\n    static _moveToLineEnd(viewModel, cursor, inSelectionMode, sticky) {\n        const viewStatePosition = cursor.viewState.position;\n        const viewModelMaxColumn = viewModel.getLineMaxColumn(viewStatePosition.lineNumber);\n        const isEndOfViewLine = viewStatePosition.column === viewModelMaxColumn;\n        const modelStatePosition = cursor.modelState.position;\n        const modelMaxColumn = viewModel.model.getLineMaxColumn(modelStatePosition.lineNumber);\n        const isEndLineOfWrappedLine = viewModelMaxColumn - viewStatePosition.column === modelMaxColumn - modelStatePosition.column;\n        if (isEndOfViewLine || isEndLineOfWrappedLine) {\n            return this._moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky);\n        }\n        else {\n            return this._moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky);\n        }\n    }\n    static _moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky) {\n        return CursorState.fromViewState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, sticky));\n    }\n    static _moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky) {\n        return CursorState.fromModelState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, sticky));\n    }\n    static expandLineSelection(viewModel, cursors) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const startLineNumber = cursor.modelState.selection.startLineNumber;\n            const lineCount = viewModel.model.getLineCount();\n            let endLineNumber = cursor.modelState.selection.endLineNumber;\n            let endColumn;\n            if (endLineNumber === lineCount) {\n                endColumn = viewModel.model.getLineMaxColumn(lineCount);\n            }\n            else {\n                endLineNumber++;\n                endColumn = 1;\n            }\n            result[i] = CursorState.fromModelState(new SingleCursorState(new Range(startLineNumber, 1, startLineNumber, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(endLineNumber, endColumn), 0));\n        }\n        return result;\n    }\n    static moveToBeginningOfBuffer(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveToBeginningOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n        }\n        return result;\n    }\n    static moveToEndOfBuffer(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveToEndOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n        }\n        return result;\n    }\n    static selectAll(viewModel, cursor) {\n        const lineCount = viewModel.model.getLineCount();\n        const maxColumn = viewModel.model.getLineMaxColumn(lineCount);\n        return CursorState.fromModelState(new SingleCursorState(new Range(1, 1, 1, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(lineCount, maxColumn), 0));\n    }\n    static line(viewModel, cursor, inSelectionMode, _position, _viewPosition) {\n        const position = viewModel.model.validatePosition(_position);\n        const viewPosition = (_viewPosition\n            ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\n            : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position));\n        if (!inSelectionMode) {\n            // Entering line selection for the first time\n            const lineCount = viewModel.model.getLineCount();\n            let selectToLineNumber = position.lineNumber + 1;\n            let selectToColumn = 1;\n            if (selectToLineNumber > lineCount) {\n                selectToLineNumber = lineCount;\n                selectToColumn = viewModel.model.getLineMaxColumn(selectToLineNumber);\n            }\n            return CursorState.fromModelState(new SingleCursorState(new Range(position.lineNumber, 1, selectToLineNumber, selectToColumn), 2 /* SelectionStartKind.Line */, 0, new Position(selectToLineNumber, selectToColumn), 0));\n        }\n        // Continuing line selection\n        const enteringLineNumber = cursor.modelState.selectionStart.getStartPosition().lineNumber;\n        if (position.lineNumber < enteringLineNumber) {\n            return CursorState.fromViewState(cursor.viewState.move(true, viewPosition.lineNumber, 1, 0));\n        }\n        else if (position.lineNumber > enteringLineNumber) {\n            const lineCount = viewModel.getLineCount();\n            let selectToViewLineNumber = viewPosition.lineNumber + 1;\n            let selectToViewColumn = 1;\n            if (selectToViewLineNumber > lineCount) {\n                selectToViewLineNumber = lineCount;\n                selectToViewColumn = viewModel.getLineMaxColumn(selectToViewLineNumber);\n            }\n            return CursorState.fromViewState(cursor.viewState.move(true, selectToViewLineNumber, selectToViewColumn, 0));\n        }\n        else {\n            const endPositionOfSelectionStart = cursor.modelState.selectionStart.getEndPosition();\n            return CursorState.fromModelState(cursor.modelState.move(true, endPositionOfSelectionStart.lineNumber, endPositionOfSelectionStart.column, 0));\n        }\n    }\n    static word(viewModel, cursor, inSelectionMode, _position) {\n        const position = viewModel.model.validatePosition(_position);\n        return CursorState.fromModelState(WordOperations.word(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, position));\n    }\n    static cancelSelection(viewModel, cursor) {\n        if (!cursor.modelState.hasSelection()) {\n            return new CursorState(cursor.modelState, cursor.viewState);\n        }\n        const lineNumber = cursor.viewState.position.lineNumber;\n        const column = cursor.viewState.position.column;\n        return CursorState.fromViewState(new SingleCursorState(new Range(lineNumber, column, lineNumber, column), 0 /* SelectionStartKind.Simple */, 0, new Position(lineNumber, column), 0));\n    }\n    static moveTo(viewModel, cursor, inSelectionMode, _position, _viewPosition) {\n        if (inSelectionMode) {\n            if (cursor.modelState.selectionStartKind === 1 /* SelectionStartKind.Word */) {\n                return this.word(viewModel, cursor, inSelectionMode, _position);\n            }\n            if (cursor.modelState.selectionStartKind === 2 /* SelectionStartKind.Line */) {\n                return this.line(viewModel, cursor, inSelectionMode, _position, _viewPosition);\n            }\n        }\n        const position = viewModel.model.validatePosition(_position);\n        const viewPosition = (_viewPosition\n            ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\n            : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position));\n        return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, viewPosition.lineNumber, viewPosition.column, 0));\n    }\n    static simpleMove(viewModel, cursors, direction, inSelectionMode, value, unit) {\n        switch (direction) {\n            case 0 /* CursorMove.Direction.Left */: {\n                if (unit === 4 /* CursorMove.Unit.HalfLine */) {\n                    // Move left by half the current line length\n                    return this._moveHalfLineLeft(viewModel, cursors, inSelectionMode);\n                }\n                else {\n                    // Move left by `moveParams.value` columns\n                    return this._moveLeft(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 1 /* CursorMove.Direction.Right */: {\n                if (unit === 4 /* CursorMove.Unit.HalfLine */) {\n                    // Move right by half the current line length\n                    return this._moveHalfLineRight(viewModel, cursors, inSelectionMode);\n                }\n                else {\n                    // Move right by `moveParams.value` columns\n                    return this._moveRight(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 2 /* CursorMove.Direction.Up */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    // Move up by view lines\n                    return this._moveUpByViewLines(viewModel, cursors, inSelectionMode, value);\n                }\n                else {\n                    // Move up by model lines\n                    return this._moveUpByModelLines(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 3 /* CursorMove.Direction.Down */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    // Move down by view lines\n                    return this._moveDownByViewLines(viewModel, cursors, inSelectionMode, value);\n                }\n                else {\n                    // Move down by model lines\n                    return this._moveDownByModelLines(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 4 /* CursorMove.Direction.PrevBlankLine */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)));\n                }\n                else {\n                    return cursors.map(cursor => CursorState.fromModelState(MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)));\n                }\n            }\n            case 5 /* CursorMove.Direction.NextBlankLine */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)));\n                }\n                else {\n                    return cursors.map(cursor => CursorState.fromModelState(MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)));\n                }\n            }\n            case 6 /* CursorMove.Direction.WrappedLineStart */: {\n                // Move to the beginning of the current view line\n                return this._moveToViewMinColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 7 /* CursorMove.Direction.WrappedLineFirstNonWhitespaceCharacter */: {\n                // Move to the first non-whitespace column of the current view line\n                return this._moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 8 /* CursorMove.Direction.WrappedLineColumnCenter */: {\n                // Move to the \"center\" of the current view line\n                return this._moveToViewCenterColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 9 /* CursorMove.Direction.WrappedLineEnd */: {\n                // Move to the end of the current view line\n                return this._moveToViewMaxColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 10 /* CursorMove.Direction.WrappedLineLastNonWhitespaceCharacter */: {\n                // Move to the last non-whitespace column of the current view line\n                return this._moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n            }\n            default:\n                return null;\n        }\n    }\n    static viewportMove(viewModel, cursors, direction, inSelectionMode, value) {\n        const visibleViewRange = viewModel.getCompletelyVisibleViewRange();\n        const visibleModelRange = viewModel.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n        switch (direction) {\n            case 11 /* CursorMove.Direction.ViewPortTop */: {\n                // Move to the nth line start in the viewport (from the top)\n                const modelLineNumber = this._firstLineNumberInRange(viewModel.model, visibleModelRange, value);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 13 /* CursorMove.Direction.ViewPortBottom */: {\n                // Move to the nth line start in the viewport (from the bottom)\n                const modelLineNumber = this._lastLineNumberInRange(viewModel.model, visibleModelRange, value);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 12 /* CursorMove.Direction.ViewPortCenter */: {\n                // Move to the line start in the viewport center\n                const modelLineNumber = Math.round((visibleModelRange.startLineNumber + visibleModelRange.endLineNumber) / 2);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 14 /* CursorMove.Direction.ViewPortIfOutside */: {\n                // Move to a position inside the viewport\n                const result = [];\n                for (let i = 0, len = cursors.length; i < len; i++) {\n                    const cursor = cursors[i];\n                    result[i] = this.findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode);\n                }\n                return result;\n            }\n            default:\n                return null;\n        }\n    }\n    static findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode) {\n        const viewLineNumber = cursor.viewState.position.lineNumber;\n        if (visibleViewRange.startLineNumber <= viewLineNumber && viewLineNumber <= visibleViewRange.endLineNumber - 1) {\n            // Nothing to do, cursor is in viewport\n            return new CursorState(cursor.modelState, cursor.viewState);\n        }\n        else {\n            let newViewLineNumber;\n            if (viewLineNumber > visibleViewRange.endLineNumber - 1) {\n                newViewLineNumber = visibleViewRange.endLineNumber - 1;\n            }\n            else if (viewLineNumber < visibleViewRange.startLineNumber) {\n                newViewLineNumber = visibleViewRange.startLineNumber;\n            }\n            else {\n                newViewLineNumber = viewLineNumber;\n            }\n            const position = MoveOperations.vertical(viewModel.cursorConfig, viewModel, viewLineNumber, cursor.viewState.position.column, cursor.viewState.leftoverVisibleColumns, newViewLineNumber, false);\n            return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, position.lineNumber, position.column, position.leftoverVisibleColumns));\n        }\n    }\n    /**\n     * Find the nth line start included in the range (from the start).\n     */\n    static _firstLineNumberInRange(model, range, count) {\n        let startLineNumber = range.startLineNumber;\n        if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n            // Move on to the second line if the first line start is not included in the range\n            startLineNumber++;\n        }\n        return Math.min(range.endLineNumber, startLineNumber + count - 1);\n    }\n    /**\n     * Find the nth line start included in the range (from the end).\n     */\n    static _lastLineNumberInRange(model, range, count) {\n        let startLineNumber = range.startLineNumber;\n        if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n            // Move on to the second line if the first line start is not included in the range\n            startLineNumber++;\n        }\n        return Math.max(startLineNumber, range.endLineNumber - count + 1);\n    }\n    static _moveLeft(viewModel, cursors, inSelectionMode, noOfColumns) {\n        return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)));\n    }\n    static _moveHalfLineLeft(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const halfLine = Math.round(viewModel.getLineContent(viewLineNumber).length / 2);\n            result[i] = CursorState.fromViewState(MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n        }\n        return result;\n    }\n    static _moveRight(viewModel, cursors, inSelectionMode, noOfColumns) {\n        return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)));\n    }\n    static _moveHalfLineRight(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const halfLine = Math.round(viewModel.getLineContent(viewLineNumber).length / 2);\n            result[i] = CursorState.fromViewState(MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n        }\n        return result;\n    }\n    static _moveDownByViewLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromViewState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveDownByModelLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveUpByViewLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromViewState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveUpByModelLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveToViewPosition(viewModel, cursor, inSelectionMode, toViewLineNumber, toViewColumn) {\n        return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, toViewLineNumber, toViewColumn, 0));\n    }\n    static _moveToModelPosition(viewModel, cursor, inSelectionMode, toModelLineNumber, toModelColumn) {\n        return CursorState.fromModelState(cursor.modelState.move(inSelectionMode, toModelLineNumber, toModelColumn, 0));\n    }\n    static _moveToViewMinColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineMinColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineFirstNonWhitespaceColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewCenterColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = Math.round((viewModel.getLineMaxColumn(viewLineNumber) + viewModel.getLineMinColumn(viewLineNumber)) / 2);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewMaxColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineMaxColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineLastNonWhitespaceColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n}\nexport var CursorMove;\n(function (CursorMove) {\n    const isCursorMoveArgs = function (arg) {\n        if (!types.isObject(arg)) {\n            return false;\n        }\n        const cursorMoveArg = arg;\n        if (!types.isString(cursorMoveArg.to)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.select) && !types.isBoolean(cursorMoveArg.select)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.by) && !types.isString(cursorMoveArg.by)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.value) && !types.isNumber(cursorMoveArg.value)) {\n            return false;\n        }\n        return true;\n    };\n    CursorMove.description = {\n        description: 'Move cursor to a logical position in the view',\n        args: [\n            {\n                name: 'Cursor move argument object',\n                description: `Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'to': A mandatory logical position value providing where to move the cursor.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine',\n\t\t\t\t\t\t'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'\n\t\t\t\t\t\t'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'\n\t\t\t\t\t\t'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'by': Unit to move. Default is computed based on 'to' value.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'line', 'wrappedLine', 'character', 'halfLine'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'value': Number of units to move. Default is '1'.\n\t\t\t\t\t* 'select': If 'true' makes the selection. Default is 'false'.\n\t\t\t\t`,\n                constraint: isCursorMoveArgs,\n                schema: {\n                    'type': 'object',\n                    'required': ['to'],\n                    'properties': {\n                        'to': {\n                            'type': 'string',\n                            'enum': ['left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine', 'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter', 'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter', 'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside']\n                        },\n                        'by': {\n                            'type': 'string',\n                            'enum': ['line', 'wrappedLine', 'character', 'halfLine']\n                        },\n                        'value': {\n                            'type': 'number',\n                            'default': 1\n                        },\n                        'select': {\n                            'type': 'boolean',\n                            'default': false\n                        }\n                    }\n                }\n            }\n        ]\n    };\n    /**\n     * Positions in the view for cursor move command.\n     */\n    CursorMove.RawDirection = {\n        Left: 'left',\n        Right: 'right',\n        Up: 'up',\n        Down: 'down',\n        PrevBlankLine: 'prevBlankLine',\n        NextBlankLine: 'nextBlankLine',\n        WrappedLineStart: 'wrappedLineStart',\n        WrappedLineFirstNonWhitespaceCharacter: 'wrappedLineFirstNonWhitespaceCharacter',\n        WrappedLineColumnCenter: 'wrappedLineColumnCenter',\n        WrappedLineEnd: 'wrappedLineEnd',\n        WrappedLineLastNonWhitespaceCharacter: 'wrappedLineLastNonWhitespaceCharacter',\n        ViewPortTop: 'viewPortTop',\n        ViewPortCenter: 'viewPortCenter',\n        ViewPortBottom: 'viewPortBottom',\n        ViewPortIfOutside: 'viewPortIfOutside'\n    };\n    /**\n     * Units for Cursor move 'by' argument\n     */\n    CursorMove.RawUnit = {\n        Line: 'line',\n        WrappedLine: 'wrappedLine',\n        Character: 'character',\n        HalfLine: 'halfLine'\n    };\n    function parse(args) {\n        if (!args.to) {\n            // illegal arguments\n            return null;\n        }\n        let direction;\n        switch (args.to) {\n            case CursorMove.RawDirection.Left:\n                direction = 0 /* Direction.Left */;\n                break;\n            case CursorMove.RawDirection.Right:\n                direction = 1 /* Direction.Right */;\n                break;\n            case CursorMove.RawDirection.Up:\n                direction = 2 /* Direction.Up */;\n                break;\n            case CursorMove.RawDirection.Down:\n                direction = 3 /* Direction.Down */;\n                break;\n            case CursorMove.RawDirection.PrevBlankLine:\n                direction = 4 /* Direction.PrevBlankLine */;\n                break;\n            case CursorMove.RawDirection.NextBlankLine:\n                direction = 5 /* Direction.NextBlankLine */;\n                break;\n            case CursorMove.RawDirection.WrappedLineStart:\n                direction = 6 /* Direction.WrappedLineStart */;\n                break;\n            case CursorMove.RawDirection.WrappedLineFirstNonWhitespaceCharacter:\n                direction = 7 /* Direction.WrappedLineFirstNonWhitespaceCharacter */;\n                break;\n            case CursorMove.RawDirection.WrappedLineColumnCenter:\n                direction = 8 /* Direction.WrappedLineColumnCenter */;\n                break;\n            case CursorMove.RawDirection.WrappedLineEnd:\n                direction = 9 /* Direction.WrappedLineEnd */;\n                break;\n            case CursorMove.RawDirection.WrappedLineLastNonWhitespaceCharacter:\n                direction = 10 /* Direction.WrappedLineLastNonWhitespaceCharacter */;\n                break;\n            case CursorMove.RawDirection.ViewPortTop:\n                direction = 11 /* Direction.ViewPortTop */;\n                break;\n            case CursorMove.RawDirection.ViewPortBottom:\n                direction = 13 /* Direction.ViewPortBottom */;\n                break;\n            case CursorMove.RawDirection.ViewPortCenter:\n                direction = 12 /* Direction.ViewPortCenter */;\n                break;\n            case CursorMove.RawDirection.ViewPortIfOutside:\n                direction = 14 /* Direction.ViewPortIfOutside */;\n                break;\n            default:\n                // illegal arguments\n                return null;\n        }\n        let unit = 0 /* Unit.None */;\n        switch (args.by) {\n            case CursorMove.RawUnit.Line:\n                unit = 1 /* Unit.Line */;\n                break;\n            case CursorMove.RawUnit.WrappedLine:\n                unit = 2 /* Unit.WrappedLine */;\n                break;\n            case CursorMove.RawUnit.Character:\n                unit = 3 /* Unit.Character */;\n                break;\n            case CursorMove.RawUnit.HalfLine:\n                unit = 4 /* Unit.HalfLine */;\n                break;\n        }\n        return {\n            direction: direction,\n            unit: unit,\n            select: (!!args.select),\n            value: (args.value || 1)\n        };\n    }\n    CursorMove.parse = parse;\n})(CursorMove || (CursorMove = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { AtomicTabMoveOperations } from './cursorAtomicMoveOperations.js';\nexport class CursorPosition {\n    constructor(lineNumber, column, leftoverVisibleColumns) {\n        this._cursorPositionBrand = undefined;\n        this.lineNumber = lineNumber;\n        this.column = column;\n        this.leftoverVisibleColumns = leftoverVisibleColumns;\n    }\n}\nexport class MoveOperations {\n    static leftPosition(model, position) {\n        if (position.column > model.getLineMinColumn(position.lineNumber)) {\n            return position.delta(undefined, -strings.prevCharLength(model.getLineContent(position.lineNumber), position.column - 1));\n        }\n        else if (position.lineNumber > 1) {\n            const newLineNumber = position.lineNumber - 1;\n            return new Position(newLineNumber, model.getLineMaxColumn(newLineNumber));\n        }\n        else {\n            return position;\n        }\n    }\n    static leftPositionAtomicSoftTabs(model, position, tabSize) {\n        if (position.column <= model.getLineIndentColumn(position.lineNumber)) {\n            const minColumn = model.getLineMinColumn(position.lineNumber);\n            const lineContent = model.getLineContent(position.lineNumber);\n            const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, 0 /* Direction.Left */);\n            if (newPosition !== -1 && newPosition + 1 >= minColumn) {\n                return new Position(position.lineNumber, newPosition + 1);\n            }\n        }\n        return this.leftPosition(model, position);\n    }\n    static left(config, model, position) {\n        const pos = config.stickyTabStops\n            ? MoveOperations.leftPositionAtomicSoftTabs(model, position, config.tabSize)\n            : MoveOperations.leftPosition(model, position);\n        return new CursorPosition(pos.lineNumber, pos.column, 0);\n    }\n    /**\n     * @param noOfColumns Must be either `1`\n     * or `Math.round(viewModel.getLineContent(viewLineNumber).length / 2)` (for half lines).\n    */\n    static moveLeft(config, model, cursor, inSelectionMode, noOfColumns) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If the user has a selection and does not want to extend it,\n            // put the cursor at the beginning of the selection.\n            lineNumber = cursor.selection.startLineNumber;\n            column = cursor.selection.startColumn;\n        }\n        else {\n            // This has no effect if noOfColumns === 1.\n            // It is ok to do so in the half-line scenario.\n            const pos = cursor.position.delta(undefined, -(noOfColumns - 1));\n            // We clip the position before normalization, as normalization is not defined\n            // for possibly negative columns.\n            const normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 0 /* PositionAffinity.Left */);\n            const p = MoveOperations.left(config, model, normalizedPos);\n            lineNumber = p.lineNumber;\n            column = p.column;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    /**\n     * Adjusts the column so that it is within min/max of the line.\n    */\n    static clipPositionColumn(position, model) {\n        return new Position(position.lineNumber, MoveOperations.clipRange(position.column, model.getLineMinColumn(position.lineNumber), model.getLineMaxColumn(position.lineNumber)));\n    }\n    static clipRange(value, min, max) {\n        if (value < min) {\n            return min;\n        }\n        if (value > max) {\n            return max;\n        }\n        return value;\n    }\n    static rightPosition(model, lineNumber, column) {\n        if (column < model.getLineMaxColumn(lineNumber)) {\n            column = column + strings.nextCharLength(model.getLineContent(lineNumber), column - 1);\n        }\n        else if (lineNumber < model.getLineCount()) {\n            lineNumber = lineNumber + 1;\n            column = model.getLineMinColumn(lineNumber);\n        }\n        return new Position(lineNumber, column);\n    }\n    static rightPositionAtomicSoftTabs(model, lineNumber, column, tabSize, indentSize) {\n        if (column < model.getLineIndentColumn(lineNumber)) {\n            const lineContent = model.getLineContent(lineNumber);\n            const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, column - 1, tabSize, 1 /* Direction.Right */);\n            if (newPosition !== -1) {\n                return new Position(lineNumber, newPosition + 1);\n            }\n        }\n        return this.rightPosition(model, lineNumber, column);\n    }\n    static right(config, model, position) {\n        const pos = config.stickyTabStops\n            ? MoveOperations.rightPositionAtomicSoftTabs(model, position.lineNumber, position.column, config.tabSize, config.indentSize)\n            : MoveOperations.rightPosition(model, position.lineNumber, position.column);\n        return new CursorPosition(pos.lineNumber, pos.column, 0);\n    }\n    static moveRight(config, model, cursor, inSelectionMode, noOfColumns) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move right without selection cancels selection and puts cursor at the end of the selection\n            lineNumber = cursor.selection.endLineNumber;\n            column = cursor.selection.endColumn;\n        }\n        else {\n            const pos = cursor.position.delta(undefined, noOfColumns - 1);\n            const normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 1 /* PositionAffinity.Right */);\n            const r = MoveOperations.right(config, model, normalizedPos);\n            lineNumber = r.lineNumber;\n            column = r.column;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    static vertical(config, model, lineNumber, column, leftoverVisibleColumns, newLineNumber, allowMoveOnEdgeLine, normalizationAffinity) {\n        const currentVisibleColumn = CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize) + leftoverVisibleColumns;\n        const lineCount = model.getLineCount();\n        const wasOnFirstPosition = (lineNumber === 1 && column === 1);\n        const wasOnLastPosition = (lineNumber === lineCount && column === model.getLineMaxColumn(lineNumber));\n        const wasAtEdgePosition = (newLineNumber < lineNumber ? wasOnFirstPosition : wasOnLastPosition);\n        lineNumber = newLineNumber;\n        if (lineNumber < 1) {\n            lineNumber = 1;\n            if (allowMoveOnEdgeLine) {\n                column = model.getLineMinColumn(lineNumber);\n            }\n            else {\n                column = Math.min(model.getLineMaxColumn(lineNumber), column);\n            }\n        }\n        else if (lineNumber > lineCount) {\n            lineNumber = lineCount;\n            if (allowMoveOnEdgeLine) {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n            else {\n                column = Math.min(model.getLineMaxColumn(lineNumber), column);\n            }\n        }\n        else {\n            column = config.columnFromVisibleColumn(model, lineNumber, currentVisibleColumn);\n        }\n        if (wasAtEdgePosition) {\n            leftoverVisibleColumns = 0;\n        }\n        else {\n            leftoverVisibleColumns = currentVisibleColumn - CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize);\n        }\n        if (normalizationAffinity !== undefined) {\n            const position = new Position(lineNumber, column);\n            const newPosition = model.normalizePosition(position, normalizationAffinity);\n            leftoverVisibleColumns = leftoverVisibleColumns + (column - newPosition.column);\n            lineNumber = newPosition.lineNumber;\n            column = newPosition.column;\n        }\n        return new CursorPosition(lineNumber, column, leftoverVisibleColumns);\n    }\n    static down(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnLastLine) {\n        return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber + count, allowMoveOnLastLine, 4 /* PositionAffinity.RightOfInjectedText */);\n    }\n    static moveDown(config, model, cursor, inSelectionMode, linesCount) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move down acts relative to the end of selection\n            lineNumber = cursor.selection.endLineNumber;\n            column = cursor.selection.endColumn;\n        }\n        else {\n            lineNumber = cursor.position.lineNumber;\n            column = cursor.position.column;\n        }\n        const r = MoveOperations.down(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);\n        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n    }\n    static translateDown(config, model, cursor) {\n        const selection = cursor.selection;\n        const selectionStart = MoveOperations.down(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n        const position = MoveOperations.down(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), 0 /* SelectionStartKind.Simple */, selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n    }\n    static up(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnFirstLine) {\n        return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber - count, allowMoveOnFirstLine, 3 /* PositionAffinity.LeftOfInjectedText */);\n    }\n    static moveUp(config, model, cursor, inSelectionMode, linesCount) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move up acts relative to the beginning of selection\n            lineNumber = cursor.selection.startLineNumber;\n            column = cursor.selection.startColumn;\n        }\n        else {\n            lineNumber = cursor.position.lineNumber;\n            column = cursor.position.column;\n        }\n        const r = MoveOperations.up(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);\n        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n    }\n    static translateUp(config, model, cursor) {\n        const selection = cursor.selection;\n        const selectionStart = MoveOperations.up(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n        const position = MoveOperations.up(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), 0 /* SelectionStartKind.Simple */, selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n    }\n    static _isBlankLine(model, lineNumber) {\n        if (model.getLineFirstNonWhitespaceColumn(lineNumber) === 0) {\n            // empty or contains only whitespace\n            return true;\n        }\n        return false;\n    }\n    static moveToPrevBlankLine(config, model, cursor, inSelectionMode) {\n        let lineNumber = cursor.position.lineNumber;\n        // If our current line is blank, move to the previous non-blank line\n        while (lineNumber > 1 && this._isBlankLine(model, lineNumber)) {\n            lineNumber--;\n        }\n        // Find the previous blank line\n        while (lineNumber > 1 && !this._isBlankLine(model, lineNumber)) {\n            lineNumber--;\n        }\n        return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n    }\n    static moveToNextBlankLine(config, model, cursor, inSelectionMode) {\n        const lineCount = model.getLineCount();\n        let lineNumber = cursor.position.lineNumber;\n        // If our current line is blank, move to the next non-blank line\n        while (lineNumber < lineCount && this._isBlankLine(model, lineNumber)) {\n            lineNumber++;\n        }\n        // Find the next blank line\n        while (lineNumber < lineCount && !this._isBlankLine(model, lineNumber)) {\n            lineNumber++;\n        }\n        return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n    }\n    static moveToBeginningOfLine(config, model, cursor, inSelectionMode) {\n        const lineNumber = cursor.position.lineNumber;\n        const minColumn = model.getLineMinColumn(lineNumber);\n        const firstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(lineNumber) || minColumn;\n        let column;\n        const relevantColumnNumber = cursor.position.column;\n        if (relevantColumnNumber === firstNonBlankColumn) {\n            column = minColumn;\n        }\n        else {\n            column = firstNonBlankColumn;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    static moveToEndOfLine(config, model, cursor, inSelectionMode, sticky) {\n        const lineNumber = cursor.position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        return cursor.move(inSelectionMode, lineNumber, maxColumn, sticky ? 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */ - maxColumn : 0);\n    }\n    static moveToBeginningOfBuffer(config, model, cursor, inSelectionMode) {\n        return cursor.move(inSelectionMode, 1, 1, 0);\n    }\n    static moveToEndOfBuffer(config, model, cursor, inSelectionMode) {\n        const lastLineNumber = model.getLineCount();\n        const lastColumn = model.getLineMaxColumn(lastLineNumber);\n        return cursor.move(inSelectionMode, lastLineNumber, lastColumn, 0);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition, ReplaceCommandThatPreservesSelection } from '../commands/replaceCommand.js';\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { CompositionSurroundSelectionCommand, SurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nimport { IndentAction } from '../languages/languageConfiguration.js';\nimport { getIndentationAtPosition } from '../languages/languageConfigurationRegistry.js';\nimport { createScopedLineTokens } from '../languages/supports.js';\nimport { getIndentActionForType, getIndentForEnter, getInheritIndentForLine } from '../languages/autoIndent.js';\nimport { getEnterAction } from '../languages/enterAction.js';\nexport class TypeOperations {\n    static indent(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: false,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            }, config.languageConfigurationService);\n        }\n        return commands;\n    }\n    static outdent(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: true,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            }, config.languageConfigurationService);\n        }\n        return commands;\n    }\n    static shiftIndent(config, indentation, count) {\n        count = count || 1;\n        return ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n    static unshiftIndent(config, indentation, count) {\n        count = count || 1;\n        return ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n    static _distributedPaste(config, model, selections, text) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], text[i]);\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _simplePaste(config, model, selections, text, pasteOnNewLine) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            if (pasteOnNewLine && !selection.isEmpty()) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine) {\n                // Paste entire line at the beginning of line\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\n                commands[i] = new ReplaceCommandThatPreservesSelection(typeSelection, text, selection, true);\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, text);\n            }\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText) {\n        if (pasteOnNewLine) {\n            return null;\n        }\n        if (selections.length === 1) {\n            return null;\n        }\n        if (multicursorText && multicursorText.length === selections.length) {\n            return multicursorText;\n        }\n        if (config.multiCursorPaste === 'spread') {\n            // Try to spread the pasted text in case the line count matches the cursor count\n            // Remove trailing \\n if present\n            if (text.charCodeAt(text.length - 1) === 10 /* CharCode.LineFeed */) {\n                text = text.substr(0, text.length - 1);\n            }\n            // Remove trailing \\r if present\n            if (text.charCodeAt(text.length - 1) === 13 /* CharCode.CarriageReturn */) {\n                text = text.substr(0, text.length - 1);\n            }\n            const lines = strings.splitLines(text);\n            if (lines.length === selections.length) {\n                return lines;\n            }\n        }\n        return null;\n    }\n    static paste(config, model, selections, text, pasteOnNewLine, multicursorText) {\n        const distributedPaste = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText);\n        if (distributedPaste) {\n            selections = selections.sort(Range.compareRangesUsingStarts);\n            return this._distributedPaste(config, model, selections, distributedPaste);\n        }\n        else {\n            return this._simplePaste(config, model, selections, text, pasteOnNewLine);\n        }\n    }\n    static _goodIndentForLine(config, model, lineNumber) {\n        let action = null;\n        let indentation = '';\n        const expectedIndentAction = getInheritIndentForLine(config.autoIndent, model, lineNumber, false, config.languageConfigurationService);\n        if (expectedIndentAction) {\n            action = expectedIndentAction.action;\n            indentation = expectedIndentAction.indentation;\n        }\n        else if (lineNumber > 1) {\n            let lastLineNumber;\n            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n                const lineText = model.getLineContent(lastLineNumber);\n                const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n                if (nonWhitespaceIdx >= 0) {\n                    break;\n                }\n            }\n            if (lastLineNumber < 1) {\n                // No previous line with content found\n                return null;\n            }\n            const maxColumn = model.getLineMaxColumn(lastLineNumber);\n            const expectedEnterAction = getEnterAction(config.autoIndent, model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn), config.languageConfigurationService);\n            if (expectedEnterAction) {\n                indentation = expectedEnterAction.indentation + expectedEnterAction.appendText;\n            }\n        }\n        if (action) {\n            if (action === IndentAction.Indent) {\n                indentation = TypeOperations.shiftIndent(config, indentation);\n            }\n            if (action === IndentAction.Outdent) {\n                indentation = TypeOperations.unshiftIndent(config, indentation);\n            }\n            indentation = config.normalizeIndentation(indentation);\n        }\n        if (!indentation) {\n            return null;\n        }\n        return indentation;\n    }\n    static _replaceJumpToNextIndent(config, model, selection, insertsAutoWhitespace) {\n        let typeText = '';\n        const position = selection.getStartPosition();\n        if (config.insertSpaces) {\n            const visibleColumnFromColumn = config.visibleColumnFromColumn(model, position);\n            const indentSize = config.indentSize;\n            const spacesCnt = indentSize - (visibleColumnFromColumn % indentSize);\n            for (let i = 0; i < spacesCnt; i++) {\n                typeText += ' ';\n            }\n        }\n        else {\n            typeText = '\\t';\n        }\n        return new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n    }\n    static tab(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                const lineText = model.getLineContent(selection.startLineNumber);\n                if (/^\\s*$/.test(lineText) && model.tokenization.isCheapToTokenize(selection.startLineNumber)) {\n                    let goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n                    goodIndent = goodIndent || '\\t';\n                    const possibleTypeText = config.normalizeIndentation(goodIndent);\n                    if (!lineText.startsWith(possibleTypeText)) {\n                        commands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n                        continue;\n                    }\n                }\n                commands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n            }\n            else {\n                if (selection.startLineNumber === selection.endLineNumber) {\n                    const lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n                        // This is a single line selection that is not the entire line\n                        commands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n                        continue;\n                    }\n                }\n                commands[i] = new ShiftCommand(selection, {\n                    isUnshift: false,\n                    tabSize: config.tabSize,\n                    indentSize: config.indentSize,\n                    insertSpaces: config.insertSpaces,\n                    useTabStops: config.useTabStops,\n                    autoIndent: config.autoIndent\n                }, config.languageConfigurationService);\n            }\n        }\n        return commands;\n    }\n    static compositionType(prevEditOperationType, config, model, selections, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        const commands = selections.map(selection => this._compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        if (!selection.isEmpty()) {\n            // looks like https://github.com/microsoft/vscode/issues/2773\n            // where a cursor operation occurred before a canceled composition\n            // => ignore composition\n            return null;\n        }\n        const pos = selection.getPosition();\n        const startColumn = Math.max(1, pos.column - replacePrevCharCnt);\n        const endColumn = Math.min(model.getLineMaxColumn(pos.lineNumber), pos.column + replaceNextCharCnt);\n        const range = new Range(pos.lineNumber, startColumn, pos.lineNumber, endColumn);\n        const oldText = model.getValueInRange(range);\n        if (oldText === text && positionDelta === 0) {\n            // => ignore composition that doesn't do anything\n            return null;\n        }\n        return new ReplaceCommandWithOffsetCursorState(range, text, 0, positionDelta);\n    }\n    static _typeCommand(range, text, keepPosition) {\n        if (keepPosition) {\n            return new ReplaceCommandWithoutChangingPosition(range, text, true);\n        }\n        else {\n            return new ReplaceCommand(range, text, true);\n        }\n    }\n    static _enter(config, model, keepPosition, range) {\n        if (config.autoIndent === 0 /* EditorAutoIndentStrategy.None */) {\n            return TypeOperations._typeCommand(range, '\\n', keepPosition);\n        }\n        if (!model.tokenization.isCheapToTokenize(range.getStartPosition().lineNumber) || config.autoIndent === 1 /* EditorAutoIndentStrategy.Keep */) {\n            const lineText = model.getLineContent(range.startLineNumber);\n            const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n            return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n        }\n        const r = getEnterAction(config.autoIndent, model, range, config.languageConfigurationService);\n        if (r) {\n            if (r.indentAction === IndentAction.None) {\n                // Nothing special\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.Indent) {\n                // Indent once\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.IndentOutdent) {\n                // Ultra special\n                const normalIndent = config.normalizeIndentation(r.indentation);\n                const increasedIndent = config.normalizeIndentation(r.indentation + r.appendText);\n                const typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, typeText, true);\n                }\n                else {\n                    return new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n                }\n            }\n            else if (r.indentAction === IndentAction.Outdent) {\n                const actualIndentation = TypeOperations.unshiftIndent(config, r.indentation);\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + r.appendText), keepPosition);\n            }\n        }\n        const lineText = model.getLineContent(range.startLineNumber);\n        const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n        if (config.autoIndent >= 4 /* EditorAutoIndentStrategy.Full */) {\n            const ir = getIndentForEnter(config.autoIndent, model, range, {\n                unshiftIndent: (indent) => {\n                    return TypeOperations.unshiftIndent(config, indent);\n                },\n                shiftIndent: (indent) => {\n                    return TypeOperations.shiftIndent(config, indent);\n                },\n                normalizeIndentation: (indent) => {\n                    return config.normalizeIndentation(indent);\n                }\n            }, config.languageConfigurationService);\n            if (ir) {\n                let oldEndViewColumn = config.visibleColumnFromColumn(model, range.getEndPosition());\n                const oldEndColumn = range.endColumn;\n                const newLineContent = model.getLineContent(range.endLineNumber);\n                const firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n                if (firstNonWhitespace >= 0) {\n                    range = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n                }\n                else {\n                    range = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n                }\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, '\\n' + config.normalizeIndentation(ir.afterEnter), true);\n                }\n                else {\n                    let offset = 0;\n                    if (oldEndColumn <= firstNonWhitespace + 1) {\n                        if (!config.insertSpaces) {\n                            oldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n                        }\n                        offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n                    }\n                    return new ReplaceCommandWithOffsetCursorState(range, '\\n' + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n                }\n            }\n        }\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n    }\n    static _isAutoIndentType(config, model, selections) {\n        if (config.autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            if (!model.tokenization.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _runAutoIndentType(config, model, range, ch) {\n        const currentIndentation = getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n        const actualIndentation = getIndentActionForType(config.autoIndent, model, range, ch, {\n            shiftIndent: (indentation) => {\n                return TypeOperations.shiftIndent(config, indentation);\n            },\n            unshiftIndent: (indentation) => {\n                return TypeOperations.unshiftIndent(config, indentation);\n            },\n        }, config.languageConfigurationService);\n        if (actualIndentation === null) {\n            return null;\n        }\n        if (actualIndentation !== config.normalizeIndentation(currentIndentation)) {\n            const firstNonWhitespace = model.getLineFirstNonWhitespaceColumn(range.startLineNumber);\n            if (firstNonWhitespace === 0) {\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + ch, false);\n            }\n            else {\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) +\n                    model.getLineContent(range.startLineNumber).substring(firstNonWhitespace - 1, range.startColumn - 1) + ch, false);\n            }\n        }\n        return null;\n    }\n    static _isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch) {\n        if (config.autoClosingOvertype === 'never') {\n            return false;\n        }\n        if (!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (!selection.isEmpty()) {\n                return false;\n            }\n            const position = selection.getPosition();\n            const lineText = model.getLineContent(position.lineNumber);\n            const afterCharacter = lineText.charAt(position.column - 1);\n            if (afterCharacter !== ch) {\n                return false;\n            }\n            // Do not over-type quotes after a backslash\n            const chIsQuote = isQuote(ch);\n            const beforeCharacter = position.column > 2 ? lineText.charCodeAt(position.column - 2) : 0 /* CharCode.Null */;\n            if (beforeCharacter === 92 /* CharCode.Backslash */ && chIsQuote) {\n                return false;\n            }\n            // Must over-type a closing character typed by the editor\n            if (config.autoClosingOvertype === 'auto') {\n                let found = false;\n                for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                    const autoClosedCharacter = autoClosedCharacters[j];\n                    if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            const typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(typeSelection, ch);\n        }\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _isBeforeClosingBrace(config, lineAfter) {\n        // If the start of lineAfter can be interpretted as both a starting or ending brace, default to returning false\n        const nextChar = lineAfter.charAt(0);\n        const potentialStartingBraces = config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) || [];\n        const potentialClosingBraces = config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar) || [];\n        const isBeforeStartingBrace = potentialStartingBraces.some(x => lineAfter.startsWith(x.open));\n        const isBeforeClosingBrace = potentialClosingBraces.some(x => lineAfter.startsWith(x.close));\n        return !isBeforeStartingBrace && isBeforeClosingBrace;\n    }\n    /**\n     * Determine if typing `ch` at all `positions` in the `model` results in an\n     * auto closing open sequence being typed.\n     *\n     * Auto closing open sequences can consist of multiple characters, which\n     * can lead to ambiguities. In such a case, the longest auto-closing open\n     * sequence is returned.\n     */\n    static _findAutoClosingPairOpen(config, model, positions, ch) {\n        const candidates = config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n        if (!candidates) {\n            return null;\n        }\n        // Determine which auto-closing pair it is\n        let result = null;\n        for (const candidate of candidates) {\n            if (result === null || candidate.open.length > result.open.length) {\n                let candidateIsMatch = true;\n                for (const position of positions) {\n                    const relevantText = model.getValueInRange(new Range(position.lineNumber, position.column - candidate.open.length + 1, position.lineNumber, position.column));\n                    if (relevantText + ch !== candidate.open) {\n                        candidateIsMatch = false;\n                        break;\n                    }\n                }\n                if (candidateIsMatch) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Find another auto-closing pair that is contained by the one passed in.\n     *\n     * e.g. when having [(,)] and [(*,*)] as auto-closing pairs\n     * this method will find [(,)] as a containment pair for [(*,*)]\n     */\n    static _findContainedAutoClosingPair(config, pair) {\n        if (pair.open.length <= 1) {\n            return null;\n        }\n        const lastChar = pair.close.charAt(pair.close.length - 1);\n        // get candidates with the same last character as close\n        const candidates = config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) || [];\n        let result = null;\n        for (const candidate of candidates) {\n            if (candidate.open !== pair.open && pair.open.includes(candidate.open) && pair.close.endsWith(candidate.close)) {\n                if (!result || candidate.open.length > result.open.length) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    static _getAutoClosingPairClose(config, model, selections, ch, chIsAlreadyTyped) {\n        const chIsQuote = isQuote(ch);\n        const autoCloseConfig = (chIsQuote ? config.autoClosingQuotes : config.autoClosingBrackets);\n        const shouldAutoCloseBefore = (chIsQuote ? config.shouldAutoCloseBefore.quote : config.shouldAutoCloseBefore.bracket);\n        if (autoCloseConfig === 'never') {\n            return null;\n        }\n        for (const selection of selections) {\n            if (!selection.isEmpty()) {\n                return null;\n            }\n        }\n        // This method is called both when typing (regularly) and when composition ends\n        // This means that we need to work with a text buffer where sometimes `ch` is not\n        // there (it is being typed right now) or with a text buffer where `ch` has already been typed\n        //\n        // In order to avoid adding checks for `chIsAlreadyTyped` in all places, we will work\n        // with two conceptual positions, the position before `ch` and the position after `ch`\n        //\n        const positions = selections.map((s) => {\n            const position = s.getPosition();\n            if (chIsAlreadyTyped) {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column - ch.length, afterColumn: position.column };\n            }\n            else {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column, afterColumn: position.column };\n            }\n        });\n        // Find the longest auto-closing open pair in case of multiple ending in `ch`\n        // e.g. when having [f\",\"] and [\",\"], it picks [f\",\"] if the character before is f\n        const pair = this._findAutoClosingPairOpen(config, model, positions.map(p => new Position(p.lineNumber, p.beforeColumn)), ch);\n        if (!pair) {\n            return null;\n        }\n        // Sometimes, it is possible to have two auto-closing pairs that have a containment relationship\n        // e.g. when having [(,)] and [(*,*)]\n        // - when typing (, the resulting state is (|)\n        // - when typing *, the desired resulting state is (*|*), not (*|*))\n        const containedPair = this._findContainedAutoClosingPair(config, pair);\n        const containedPairClose = containedPair ? containedPair.close : '';\n        let isContainedPairPresent = true;\n        for (const position of positions) {\n            const { lineNumber, beforeColumn, afterColumn } = position;\n            const lineText = model.getLineContent(lineNumber);\n            const lineBefore = lineText.substring(0, beforeColumn - 1);\n            const lineAfter = lineText.substring(afterColumn - 1);\n            if (!lineAfter.startsWith(containedPairClose)) {\n                isContainedPairPresent = false;\n            }\n            // Only consider auto closing the pair if an allowed character follows or if another autoclosed pair closing brace follows\n            if (lineAfter.length > 0) {\n                const characterAfter = lineAfter.charAt(0);\n                const isBeforeCloseBrace = TypeOperations._isBeforeClosingBrace(config, lineAfter);\n                if (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n                    return null;\n                }\n            }\n            // Do not auto-close ' or \" after a word character\n            if (pair.open.length === 1 && (ch === '\\'' || ch === '\"') && autoCloseConfig !== 'always') {\n                const wordSeparators = getMapForWordSeparators(config.wordSeparators);\n                if (lineBefore.length > 0) {\n                    const characterBefore = lineBefore.charCodeAt(lineBefore.length - 1);\n                    if (wordSeparators.get(characterBefore) === 0 /* WordCharacterClass.Regular */) {\n                        return null;\n                    }\n                }\n            }\n            if (!model.tokenization.isCheapToTokenize(lineNumber)) {\n                // Do not force tokenization\n                return null;\n            }\n            model.tokenization.forceTokenization(lineNumber);\n            const lineTokens = model.tokenization.getLineTokens(lineNumber);\n            const scopedLineTokens = createScopedLineTokens(lineTokens, beforeColumn - 1);\n            if (!pair.shouldAutoClose(scopedLineTokens, beforeColumn - scopedLineTokens.firstCharOffset)) {\n                return null;\n            }\n            // Typing for example a quote could either start a new string, in which case auto-closing is desirable\n            // or it could end a previously started string, in which case auto-closing is not desirable\n            //\n            // In certain cases, it is really not possible to look at the previous token to determine\n            // what would happen. That's why we do something really unusual, we pretend to type a different\n            // character and ask the tokenizer what the outcome of doing that is: after typing a neutral\n            // character, are we in a string (i.e. the quote would most likely end a string) or not?\n            //\n            const neutralCharacter = pair.findNeutralCharacter();\n            if (neutralCharacter) {\n                const tokenType = model.tokenization.getTokenTypeIfInsertingCharacter(lineNumber, beforeColumn, neutralCharacter);\n                if (!pair.isOK(tokenType)) {\n                    return null;\n                }\n            }\n        }\n        if (isContainedPairPresent) {\n            return pair.close.substring(0, pair.close.length - containedPairClose.length);\n        }\n        else {\n            return pair.close;\n        }\n    }\n    static _runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, chIsAlreadyTyped, autoClosingPairClose) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            commands[i] = new TypeWithAutoClosingCommand(selection, ch, !chIsAlreadyTyped, autoClosingPairClose);\n        }\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _shouldSurroundChar(config, ch) {\n        if (isQuote(ch)) {\n            return (config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined');\n        }\n        else {\n            // Character is a bracket\n            return (config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined');\n        }\n    }\n    static _isSurroundSelectionType(config, model, selections, ch) {\n        if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n            return false;\n        }\n        const isTypingAQuoteCharacter = isQuote(ch);\n        for (const selection of selections) {\n            if (selection.isEmpty()) {\n                return false;\n            }\n            let selectionContainsOnlyWhitespace = true;\n            for (let lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n                const lineText = model.getLineContent(lineNumber);\n                const startIndex = (lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0);\n                const endIndex = (lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length);\n                const selectedText = lineText.substring(startIndex, endIndex);\n                if (/[^ \\t]/.test(selectedText)) {\n                    // this selected text contains something other than whitespace\n                    selectionContainsOnlyWhitespace = false;\n                    break;\n                }\n            }\n            if (selectionContainsOnlyWhitespace) {\n                return false;\n            }\n            if (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n                const selectionText = model.getValueInRange(selection);\n                if (isQuote(selectionText)) {\n                    // Typing a quote character on top of another quote character\n                    // => disable surround selection type\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runSurroundSelectionType(prevEditOperationType, config, model, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const closeCharacter = config.surroundingPairs[ch];\n            commands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _isTypeInterceptorElectricChar(config, model, selections) {\n        if (selections.length === 1 && model.tokenization.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n            return true;\n        }\n        return false;\n    }\n    static _typeInterceptorElectricChar(prevEditOperationType, config, model, selection, ch) {\n        if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n            return null;\n        }\n        const position = selection.getPosition();\n        model.tokenization.forceTokenization(position.lineNumber);\n        const lineTokens = model.tokenization.getLineTokens(position.lineNumber);\n        let electricAction;\n        try {\n            electricAction = config.onElectricCharacter(ch, lineTokens, position.column);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n        if (!electricAction) {\n            return null;\n        }\n        if (electricAction.matchOpenBracket) {\n            const endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n            const match = model.bracketPairs.findMatchingBracketUp(electricAction.matchOpenBracket, {\n                lineNumber: position.lineNumber,\n                column: endColumn\n            }, 500 /* give at most 500ms to compute */);\n            if (match) {\n                if (match.startLineNumber === position.lineNumber) {\n                    // matched something on the same line => no change in indentation\n                    return null;\n                }\n                const matchLine = model.getLineContent(match.startLineNumber);\n                const matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n                const newIndentation = config.normalizeIndentation(matchLineIndentation);\n                const lineText = model.getLineContent(position.lineNumber);\n                const lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n                const prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n                const typeText = newIndentation + prefix + ch;\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\n                const command = new ReplaceCommand(typeSelection, typeText);\n                return new EditOperationResult(getTypingOperation(typeText, prevEditOperationType), [command], {\n                    shouldPushStackElementBefore: false,\n                    shouldPushStackElementAfter: true\n                });\n            }\n        }\n        return null;\n    }\n    /**\n     * This is very similar with typing, but the character is already in the text buffer!\n     */\n    static compositionEndWithInterceptors(prevEditOperationType, config, model, compositions, selections, autoClosedCharacters) {\n        if (!compositions) {\n            // could not deduce what the composition did\n            return null;\n        }\n        let insertedText = null;\n        for (const composition of compositions) {\n            if (insertedText === null) {\n                insertedText = composition.insertedText;\n            }\n            else if (insertedText !== composition.insertedText) {\n                // not all selections agree on what was typed\n                return null;\n            }\n        }\n        if (!insertedText || insertedText.length !== 1) {\n            // we're only interested in the case where a single character was inserted\n            return null;\n        }\n        const ch = insertedText;\n        let hasDeletion = false;\n        for (const composition of compositions) {\n            if (composition.deletedText.length !== 0) {\n                hasDeletion = true;\n                break;\n            }\n        }\n        if (hasDeletion) {\n            // Check if this could have been a surround selection\n            if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n                return null;\n            }\n            const isTypingAQuoteCharacter = isQuote(ch);\n            for (const composition of compositions) {\n                if (composition.deletedSelectionStart !== 0 || composition.deletedSelectionEnd !== composition.deletedText.length) {\n                    // more text was deleted than was selected, so this could not have been a surround selection\n                    return null;\n                }\n                if (/^[ \\t]+$/.test(composition.deletedText)) {\n                    // deleted text was only whitespace\n                    return null;\n                }\n                if (isTypingAQuoteCharacter && isQuote(composition.deletedText)) {\n                    // deleted text was a quote\n                    return null;\n                }\n            }\n            const positions = [];\n            for (const selection of selections) {\n                if (!selection.isEmpty()) {\n                    return null;\n                }\n                positions.push(selection.getPosition());\n            }\n            if (positions.length !== compositions.length) {\n                return null;\n            }\n            const commands = [];\n            for (let i = 0, len = positions.length; i < len; i++) {\n                commands.push(new CompositionSurroundSelectionCommand(positions[i], compositions[i].deletedText, config.surroundingPairs[ch]));\n            }\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            // Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\n            const commands = selections.map(s => new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), '', false));\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, true);\n        if (autoClosingPairClose !== null) {\n            return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, true, autoClosingPairClose);\n        }\n        return null;\n    }\n    static typeWithInterceptors(isDoingComposition, prevEditOperationType, config, model, selections, autoClosedCharacters, ch) {\n        if (!isDoingComposition && ch === '\\n') {\n            const commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = TypeOperations._enter(config, model, false, selections[i]);\n            }\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false,\n            });\n        }\n        if (!isDoingComposition && this._isAutoIndentType(config, model, selections)) {\n            const commands = [];\n            let autoIndentFails = false;\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = this._runAutoIndentType(config, model, selections[i], ch);\n                if (!commands[i]) {\n                    autoIndentFails = true;\n                    break;\n                }\n            }\n            if (!autoIndentFails) {\n                return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                    shouldPushStackElementBefore: true,\n                    shouldPushStackElementAfter: false,\n                });\n            }\n        }\n        if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            return this._runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch);\n        }\n        if (!isDoingComposition) {\n            const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, false);\n            if (autoClosingPairClose) {\n                return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, false, autoClosingPairClose);\n            }\n        }\n        if (!isDoingComposition && this._isSurroundSelectionType(config, model, selections, ch)) {\n            return this._runSurroundSelectionType(prevEditOperationType, config, model, selections, ch);\n        }\n        // Electric characters make sense only when dealing with a single cursor,\n        // as multiple cursors typing brackets for example would interfer with bracket matching\n        if (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model, selections)) {\n            const r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n            if (r) {\n                return r;\n            }\n        }\n        // A simple character type\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], ch);\n        }\n        const opType = getTypingOperation(ch, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static typeWithoutInterceptors(prevEditOperationType, config, model, selections, str) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], str);\n        }\n        const opType = getTypingOperation(str, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static lineInsertBefore(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            let lineNumber = selections[i].positionLineNumber;\n            if (lineNumber === 1) {\n                commands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\n            }\n            else {\n                lineNumber--;\n                const column = model.getLineMaxColumn(lineNumber);\n                commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n            }\n        }\n        return commands;\n    }\n    static lineInsertAfter(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const lineNumber = selections[i].positionLineNumber;\n            const column = model.getLineMaxColumn(lineNumber);\n            commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n        }\n        return commands;\n    }\n    static lineBreakInsert(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = this._enter(config, model, true, selections[i]);\n        }\n        return commands;\n    }\n}\nexport class TypeWithAutoClosingCommand extends ReplaceCommandWithOffsetCursorState {\n    constructor(selection, openCharacter, insertOpenCharacter, closeCharacter) {\n        super(selection, (insertOpenCharacter ? openCharacter : '') + closeCharacter, 0, -closeCharacter.length);\n        this._openCharacter = openCharacter;\n        this._closeCharacter = closeCharacter;\n        this.closeCharacterRange = null;\n        this.enclosingRange = null;\n    }\n    computeCursorState(model, helper) {\n        const inverseEditOperations = helper.getInverseEditOperations();\n        const range = inverseEditOperations[0].range;\n        this.closeCharacterRange = new Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        this.enclosingRange = new Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        return super.computeCursorState(model, helper);\n    }\n}\nexport class CompositionOutcome {\n    constructor(deletedText, deletedSelectionStart, deletedSelectionEnd, insertedText, insertedSelectionStart, insertedSelectionEnd) {\n        this.deletedText = deletedText;\n        this.deletedSelectionStart = deletedSelectionStart;\n        this.deletedSelectionEnd = deletedSelectionEnd;\n        this.insertedText = insertedText;\n        this.insertedSelectionStart = insertedSelectionStart;\n        this.insertedSelectionEnd = insertedSelectionEnd;\n    }\n}\nfunction getTypingOperation(typedText, previousTypingOperation) {\n    if (typedText === ' ') {\n        return previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */\n            || previousTypingOperation === 6 /* EditOperationType.TypingConsecutiveSpace */\n            ? 6 /* EditOperationType.TypingConsecutiveSpace */\n            : 5 /* EditOperationType.TypingFirstSpace */;\n    }\n    return 4 /* EditOperationType.TypingOther */;\n}\nfunction shouldPushStackElementBetween(previousTypingOperation, typingOperation) {\n    if (isTypingOperation(previousTypingOperation) && !isTypingOperation(typingOperation)) {\n        // Always set an undo stop before non-type operations\n        return true;\n    }\n    if (previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */) {\n        // `abc |d`: No undo stop\n        // `abc  |d`: Undo stop\n        return false;\n    }\n    // Insert undo stop between different operation types\n    return normalizeOperationType(previousTypingOperation) !== normalizeOperationType(typingOperation);\n}\nfunction normalizeOperationType(type) {\n    return (type === 6 /* EditOperationType.TypingConsecutiveSpace */ || type === 5 /* EditOperationType.TypingFirstSpace */)\n        ? 'space'\n        : type;\n}\nfunction isTypingOperation(type) {\n    return type === 4 /* EditOperationType.TypingOther */\n        || type === 5 /* EditOperationType.TypingFirstSpace */\n        || type === 6 /* EditOperationType.TypingConsecutiveSpace */;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class WordOperations {\n    static _createWord(lineContent, wordType, nextCharClass, start, end) {\n        // console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\n        return { start: start, end: end, wordType: wordType, nextCharClass: nextCharClass };\n    }\n    static _findPreviousWordOnLine(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\n    }\n    static _doFindPreviousWordOnLine(lineContent, wordSeparators, position) {\n        let wordType = 0 /* WordType.None */;\n        for (let chIndex = position.column - 2; chIndex >= 0; chIndex--) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 0 /* WordCharacterClass.Regular */) {\n                if (wordType === 2 /* WordType.Separator */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = 1 /* WordType.Regular */;\n            }\n            else if (chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                if (wordType === 1 /* WordType.Regular */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = 2 /* WordType.Separator */;\n            }\n            else if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                if (wordType !== 0 /* WordType.None */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n            }\n        }\n        if (wordType !== 0 /* WordType.None */) {\n            return this._createWord(lineContent, wordType, 1 /* WordCharacterClass.Whitespace */, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\n        }\n        return null;\n    }\n    static _findEndOfWord(lineContent, wordSeparators, wordType, startIndex) {\n        const len = lineContent.length;\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                return chIndex;\n            }\n            if (wordType === 1 /* WordType.Regular */ && chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                return chIndex;\n            }\n            if (wordType === 2 /* WordType.Separator */ && chClass === 0 /* WordCharacterClass.Regular */) {\n                return chIndex;\n            }\n        }\n        return len;\n    }\n    static _findNextWordOnLine(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindNextWordOnLine(lineContent, wordSeparators, position);\n    }\n    static _doFindNextWordOnLine(lineContent, wordSeparators, position) {\n        let wordType = 0 /* WordType.None */;\n        const len = lineContent.length;\n        for (let chIndex = position.column - 1; chIndex < len; chIndex++) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 0 /* WordCharacterClass.Regular */) {\n                if (wordType === 2 /* WordType.Separator */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = 1 /* WordType.Regular */;\n            }\n            else if (chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                if (wordType === 1 /* WordType.Regular */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = 2 /* WordType.Separator */;\n            }\n            else if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                if (wordType !== 0 /* WordType.None */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n            }\n        }\n        if (wordType !== 0 /* WordType.None */) {\n            return this._createWord(lineContent, wordType, 1 /* WordCharacterClass.Whitespace */, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\n        }\n        return null;\n    }\n    static _findStartOfWord(lineContent, wordSeparators, wordType, startIndex) {\n        for (let chIndex = startIndex; chIndex >= 0; chIndex--) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                return chIndex + 1;\n            }\n            if (wordType === 1 /* WordType.Regular */ && chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                return chIndex + 1;\n            }\n            if (wordType === 2 /* WordType.Separator */ && chClass === 0 /* WordCharacterClass.Regular */) {\n                return chIndex + 1;\n            }\n        }\n        return 0;\n    }\n    static moveWordLeft(wordSeparators, model, position, wordNavigationType) {\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        if (column === 1) {\n            if (lineNumber > 1) {\n                lineNumber = lineNumber - 1;\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n        if (wordNavigationType === 0 /* WordNavigationType.WordStart */) {\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        if (wordNavigationType === 1 /* WordNavigationType.WordStartFast */) {\n            if (prevWordOnLine\n                && prevWordOnLine.wordType === 2 /* WordType.Separator */\n                && prevWordOnLine.end - prevWordOnLine.start === 1\n                && prevWordOnLine.nextCharClass === 0 /* WordCharacterClass.Regular */) {\n                // Skip over a word made up of one single separator and followed by a regular character\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        if (wordNavigationType === 3 /* WordNavigationType.WordAccessibility */) {\n            while (prevWordOnLine\n                && prevWordOnLine.wordType === 2 /* WordType.Separator */) {\n                // Skip over words made up of only separators\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        // We are stopping at the ending of words\n        if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n            prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n        }\n        return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\n    }\n    static _moveWordPartLeft(model, position) {\n        const lineNumber = position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === 1) {\n            return (lineNumber > 1 ? new Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position);\n        }\n        const lineContent = model.getLineContent(lineNumber);\n        for (let column = position.column - 1; column > 1; column--) {\n            const left = lineContent.charCodeAt(column - 2);\n            const right = lineContent.charCodeAt(column - 1);\n            if (left === 95 /* CharCode.Underline */ && right !== 95 /* CharCode.Underline */) {\n                // snake_case_variables\n                return new Position(lineNumber, column);\n            }\n            if (left === 45 /* CharCode.Dash */ && right !== 45 /* CharCode.Dash */) {\n                // kebab-case-variables\n                return new Position(lineNumber, column);\n            }\n            if ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    const rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n                        return new Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new Position(lineNumber, 1);\n    }\n    static moveWordRight(wordSeparators, model, position, wordNavigationType) {\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        let movedDown = false;\n        if (column === model.getLineMaxColumn(lineNumber)) {\n            if (lineNumber < model.getLineCount()) {\n                movedDown = true;\n                lineNumber = lineNumber + 1;\n                column = 1;\n            }\n        }\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n        if (wordNavigationType === 2 /* WordNavigationType.WordEnd */) {\n            if (nextWordOnLine && nextWordOnLine.wordType === 2 /* WordType.Separator */) {\n                if (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === 0 /* WordCharacterClass.Regular */) {\n                    // Skip over a word made up of one single separator and followed by a regular character\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n                }\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        else if (wordNavigationType === 3 /* WordNavigationType.WordAccessibility */) {\n            if (movedDown) {\n                // If we move to the next line, pretend that the cursor is right before the first character.\n                // This is needed when the first word starts right at the first character - and in order not to miss it,\n                // we need to start before.\n                column = 0;\n            }\n            while (nextWordOnLine\n                && (nextWordOnLine.wordType === 2 /* WordType.Separator */\n                    || nextWordOnLine.start + 1 <= column)) {\n                // Skip over a word made up of one single separator\n                // Also skip over word if it begins before current cursor position to ascertain we're moving forward at least 1 character.\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        else {\n            if (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    static _moveWordPartRight(model, position) {\n        const lineNumber = position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === maxColumn) {\n            return (lineNumber < model.getLineCount() ? new Position(lineNumber + 1, 1) : position);\n        }\n        const lineContent = model.getLineContent(lineNumber);\n        for (let column = position.column + 1; column < maxColumn; column++) {\n            const left = lineContent.charCodeAt(column - 2);\n            const right = lineContent.charCodeAt(column - 1);\n            if (left !== 95 /* CharCode.Underline */ && right === 95 /* CharCode.Underline */) {\n                // snake_case_variables\n                return new Position(lineNumber, column);\n            }\n            if (left !== 45 /* CharCode.Dash */ && right === 45 /* CharCode.Dash */) {\n                // kebab-case-variables\n                return new Position(lineNumber, column);\n            }\n            if ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    const rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n                        return new Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new Position(lineNumber, maxColumn);\n    }\n    static _deleteWordLeftWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const startIndex = position.column - 2;\n        const lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\n        if (lastNonWhitespace + 1 < startIndex) {\n            return new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\n        }\n        return null;\n    }\n    static deleteWordLeft(ctx, wordNavigationType) {\n        const wordSeparators = ctx.wordSeparators;\n        const model = ctx.model;\n        const selection = ctx.selection;\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        if (DeleteOperations.isAutoClosingPairDelete(ctx.autoClosingDelete, ctx.autoClosingBrackets, ctx.autoClosingQuotes, ctx.autoClosingPairs.autoClosingPairsOpenByEnd, ctx.model, [ctx.selection], ctx.autoClosedCharacters)) {\n            const position = ctx.selection.getPosition();\n            return new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        if (lineNumber === 1 && column === 1) {\n            // Ignore deleting at beginning of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            const r = this._deleteWordLeftWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === 0 /* WordNavigationType.WordStart */) {\n            if (prevWordOnLine) {\n                column = prevWordOnLine.start + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        else {\n            if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            if (prevWordOnLine) {\n                column = prevWordOnLine.end + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n    static deleteInsideWord(wordSeparators, model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        const r = this._deleteInsideWordWhitespace(model, position);\n        if (r) {\n            return r;\n        }\n        return this._deleteInsideWordDetermineDeleteRange(wordSeparators, model, position);\n    }\n    static _charAtIsWhitespace(str, index) {\n        const charCode = str.charCodeAt(index);\n        return (charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */);\n    }\n    static _deleteInsideWordWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const lineContentLength = lineContent.length;\n        if (lineContentLength === 0) {\n            // empty line\n            return null;\n        }\n        let leftIndex = Math.max(position.column - 2, 0);\n        if (!this._charAtIsWhitespace(lineContent, leftIndex)) {\n            // touches a non-whitespace character to the left\n            return null;\n        }\n        let rightIndex = Math.min(position.column - 1, lineContentLength - 1);\n        if (!this._charAtIsWhitespace(lineContent, rightIndex)) {\n            // touches a non-whitespace character to the right\n            return null;\n        }\n        // walk over whitespace to the left\n        while (leftIndex > 0 && this._charAtIsWhitespace(lineContent, leftIndex - 1)) {\n            leftIndex--;\n        }\n        // walk over whitespace to the right\n        while (rightIndex + 1 < lineContentLength && this._charAtIsWhitespace(lineContent, rightIndex + 1)) {\n            rightIndex++;\n        }\n        return new Range(position.lineNumber, leftIndex + 1, position.lineNumber, rightIndex + 2);\n    }\n    static _deleteInsideWordDetermineDeleteRange(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const lineLength = lineContent.length;\n        if (lineLength === 0) {\n            // empty line\n            if (position.lineNumber > 1) {\n                return new Range(position.lineNumber - 1, model.getLineMaxColumn(position.lineNumber - 1), position.lineNumber, 1);\n            }\n            else {\n                if (position.lineNumber < model.getLineCount()) {\n                    return new Range(position.lineNumber, 1, position.lineNumber + 1, 1);\n                }\n                else {\n                    // empty model\n                    return new Range(position.lineNumber, 1, position.lineNumber, 1);\n                }\n            }\n        }\n        const touchesWord = (word) => {\n            return (word.start + 1 <= position.column && position.column <= word.end + 1);\n        };\n        const createRangeWithPosition = (startColumn, endColumn) => {\n            startColumn = Math.min(startColumn, position.column);\n            endColumn = Math.max(endColumn, position.column);\n            return new Range(position.lineNumber, startColumn, position.lineNumber, endColumn);\n        };\n        const deleteWordAndAdjacentWhitespace = (word) => {\n            let startColumn = word.start + 1;\n            let endColumn = word.end + 1;\n            let expandedToTheRight = false;\n            while (endColumn - 1 < lineLength && this._charAtIsWhitespace(lineContent, endColumn - 1)) {\n                expandedToTheRight = true;\n                endColumn++;\n            }\n            if (!expandedToTheRight) {\n                while (startColumn > 1 && this._charAtIsWhitespace(lineContent, startColumn - 2)) {\n                    startColumn--;\n                }\n            }\n            return createRangeWithPosition(startColumn, endColumn);\n        };\n        const prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (prevWordOnLine && touchesWord(prevWordOnLine)) {\n            return deleteWordAndAdjacentWhitespace(prevWordOnLine);\n        }\n        const nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (nextWordOnLine && touchesWord(nextWordOnLine)) {\n            return deleteWordAndAdjacentWhitespace(nextWordOnLine);\n        }\n        if (prevWordOnLine && nextWordOnLine) {\n            return createRangeWithPosition(prevWordOnLine.end + 1, nextWordOnLine.start + 1);\n        }\n        if (prevWordOnLine) {\n            return createRangeWithPosition(prevWordOnLine.start + 1, prevWordOnLine.end + 1);\n        }\n        if (nextWordOnLine) {\n            return createRangeWithPosition(nextWordOnLine.start + 1, nextWordOnLine.end + 1);\n        }\n        return createRangeWithPosition(1, lineLength + 1);\n    }\n    static _deleteWordPartLeft(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const pos = selection.getPosition();\n        const toPosition = WordOperations._moveWordPartLeft(model, pos);\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n    static _findFirstNonWhitespaceChar(str, startIndex) {\n        const len = str.length;\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\n            const ch = str.charAt(chIndex);\n            if (ch !== ' ' && ch !== '\\t') {\n                return chIndex;\n            }\n        }\n        return len;\n    }\n    static _deleteWordRightWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const startIndex = position.column - 1;\n        const firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\n        if (startIndex + 1 < firstNonWhitespace) {\n            // bingo\n            return new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\n        }\n        return null;\n    }\n    static deleteWordRight(ctx, wordNavigationType) {\n        const wordSeparators = ctx.wordSeparators;\n        const model = ctx.model;\n        const selection = ctx.selection;\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        const lineCount = model.getLineCount();\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (lineNumber === lineCount && column === maxColumn) {\n            // Ignore deleting at end of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            const r = this._deleteWordRightWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === 2 /* WordNavigationType.WordEnd */) {\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        else {\n            if (nextWordOnLine && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n    static _deleteWordPartRight(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const pos = selection.getPosition();\n        const toPosition = WordOperations._moveWordPartRight(model, pos);\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n    static _createWordAtPosition(model, lineNumber, word) {\n        const range = new Range(lineNumber, word.start + 1, lineNumber, word.end + 1);\n        return {\n            word: model.getValueInRange(range),\n            startColumn: range.startColumn,\n            endColumn: range.endColumn\n        };\n    }\n    static getWordAtPosition(model, _wordSeparators, position) {\n        const wordSeparators = getMapForWordSeparators(_wordSeparators);\n        const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n            return WordOperations._createWordAtPosition(model, position.lineNumber, prevWord);\n        }\n        const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n            return WordOperations._createWordAtPosition(model, position.lineNumber, nextWord);\n        }\n        return null;\n    }\n    static word(config, model, cursor, inSelectionMode, position) {\n        const wordSeparators = getMapForWordSeparators(config.wordSeparators);\n        const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (!inSelectionMode) {\n            // Entering word selection for the first time\n            let startColumn;\n            let endColumn;\n            if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n                // isTouchingPrevWord\n                startColumn = prevWord.start + 1;\n                endColumn = prevWord.end + 1;\n            }\n            else if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n                // isTouchingNextWord\n                startColumn = nextWord.start + 1;\n                endColumn = nextWord.end + 1;\n            }\n            else {\n                if (prevWord) {\n                    startColumn = prevWord.end + 1;\n                }\n                else {\n                    startColumn = 1;\n                }\n                if (nextWord) {\n                    endColumn = nextWord.start + 1;\n                }\n                else {\n                    endColumn = model.getLineMaxColumn(position.lineNumber);\n                }\n            }\n            return new SingleCursorState(new Range(position.lineNumber, startColumn, position.lineNumber, endColumn), 1 /* SelectionStartKind.Word */, 0, new Position(position.lineNumber, endColumn), 0);\n        }\n        let startColumn;\n        let endColumn;\n        if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\n            // isInsidePrevWord\n            startColumn = prevWord.start + 1;\n            endColumn = prevWord.end + 1;\n        }\n        else if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\n            // isInsideNextWord\n            startColumn = nextWord.start + 1;\n            endColumn = nextWord.end + 1;\n        }\n        else {\n            startColumn = position.column;\n            endColumn = position.column;\n        }\n        const lineNumber = position.lineNumber;\n        let column;\n        if (cursor.selectionStart.containsPosition(position)) {\n            column = cursor.selectionStart.endColumn;\n        }\n        else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\n            column = startColumn;\n            const possiblePosition = new Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.endColumn;\n            }\n        }\n        else {\n            column = endColumn;\n            const possiblePosition = new Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.startColumn;\n            }\n        }\n        return cursor.move(true, lineNumber, column, 0);\n    }\n}\nexport class WordPartOperations extends WordOperations {\n    static deleteWordPartLeft(ctx) {\n        const candidates = enforceDefined([\n            WordOperations.deleteWordLeft(ctx, 0 /* WordNavigationType.WordStart */),\n            WordOperations.deleteWordLeft(ctx, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._deleteWordPartLeft(ctx.model, ctx.selection)\n        ]);\n        candidates.sort(Range.compareRangesUsingEnds);\n        return candidates[2];\n    }\n    static deleteWordPartRight(ctx) {\n        const candidates = enforceDefined([\n            WordOperations.deleteWordRight(ctx, 0 /* WordNavigationType.WordStart */),\n            WordOperations.deleteWordRight(ctx, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._deleteWordPartRight(ctx.model, ctx.selection)\n        ]);\n        candidates.sort(Range.compareRangesUsingStarts);\n        return candidates[0];\n    }\n    static moveWordPartLeft(wordSeparators, model, position) {\n        const candidates = enforceDefined([\n            WordOperations.moveWordLeft(wordSeparators, model, position, 0 /* WordNavigationType.WordStart */),\n            WordOperations.moveWordLeft(wordSeparators, model, position, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._moveWordPartLeft(model, position)\n        ]);\n        candidates.sort(Position.compare);\n        return candidates[2];\n    }\n    static moveWordPartRight(wordSeparators, model, position) {\n        const candidates = enforceDefined([\n            WordOperations.moveWordRight(wordSeparators, model, position, 0 /* WordNavigationType.WordStart */),\n            WordOperations.moveWordRight(wordSeparators, model, position, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._moveWordPartRight(model, position)\n        ]);\n        candidates.sort(Position.compare);\n        return candidates[0];\n    }\n}\nfunction enforceDefined(arr) {\n    return arr.filter(el => Boolean(el));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './core/position.js';\nimport { Range } from './core/range.js';\nimport { Selection } from './core/selection.js';\nimport { createScopedLineTokens } from './languages/supports.js';\nimport { CursorColumns } from './core/cursorColumns.js';\nimport { normalizeIndentation } from './core/indentation.js';\nconst autoCloseAlways = () => true;\nconst autoCloseNever = () => false;\nconst autoCloseBeforeWhitespace = (chr) => (chr === ' ' || chr === '\\t');\nexport class CursorConfiguration {\n    static shouldRecreate(e) {\n        return (e.hasChanged(140 /* EditorOption.layoutInfo */)\n            || e.hasChanged(126 /* EditorOption.wordSeparators */)\n            || e.hasChanged(35 /* EditorOption.emptySelectionClipboard */)\n            || e.hasChanged(74 /* EditorOption.multiCursorMergeOverlapping */)\n            || e.hasChanged(76 /* EditorOption.multiCursorPaste */)\n            || e.hasChanged(77 /* EditorOption.multiCursorLimit */)\n            || e.hasChanged(5 /* EditorOption.autoClosingBrackets */)\n            || e.hasChanged(9 /* EditorOption.autoClosingQuotes */)\n            || e.hasChanged(7 /* EditorOption.autoClosingDelete */)\n            || e.hasChanged(8 /* EditorOption.autoClosingOvertype */)\n            || e.hasChanged(12 /* EditorOption.autoSurround */)\n            || e.hasChanged(124 /* EditorOption.useTabStops */)\n            || e.hasChanged(48 /* EditorOption.fontInfo */)\n            || e.hasChanged(88 /* EditorOption.readOnly */));\n    }\n    constructor(languageId, modelOptions, configuration, languageConfigurationService) {\n        this.languageConfigurationService = languageConfigurationService;\n        this._cursorMoveConfigurationBrand = undefined;\n        this._languageId = languageId;\n        const options = configuration.options;\n        const layoutInfo = options.get(140 /* EditorOption.layoutInfo */);\n        const fontInfo = options.get(48 /* EditorOption.fontInfo */);\n        this.readOnly = options.get(88 /* EditorOption.readOnly */);\n        this.tabSize = modelOptions.tabSize;\n        this.indentSize = modelOptions.indentSize;\n        this.insertSpaces = modelOptions.insertSpaces;\n        this.stickyTabStops = options.get(112 /* EditorOption.stickyTabStops */);\n        this.lineHeight = fontInfo.lineHeight;\n        this.typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n        this.pageSize = Math.max(1, Math.floor(layoutInfo.height / this.lineHeight) - 2);\n        this.useTabStops = options.get(124 /* EditorOption.useTabStops */);\n        this.wordSeparators = options.get(126 /* EditorOption.wordSeparators */);\n        this.emptySelectionClipboard = options.get(35 /* EditorOption.emptySelectionClipboard */);\n        this.copyWithSyntaxHighlighting = options.get(23 /* EditorOption.copyWithSyntaxHighlighting */);\n        this.multiCursorMergeOverlapping = options.get(74 /* EditorOption.multiCursorMergeOverlapping */);\n        this.multiCursorPaste = options.get(76 /* EditorOption.multiCursorPaste */);\n        this.multiCursorLimit = options.get(77 /* EditorOption.multiCursorLimit */);\n        this.autoClosingBrackets = options.get(5 /* EditorOption.autoClosingBrackets */);\n        this.autoClosingQuotes = options.get(9 /* EditorOption.autoClosingQuotes */);\n        this.autoClosingDelete = options.get(7 /* EditorOption.autoClosingDelete */);\n        this.autoClosingOvertype = options.get(8 /* EditorOption.autoClosingOvertype */);\n        this.autoSurround = options.get(12 /* EditorOption.autoSurround */);\n        this.autoIndent = options.get(10 /* EditorOption.autoIndent */);\n        this.surroundingPairs = {};\n        this._electricChars = null;\n        this.shouldAutoCloseBefore = {\n            quote: this._getShouldAutoClose(languageId, this.autoClosingQuotes, true),\n            bracket: this._getShouldAutoClose(languageId, this.autoClosingBrackets, false)\n        };\n        this.autoClosingPairs = this.languageConfigurationService.getLanguageConfiguration(languageId).getAutoClosingPairs();\n        const surroundingPairs = this.languageConfigurationService.getLanguageConfiguration(languageId).getSurroundingPairs();\n        if (surroundingPairs) {\n            for (const pair of surroundingPairs) {\n                this.surroundingPairs[pair.open] = pair.close;\n            }\n        }\n    }\n    get electricChars() {\n        var _a;\n        if (!this._electricChars) {\n            this._electricChars = {};\n            const electricChars = (_a = this.languageConfigurationService.getLanguageConfiguration(this._languageId).electricCharacter) === null || _a === void 0 ? void 0 : _a.getElectricCharacters();\n            if (electricChars) {\n                for (const char of electricChars) {\n                    this._electricChars[char] = true;\n                }\n            }\n        }\n        return this._electricChars;\n    }\n    /**\n     * Should return opening bracket type to match indentation with\n     */\n    onElectricCharacter(character, context, column) {\n        const scopedLineTokens = createScopedLineTokens(context, column - 1);\n        const electricCharacterSupport = this.languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId).electricCharacter;\n        if (!electricCharacterSupport) {\n            return null;\n        }\n        return electricCharacterSupport.onElectricCharacter(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\n    }\n    normalizeIndentation(str) {\n        return normalizeIndentation(str, this.indentSize, this.insertSpaces);\n    }\n    _getShouldAutoClose(languageId, autoCloseConfig, forQuotes) {\n        switch (autoCloseConfig) {\n            case 'beforeWhitespace':\n                return autoCloseBeforeWhitespace;\n            case 'languageDefined':\n                return this._getLanguageDefinedShouldAutoClose(languageId, forQuotes);\n            case 'always':\n                return autoCloseAlways;\n            case 'never':\n                return autoCloseNever;\n        }\n    }\n    _getLanguageDefinedShouldAutoClose(languageId, forQuotes) {\n        const autoCloseBeforeSet = this.languageConfigurationService.getLanguageConfiguration(languageId).getAutoCloseBeforeSet(forQuotes);\n        return c => autoCloseBeforeSet.indexOf(c) !== -1;\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    visibleColumnFromColumn(model, position) {\n        return CursorColumns.visibleColumnFromColumn(model.getLineContent(position.lineNumber), position.column, this.tabSize);\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    columnFromVisibleColumn(model, lineNumber, visibleColumn) {\n        const result = CursorColumns.columnFromVisibleColumn(model.getLineContent(lineNumber), visibleColumn, this.tabSize);\n        const minColumn = model.getLineMinColumn(lineNumber);\n        if (result < minColumn) {\n            return minColumn;\n        }\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (result > maxColumn) {\n            return maxColumn;\n        }\n        return result;\n    }\n}\nexport class CursorState {\n    static fromModelState(modelState) {\n        return new PartialModelCursorState(modelState);\n    }\n    static fromViewState(viewState) {\n        return new PartialViewCursorState(viewState);\n    }\n    static fromModelSelection(modelSelection) {\n        const selection = Selection.liftSelection(modelSelection);\n        const modelState = new SingleCursorState(Range.fromPositions(selection.getSelectionStart()), 0 /* SelectionStartKind.Simple */, 0, selection.getPosition(), 0);\n        return CursorState.fromModelState(modelState);\n    }\n    static fromModelSelections(modelSelections) {\n        const states = [];\n        for (let i = 0, len = modelSelections.length; i < len; i++) {\n            states[i] = this.fromModelSelection(modelSelections[i]);\n        }\n        return states;\n    }\n    constructor(modelState, viewState) {\n        this._cursorStateBrand = undefined;\n        this.modelState = modelState;\n        this.viewState = viewState;\n    }\n    equals(other) {\n        return (this.viewState.equals(other.viewState) && this.modelState.equals(other.modelState));\n    }\n}\nexport class PartialModelCursorState {\n    constructor(modelState) {\n        this.modelState = modelState;\n        this.viewState = null;\n    }\n}\nexport class PartialViewCursorState {\n    constructor(viewState) {\n        this.modelState = null;\n        this.viewState = viewState;\n    }\n}\n/**\n * Represents the cursor state on either the model or on the view model.\n */\nexport class SingleCursorState {\n    constructor(selectionStart, selectionStartKind, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns) {\n        this.selectionStart = selectionStart;\n        this.selectionStartKind = selectionStartKind;\n        this.selectionStartLeftoverVisibleColumns = selectionStartLeftoverVisibleColumns;\n        this.position = position;\n        this.leftoverVisibleColumns = leftoverVisibleColumns;\n        this._singleCursorStateBrand = undefined;\n        this.selection = SingleCursorState._computeSelection(this.selectionStart, this.position);\n    }\n    equals(other) {\n        return (this.selectionStartLeftoverVisibleColumns === other.selectionStartLeftoverVisibleColumns\n            && this.leftoverVisibleColumns === other.leftoverVisibleColumns\n            && this.selectionStartKind === other.selectionStartKind\n            && this.position.equals(other.position)\n            && this.selectionStart.equalsRange(other.selectionStart));\n    }\n    hasSelection() {\n        return (!this.selection.isEmpty() || !this.selectionStart.isEmpty());\n    }\n    move(inSelectionMode, lineNumber, column, leftoverVisibleColumns) {\n        if (inSelectionMode) {\n            // move just position\n            return new SingleCursorState(this.selectionStart, this.selectionStartKind, this.selectionStartLeftoverVisibleColumns, new Position(lineNumber, column), leftoverVisibleColumns);\n        }\n        else {\n            // move everything\n            return new SingleCursorState(new Range(lineNumber, column, lineNumber, column), 0 /* SelectionStartKind.Simple */, leftoverVisibleColumns, new Position(lineNumber, column), leftoverVisibleColumns);\n        }\n    }\n    static _computeSelection(selectionStart, position) {\n        if (selectionStart.isEmpty() || !position.isBeforeOrEqual(selectionStart.getStartPosition())) {\n            return Selection.fromPositions(selectionStart.getStartPosition(), position);\n        }\n        else {\n            return Selection.fromPositions(selectionStart.getEndPosition(), position);\n        }\n    }\n}\nexport class EditOperationResult {\n    constructor(type, commands, opts) {\n        this._editOperationResultBrand = undefined;\n        this.type = type;\n        this.commands = commands;\n        this.shouldPushStackElementBefore = opts.shouldPushStackElementBefore;\n        this.shouldPushStackElementAfter = opts.shouldPushStackElementAfter;\n    }\n}\nexport function isQuote(ch) {\n    return (ch === '\\'' || ch === '\"' || ch === '`');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineRange } from '../core/lineRange.js';\nexport class LinesDiff {\n    constructor(changes, \n    /**\n     * Indicates if the time out was reached.\n     * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n     */\n    hitTimeout) {\n        this.changes = changes;\n        this.hitTimeout = hitTimeout;\n    }\n}\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n */\nexport class LineRangeMapping {\n    static inverse(mapping, originalLineCount, modifiedLineCount) {\n        const result = [];\n        let lastOriginalEndLineNumber = 1;\n        let lastModifiedEndLineNumber = 1;\n        for (const m of mapping) {\n            const r = new LineRangeMapping(new LineRange(lastOriginalEndLineNumber, m.originalRange.startLineNumber), new LineRange(lastModifiedEndLineNumber, m.modifiedRange.startLineNumber), undefined);\n            if (!r.modifiedRange.isEmpty) {\n                result.push(r);\n            }\n            lastOriginalEndLineNumber = m.originalRange.endLineNumberExclusive;\n            lastModifiedEndLineNumber = m.modifiedRange.endLineNumberExclusive;\n        }\n        const r = new LineRangeMapping(new LineRange(lastOriginalEndLineNumber, originalLineCount + 1), new LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1), undefined);\n        if (!r.modifiedRange.isEmpty) {\n            result.push(r);\n        }\n        return result;\n    }\n    constructor(originalRange, modifiedRange, innerChanges) {\n        this.originalRange = originalRange;\n        this.modifiedRange = modifiedRange;\n        this.innerChanges = innerChanges;\n    }\n    toString() {\n        return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;\n    }\n    get changedLineCount() {\n        return Math.max(this.originalRange.length, this.modifiedRange.length);\n    }\n}\n/**\n * Maps a range in the original text model to a range in the modified text model.\n */\nexport class RangeMapping {\n    constructor(originalRange, modifiedRange) {\n        this.originalRange = originalRange;\n        this.modifiedRange = modifiedRange;\n    }\n    toString() {\n        return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../base/common/diff/diff.js';\nimport { RangeMapping, LineRangeMapping, LinesDiff } from './linesDiffComputer.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Range } from '../core/range.js';\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { LineRange } from '../core/lineRange.js';\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\nexport class SmartLinesDiffComputer {\n    computeDiff(originalLines, modifiedLines, options) {\n        var _a;\n        const diffComputer = new DiffComputer(originalLines, modifiedLines, {\n            maxComputationTime: options.maxComputationTimeMs,\n            shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,\n            shouldComputeCharChanges: true,\n            shouldMakePrettyDiff: true,\n            shouldPostProcessCharChanges: true,\n        });\n        const result = diffComputer.computeDiff();\n        const changes = [];\n        let lastChange = null;\n        for (const c of result.changes) {\n            let originalRange;\n            if (c.originalEndLineNumber === 0) {\n                // Insertion\n                originalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);\n            }\n            else {\n                originalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);\n            }\n            let modifiedRange;\n            if (c.modifiedEndLineNumber === 0) {\n                // Deletion\n                modifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);\n            }\n            else {\n                modifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);\n            }\n            let change = new LineRangeMapping(originalRange, modifiedRange, (_a = c.charChanges) === null || _a === void 0 ? void 0 : _a.map(c => new RangeMapping(new Range(c.originalStartLineNumber, c.originalStartColumn, c.originalEndLineNumber, c.originalEndColumn), new Range(c.modifiedStartLineNumber, c.modifiedStartColumn, c.modifiedEndLineNumber, c.modifiedEndColumn))));\n            if (lastChange) {\n                if (lastChange.modifiedRange.endLineNumberExclusive === change.modifiedRange.startLineNumber\n                    || lastChange.originalRange.endLineNumberExclusive === change.originalRange.startLineNumber) {\n                    // join touching diffs. Probably moving diffs up/down in the algorithm causes touching diffs.\n                    change = new LineRangeMapping(lastChange.originalRange.join(change.originalRange), lastChange.modifiedRange.join(change.modifiedRange), lastChange.innerChanges && change.innerChanges ?\n                        lastChange.innerChanges.concat(change.innerChanges) : undefined);\n                    changes.pop();\n                }\n            }\n            changes.push(change);\n            lastChange = change;\n        }\n        assertFn(() => {\n            return checkAdjacentItems(changes, (m1, m2) => m2.originalRange.startLineNumber - m1.originalRange.endLineNumberExclusive === m2.modifiedRange.startLineNumber - m1.modifiedRange.endLineNumberExclusive &&\n                // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n                m1.originalRange.endLineNumberExclusive < m2.originalRange.startLineNumber &&\n                m1.modifiedRange.endLineNumberExclusive < m2.modifiedRange.startLineNumber);\n        });\n        return new LinesDiff(changes, result.quitEarly);\n    }\n}\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n    return diffAlgo.ComputeDiff(pretty);\n}\nclass LineSequence {\n    constructor(lines) {\n        const startColumns = [];\n        const endColumns = [];\n        for (let i = 0, length = lines.length; i < length; i++) {\n            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n            endColumns[i] = getLastNonBlankColumn(lines[i], 1);\n        }\n        this.lines = lines;\n        this._startColumns = startColumns;\n        this._endColumns = endColumns;\n    }\n    getElements() {\n        const elements = [];\n        for (let i = 0, len = this.lines.length; i < len; i++) {\n            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n        }\n        return elements;\n    }\n    getStrictElement(index) {\n        return this.lines[index];\n    }\n    getStartLineNumber(i) {\n        return i + 1;\n    }\n    getEndLineNumber(i) {\n        return i + 1;\n    }\n    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\n        const charCodes = [];\n        const lineNumbers = [];\n        const columns = [];\n        let len = 0;\n        for (let index = startIndex; index <= endIndex; index++) {\n            const lineContent = this.lines[index];\n            const startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\n            const endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\n            for (let col = startColumn; col < endColumn; col++) {\n                charCodes[len] = lineContent.charCodeAt(col - 1);\n                lineNumbers[len] = index + 1;\n                columns[len] = col;\n                len++;\n            }\n            if (!shouldIgnoreTrimWhitespace && index < endIndex) {\n                // Add \\n if trim whitespace is not ignored\n                charCodes[len] = 10 /* CharCode.LineFeed */;\n                lineNumbers[len] = index + 1;\n                columns[len] = lineContent.length + 1;\n                len++;\n            }\n        }\n        return new CharSequence(charCodes, lineNumbers, columns);\n    }\n}\nclass CharSequence {\n    constructor(charCodes, lineNumbers, columns) {\n        this._charCodes = charCodes;\n        this._lineNumbers = lineNumbers;\n        this._columns = columns;\n    }\n    toString() {\n        return ('[' + this._charCodes.map((s, idx) => (s === 10 /* CharCode.LineFeed */ ? '\\\\n' : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(', ') + ']');\n    }\n    _assertIndex(index, arr) {\n        if (index < 0 || index >= arr.length) {\n            throw new Error(`Illegal index`);\n        }\n    }\n    getElements() {\n        return this._charCodes;\n    }\n    getStartLineNumber(i) {\n        if (i > 0 && i === this._lineNumbers.length) {\n            // the start line number of the element after the last element\n            // is the end line number of the last element\n            return this.getEndLineNumber(i - 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        return this._lineNumbers[i];\n    }\n    getEndLineNumber(i) {\n        if (i === -1) {\n            // the end line number of the element before the first element\n            // is the start line number of the first element\n            return this.getStartLineNumber(i + 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return this._lineNumbers[i] + 1;\n        }\n        return this._lineNumbers[i];\n    }\n    getStartColumn(i) {\n        if (i > 0 && i === this._columns.length) {\n            // the start column of the element after the last element\n            // is the end column of the last element\n            return this.getEndColumn(i - 1);\n        }\n        this._assertIndex(i, this._columns);\n        return this._columns[i];\n    }\n    getEndColumn(i) {\n        if (i === -1) {\n            // the end column of the element before the first element\n            // is the start column of the first element\n            return this.getStartColumn(i + 1);\n        }\n        this._assertIndex(i, this._columns);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return 1;\n        }\n        return this._columns[i] + 1;\n    }\n}\nclass CharChange {\n    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalStartColumn = originalStartColumn;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.originalEndColumn = originalEndColumn;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedStartColumn = modifiedStartColumn;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.modifiedEndColumn = modifiedEndColumn;\n    }\n    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\n        const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n        const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n        const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n        const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n        const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n        const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\n    }\n}\nfunction postProcessCharChanges(rawChanges) {\n    if (rawChanges.length <= 1) {\n        return rawChanges;\n    }\n    const result = [rawChanges[0]];\n    let prevChange = result[0];\n    for (let i = 1, len = rawChanges.length; i < len; i++) {\n        const currChange = rawChanges[i];\n        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n        // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n            // Merge the current change into the previous one\n            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n        }\n        else {\n            // Add the current change\n            result.push(currChange);\n            prevChange = currChange;\n        }\n    }\n    return result;\n}\nclass LineChange {\n    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.charChanges = charChanges;\n    }\n    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\n        let originalStartLineNumber;\n        let originalEndLineNumber;\n        let modifiedStartLineNumber;\n        let modifiedEndLineNumber;\n        let charChanges = undefined;\n        if (diffChange.originalLength === 0) {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n            originalEndLineNumber = 0;\n        }\n        else {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        }\n        if (diffChange.modifiedLength === 0) {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n            modifiedEndLineNumber = 0;\n        }\n        else {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        }\n        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n            // Compute character changes for diff chunks of at most 20 lines...\n            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n            if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {\n                let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n                if (shouldPostProcessCharChanges) {\n                    rawChanges = postProcessCharChanges(rawChanges);\n                }\n                charChanges = [];\n                for (let i = 0, length = rawChanges.length; i < length; i++) {\n                    charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n                }\n            }\n        }\n        return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n    }\n}\nexport class DiffComputer {\n    constructor(originalLines, modifiedLines, opts) {\n        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n        this.originalLines = originalLines;\n        this.modifiedLines = modifiedLines;\n        this.original = new LineSequence(originalLines);\n        this.modified = new LineSequence(modifiedLines);\n        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n    }\n    computeDiff() {\n        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n            // empty original => fast path\n            if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n                return {\n                    quitEarly: false,\n                    changes: []\n                };\n            }\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: 1,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: this.modified.lines.length,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n            // empty modified => fast path\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: this.original.lines.length,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: 1,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n        const rawChanges = diffResult.changes;\n        const quitEarly = diffResult.quitEarly;\n        // The diff is always computed with ignoring trim whitespace\n        // This ensures we get the prettiest diff\n        if (this.shouldIgnoreTrimWhitespace) {\n            const lineChanges = [];\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\n                lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n            }\n            return {\n                quitEarly: quitEarly,\n                changes: lineChanges\n            };\n        }\n        // Need to post-process and introduce changes where the trim whitespace is different\n        // Note that we are looping starting at -1 to also cover the lines before the first change\n        const result = [];\n        let originalLineIndex = 0;\n        let modifiedLineIndex = 0;\n        for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n            const nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\n            const originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\n            const modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\n            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n                const originalLine = this.originalLines[originalLineIndex];\n                const modifiedLine = this.modifiedLines[modifiedLineIndex];\n                if (originalLine !== modifiedLine) {\n                    // These lines differ only in trim whitespace\n                    // Check the leading whitespace\n                    {\n                        let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n                        let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {\n                            const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n                            const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalStartColumn--;\n                            modifiedStartColumn--;\n                        }\n                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n                        }\n                    }\n                    // Check the trailing whitespace\n                    {\n                        let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n                        let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n                        const originalMaxColumn = originalLine.length + 1;\n                        const modifiedMaxColumn = modifiedLine.length + 1;\n                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n                            const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n                            const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalEndColumn++;\n                            modifiedEndColumn++;\n                        }\n                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n                        }\n                    }\n                }\n                originalLineIndex++;\n                modifiedLineIndex++;\n            }\n            if (nextChange) {\n                // Emit the actual change\n                result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n                originalLineIndex += nextChange.originalLength;\n                modifiedLineIndex += nextChange.modifiedLength;\n            }\n        }\n        return {\n            quitEarly: quitEarly,\n            changes: result\n        };\n    }\n    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n            // Merged into previous\n            return;\n        }\n        let charChanges = undefined;\n        if (this.shouldComputeCharChanges) {\n            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\n        }\n        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\n    }\n    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        const len = result.length;\n        if (len === 0) {\n            return false;\n        }\n        const prevChange = result[len - 1];\n        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n            // Don't merge with inserts/deletes\n            return false;\n        }\n        if (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n            prevChange.originalEndLineNumber = originalLineNumber;\n            prevChange.modifiedEndLineNumber = modifiedLineNumber;\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        return false;\n    }\n}\nfunction getFirstNonBlankColumn(txt, defaultValue) {\n    const r = strings.firstNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 1;\n}\nfunction getLastNonBlankColumn(txt, defaultValue) {\n    const r = strings.lastNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 2;\n}\nfunction createContinueProcessingPredicate(maximumRuntime) {\n    if (maximumRuntime === 0) {\n        return () => true;\n    }\n    const startTime = Date.now();\n    return () => {\n        return Date.now() - startTime < maximumRuntime;\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nexport class DiffAlgorithmResult {\n    static trivial(seq1, seq2) {\n        return new DiffAlgorithmResult([new SequenceDiff(new OffsetRange(0, seq1.length), new OffsetRange(0, seq2.length))], false);\n    }\n    static trivialTimedOut(seq1, seq2) {\n        return new DiffAlgorithmResult([new SequenceDiff(new OffsetRange(0, seq1.length), new OffsetRange(0, seq2.length))], true);\n    }\n    constructor(diffs, \n    /**\n     * Indicates if the time out was reached.\n     * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n     */\n    hitTimeout) {\n        this.diffs = diffs;\n        this.hitTimeout = hitTimeout;\n    }\n}\nexport class SequenceDiff {\n    constructor(seq1Range, seq2Range) {\n        this.seq1Range = seq1Range;\n        this.seq2Range = seq2Range;\n    }\n    reverse() {\n        return new SequenceDiff(this.seq2Range, this.seq1Range);\n    }\n    toString() {\n        return `${this.seq1Range} <-> ${this.seq2Range}`;\n    }\n    join(other) {\n        return new SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range));\n    }\n}\nexport class InfiniteTimeout {\n    isValid() {\n        return true;\n    }\n}\nInfiniteTimeout.instance = new InfiniteTimeout();\nexport class DateTimeout {\n    constructor(timeout) {\n        this.timeout = timeout;\n        this.startTime = Date.now();\n        this.valid = true;\n        if (timeout <= 0) {\n            throw new BugIndicatingError('timeout must be positive');\n        }\n    }\n    // Recommendation: Set a log-point `{this.disable()}` in the body\n    isValid() {\n        const valid = Date.now() - this.startTime < this.timeout;\n        if (!valid && this.valid) {\n            this.valid = false; // timeout reached\n            // eslint-disable-next-line no-debugger\n            debugger; // WARNING: Most likely debugging caused the timeout. Call `this.disable()` to continue without timing out.\n        }\n        return this.valid;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class Array2D {\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n        this.array = [];\n        this.array = new Array(width * height);\n    }\n    get(x, y) {\n        return this.array[x + y * this.width];\n    }\n    set(x, y, value) {\n        this.array[x + y * this.width] = value;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { SequenceDiff, InfiniteTimeout, DiffAlgorithmResult } from './diffAlgorithm.js';\nimport { Array2D } from './utils.js';\n/**\n * A O(MN) diffing algorithm that supports a score function.\n * The algorithm can be improved by processing the 2d array diagonally.\n*/\nexport class DynamicProgrammingDiffing {\n    compute(sequence1, sequence2, timeout = InfiniteTimeout.instance, equalityScore) {\n        if (sequence1.length === 0 || sequence2.length === 0) {\n            return DiffAlgorithmResult.trivial(sequence1, sequence2);\n        }\n        /**\n         * lcsLengths.get(i, j): Length of the longest common subsequence of sequence1.substring(0, i + 1) and sequence2.substring(0, j + 1).\n         */\n        const lcsLengths = new Array2D(sequence1.length, sequence2.length);\n        const directions = new Array2D(sequence1.length, sequence2.length);\n        const lengths = new Array2D(sequence1.length, sequence2.length);\n        // ==== Initializing lcsLengths ====\n        for (let s1 = 0; s1 < sequence1.length; s1++) {\n            for (let s2 = 0; s2 < sequence2.length; s2++) {\n                if (!timeout.isValid()) {\n                    return DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);\n                }\n                const horizontalLen = s1 === 0 ? 0 : lcsLengths.get(s1 - 1, s2);\n                const verticalLen = s2 === 0 ? 0 : lcsLengths.get(s1, s2 - 1);\n                let extendedSeqScore;\n                if (sequence1.getElement(s1) === sequence2.getElement(s2)) {\n                    if (s1 === 0 || s2 === 0) {\n                        extendedSeqScore = 0;\n                    }\n                    else {\n                        extendedSeqScore = lcsLengths.get(s1 - 1, s2 - 1);\n                    }\n                    if (s1 > 0 && s2 > 0 && directions.get(s1 - 1, s2 - 1) === 3) {\n                        // Prefer consecutive diagonals\n                        extendedSeqScore += lengths.get(s1 - 1, s2 - 1);\n                    }\n                    extendedSeqScore += (equalityScore ? equalityScore(s1, s2) : 1);\n                }\n                else {\n                    extendedSeqScore = -1;\n                }\n                const newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);\n                if (newValue === extendedSeqScore) {\n                    // Prefer diagonals\n                    const prevLen = s1 > 0 && s2 > 0 ? lengths.get(s1 - 1, s2 - 1) : 0;\n                    lengths.set(s1, s2, prevLen + 1);\n                    directions.set(s1, s2, 3);\n                }\n                else if (newValue === horizontalLen) {\n                    lengths.set(s1, s2, 0);\n                    directions.set(s1, s2, 1);\n                }\n                else if (newValue === verticalLen) {\n                    lengths.set(s1, s2, 0);\n                    directions.set(s1, s2, 2);\n                }\n                lcsLengths.set(s1, s2, newValue);\n            }\n        }\n        // ==== Backtracking ====\n        const result = [];\n        let lastAligningPosS1 = sequence1.length;\n        let lastAligningPosS2 = sequence2.length;\n        function reportDecreasingAligningPositions(s1, s2) {\n            if (s1 + 1 !== lastAligningPosS1 || s2 + 1 !== lastAligningPosS2) {\n                result.push(new SequenceDiff(new OffsetRange(s1 + 1, lastAligningPosS1), new OffsetRange(s2 + 1, lastAligningPosS2)));\n            }\n            lastAligningPosS1 = s1;\n            lastAligningPosS2 = s2;\n        }\n        let s1 = sequence1.length - 1;\n        let s2 = sequence2.length - 1;\n        while (s1 >= 0 && s2 >= 0) {\n            if (directions.get(s1, s2) === 3) {\n                reportDecreasingAligningPositions(s1, s2);\n                s1--;\n                s2--;\n            }\n            else {\n                if (directions.get(s1, s2) === 1) {\n                    s1--;\n                }\n                else {\n                    s2--;\n                }\n            }\n        }\n        reportDecreasingAligningPositions(-1, -1);\n        result.reverse();\n        return new DiffAlgorithmResult(result, false);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { SequenceDiff } from './diffAlgorithm.js';\nexport function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    let result = sequenceDiffs;\n    result = joinSequenceDiffs(sequence1, sequence2, result);\n    result = shiftSequenceDiffs(sequence1, sequence2, result);\n    return result;\n}\nexport function smoothenSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    const result = [];\n    for (const s of sequenceDiffs) {\n        const last = result[result.length - 1];\n        if (!last) {\n            result.push(s);\n            continue;\n        }\n        if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {\n            result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));\n        }\n        else {\n            result.push(s);\n        }\n    }\n    return result;\n}\n/**\n * This function fixes issues like this:\n * ```\n * import { Baz, Bar } from \"foo\";\n * ```\n * <->\n * ```\n * import { Baz, Bar, Foo } from \"foo\";\n * ```\n * Computed diff: [ {Add \",\" after Bar}, {Add \"Foo \" after space} }\n * Improved diff: [{Add \", Foo\" after Bar}]\n */\nexport function joinSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    const result = [];\n    if (sequenceDiffs.length > 0) {\n        result.push(sequenceDiffs[0]);\n    }\n    for (let i = 1; i < sequenceDiffs.length; i++) {\n        const lastResult = result[result.length - 1];\n        const cur = sequenceDiffs[i];\n        if (cur.seq1Range.isEmpty) {\n            let all = true;\n            const length = cur.seq1Range.start - lastResult.seq1Range.endExclusive;\n            for (let i = 1; i <= length; i++) {\n                if (sequence2.getElement(cur.seq2Range.start - i) !== sequence2.getElement(cur.seq2Range.endExclusive - i)) {\n                    all = false;\n                    break;\n                }\n            }\n            if (all) {\n                // Merge previous and current diff\n                result[result.length - 1] = new SequenceDiff(lastResult.seq1Range, new OffsetRange(lastResult.seq2Range.start, cur.seq2Range.endExclusive - length));\n                continue;\n            }\n        }\n        result.push(cur);\n    }\n    return result;\n}\n// align character level diffs at whitespace characters\n// import { IBar } from \"foo\";\n// import { I[Arr, I]Bar } from \"foo\";\n// ->\n// import { [IArr, ]IBar } from \"foo\";\n// import { ITransaction, observableValue, transaction } from 'vs/base/common/observable';\n// import { ITransaction, observable[FromEvent, observable]Value, transaction } from 'vs/base/common/observable';\n// ->\n// import { ITransaction, [observableFromEvent, ]observableValue, transaction } from 'vs/base/common/observable';\n// collectBrackets(level + 1, levelPerBracketType);\n// collectBrackets(level + 1, levelPerBracket[ + 1, levelPerBracket]Type);\n// ->\n// collectBrackets(level + 1, [levelPerBracket + 1, ]levelPerBracketType);\nexport function shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\n        return sequenceDiffs;\n    }\n    for (let i = 0; i < sequenceDiffs.length; i++) {\n        const diff = sequenceDiffs[i];\n        if (diff.seq1Range.isEmpty) {\n            const seq2PrevEndExclusive = (i > 0 ? sequenceDiffs[i - 1].seq2Range.endExclusive : -1);\n            const seq2NextStart = (i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1].seq2Range.start : sequence2.length);\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq2NextStart, seq2PrevEndExclusive);\n        }\n        else if (diff.seq2Range.isEmpty) {\n            const seq1PrevEndExclusive = (i > 0 ? sequenceDiffs[i - 1].seq1Range.endExclusive : -1);\n            const seq1NextStart = (i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1].seq1Range.start : sequence1.length);\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff.reverse(), sequence2, sequence1, seq1NextStart, seq1PrevEndExclusive).reverse();\n        }\n    }\n    return sequenceDiffs;\n}\nfunction shiftDiffToBetterPosition(diff, sequence1, sequence2, seq2NextStart, seq2PrevEndExclusive) {\n    const maxShiftLimit = 20; // To prevent performance issues\n    // don't touch previous or next!\n    let deltaBefore = 1;\n    while (diff.seq2Range.start - deltaBefore > seq2PrevEndExclusive &&\n        sequence2.getElement(diff.seq2Range.start - deltaBefore) ===\n            sequence2.getElement(diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {\n        deltaBefore++;\n    }\n    deltaBefore--;\n    let deltaAfter = 0;\n    while (diff.seq2Range.start + deltaAfter < seq2NextStart &&\n        sequence2.getElement(diff.seq2Range.start + deltaAfter) ===\n            sequence2.getElement(diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {\n        deltaAfter++;\n    }\n    if (deltaBefore === 0 && deltaAfter === 0) {\n        return diff;\n    }\n    // Visualize `[sequence1.text, diff.seq1Range.start + deltaAfter]`\n    // and `[sequence2.text, diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter]`\n    let bestDelta = 0;\n    let bestScore = -1;\n    // find best scored delta\n    for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {\n        const seq2OffsetStart = diff.seq2Range.start + delta;\n        const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\n        const seq1Offset = diff.seq1Range.start + delta;\n        const score = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);\n        if (score > bestScore) {\n            bestScore = score;\n            bestDelta = delta;\n        }\n    }\n    if (bestDelta !== 0) {\n        return new SequenceDiff(diff.seq1Range.delta(bestDelta), diff.seq2Range.delta(bestDelta));\n    }\n    return diff;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { DiffAlgorithmResult, InfiniteTimeout, SequenceDiff } from './diffAlgorithm.js';\n/**\n * An O(ND) diff algorithm that has a quadratic space worst-case complexity.\n*/\nexport class MyersDiffAlgorithm {\n    compute(seq1, seq2, timeout = InfiniteTimeout.instance) {\n        // These are common special cases.\n        // The early return improves performance dramatically.\n        if (seq1.length === 0 || seq2.length === 0) {\n            return DiffAlgorithmResult.trivial(seq1, seq2);\n        }\n        function getXAfterSnake(x, y) {\n            while (x < seq1.length && y < seq2.length && seq1.getElement(x) === seq2.getElement(y)) {\n                x++;\n                y++;\n            }\n            return x;\n        }\n        let d = 0;\n        // V[k]: X value of longest d-line that ends in diagonal k.\n        // d-line: path from (0,0) to (x,y) that uses exactly d non-diagonals.\n        // diagonal k: Set of points (x,y) with x-y = k.\n        const V = new FastInt32Array();\n        V.set(0, getXAfterSnake(0, 0));\n        const paths = new FastArrayNegativeIndices();\n        paths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));\n        let k = 0;\n        loop: while (true) {\n            d++;\n            for (k = -d; k <= d; k += 2) {\n                if (!timeout.isValid()) {\n                    return DiffAlgorithmResult.trivialTimedOut(seq1, seq2);\n                }\n                const maxXofDLineTop = k === d ? -1 : V.get(k + 1); // We take a vertical non-diagonal\n                const maxXofDLineLeft = k === -d ? -1 : V.get(k - 1) + 1; // We take a horizontal non-diagonal (+1 x)\n                const x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seq1.length);\n                const y = x - k;\n                const newMaxX = getXAfterSnake(x, y);\n                V.set(k, newMaxX);\n                const lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);\n                paths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);\n                if (V.get(k) === seq1.length && V.get(k) - k === seq2.length) {\n                    break loop;\n                }\n            }\n        }\n        let path = paths.get(k);\n        const result = [];\n        let lastAligningPosS1 = seq1.length;\n        let lastAligningPosS2 = seq2.length;\n        while (true) {\n            const endX = path ? path.x + path.length : 0;\n            const endY = path ? path.y + path.length : 0;\n            if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {\n                result.push(new SequenceDiff(new OffsetRange(endX, lastAligningPosS1), new OffsetRange(endY, lastAligningPosS2)));\n            }\n            if (!path) {\n                break;\n            }\n            lastAligningPosS1 = path.x;\n            lastAligningPosS2 = path.y;\n            path = path.prev;\n        }\n        result.reverse();\n        return new DiffAlgorithmResult(result, false);\n    }\n}\nclass SnakePath {\n    constructor(prev, x, y, length) {\n        this.prev = prev;\n        this.x = x;\n        this.y = y;\n        this.length = length;\n    }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastInt32Array {\n    constructor() {\n        this.positiveArr = new Int32Array(10);\n        this.negativeArr = new Int32Array(10);\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            if (idx >= this.negativeArr.length) {\n                const arr = this.negativeArr;\n                this.negativeArr = new Int32Array(arr.length * 2);\n                this.negativeArr.set(arr);\n            }\n            this.negativeArr[idx] = value;\n        }\n        else {\n            if (idx >= this.positiveArr.length) {\n                const arr = this.positiveArr;\n                this.positiveArr = new Int32Array(arr.length * 2);\n                this.positiveArr.set(arr);\n            }\n            this.positiveArr[idx] = value;\n        }\n    }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastArrayNegativeIndices {\n    constructor() {\n        this.positiveArr = [];\n        this.negativeArr = [];\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            this.negativeArr[idx] = value;\n        }\n        else {\n            this.positiveArr[idx] = value;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { OffsetRange } from '../core/offsetRange.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { DateTimeout, InfiniteTimeout, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { DynamicProgrammingDiffing } from './algorithms/dynamicProgrammingDiffing.js';\nimport { optimizeSequenceDiffs, smoothenSequenceDiffs } from './algorithms/joinSequenceDiffs.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { LineRangeMapping, LinesDiff, RangeMapping } from './linesDiffComputer.js';\nexport class StandardLinesDiffComputer {\n    constructor() {\n        this.dynamicProgrammingDiffing = new DynamicProgrammingDiffing();\n        this.myersDiffingAlgorithm = new MyersDiffAlgorithm();\n    }\n    computeDiff(originalLines, modifiedLines, options) {\n        const timeout = options.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : new DateTimeout(options.maxComputationTimeMs);\n        const considerWhitespaceChanges = !options.ignoreTrimWhitespace;\n        const perfectHashes = new Map();\n        function getOrCreateHash(text) {\n            let hash = perfectHashes.get(text);\n            if (hash === undefined) {\n                hash = perfectHashes.size;\n                perfectHashes.set(text, hash);\n            }\n            return hash;\n        }\n        const srcDocLines = originalLines.map((l) => getOrCreateHash(l.trim()));\n        const tgtDocLines = modifiedLines.map((l) => getOrCreateHash(l.trim()));\n        const sequence1 = new LineSequence(srcDocLines, originalLines);\n        const sequence2 = new LineSequence(tgtDocLines, modifiedLines);\n        const lineAlignmentResult = (() => {\n            if (sequence1.length + sequence2.length < 1500) {\n                // Use the improved algorithm for small files\n                return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, timeout, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2]\n                    ? modifiedLines[offset2].length === 0\n                        ? 0.1\n                        : 1 + Math.log(1 + modifiedLines[offset2].length)\n                    : 0.99);\n            }\n            return this.myersDiffingAlgorithm.compute(sequence1, sequence2);\n        })();\n        let lineAlignments = lineAlignmentResult.diffs;\n        let hitTimeout = lineAlignmentResult.hitTimeout;\n        lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);\n        const alignments = [];\n        const scanForWhitespaceChanges = (equalLinesCount) => {\n            if (!considerWhitespaceChanges) {\n                return;\n            }\n            for (let i = 0; i < equalLinesCount; i++) {\n                const seq1Offset = seq1LastStart + i;\n                const seq2Offset = seq2LastStart + i;\n                if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {\n                    // This is because of whitespace changes, diff these lines\n                    const characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(seq1Offset, seq1Offset + 1), new OffsetRange(seq2Offset, seq2Offset + 1)), timeout, considerWhitespaceChanges);\n                    for (const a of characterDiffs.mappings) {\n                        alignments.push(a);\n                    }\n                    if (characterDiffs.hitTimeout) {\n                        hitTimeout = true;\n                    }\n                }\n            }\n        };\n        let seq1LastStart = 0;\n        let seq2LastStart = 0;\n        for (const diff of lineAlignments) {\n            assertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);\n            const equalLinesCount = diff.seq1Range.start - seq1LastStart;\n            scanForWhitespaceChanges(equalLinesCount);\n            seq1LastStart = diff.seq1Range.endExclusive;\n            seq2LastStart = diff.seq2Range.endExclusive;\n            const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges);\n            if (characterDiffs.hitTimeout) {\n                hitTimeout = true;\n            }\n            for (const a of characterDiffs.mappings) {\n                alignments.push(a);\n            }\n        }\n        scanForWhitespaceChanges(originalLines.length - seq1LastStart);\n        const changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);\n        return new LinesDiff(changes, hitTimeout);\n    }\n    refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges) {\n        const sourceSlice = new Slice(originalLines, diff.seq1Range, considerWhitespaceChanges);\n        const targetSlice = new Slice(modifiedLines, diff.seq2Range, considerWhitespaceChanges);\n        const diffResult = sourceSlice.length + targetSlice.length < 500\n            ? this.dynamicProgrammingDiffing.compute(sourceSlice, targetSlice, timeout)\n            : this.myersDiffingAlgorithm.compute(sourceSlice, targetSlice, timeout);\n        let diffs = diffResult.diffs;\n        diffs = optimizeSequenceDiffs(sourceSlice, targetSlice, diffs);\n        diffs = coverFullWords(sourceSlice, targetSlice, diffs);\n        diffs = smoothenSequenceDiffs(sourceSlice, targetSlice, diffs);\n        const result = diffs.map((d) => new RangeMapping(sourceSlice.translateRange(d.seq1Range), targetSlice.translateRange(d.seq2Range)));\n        // Assert: result applied on original should be the same as diff applied to original\n        return {\n            mappings: result,\n            hitTimeout: diffResult.hitTimeout,\n        };\n    }\n}\nfunction coverFullWords(sequence1, sequence2, sequenceDiffs) {\n    const additional = [];\n    let lastModifiedWord = undefined;\n    function maybePushWordToAdditional() {\n        if (!lastModifiedWord) {\n            return;\n        }\n        const originalLength1 = lastModifiedWord.s1Range.length - lastModifiedWord.deleted;\n        const originalLength2 = lastModifiedWord.s2Range.length - lastModifiedWord.added;\n        if (originalLength1 !== originalLength2) {\n            // TODO figure out why this happens\n        }\n        if (Math.max(lastModifiedWord.deleted, lastModifiedWord.added) + (lastModifiedWord.count - 1) > originalLength1) {\n            additional.push(new SequenceDiff(lastModifiedWord.s1Range, lastModifiedWord.s2Range));\n        }\n        lastModifiedWord = undefined;\n    }\n    for (const s of sequenceDiffs) {\n        function processWord(s1Range, s2Range) {\n            var _a, _b, _c, _d;\n            if (!lastModifiedWord || !lastModifiedWord.s1Range.containsRange(s1Range) || !lastModifiedWord.s2Range.containsRange(s2Range)) {\n                if (lastModifiedWord && !(lastModifiedWord.s1Range.endExclusive < s1Range.start && lastModifiedWord.s2Range.endExclusive < s2Range.start)) {\n                    const s1Added = OffsetRange.tryCreate(lastModifiedWord.s1Range.endExclusive, s1Range.start);\n                    const s2Added = OffsetRange.tryCreate(lastModifiedWord.s2Range.endExclusive, s2Range.start);\n                    lastModifiedWord.deleted += (_a = s1Added === null || s1Added === void 0 ? void 0 : s1Added.length) !== null && _a !== void 0 ? _a : 0;\n                    lastModifiedWord.added += (_b = s2Added === null || s2Added === void 0 ? void 0 : s2Added.length) !== null && _b !== void 0 ? _b : 0;\n                    lastModifiedWord.s1Range = lastModifiedWord.s1Range.join(s1Range);\n                    lastModifiedWord.s2Range = lastModifiedWord.s2Range.join(s2Range);\n                }\n                else {\n                    maybePushWordToAdditional();\n                    lastModifiedWord = { added: 0, deleted: 0, count: 0, s1Range: s1Range, s2Range: s2Range };\n                }\n            }\n            const changedS1 = s1Range.intersect(s.seq1Range);\n            const changedS2 = s2Range.intersect(s.seq2Range);\n            lastModifiedWord.count++;\n            lastModifiedWord.deleted += (_c = changedS1 === null || changedS1 === void 0 ? void 0 : changedS1.length) !== null && _c !== void 0 ? _c : 0;\n            lastModifiedWord.added += (_d = changedS2 === null || changedS2 === void 0 ? void 0 : changedS2.length) !== null && _d !== void 0 ? _d : 0;\n        }\n        const w1Before = sequence1.findWordContaining(s.seq1Range.start - 1);\n        const w2Before = sequence2.findWordContaining(s.seq2Range.start - 1);\n        const w1After = sequence1.findWordContaining(s.seq1Range.endExclusive);\n        const w2After = sequence2.findWordContaining(s.seq2Range.endExclusive);\n        if (w1Before && w1After && w2Before && w2After && w1Before.equals(w1After) && w2Before.equals(w2After)) {\n            processWord(w1Before, w2Before);\n        }\n        else {\n            if (w1Before && w2Before) {\n                processWord(w1Before, w2Before);\n            }\n            if (w1After && w2After) {\n                processWord(w1After, w2After);\n            }\n        }\n    }\n    maybePushWordToAdditional();\n    const merged = mergeSequenceDiffs(sequenceDiffs, additional);\n    return merged;\n}\nfunction mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {\n    const result = [];\n    while (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {\n        const sd1 = sequenceDiffs1[0];\n        const sd2 = sequenceDiffs2[0];\n        let next;\n        if (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {\n            next = sequenceDiffs1.shift();\n        }\n        else {\n            next = sequenceDiffs2.shift();\n        }\n        if (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {\n            result[result.length - 1] = result[result.length - 1].join(next);\n        }\n        else {\n            result.push(next);\n        }\n    }\n    return result;\n}\nexport function lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines) {\n    const changes = [];\n    for (const g of group(alignments.map(a => getLineRangeMapping(a, originalLines, modifiedLines)), (a1, a2) => a1.originalRange.overlapOrTouch(a2.originalRange)\n        || a1.modifiedRange.overlapOrTouch(a2.modifiedRange))) {\n        const first = g[0];\n        const last = g[g.length - 1];\n        changes.push(new LineRangeMapping(first.originalRange.join(last.originalRange), first.modifiedRange.join(last.modifiedRange), g.map(a => a.innerChanges[0])));\n    }\n    assertFn(() => {\n        return checkAdjacentItems(changes, (m1, m2) => m2.originalRange.startLineNumber - m1.originalRange.endLineNumberExclusive === m2.modifiedRange.startLineNumber - m1.modifiedRange.endLineNumberExclusive &&\n            // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n            m1.originalRange.endLineNumberExclusive < m2.originalRange.startLineNumber &&\n            m1.modifiedRange.endLineNumberExclusive < m2.modifiedRange.startLineNumber);\n    });\n    return changes;\n}\nexport function getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {\n    let lineStartDelta = 0;\n    let lineEndDelta = 0;\n    // rangeMapping describes the edit that replaces `rangeMapping.originalRange` with `newText := getText(modifiedLines, rangeMapping.modifiedRange)`.\n    // original: xxx[ \\n <- this line is not modified\n    // modified: xxx[ \\n\n    if (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length\n        && rangeMapping.originalRange.startColumn - 1 >= originalLines[rangeMapping.originalRange.startLineNumber - 1].length) {\n        lineStartDelta = 1; // +1 is always possible, as startLineNumber < endLineNumber + 1\n    }\n    // original: ]xxx \\n <- this line is not modified\n    // modified: ]xx  \\n\n    if (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1\n        && rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber\n        && rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {\n        lineEndDelta = -1; // We can only do this if the range is not empty yet\n    }\n    const originalLineRange = new LineRange(rangeMapping.originalRange.startLineNumber + lineStartDelta, rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta);\n    const modifiedLineRange = new LineRange(rangeMapping.modifiedRange.startLineNumber + lineStartDelta, rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta);\n    return new LineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);\n}\nfunction* group(items, shouldBeGrouped) {\n    let currentGroup;\n    let last;\n    for (const item of items) {\n        if (last !== undefined && shouldBeGrouped(last, item)) {\n            currentGroup.push(item);\n        }\n        else {\n            if (currentGroup) {\n                yield currentGroup;\n            }\n            currentGroup = [item];\n        }\n        last = item;\n    }\n    if (currentGroup) {\n        yield currentGroup;\n    }\n}\nexport class LineSequence {\n    constructor(trimmedHash, lines) {\n        this.trimmedHash = trimmedHash;\n        this.lines = lines;\n    }\n    getElement(offset) {\n        return this.trimmedHash[offset];\n    }\n    get length() {\n        return this.trimmedHash.length;\n    }\n    getBoundaryScore(length) {\n        const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);\n        const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);\n        return 1000 - (indentationBefore + indentationAfter);\n    }\n}\nfunction getIndentation(str) {\n    let i = 0;\n    while (i < str.length && (str.charCodeAt(i) === 32 /* CharCode.Space */ || str.charCodeAt(i) === 9 /* CharCode.Tab */)) {\n        i++;\n    }\n    return i;\n}\nclass Slice {\n    constructor(lines, lineRange, considerWhitespaceChanges) {\n        // This slice has to have lineRange.length many \\n! (otherwise diffing against an empty slice will be problematic)\n        // (Unless it covers the entire document, in that case the other slice also has to cover the entire document ands it's okay)\n        this.lines = lines;\n        this.considerWhitespaceChanges = considerWhitespaceChanges;\n        this.elements = [];\n        this.firstCharOffsetByLineMinusOne = [];\n        // To account for trimming\n        this.offsetByLine = [];\n        // If the slice covers the end, but does not start at the beginning, we include just the \\n of the previous line.\n        let trimFirstLineFully = false;\n        if (lineRange.start > 0 && lineRange.endExclusive >= lines.length) {\n            lineRange = new OffsetRange(lineRange.start - 1, lineRange.endExclusive);\n            trimFirstLineFully = true;\n        }\n        this.lineRange = lineRange;\n        for (let i = this.lineRange.start; i < this.lineRange.endExclusive; i++) {\n            let line = lines[i];\n            let offset = 0;\n            if (trimFirstLineFully) {\n                offset = line.length;\n                line = '';\n                trimFirstLineFully = false;\n            }\n            else if (!considerWhitespaceChanges) {\n                const trimmedStartLine = line.trimStart();\n                offset = line.length - trimmedStartLine.length;\n                line = trimmedStartLine.trimEnd();\n            }\n            this.offsetByLine.push(offset);\n            for (let i = 0; i < line.length; i++) {\n                this.elements.push(line.charCodeAt(i));\n            }\n            // Don't add an \\n that does not exist in the document.\n            if (i < lines.length - 1) {\n                this.elements.push('\\n'.charCodeAt(0));\n                this.firstCharOffsetByLineMinusOne[i - this.lineRange.start] = this.elements.length;\n            }\n        }\n        // To account for the last line\n        this.offsetByLine.push(0);\n    }\n    toString() {\n        return `Slice: \"${this.text}\"`;\n    }\n    get text() {\n        return [...this.elements].map(e => String.fromCharCode(e)).join('');\n    }\n    getElement(offset) {\n        return this.elements[offset];\n    }\n    get length() {\n        return this.elements.length;\n    }\n    getBoundaryScore(length) {\n        //   a   b   c   ,           d   e   f\n        // 11  0   0   12  15  6   13  0   0   11\n        const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n        const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n        if (prevCategory === 6 /* CharBoundaryCategory.LineBreakCR */ && nextCategory === 7 /* CharBoundaryCategory.LineBreakLF */) {\n            // don't break between \\r and \\n\n            return 0;\n        }\n        let score = 0;\n        if (prevCategory !== nextCategory) {\n            score += 10;\n            if (nextCategory === 1 /* CharBoundaryCategory.WordUpper */) {\n                score += 1;\n            }\n        }\n        score += getCategoryBoundaryScore(prevCategory);\n        score += getCategoryBoundaryScore(nextCategory);\n        return score;\n    }\n    translateOffset(offset) {\n        // find smallest i, so that lineBreakOffsets[i] <= offset using binary search\n        if (this.lineRange.isEmpty) {\n            return new Position(this.lineRange.start + 1, 1);\n        }\n        let i = 0;\n        let j = this.firstCharOffsetByLineMinusOne.length;\n        while (i < j) {\n            const k = Math.floor((i + j) / 2);\n            if (this.firstCharOffsetByLineMinusOne[k] > offset) {\n                j = k;\n            }\n            else {\n                i = k + 1;\n            }\n        }\n        const offsetOfPrevLineBreak = i === 0 ? 0 : this.firstCharOffsetByLineMinusOne[i - 1];\n        return new Position(this.lineRange.start + i + 1, offset - offsetOfPrevLineBreak + 1 + this.offsetByLine[i]);\n    }\n    translateRange(range) {\n        return Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));\n    }\n    /**\n     * Finds the word that contains the character at the given offset\n     */\n    findWordContaining(offset) {\n        if (offset < 0 || offset >= this.elements.length) {\n            return undefined;\n        }\n        if (!isWordChar(this.elements[offset])) {\n            return undefined;\n        }\n        // find start\n        let start = offset;\n        while (start > 0 && isWordChar(this.elements[start - 1])) {\n            start--;\n        }\n        // find end\n        let end = offset;\n        while (end < this.elements.length && isWordChar(this.elements[end])) {\n            end++;\n        }\n        return new OffsetRange(start, end);\n    }\n}\nfunction isWordChar(charCode) {\n    return charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */\n        || charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */\n        || charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */;\n}\nconst score = {\n    [0 /* CharBoundaryCategory.WordLower */]: 0,\n    [1 /* CharBoundaryCategory.WordUpper */]: 0,\n    [2 /* CharBoundaryCategory.WordNumber */]: 0,\n    [3 /* CharBoundaryCategory.End */]: 10,\n    [4 /* CharBoundaryCategory.Other */]: 2,\n    [5 /* CharBoundaryCategory.Space */]: 3,\n    [6 /* CharBoundaryCategory.LineBreakCR */]: 10,\n    [7 /* CharBoundaryCategory.LineBreakLF */]: 10,\n};\nfunction getCategoryBoundaryScore(category) {\n    return score[category];\n}\nfunction getCategory(charCode) {\n    if (charCode === 10 /* CharCode.LineFeed */) {\n        return 7 /* CharBoundaryCategory.LineBreakLF */;\n    }\n    else if (charCode === 13 /* CharCode.CarriageReturn */) {\n        return 6 /* CharBoundaryCategory.LineBreakCR */;\n    }\n    else if (isSpace(charCode)) {\n        return 5 /* CharBoundaryCategory.Space */;\n    }\n    else if (charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */) {\n        return 0 /* CharBoundaryCategory.WordLower */;\n    }\n    else if (charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */) {\n        return 1 /* CharBoundaryCategory.WordUpper */;\n    }\n    else if (charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */) {\n        return 2 /* CharBoundaryCategory.WordNumber */;\n    }\n    else if (charCode === -1) {\n        return 3 /* CharBoundaryCategory.End */;\n    }\n    else {\n        return 4 /* CharBoundaryCategory.Other */;\n    }\n}\nfunction isSpace(charCode) {\n    return charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SmartLinesDiffComputer } from './smartLinesDiffComputer.js';\nimport { StandardLinesDiffComputer } from './standardLinesDiffComputer.js';\nexport const linesDiffComputers = {\n    legacy: new SmartLinesDiffComputer(),\n    advanced: new StandardLinesDiffComputer(),\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class InternalEditorAction {\n    constructor(id, label, alias, precondition, run, contextKeyService) {\n        this.id = id;\n        this.label = label;\n        this.alias = alias;\n        this._precondition = precondition;\n        this._run = run;\n        this._contextKeyService = contextKeyService;\n    }\n    isSupported() {\n        return this._contextKeyService.contextMatchesRules(this._precondition);\n    }\n    run(args) {\n        if (!this.isSupported()) {\n            return Promise.resolve(undefined);\n        }\n        return this._run(args);\n    }\n}\n","/**\n * The type of the `IEditor`.\n */\nexport const EditorType = {\n    ICodeEditor: 'vs.editor.ICodeEditor',\n    IDiffEditor: 'vs.editor.IDiffEditor'\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../nls.js';\nimport { RawContextKey } from '../../platform/contextkey/common/contextkey.js';\nexport var EditorContextKeys;\n(function (EditorContextKeys) {\n    EditorContextKeys.editorSimpleInput = new RawContextKey('editorSimpleInput', false, true);\n    /**\n     * A context key that is set when the editor's text has focus (cursor is blinking).\n     * Is false when focus is in simple editor widgets (repl input, scm commit input).\n     */\n    EditorContextKeys.editorTextFocus = new RawContextKey('editorTextFocus', false, nls.localize('editorTextFocus', \"Whether the editor text has focus (cursor is blinking)\"));\n    /**\n     * A context key that is set when the editor's text or an editor's widget has focus.\n     */\n    EditorContextKeys.focus = new RawContextKey('editorFocus', false, nls.localize('editorFocus', \"Whether the editor or an editor widget has focus (e.g. focus is in the find widget)\"));\n    /**\n     * A context key that is set when any editor input has focus (regular editor, repl input...).\n     */\n    EditorContextKeys.textInputFocus = new RawContextKey('textInputFocus', false, nls.localize('textInputFocus', \"Whether an editor or a rich text input has focus (cursor is blinking)\"));\n    EditorContextKeys.readOnly = new RawContextKey('editorReadonly', false, nls.localize('editorReadonly', \"Whether the editor is read only\"));\n    EditorContextKeys.inDiffEditor = new RawContextKey('inDiffEditor', false, nls.localize('inDiffEditor', \"Whether the context is a diff editor\"));\n    EditorContextKeys.isEmbeddedDiffEditor = new RawContextKey('isEmbeddedDiffEditor', false, nls.localize('isEmbeddedDiffEditor', \"Whether the context is an embedded diff editor\"));\n    EditorContextKeys.columnSelection = new RawContextKey('editorColumnSelection', false, nls.localize('editorColumnSelection', \"Whether `editor.columnSelection` is enabled\"));\n    EditorContextKeys.writable = EditorContextKeys.readOnly.toNegated();\n    EditorContextKeys.hasNonEmptySelection = new RawContextKey('editorHasSelection', false, nls.localize('editorHasSelection', \"Whether the editor has text selected\"));\n    EditorContextKeys.hasOnlyEmptySelection = EditorContextKeys.hasNonEmptySelection.toNegated();\n    EditorContextKeys.hasMultipleSelections = new RawContextKey('editorHasMultipleSelections', false, nls.localize('editorHasMultipleSelections', \"Whether the editor has multiple selections\"));\n    EditorContextKeys.hasSingleSelection = EditorContextKeys.hasMultipleSelections.toNegated();\n    EditorContextKeys.tabMovesFocus = new RawContextKey('editorTabMovesFocus', false, nls.localize('editorTabMovesFocus', \"Whether `Tab` will move focus out of the editor\"));\n    EditorContextKeys.tabDoesNotMoveFocus = EditorContextKeys.tabMovesFocus.toNegated();\n    EditorContextKeys.isInWalkThroughSnippet = new RawContextKey('isInEmbeddedEditor', false, true);\n    EditorContextKeys.canUndo = new RawContextKey('canUndo', false, true);\n    EditorContextKeys.canRedo = new RawContextKey('canRedo', false, true);\n    EditorContextKeys.hoverVisible = new RawContextKey('editorHoverVisible', false, nls.localize('editorHoverVisible', \"Whether the editor hover is visible\"));\n    EditorContextKeys.hoverFocused = new RawContextKey('editorHoverFocused', false, nls.localize('editorHoverFocused', \"Whether the editor hover is focused\"));\n    EditorContextKeys.stickyScrollFocused = new RawContextKey('stickyScrollFocused', false, nls.localize('stickyScrollFocused', \"Whether the sticky scroll is focused\"));\n    EditorContextKeys.stickyScrollVisible = new RawContextKey('stickyScrollVisible', false, nls.localize('stickyScrollVisible', \"Whether the sticky scroll is visible\"));\n    EditorContextKeys.standaloneColorPickerVisible = new RawContextKey('standaloneColorPickerVisible', false, nls.localize('standaloneColorPickerVisible', \"Whether the standalone color picker is visible\"));\n    EditorContextKeys.standaloneColorPickerFocused = new RawContextKey('standaloneColorPickerFocused', false, nls.localize('standaloneColorPickerFocused', \"Whether the standalone color picker is focused\"));\n    /**\n     * A context key that is set when an editor is part of a larger editor, like notebooks or\n     * (future) a diff editor\n     */\n    EditorContextKeys.inCompositeEditor = new RawContextKey('inCompositeEditor', undefined, nls.localize('inCompositeEditor', \"Whether the editor is part of a larger editor (e.g. notebooks)\"));\n    EditorContextKeys.notInCompositeEditor = EditorContextKeys.inCompositeEditor.toNegated();\n    // -- mode context keys\n    EditorContextKeys.languageId = new RawContextKey('editorLangId', '', nls.localize('editorLangId', \"The language identifier of the editor\"));\n    EditorContextKeys.hasCompletionItemProvider = new RawContextKey('editorHasCompletionItemProvider', false, nls.localize('editorHasCompletionItemProvider', \"Whether the editor has a completion item provider\"));\n    EditorContextKeys.hasCodeActionsProvider = new RawContextKey('editorHasCodeActionsProvider', false, nls.localize('editorHasCodeActionsProvider', \"Whether the editor has a code actions provider\"));\n    EditorContextKeys.hasCodeLensProvider = new RawContextKey('editorHasCodeLensProvider', false, nls.localize('editorHasCodeLensProvider', \"Whether the editor has a code lens provider\"));\n    EditorContextKeys.hasDefinitionProvider = new RawContextKey('editorHasDefinitionProvider', false, nls.localize('editorHasDefinitionProvider', \"Whether the editor has a definition provider\"));\n    EditorContextKeys.hasDeclarationProvider = new RawContextKey('editorHasDeclarationProvider', false, nls.localize('editorHasDeclarationProvider', \"Whether the editor has a declaration provider\"));\n    EditorContextKeys.hasImplementationProvider = new RawContextKey('editorHasImplementationProvider', false, nls.localize('editorHasImplementationProvider', \"Whether the editor has an implementation provider\"));\n    EditorContextKeys.hasTypeDefinitionProvider = new RawContextKey('editorHasTypeDefinitionProvider', false, nls.localize('editorHasTypeDefinitionProvider', \"Whether the editor has a type definition provider\"));\n    EditorContextKeys.hasHoverProvider = new RawContextKey('editorHasHoverProvider', false, nls.localize('editorHasHoverProvider', \"Whether the editor has a hover provider\"));\n    EditorContextKeys.hasDocumentHighlightProvider = new RawContextKey('editorHasDocumentHighlightProvider', false, nls.localize('editorHasDocumentHighlightProvider', \"Whether the editor has a document highlight provider\"));\n    EditorContextKeys.hasDocumentSymbolProvider = new RawContextKey('editorHasDocumentSymbolProvider', false, nls.localize('editorHasDocumentSymbolProvider', \"Whether the editor has a document symbol provider\"));\n    EditorContextKeys.hasReferenceProvider = new RawContextKey('editorHasReferenceProvider', false, nls.localize('editorHasReferenceProvider', \"Whether the editor has a reference provider\"));\n    EditorContextKeys.hasRenameProvider = new RawContextKey('editorHasRenameProvider', false, nls.localize('editorHasRenameProvider', \"Whether the editor has a rename provider\"));\n    EditorContextKeys.hasSignatureHelpProvider = new RawContextKey('editorHasSignatureHelpProvider', false, nls.localize('editorHasSignatureHelpProvider', \"Whether the editor has a signature help provider\"));\n    EditorContextKeys.hasInlayHintsProvider = new RawContextKey('editorHasInlayHintsProvider', false, nls.localize('editorHasInlayHintsProvider', \"Whether the editor has an inline hints provider\"));\n    // -- mode context keys: formatting\n    EditorContextKeys.hasDocumentFormattingProvider = new RawContextKey('editorHasDocumentFormattingProvider', false, nls.localize('editorHasDocumentFormattingProvider', \"Whether the editor has a document formatting provider\"));\n    EditorContextKeys.hasDocumentSelectionFormattingProvider = new RawContextKey('editorHasDocumentSelectionFormattingProvider', false, nls.localize('editorHasDocumentSelectionFormattingProvider', \"Whether the editor has a document selection formatting provider\"));\n    EditorContextKeys.hasMultipleDocumentFormattingProvider = new RawContextKey('editorHasMultipleDocumentFormattingProvider', false, nls.localize('editorHasMultipleDocumentFormattingProvider', \"Whether the editor has multiple document formatting providers\"));\n    EditorContextKeys.hasMultipleDocumentSelectionFormattingProvider = new RawContextKey('editorHasMultipleDocumentSelectionFormattingProvider', false, nls.localize('editorHasMultipleDocumentSelectionFormattingProvider', \"Whether the editor has multiple document selection formatting providers\"));\n})(EditorContextKeys || (EditorContextKeys = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst editorFeatures = [];\n/**\n * Registers an editor feature. Editor features will be instantiated only once, as soon as\n * the first code editor is instantiated.\n */\nexport function registerEditorFeature(ctor) {\n    editorFeatures.push(ctor);\n}\nexport function getEditorFeatures() {\n    return editorFeatures.slice(0);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class EditorTheme {\n    get type() {\n        return this._theme.type;\n    }\n    get value() {\n        return this._theme;\n    }\n    constructor(theme) {\n        this._theme = theme;\n    }\n    update(theme) {\n        this._theme = theme;\n    }\n    getColor(color) {\n        return this._theme.getColor(color);\n    }\n}\n"],"names":["CharacterClassifier","_defaultValue","_classCallCheck","defaultValue","toUint8","this","_asciiMap","_createAsciiMap","_map","Map","_createClass","key","value","charCode","_value","set","get","fill","clear","asciiMap","Uint8Array","CharacterSet","_actual","CursorColumns","codePoint","visibleColumn","tabSize","nextRenderTabStop","strings","lineContent","column","textLen","Math","min","length","text","substring","iterator","result","eol","offset","nextGraphemeLength","_nextVisibleColumn","lineContentLength","beforeVisibleColumn","beforeColumn","afterVisibleColumn","afterColumn","indentSize","max","EditOperation","position","range","Range","lineNumber","forceMoveMarkers","editorLineHighlight","registerColor","dark","light","hcDark","hcLight","nls","editorLineHighlightBorder","contrastBorder","editorCursorForeground","activeContrastBorder","editorFindMatchHighlight","Color","black","white","editorCursorBackground","editorWhitespaces","editorIndentGuides","editorActiveIndentGuides","editorLineNumbers","deprecatedEditorActiveLineNumber","editorDimmedLineNumber","editorOverviewRulerBorder","lightgrey","editorOverviewRulerBackground","editorUnnecessaryCodeOpacity","editorBackground","fromHex","transparent","rulerRangeDefault","RGBA","overviewRulerRangeHighlight","overviewRulerError","overviewRulerWarning","editorWarningForeground","editorWarningBorder","overviewRulerInfo","editorInfoForeground","editorInfoBorder","editorBracketHighlightingForeground1","editorBracketHighlightingForeground2","editorBracketHighlightingForeground3","editorBracketHighlightingForeground4","editorBracketHighlightingForeground5","editorBracketHighlightingForeground6","editorBracketHighlightingUnexpectedBracketForeground","editorBracketPairGuideBackground1","editorBracketPairGuideBackground2","editorBracketPairGuideBackground3","editorBracketPairGuideBackground4","editorBracketPairGuideBackground5","editorBracketPairGuideBackground6","editorBracketPairGuideActiveBackground1","editorBracketPairGuideActiveBackground2","editorBracketPairGuideActiveBackground3","editorBracketPairGuideActiveBackground4","editorBracketPairGuideActiveBackground5","editorBracketPairGuideActiveBackground6","registerThemingParticipant","theme","collector","background","getColor","lineHighlight","imeBackground","isTransparent","addRule","concat","countEOL","eolCount","firstLineLength","lastLineStart","i","len","chr","charCodeAt","normalizeIndentation","str","insertSpaces","firstNonWhitespaceIndex","spacesCnt","charAt","nextIndentTabStop","tabsCnt","floor","_normalizeIndentationFromWhitespace","LineRange","startLineNumber","endLineNumberExclusive","BugIndicatingError","other","b","isEmpty","Number","MAX_SAFE_INTEGER","endLineNumber","lineRanges","join","lineRanges1","lineRanges2","i1","i2","current","next","lineRange1","lineRange2","push","OffsetRange","start","endExclusive","toString","end","sortedRanges","j","splice","Position","newLineNumber","arguments","undefined","newColumn","deltaLineNumber","deltaColumn","with","equals","isBefore","isBeforeOrEqual","a","aLineNumber","bLineNumber","pos","obj","startColumn","endColumn","containsPosition","containsRange","strictContainsRange","plusRange","intersectRanges","equalsRange","getEndPosition","getStartPosition","collapseToStart","collapseToEnd","lineCount","otherRange","resultStartLineNumber","resultStartColumn","resultEndLineNumber","resultEndColumn","otherStartLineNumber","otherStartColumn","otherEndLineNumber","otherEndColumn","aStartLineNumber","bStartLineNumber","aStartColumn","bStartColumn","aEndLineNumber","bEndLineNumber","RGBA8","r","g","_rgba8Brand","_clamp","c","Empty","Selection","_Range","_inherits","_super","_createSuper","selectionStartLineNumber","selectionStartColumn","positionLineNumber","positionColumn","_this","call","selectionsEqual","getDirection","direction","sel","_utf16LE_TextDecoder","_utf16BE_TextDecoder","_platformTextDecoder","getUTF16LE_TextDecoder","TextDecoder","getPlatformTextDecoder","platform","decodeUTF16LE","source","view","Uint16Array","buffer","resultLen","String","fromCharCode","compatDecodeUTF16LE","decode","StringBuilder","capacity","_capacity","_buffer","_completedStrings","_bufferLength","_flushBuffer","_buildBuffer","bufferString","remainingSpace","strLen","escapeNewLine","replace","TextChange","oldPosition","oldText","newPosition","newText","_writeStringSize","_writeString","dest","_readString","compressConsecutiveTextChanges","prevEdits","currEdits","TextChangeCompressor","compress","_prevEdits","_currEdits","_result","_resultLen","_prevLen","_prevDeltaOffset","_currLen","_currDeltaOffset","prevIndex","currIndex","prevEdit","_getPrev","currEdit","_getCurr","oldEnd","_acceptCurr","newEnd","_acceptPrev","_TextChangeCompressor","_splitCurr","_TextChangeCompressor2","_slicedToArray","e1","e2","_TextChangeCompressor3","_splitPrev","_TextChangeCompressor4","mergePrev","mergeCurr","_TextChangeCompressor5","oldLength","_TextChangeCompressor6","_TextChangeCompressor7","newLength","_TextChangeCompressor8","merged","_merge","_removeNoOps","_rebaseCurr","_rebasePrev","prevDeltaOffset","currDeltaOffset","edit","preText","substr","postText","edits","prev","curr","EDITOR_MODEL_DEFAULTS","detectIndentation","trimAutoWhitespace","largeFileOptimizations","bracketPairColorizationOptions","enabled","independentColorPoolPerBracketType","WordCharacterClassifier","_CharacterClassifier","wordSeparators","getMapForWordSeparators","computeFn","cache","input","hasOwnProperty","once","USUAL_WORD_SEPARATORS","DEFAULT_WORD_REGEXP","_step","allowInWords","_iterator","_createForOfIteratorHelper","s","n","done","sep","indexOf","err","e","f","RegExp","createWordRegExp","ensureValidWordDefinition","wordDefinition","global","flags","ignoreCase","multiline","unicode","lastIndex","_defaultConfig","LinkedList","getWordAtText","textOffset","config","Iterable","first","maxLen","t1","Date","now","prevRegexIndex","match","timeBudget","regexIndex","windowSize","thisMatch","_findRegexMatchEnclosingPosition","word","index","stopPos","exec","matchIndex","unshift","Cursor","context","_selTrackedRange","_trackSelection","_setState","SingleCursorState","_removeTrackedRange","_updateTrackedRange","model","_setTrackedRange","modelState","selection","CursorState","viewState","_getTrackedRange","fromRange","_validateViewState","viewModel","selectionStart","validateRange","selectionStartLeftoverVisibleColumns","validatePosition","leftoverVisibleColumns","selectionStartKind","coordinatesConverter","convertViewRangeToModelRange","convertViewPositionToModelPosition","viewSelectionStart","validateViewRange","viewPosition","validateViewPosition","viewSelectionStart1","convertModelPositionToViewPosition","viewSelectionStart2","cacheInput","cacheOutput","normalizePosition","sStartPosition","sEndPosition","validPosition","validSStartPosition","_validatePositionWithCache","validSEndPosition","fromPositions","CursorCollection","cursors","lastAddedCursorIndex","dispose","_step2","_iterator2","startTrackingSelection","_step3","_iterator3","stopTrackingSelection","_step4","_iterator4","ensureValidState","map","readSelectionFromMarkers","asCursorState","findMinBy","compareBy","compare","findLastMaxBy","selections","setStates","fromModelSelections","states","setState","_setSecondaryStates","slice","secondaryStates","secondaryCursorsLength","secondaryStatesLength","createCnt","_addSecondaryCursor","removeCnt","_removeSecondaryCursor","removeIndex","sortedCursors","sort","compareRangesUsingStarts","sortedCursorIndex","currentSelection","nextSelection","cursorConfig","multiCursorMergeOverlapping","winnerSortedCursorIndex","looserSortedCursorIndex","looserIndex","winnerIndex","looserSelection","winnerSelection","equalsSelection","resultingRange","looserSelectionIsLTR","winnerSelectionIsLTR","resultingSelectionIsLTR","resultingSelection","resultingState","fromModelSelection","_step5","_iterator5","sortedCursor","CursorContext","_cursorContextBrand","CursorsController","_Disposable","_model","_knownModelVersionId","getVersionId","_viewModel","_coordinatesConverter","_cursors","_hasFocus","_isHandling","_compositionState","_columnSelectData","_autoClosedActions","_prevEditOperationType","_get","_getPrototypeOf","prototype","updateContext","eventsCollector","getCursorStates","hasFocus","getSelections","autoClosedAction","isValid","getPrimaryCursor","getLastAddedCursorIndex","getAll","reason","reachedMaxCursorCount","multiCursorLimit","oldState","CursorModelState","from","normalize","_validateAutoClosedActions","_emitStateChangedIfNecessary","columnSelectData","minimalReveal","verticalType","revealHorizontal","scrollType","viewPositions","getViewPositions","revealViewRange","revealViewSelections","getViewSelections","emitViewEvent","ViewRevealRangeRequestEvent","inSelectionMode","desiredSelections","state","revealPrimary","event","ModelInjectedTextChangedEvent","rawContentChangedEvent","versionId","hadFlushEvent","containsEvent","cursorState","isUndoing","isRedoing","selectionsFromMarkers","getTopMostViewPosition","getBottomMostViewPosition","primaryCursor","isReal","fromViewLineNumber","fromViewVisualColumn","visibleColumnFromColumn","toViewLineNumber","toViewVisualColumn","type","autoClosedCharactersRanges","autoClosedEnclosingRanges","autoClosedCharactersDeltaDecorations","autoClosedEnclosingDeltaDecorations","options","description","inlineClassName","stickiness","autoClosedCharactersDecorations","deltaDecorations","autoClosedEnclosingDecorations","AutoClosedAction","opResult","shouldPushStackElementBefore","pushStackElement","CommandExecutor","executeCommands","commands","_interpretCommandResult","command","TypeWithAutoClosingCommand","enclosingRange","closeCharacterRange","_pushAutoClosedAction","shouldPushStackElementAfter","setSelections","newState","viewSelections","ViewCursorStateChangedEvent","some","newCursorState","oldSelections","oldModelVersionId","modelVersionId","emitOutgoingEvent","CursorStateChangedEvent","indices","m","closeChar","autoClosingPairsCandidates","autoClosingPairs","autoClosingPairsCloseSingleChar","openChar","open","closeCharIndex","openCharIndex","lastIndexOf","cursorStateComputer","_this2","autoClosingIndices","_findAutoClosingPairs","_isTracked","pushEditOperations","undoEdits","_autoClosingIndices$i","openCharInnerIndex","closeCharInnerIndex","undoEdit","callback","cursorChangeReason","readOnly","stopTrackingSelections","onUnexpectedError","startTrackingSelections","getAllAutoClosedCharacters","CompositionState","_this3","compositionOutcome","deduceOutcome","_executeEdit","_executeEditOperation","TypeOperations","compositionEndWithInterceptors","getAutoClosedCharacters","_this4","charLength","typeWithInterceptors","typeWithoutInterceptors","replacePrevCharCnt","replaceNextCharCnt","positionDelta","_this5","compositionType","newSelections","getPosition","pasteOnNewLine","multicursorText","_this6","paste","_this7","DeleteOperations","cut","_this8","killSecondaryCursors","EditOperationResult","_this9","Disposable","cursor","_autoClosedCharactersDecorations","_autoClosedEnclosingDecorations","decorationRange","getDecorationRange","enclosingRanges","autoClosedActions","autoClosedCharacters","getAutoClosedCharactersRanges","selectionsBefore","ctx","trackedRanges","trackedRangesDirection","_innerExecuteCommands","_arrayIsEmpty","commandsData","_getEditOperations","operations","rawOperations","loserCursorsMap","_getLoserCursorMap","console","warn","filteredOperations","identifier","major","hadTrackedEditOperation","selectionsAfter","inverseEditOperations","groupedInverseEditOperations","op","minorBasedSorter","minor","cursorSelections","_loop","_i3","computeCursorState","getInverseEditOperations","getTrackedSelection","id","idx","parseInt","losingCursors","losingCursorIndex","_i4","_losingCursors","losingCursor","_getEditOperationsFromCommand","majorIdentifier","operationMinor","addEditOperation","isAutoWhitespaceEdit","insertsAutoWhitespace","editOperationBuilder","addTrackedEditOperation","trackSelection","_selection","trackPreviousOnEmpty","liftSelection","maxLineColumn","getLineMaxColumn","l","getEditOperations","compareRangesUsingEnds","previousOp","currentOp","loserMajor","CompositionLineState","startSelection","endSelection","textModel","_original","_capture","_deduceOutcome","getLineContent","original","commonPrefix","commonSuffix","deletedText","insertedText","CompositionOutcome","AtomicTabMoveOperations","lineLength","prevTabStopPosition","prevTabStopVisibleColumn","left","_AtomicTabMoveOperati","whitespaceVisibleColumn","_AtomicTabMoveOperati2","currentVisibleColumn","targetVisibleColumn","ColumnSelection","fromLineNumber","fromVisibleColumn","toLineNumber","toVisibleColumn","abs","reversed","isRTL","isLTR","columnFromVisibleColumn","visibleStartColumn","visibleEndColumn","maxColumn","viewStates","fromVisualColumn","toVisualColumn","prevColumnSelectData","columnSelect","maxVisualViewColumn","minViewLineNumber","maxViewLineNumber","lineMaxViewColumn","lineMaxVisualViewColumn","isPaged","linesCount","pageSize","getLineCount","prevEditOperationType","deleteSelection","rightOfPosition","MoveOperations","right","ReplaceCommand","autoClosingDelete","autoClosingBrackets","autoClosingQuotes","autoClosingPairsOpen","lineText","character","autoClosingPairCandidates","isQuote","afterCharacter","foundAutoClosingPair","autoClosingPairCandidate","close","found","lenJ","autoClosedCharacter","isAutoClosingPairDelete","autoClosingPairsOpenByEnd","_runAutoClosingPairDelete","deleteRange","getDeleteRange","useTabStops","lastIndentationColumn","prevIndentTabStop","toColumn","getPositionAfterDeleteLeft","newLine","lastCutRange","emptySelectionClipboard","CursorMove","CursorMoveCommands","useLogicalLine","fromModelState","translateDown","fromViewState","translateUp","_moveToLineStart","currentViewStateColumn","isFirstLineOfWrappedLine","currentViewStatelineNumber","firstNonBlankColumn","getLineFirstNonWhitespaceColumn","_moveToLineStartByModel","_moveToLineStartByView","moveToBeginningOfLine","sticky","_moveToLineEnd","viewStatePosition","viewModelMaxColumn","isEndOfViewLine","modelStatePosition","modelMaxColumn","isEndLineOfWrappedLine","_moveToLineEndByModel","_moveToLineEndByView","moveToEndOfLine","moveToBeginningOfBuffer","moveToEndOfBuffer","_position","_viewPosition","selectToLineNumber","selectToColumn","enteringLineNumber","move","selectToViewLineNumber","selectToViewColumn","endPositionOfSelectionStart","WordOperations","hasSelection","line","unit","_moveHalfLineLeft","_moveLeft","_moveHalfLineRight","_moveRight","_moveUpByViewLines","_moveUpByModelLines","_moveDownByViewLines","_moveDownByModelLines","moveToPrevBlankLine","moveToNextBlankLine","_moveToViewMinColumn","_moveToViewFirstNonWhitespaceColumn","_moveToViewCenterColumn","_moveToViewMaxColumn","_moveToViewLastNonWhitespaceColumn","visibleViewRange","getCompletelyVisibleViewRange","visibleModelRange","modelLineNumber","_firstLineNumberInRange","modelColumn","_moveToModelPosition","_lastLineNumberInRange","round","findPositionInViewportIfOutside","newViewLineNumber","viewLineNumber","vertical","count","getLineMinColumn","noOfColumns","moveLeft","halfLine","moveRight","moveDown","moveUp","toViewColumn","toModelLineNumber","toModelColumn","viewColumn","_moveToViewPosition","getLineLastNonWhitespaceColumn","args","name","constraint","arg","types","cursorMoveArg","to","select","by","schema","RawDirection","Left","Right","Up","Down","PrevBlankLine","NextBlankLine","WrappedLineStart","WrappedLineFirstNonWhitespaceCharacter","WrappedLineColumnCenter","WrappedLineEnd","WrappedLineLastNonWhitespaceCharacter","ViewPortTop","ViewPortCenter","ViewPortBottom","ViewPortIfOutside","RawUnit","Line","WrappedLine","Character","HalfLine","parse","CursorPosition","_cursorPositionBrand","delta","getLineIndentColumn","minColumn","atomicPosition","leftPosition","stickyTabStops","leftPositionAtomicSoftTabs","normalizedPos","clipPositionColumn","p","clipRange","rightPosition","rightPositionAtomicSoftTabs","allowMoveOnEdgeLine","normalizationAffinity","wasOnFirstPosition","wasOnLastPosition","wasAtEdgePosition","allowMoveOnLastLine","down","allowMoveOnFirstLine","up","_isBlankLine","lastLineNumber","lastColumn","ShiftCommand","isUnshift","autoIndent","languageConfigurationService","indentation","shiftIndent","unshiftIndent","typeSelection","ReplaceCommandThatPreservesSelection","multiCursorPaste","lines","distributedPaste","_distributePasteToCursors","_distributedPaste","_simplePaste","action","expectedIndentAction","getInheritIndentForLine","expectedEnterAction","getEnterAction","appendText","IndentAction","Indent","Outdent","typeText","test","tokenization","isCheapToTokenize","goodIndent","_goodIndentForLine","possibleTypeText","startsWith","_replaceJumpToNextIndent","lineMaxColumn","_compositionType","shouldPushStackElementBetween","getValueInRange","ReplaceCommandWithOffsetCursorState","keepPosition","ReplaceCommandWithoutChangingPosition","_typeCommand","indentAction","None","IndentOutdent","normalIndent","increasedIndent","actualIndentation","ir","getIndentForEnter","indent","oldEndViewColumn","oldEndColumn","newLineContent","firstNonWhitespace","setEndPosition","afterEnter","ceil","ch","currentIndentation","getIndentationAtPosition","getIndentActionForType","autoClosingOvertype","has","chIsQuote","lineAfter","nextChar","potentialStartingBraces","autoClosingPairsOpenByStart","potentialClosingBraces","autoClosingPairsCloseByStart","isBeforeStartingBrace","x","isBeforeClosingBrace","positions","candidates","candidate","candidateIsMatch","pair","lastChar","autoClosingPairsCloseByEnd","includes","endsWith","chIsAlreadyTyped","autoCloseConfig","shouldAutoCloseBefore","quote","bracket","_findAutoClosingPairOpen","containedPair","_findContainedAutoClosingPair","containedPairClose","isContainedPairPresent","lineBefore","characterAfter","_isBeforeClosingBrace","characterBefore","forceTokenization","lineTokens","getLineTokens","scopedLineTokens","createScopedLineTokens","shouldAutoClose","firstCharOffset","neutralCharacter","findNeutralCharacter","tokenType","getTokenTypeIfInsertingCharacter","isOK","autoClosingPairClose","autoSurround","_shouldSurroundChar","surroundingPairs","_step6","isTypingAQuoteCharacter","_iterator6","selectionContainsOnlyWhitespace","startIndex","endIndex","selectedText","selectionText","closeCharacter","SurroundSelectionCommand","electricChars","electricAction","onElectricCharacter","matchOpenBracket","bracketPairs","findMatchingBracketUp","matchLine","matchLineIndentation","newIndentation","lineFirstNonBlankColumn","getTypingOperation","compositions","_step7","_iterator7","composition","_step8","hasDeletion","_iterator8","_step9","_iterator9","deletedSelectionStart","deletedSelectionEnd","_step10","_iterator10","CompositionSurroundSelectionCommand","_isAutoClosingOvertype","_getAutoClosingPairClose","_runAutoClosingOpenCharType","isDoingComposition","_enter","_isAutoIndentType","autoIndentFails","_runAutoIndentType","_runAutoClosingOvertype","_isSurroundSelectionType","_runSurroundSelectionType","_isTypeInterceptorElectricChar","_typeInterceptorElectricChar","opType","_ReplaceCommandWithOf","openCharacter","insertOpenCharacter","_openCharacter","_closeCharacter","helper","insertedSelectionStart","insertedSelectionEnd","typedText","previousTypingOperation","typingOperation","isTypingOperation","normalizeOperationType","wordType","nextCharClass","_doFindPreviousWordOnLine","chIndex","chCode","chClass","_createWord","_findEndOfWord","_doFindNextWordOnLine","_findStartOfWord","wordNavigationType","prevWordOnLine","_findPreviousWordOnLine","rightRight","movedDown","nextWordOnLine","_findNextWordOnLine","lastNonWhitespace","whitespaceHeuristics","_deleteWordLeftWhitespace","_deleteInsideWordWhitespace","_deleteInsideWordDetermineDeleteRange","leftIndex","_charAtIsWhitespace","rightIndex","touchesWord","createRangeWithPosition","deleteWordAndAdjacentWhitespace","expandedToTheRight","toPosition","_moveWordPartLeft","_findFirstNonWhitespaceChar","_deleteWordRightWhitespace","_moveWordPartRight","_wordSeparators","prevWord","_createWordAtPosition","nextWord","possiblePosition","WordPartOperations","_WordOperations","apply","enforceDefined","deleteWordLeft","_deleteWordPartLeft","deleteWordRight","_deleteWordPartRight","moveWordLeft","moveWordRight","arr","filter","el","Boolean","autoCloseAlways","autoCloseNever","autoCloseBeforeWhitespace","CursorConfiguration","languageId","modelOptions","configuration","_cursorMoveConfigurationBrand","_languageId","layoutInfo","fontInfo","lineHeight","typicalHalfwidthCharacterWidth","height","copyWithSyntaxHighlighting","_electricChars","_getShouldAutoClose","getLanguageConfiguration","getAutoClosingPairs","getSurroundingPairs","_a","electricCharacter","getElectricCharacters","char","electricCharacterSupport","forQuotes","_getLanguageDefinedShouldAutoClose","autoCloseBeforeSet","getAutoCloseBeforeSet","hasChanged","_cursorStateBrand","PartialModelCursorState","PartialViewCursorState","modelSelection","getSelectionStart","modelSelections","_singleCursorStateBrand","_computeSelection","opts","_editOperationResultBrand","LinesDiff","changes","hitTimeout","LineRangeMapping","originalRange","modifiedRange","innerChanges","mapping","originalLineCount","modifiedLineCount","lastOriginalEndLineNumber","lastModifiedEndLineNumber","RangeMapping","SmartLinesDiffComputer","originalLines","modifiedLines","DiffComputer","maxComputationTime","maxComputationTimeMs","shouldIgnoreTrimWhitespace","ignoreTrimWhitespace","shouldComputeCharChanges","shouldMakePrettyDiff","shouldPostProcessCharChanges","computeDiff","lastChange","originalEndLineNumber","originalStartLineNumber","modifiedEndLineNumber","modifiedStartLineNumber","change","charChanges","originalStartColumn","originalEndColumn","modifiedStartColumn","modifiedEndColumn","pop","assertFn","checkAdjacentItems","m1","m2","quitEarly","originalSequence","modifiedSequence","continueProcessingPredicate","pretty","LcsDiff","ComputeDiff","LineSequence","startColumns","endColumns","getFirstNonBlankColumn","getLastNonBlankColumn","_startColumns","_endColumns","elements","charCodes","lineNumbers","columns","col","CharSequence","_charCodes","_lineNumbers","_columns","Error","getEndLineNumber","_assertIndex","getStartLineNumber","getEndColumn","getStartColumn","CharChange","diffChange","originalCharSequence","modifiedCharSequence","originalStart","originalLength","modifiedStart","modifiedLength","LineChange","originalLineSequence","modifiedLineSequence","continueCharDiff","createCharSequence","getElements","rawChanges","prevChange","currChange","originalMatchingLength","modifiedMatchingLength","postProcessCharChanges","createFromDiffChange","modified","continueLineDiff","createContinueProcessingPredicate","diffResult","lineChanges","createFromDiffResult","originalLineIndex","modifiedLineIndex","nextChange","originalStop","modifiedStop","originalLine","modifiedLine","_pushTrimWhitespaceCharChange","originalMaxColumn","modifiedMaxColumn","originalLineNumber","modifiedLineNumber","_mergeTrimWhitespaceCharChange","txt","maximumRuntime","startTime","DiffAlgorithmResult","diffs","seq1","seq2","SequenceDiff","seq1Range","seq2Range","InfiniteTimeout","instance","DateTimeout","timeout","valid","Array2D","width","array","Array","y","DynamicProgrammingDiffing","sequence1","sequence2","equalityScore","trivial","lcsLengths","directions","lengths","s1","s2","trivialTimedOut","horizontalLen","verticalLen","extendedSeqScore","getElement","newValue","prevLen","lastAligningPosS1","lastAligningPosS2","reportDecreasingAligningPositions","reverse","optimizeSequenceDiffs","sequenceDiffs","lastResult","cur","all","joinSequenceDiffs","getBoundaryScore","diff","seq2PrevEndExclusive","seq2NextStart","shiftDiffToBetterPosition","seq1PrevEndExclusive","seq1NextStart","shiftSequenceDiffs","deltaBefore","deltaAfter","bestDelta","bestScore","seq2OffsetStart","seq2OffsetEndExclusive","seq1Offset","score","MyersDiffAlgorithm","getXAfterSnake","d","V","FastInt32Array","paths","FastArrayNegativeIndices","SnakePath","k","loop","maxXofDLineTop","maxXofDLineLeft","newMaxX","lastPath","path","endX","endY","positiveArr","Int32Array","negativeArr","group","StandardLinesDiffComputer","dynamicProgrammingDiffing","myersDiffingAlgorithm","considerWhitespaceChanges","perfectHashes","getOrCreateHash","hash","size","srcDocLines","trim","tgtDocLines","lineAlignmentResult","compute","offset1","offset2","log","lineAlignments","alignments","scanForWhitespaceChanges","equalLinesCount","seq1LastStart","seq2Offset","seq2LastStart","characterDiffs","refineDiff","mappings","rangeMapping","lineStartDelta","lineEndDelta","originalLineRange","modifiedLineRange","getLineRangeMapping","a1","a2","overlapOrTouch","last","lineRangeMappingFromRangeMappings","sourceSlice","Slice","targetSlice","additional","lastModifiedWord","maybePushWordToAdditional","originalLength1","s1Range","deleted","s2Range","added","_loop2","processWord","_b","_c","_d","s1Added","tryCreate","s2Added","changedS1","intersect","changedS2","w1Before","findWordContaining","w2Before","w1After","w2After","sequenceDiffs1","sequenceDiffs2","sd1","sd2","shift","mergeSequenceDiffs","coverFullWords","smoothenSequenceDiffs","translateRange","items","shouldBeGrouped","currentGroup","item","_regeneratorRuntime","wrap","_context","t0","finish","stop","_marked","trimmedHash","getIndentation","lineRange","firstCharOffsetByLineMinusOne","offsetByLine","trimFirstLineFully","trimmedStartLine","trimStart","trimEnd","_toConsumableArray","prevCategory","getCategory","nextCategory","getCategoryBoundaryScore","offsetOfPrevLineBreak","translateOffset","isWordChar","_score","_defineProperty","category","isSpace","linesDiffComputers","legacy","advanced","InternalEditorAction","label","alias","precondition","run","contextKeyService","_precondition","_run","_contextKeyService","contextMatchesRules","isSupported","Promise","resolve","EditorType","ICodeEditor","IDiffEditor","EditorContextKeys","editorSimpleInput","RawContextKey","editorTextFocus","focus","textInputFocus","inDiffEditor","isEmbeddedDiffEditor","columnSelection","writable","toNegated","hasNonEmptySelection","hasOnlyEmptySelection","hasMultipleSelections","hasSingleSelection","tabMovesFocus","tabDoesNotMoveFocus","isInWalkThroughSnippet","canUndo","canRedo","hoverVisible","hoverFocused","stickyScrollFocused","stickyScrollVisible","standaloneColorPickerVisible","standaloneColorPickerFocused","inCompositeEditor","notInCompositeEditor","hasCompletionItemProvider","hasCodeActionsProvider","hasCodeLensProvider","hasDefinitionProvider","hasDeclarationProvider","hasImplementationProvider","hasTypeDefinitionProvider","hasHoverProvider","hasDocumentHighlightProvider","hasDocumentSymbolProvider","hasReferenceProvider","hasRenameProvider","hasSignatureHelpProvider","hasInlayHintsProvider","hasDocumentFormattingProvider","hasDocumentSelectionFormattingProvider","hasMultipleDocumentFormattingProvider","hasMultipleDocumentSelectionFormattingProvider","editorFeatures","registerEditorFeature","ctor","getEditorFeatures","EditorTheme","_theme","color"],"sourceRoot":""}