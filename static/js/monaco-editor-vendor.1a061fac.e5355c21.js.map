{"version":3,"file":"static/js/monaco-editor-vendor.1a061fac.e5355c21.js","mappings":"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","sources":["../node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js","../node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.js","../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js","../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js","../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js","../node_modules/monaco-editor/esm/vs/editor/common/model/textModelTokens.js","../node_modules/monaco-editor/esm/vs/editor/common/model/tokenizationTextModelPart.js","../node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js","../node_modules/monaco-editor/esm/vs/editor/common/model/textModelPart.js","../node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js","../node_modules/monaco-editor/esm/vs/editor/common/model/utils.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { splitLines } from '../../../base/common/strings.js';\nimport { Position } from '../core/position.js';\nimport { PrefixSumComputer } from './prefixSumComputer.js';\nexport class MirrorTextModel {\n    constructor(uri, lines, eol, versionId) {\n        this._uri = uri;\n        this._lines = lines;\n        this._eol = eol;\n        this._versionId = versionId;\n        this._lineStarts = null;\n        this._cachedTextValue = null;\n    }\n    dispose() {\n        this._lines.length = 0;\n    }\n    get version() {\n        return this._versionId;\n    }\n    getText() {\n        if (this._cachedTextValue === null) {\n            this._cachedTextValue = this._lines.join(this._eol);\n        }\n        return this._cachedTextValue;\n    }\n    onEvents(e) {\n        if (e.eol && e.eol !== this._eol) {\n            this._eol = e.eol;\n            this._lineStarts = null;\n        }\n        // Update my lines\n        const changes = e.changes;\n        for (const change of changes) {\n            this._acceptDeleteRange(change.range);\n            this._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);\n        }\n        this._versionId = e.versionId;\n        this._cachedTextValue = null;\n    }\n    _ensureLineStarts() {\n        if (!this._lineStarts) {\n            const eolLength = this._eol.length;\n            const linesLength = this._lines.length;\n            const lineStartValues = new Uint32Array(linesLength);\n            for (let i = 0; i < linesLength; i++) {\n                lineStartValues[i] = this._lines[i].length + eolLength;\n            }\n            this._lineStarts = new PrefixSumComputer(lineStartValues);\n        }\n    }\n    /**\n     * All changes to a line's text go through this method\n     */\n    _setLineText(lineIndex, newValue) {\n        this._lines[lineIndex] = newValue;\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);\n        }\n    }\n    _acceptDeleteRange(range) {\n        if (range.startLineNumber === range.endLineNumber) {\n            if (range.startColumn === range.endColumn) {\n                // Nothing to delete\n                return;\n            }\n            // Delete text on the affected line\n            this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n                + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));\n            return;\n        }\n        // Take remaining text on last line and append it to remaining text on first line\n        this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n            + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));\n        // Delete middle lines\n        this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n        }\n    }\n    _acceptInsertText(position, insertText) {\n        if (insertText.length === 0) {\n            // Nothing to insert\n            return;\n        }\n        const insertLines = splitLines(insertText);\n        if (insertLines.length === 1) {\n            // Inserting text on one line\n            this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\n                + insertLines[0]\n                + this._lines[position.lineNumber - 1].substring(position.column - 1));\n            return;\n        }\n        // Append overflowing text from first line to the end of text to insert\n        insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);\n        // Delete overflowing text from first line and insert text on first line\n        this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\n            + insertLines[0]);\n        // Insert new lines & store lengths\n        const newLengths = new Uint32Array(insertLines.length - 1);\n        for (let i = 1; i < insertLines.length; i++) {\n            this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);\n            newLengths[i - 1] = insertLines[i].length + this._eol.length;\n        }\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.insertValues(position.lineNumber, newLengths);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { arrayInsert } from '../../../base/common/arrays.js';\nimport { toUint32 } from '../../../base/common/uint.js';\nexport class PrefixSumComputer {\n    constructor(values) {\n        this.values = values;\n        this.prefixSum = new Uint32Array(values.length);\n        this.prefixSumValidIndex = new Int32Array(1);\n        this.prefixSumValidIndex[0] = -1;\n    }\n    insertValues(insertIndex, insertValues) {\n        insertIndex = toUint32(insertIndex);\n        const oldValues = this.values;\n        const oldPrefixSum = this.prefixSum;\n        const insertValuesLen = insertValues.length;\n        if (insertValuesLen === 0) {\n            return false;\n        }\n        this.values = new Uint32Array(oldValues.length + insertValuesLen);\n        this.values.set(oldValues.subarray(0, insertIndex), 0);\n        this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);\n        this.values.set(insertValues, insertIndex);\n        if (insertIndex - 1 < this.prefixSumValidIndex[0]) {\n            this.prefixSumValidIndex[0] = insertIndex - 1;\n        }\n        this.prefixSum = new Uint32Array(this.values.length);\n        if (this.prefixSumValidIndex[0] >= 0) {\n            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n        }\n        return true;\n    }\n    setValue(index, value) {\n        index = toUint32(index);\n        value = toUint32(value);\n        if (this.values[index] === value) {\n            return false;\n        }\n        this.values[index] = value;\n        if (index - 1 < this.prefixSumValidIndex[0]) {\n            this.prefixSumValidIndex[0] = index - 1;\n        }\n        return true;\n    }\n    removeValues(startIndex, count) {\n        startIndex = toUint32(startIndex);\n        count = toUint32(count);\n        const oldValues = this.values;\n        const oldPrefixSum = this.prefixSum;\n        if (startIndex >= oldValues.length) {\n            return false;\n        }\n        const maxCount = oldValues.length - startIndex;\n        if (count >= maxCount) {\n            count = maxCount;\n        }\n        if (count === 0) {\n            return false;\n        }\n        this.values = new Uint32Array(oldValues.length - count);\n        this.values.set(oldValues.subarray(0, startIndex), 0);\n        this.values.set(oldValues.subarray(startIndex + count), startIndex);\n        this.prefixSum = new Uint32Array(this.values.length);\n        if (startIndex - 1 < this.prefixSumValidIndex[0]) {\n            this.prefixSumValidIndex[0] = startIndex - 1;\n        }\n        if (this.prefixSumValidIndex[0] >= 0) {\n            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n        }\n        return true;\n    }\n    getTotalSum() {\n        if (this.values.length === 0) {\n            return 0;\n        }\n        return this._getPrefixSum(this.values.length - 1);\n    }\n    /**\n     * Returns the sum of the first `index + 1` many items.\n     * @returns `SUM(0 <= j <= index, values[j])`.\n     */\n    getPrefixSum(index) {\n        if (index < 0) {\n            return 0;\n        }\n        index = toUint32(index);\n        return this._getPrefixSum(index);\n    }\n    _getPrefixSum(index) {\n        if (index <= this.prefixSumValidIndex[0]) {\n            return this.prefixSum[index];\n        }\n        let startIndex = this.prefixSumValidIndex[0] + 1;\n        if (startIndex === 0) {\n            this.prefixSum[0] = this.values[0];\n            startIndex++;\n        }\n        if (index >= this.values.length) {\n            index = this.values.length - 1;\n        }\n        for (let i = startIndex; i <= index; i++) {\n            this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];\n        }\n        this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);\n        return this.prefixSum[index];\n    }\n    getIndexOf(sum) {\n        sum = Math.floor(sum);\n        // Compute all sums (to get a fully valid prefixSum)\n        this.getTotalSum();\n        let low = 0;\n        let high = this.values.length - 1;\n        let mid = 0;\n        let midStop = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            midStop = this.prefixSum[mid];\n            midStart = midStop - this.values[mid];\n            if (sum < midStart) {\n                high = mid - 1;\n            }\n            else if (sum >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        return new PrefixSumIndexOfResult(mid, sum - midStart);\n    }\n}\n/**\n * {@link getIndexOf} has an amortized runtime complexity of O(1).\n *\n * ({@link PrefixSumComputer.getIndexOf} is just  O(log n))\n*/\nexport class ConstantTimePrefixSumComputer {\n    constructor(values) {\n        this._values = values;\n        this._isValid = false;\n        this._validEndIndex = -1;\n        this._prefixSum = [];\n        this._indexBySum = [];\n    }\n    /**\n     * @returns SUM(0 <= j < values.length, values[j])\n     */\n    getTotalSum() {\n        this._ensureValid();\n        return this._indexBySum.length;\n    }\n    /**\n     * Returns the sum of the first `count` many items.\n     * @returns `SUM(0 <= j < count, values[j])`.\n     */\n    getPrefixSum(count) {\n        this._ensureValid();\n        if (count === 0) {\n            return 0;\n        }\n        return this._prefixSum[count - 1];\n    }\n    /**\n     * @returns `result`, such that `getPrefixSum(result.index) + result.remainder = sum`\n     */\n    getIndexOf(sum) {\n        this._ensureValid();\n        const idx = this._indexBySum[sum];\n        const viewLinesAbove = idx > 0 ? this._prefixSum[idx - 1] : 0;\n        return new PrefixSumIndexOfResult(idx, sum - viewLinesAbove);\n    }\n    removeValues(start, deleteCount) {\n        this._values.splice(start, deleteCount);\n        this._invalidate(start);\n    }\n    insertValues(insertIndex, insertArr) {\n        this._values = arrayInsert(this._values, insertIndex, insertArr);\n        this._invalidate(insertIndex);\n    }\n    _invalidate(index) {\n        this._isValid = false;\n        this._validEndIndex = Math.min(this._validEndIndex, index - 1);\n    }\n    _ensureValid() {\n        if (this._isValid) {\n            return;\n        }\n        for (let i = this._validEndIndex + 1, len = this._values.length; i < len; i++) {\n            const value = this._values[i];\n            const sumAbove = i > 0 ? this._prefixSum[i - 1] : 0;\n            this._prefixSum[i] = sumAbove + value;\n            for (let j = 0; j < value; j++) {\n                this._indexBySum[sumAbove + j] = i;\n            }\n        }\n        // trim things\n        this._prefixSum.length = this._values.length;\n        this._indexBySum.length = this._prefixSum[this._prefixSum.length - 1];\n        // mark as valid\n        this._isValid = true;\n        this._validEndIndex = this._values.length - 1;\n    }\n    setValue(index, value) {\n        if (this._values[index] === value) {\n            // no change\n            return;\n        }\n        this._values[index] = value;\n        this._invalidate(index);\n    }\n}\nexport class PrefixSumIndexOfResult {\n    constructor(index, remainder) {\n        this.index = index;\n        this.remainder = remainder;\n        this._prefixSumIndexOfResultBrand = undefined;\n        this.index = index;\n        this.remainder = remainder;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class TreeNode {\n    constructor(piece, color) {\n        this.piece = piece;\n        this.color = color;\n        this.size_left = 0;\n        this.lf_left = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n    }\n    next() {\n        if (this.right !== SENTINEL) {\n            return leftest(this.right);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.left === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    prev() {\n        if (this.left !== SENTINEL) {\n            return righttest(this.left);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.right === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new TreeNode(null, 0 /* NodeColor.Black */);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nSENTINEL.color = 0 /* NodeColor.Black */;\nexport function leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nexport function righttest(node) {\n    while (node.right !== SENTINEL) {\n        node = node.right;\n    }\n    return node;\n}\nexport function calculateSize(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.size_left + node.piece.length + calculateSize(node.right);\n}\nexport function calculateLF(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);\n}\nexport function resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n}\nexport function leftRotate(tree, x) {\n    const y = x.right;\n    // fix size_left\n    y.size_left += x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    x.right = y.left;\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent;\n    if (x.parent === SENTINEL) {\n        tree.root = y;\n    }\n    else if (x.parent.left === x) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x;\n    x.parent = y;\n}\nexport function rightRotate(tree, y) {\n    const x = y.left;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    // fix size_left\n    y.size_left -= x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    if (y.parent === SENTINEL) {\n        tree.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n}\nexport function rbDelete(tree, z) {\n    let x;\n    let y;\n    if (z.left === SENTINEL) {\n        y = z;\n        x = y.right;\n    }\n    else if (z.right === SENTINEL) {\n        y = z;\n        x = y.left;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n    }\n    if (y === tree.root) {\n        tree.root = x;\n        // if x is null, we are removing the only node\n        x.color = 0 /* NodeColor.Black */;\n        z.detach();\n        resetSentinel();\n        tree.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (y.color === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n        recomputeTreeMetadata(tree, x);\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        // as we make changes to x's hierarchy, update size_left of subtree first\n        recomputeTreeMetadata(tree, x);\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        y.color = z.color;\n        if (z === tree.root) {\n            tree.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n        // update metadata\n        // we replace z with y, so in this sub tree, the length change is z.item.length\n        y.size_left = z.size_left;\n        y.lf_left = z.lf_left;\n        recomputeTreeMetadata(tree, y);\n    }\n    z.detach();\n    if (x.parent.left === x) {\n        const newSizeLeft = calculateSize(x);\n        const newLFLeft = calculateLF(x);\n        if (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {\n            const delta = newSizeLeft - x.parent.size_left;\n            const lf_delta = newLFLeft - x.parent.lf_left;\n            x.parent.size_left = newSizeLeft;\n            x.parent.lf_left = newLFLeft;\n            updateTreeMetadata(tree, x.parent, delta, lf_delta);\n        }\n    }\n    recomputeTreeMetadata(tree, x.parent);\n    if (yWasRed) {\n        resetSentinel();\n        return;\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== tree.root && x.color === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (w.color === 1 /* NodeColor.Red */) {\n                w.color = 0 /* NodeColor.Black */;\n                x.parent.color = 1 /* NodeColor.Red */;\n                leftRotate(tree, x.parent);\n                w = x.parent.right;\n            }\n            if (w.left.color === 0 /* NodeColor.Black */ && w.right.color === 0 /* NodeColor.Black */) {\n                w.color = 1 /* NodeColor.Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.right.color === 0 /* NodeColor.Black */) {\n                    w.left.color = 0 /* NodeColor.Black */;\n                    w.color = 1 /* NodeColor.Red */;\n                    rightRotate(tree, w);\n                    w = x.parent.right;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* NodeColor.Black */;\n                w.right.color = 0 /* NodeColor.Black */;\n                leftRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (w.color === 1 /* NodeColor.Red */) {\n                w.color = 0 /* NodeColor.Black */;\n                x.parent.color = 1 /* NodeColor.Red */;\n                rightRotate(tree, x.parent);\n                w = x.parent.left;\n            }\n            if (w.left.color === 0 /* NodeColor.Black */ && w.right.color === 0 /* NodeColor.Black */) {\n                w.color = 1 /* NodeColor.Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.left.color === 0 /* NodeColor.Black */) {\n                    w.right.color = 0 /* NodeColor.Black */;\n                    w.color = 1 /* NodeColor.Red */;\n                    leftRotate(tree, w);\n                    w = x.parent.left;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* NodeColor.Black */;\n                w.left.color = 0 /* NodeColor.Black */;\n                rightRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n    }\n    x.color = 0 /* NodeColor.Black */;\n    resetSentinel();\n}\nexport function fixInsert(tree, x) {\n    recomputeTreeMetadata(tree, x);\n    while (x !== tree.root && x.parent.color === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (y.color === 1 /* NodeColor.Red */) {\n                x.parent.color = 0 /* NodeColor.Black */;\n                y.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(tree, x);\n                }\n                x.parent.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                rightRotate(tree, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (y.color === 1 /* NodeColor.Red */) {\n                x.parent.color = 0 /* NodeColor.Black */;\n                y.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(tree, x);\n                }\n                x.parent.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                leftRotate(tree, x.parent.parent);\n            }\n        }\n    }\n    tree.root.color = 0 /* NodeColor.Black */;\n}\nexport function updateTreeMetadata(tree, x, delta, lineFeedCntDelta) {\n    // node length change or line feed count change\n    while (x !== tree.root && x !== SENTINEL) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lineFeedCntDelta;\n        }\n        x = x.parent;\n    }\n}\nexport function recomputeTreeMetadata(tree, x) {\n    let delta = 0;\n    let lf_delta = 0;\n    if (x === tree.root) {\n        return;\n    }\n    // go upwards till the node whose left subtree is changed.\n    while (x !== tree.root && x === x.parent.right) {\n        x = x.parent;\n    }\n    if (x === tree.root) {\n        // well, it means we add a node to the end (inorder)\n        return;\n    }\n    // x is the node whose right subtree is changed.\n    x = x.parent;\n    delta = calculateSize(x.left) - x.size_left;\n    lf_delta = calculateLF(x.left) - x.lf_left;\n    x.size_left += delta;\n    x.lf_left += lf_delta;\n    // go upwards till root. O(logN)\n    while (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lf_delta;\n        }\n        x = x.parent;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { FindMatch } from '../../model.js';\nimport { SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from './rbTreeBase.js';\nimport { Searcher, createFindMatch, isValidMatch } from '../textModelSearch.js';\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\nexport const AverageBufferSize = 65535;\nexport function createUintArray(arr) {\n    let r;\n    if (arr[arr.length - 1] < 65536) {\n        r = new Uint16Array(arr.length);\n    }\n    else {\n        r = new Uint32Array(arr.length);\n    }\n    r.set(arr, 0);\n    return r;\n}\nexport class LineStarts {\n    constructor(lineStarts, cr, lf, crlf, isBasicASCII) {\n        this.lineStarts = lineStarts;\n        this.cr = cr;\n        this.lf = lf;\n        this.crlf = crlf;\n        this.isBasicASCII = isBasicASCII;\n    }\n}\nexport function createLineStartsFast(str, readonly = true) {\n    const r = [0];\n    let rLength = 1;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            r[rLength++] = i + 1;\n        }\n    }\n    if (readonly) {\n        return createUintArray(r);\n    }\n    else {\n        return r;\n    }\n}\nexport function createLineStarts(r, str) {\n    r.length = 0;\n    r[0] = 0;\n    let rLength = 1;\n    let cr = 0, lf = 0, crlf = 0;\n    let isBasicASCII = true;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                crlf++;\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                cr++;\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            lf++;\n            r[rLength++] = i + 1;\n        }\n        else {\n            if (isBasicASCII) {\n                if (chr !== 9 /* CharCode.Tab */ && (chr < 32 || chr > 126)) {\n                    isBasicASCII = false;\n                }\n            }\n        }\n    }\n    const result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n    r.length = 0;\n    return result;\n}\nexport class Piece {\n    constructor(bufferIndex, start, end, lineFeedCnt, length) {\n        this.bufferIndex = bufferIndex;\n        this.start = start;\n        this.end = end;\n        this.lineFeedCnt = lineFeedCnt;\n        this.length = length;\n    }\n}\nexport class StringBuffer {\n    constructor(buffer, lineStarts) {\n        this.buffer = buffer;\n        this.lineStarts = lineStarts;\n    }\n}\n/**\n * Readonly snapshot for piece tree.\n * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\n * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\n * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\n */\nclass PieceTreeSnapshot {\n    constructor(tree, BOM) {\n        this._pieces = [];\n        this._tree = tree;\n        this._BOM = BOM;\n        this._index = 0;\n        if (tree.root !== SENTINEL) {\n            tree.iterate(tree.root, node => {\n                if (node !== SENTINEL) {\n                    this._pieces.push(node.piece);\n                }\n                return true;\n            });\n        }\n    }\n    read() {\n        if (this._pieces.length === 0) {\n            if (this._index === 0) {\n                this._index++;\n                return this._BOM;\n            }\n            else {\n                return null;\n            }\n        }\n        if (this._index > this._pieces.length - 1) {\n            return null;\n        }\n        if (this._index === 0) {\n            return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\n        }\n        return this._tree.getPieceContent(this._pieces[this._index++]);\n    }\n}\nclass PieceTreeSearchCache {\n    constructor(limit) {\n        this._limit = limit;\n        this._cache = [];\n    }\n    get(offset) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    get2(lineNumber) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    set(nodePosition) {\n        if (this._cache.length >= this._limit) {\n            this._cache.shift();\n        }\n        this._cache.push(nodePosition);\n    }\n    validate(offset) {\n        let hasInvalidVal = false;\n        const tmp = this._cache;\n        for (let i = 0; i < tmp.length; i++) {\n            const nodePos = tmp[i];\n            if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n                tmp[i] = null;\n                hasInvalidVal = true;\n                continue;\n            }\n        }\n        if (hasInvalidVal) {\n            const newArr = [];\n            for (const entry of tmp) {\n                if (entry !== null) {\n                    newArr.push(entry);\n                }\n            }\n            this._cache = newArr;\n        }\n    }\n}\nexport class PieceTreeBase {\n    constructor(chunks, eol, eolNormalized) {\n        this.create(chunks, eol, eolNormalized);\n    }\n    create(chunks, eol, eolNormalized) {\n        this._buffers = [\n            new StringBuffer('', [0])\n        ];\n        this._lastChangeBufferPos = { line: 0, column: 0 };\n        this.root = SENTINEL;\n        this._lineCnt = 1;\n        this._length = 0;\n        this._EOL = eol;\n        this._EOLLength = eol.length;\n        this._EOLNormalized = eolNormalized;\n        let lastNode = null;\n        for (let i = 0, len = chunks.length; i < len; i++) {\n            if (chunks[i].buffer.length > 0) {\n                if (!chunks[i].lineStarts) {\n                    chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n                }\n                const piece = new Piece(i + 1, { line: 0, column: 0 }, { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);\n                this._buffers.push(chunks[i]);\n                lastNode = this.rbInsertRight(lastNode, piece);\n            }\n        }\n        this._searchCache = new PieceTreeSearchCache(1);\n        this._lastVisitedLine = { lineNumber: 0, value: '' };\n        this.computeBufferMetadata();\n    }\n    normalizeEOL(eol) {\n        const averageBufferSize = AverageBufferSize;\n        const min = averageBufferSize - Math.floor(averageBufferSize / 3);\n        const max = min * 2;\n        let tempChunk = '';\n        let tempChunkLen = 0;\n        const chunks = [];\n        this.iterate(this.root, node => {\n            const str = this.getNodeContent(node);\n            const len = str.length;\n            if (tempChunkLen <= min || tempChunkLen + len < max) {\n                tempChunk += str;\n                tempChunkLen += len;\n                return true;\n            }\n            // flush anyways\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n            tempChunk = str;\n            tempChunkLen = len;\n            return true;\n        });\n        if (tempChunkLen > 0) {\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n        }\n        this.create(chunks, eol, true);\n    }\n    // #region Buffer API\n    getEOL() {\n        return this._EOL;\n    }\n    setEOL(newEOL) {\n        this._EOL = newEOL;\n        this._EOLLength = this._EOL.length;\n        this.normalizeEOL(newEOL);\n    }\n    createSnapshot(BOM) {\n        return new PieceTreeSnapshot(this, BOM);\n    }\n    getOffsetAt(lineNumber, column) {\n        let leftLen = 0; // inorder\n        let x = this.root;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n                leftLen += x.size_left;\n                // lineNumber >= 2\n                const accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                return leftLen += accumualtedValInCurrentIndex + column - 1;\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                leftLen += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return leftLen;\n    }\n    getPositionAt(offset) {\n        offset = Math.floor(offset);\n        offset = Math.max(0, offset);\n        let x = this.root;\n        let lfCnt = 0;\n        const originalOffset = offset;\n        while (x !== SENTINEL) {\n            if (x.size_left !== 0 && x.size_left >= offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                const out = this.getIndexOf(x, offset - x.size_left);\n                lfCnt += x.lf_left + out.index;\n                if (out.index === 0) {\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                return new Position(lfCnt + 1, out.remainder + 1);\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                lfCnt += x.lf_left + x.piece.lineFeedCnt;\n                if (x.right === SENTINEL) {\n                    // last node\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - offset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                else {\n                    x = x.right;\n                }\n            }\n        }\n        return new Position(1, 1);\n    }\n    getValueInRange(range, eol) {\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n            return '';\n        }\n        const startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n        const endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n        const value = this.getValueInRange2(startPosition, endPosition);\n        if (eol) {\n            if (eol !== this._EOL || !this._EOLNormalized) {\n                return value.replace(/\\r\\n|\\r|\\n/g, eol);\n            }\n            if (eol === this.getEOL() && this._EOLNormalized) {\n                if (eol === '\\r\\n') {\n                }\n                return value;\n            }\n            return value.replace(/\\r\\n|\\r|\\n/g, eol);\n        }\n        return value;\n    }\n    getValueInRange2(startPosition, endPosition) {\n        if (startPosition.node === endPosition.node) {\n            const node = startPosition.node;\n            const buffer = this._buffers[node.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n            return buffer.substring(startOffset + startPosition.remainder, startOffset + endPosition.remainder);\n        }\n        let x = startPosition.node;\n        const buffer = this._buffers[x.piece.bufferIndex].buffer;\n        const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n        let ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (x === endPosition.node) {\n                ret += buffer.substring(startOffset, startOffset + endPosition.remainder);\n                break;\n            }\n            else {\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    getLinesContent() {\n        const lines = [];\n        let linesLength = 0;\n        let currentLine = '';\n        let danglingCR = false;\n        this.iterate(this.root, node => {\n            if (node === SENTINEL) {\n                return true;\n            }\n            const piece = node.piece;\n            let pieceLength = piece.length;\n            if (pieceLength === 0) {\n                return true;\n            }\n            const buffer = this._buffers[piece.bufferIndex].buffer;\n            const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n            const pieceStartLine = piece.start.line;\n            const pieceEndLine = piece.end.line;\n            let pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\n            if (danglingCR) {\n                if (buffer.charCodeAt(pieceStartOffset) === 10 /* CharCode.LineFeed */) {\n                    // pretend the \\n was in the previous piece..\n                    pieceStartOffset++;\n                    pieceLength--;\n                }\n                lines[linesLength++] = currentLine;\n                currentLine = '';\n                danglingCR = false;\n                if (pieceLength === 0) {\n                    return true;\n                }\n            }\n            if (pieceStartLine === pieceEndLine) {\n                // this piece has no new lines\n                if (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13 /* CharCode.CarriageReturn */) {\n                    danglingCR = true;\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\n                }\n                else {\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength);\n                }\n                return true;\n            }\n            // add the text before the first line start in this piece\n            currentLine += (this._EOLNormalized\n                ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength))\n                : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n            lines[linesLength++] = currentLine;\n            for (let line = pieceStartLine + 1; line < pieceEndLine; line++) {\n                currentLine = (this._EOLNormalized\n                    ? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength)\n                    : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n                lines[linesLength++] = currentLine;\n            }\n            if (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13 /* CharCode.CarriageReturn */) {\n                danglingCR = true;\n                if (piece.end.column === 0) {\n                    // The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\n                    linesLength--;\n                }\n                else {\n                    currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\n                }\n            }\n            else {\n                currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\n            }\n            return true;\n        });\n        if (danglingCR) {\n            lines[linesLength++] = currentLine;\n            currentLine = '';\n        }\n        lines[linesLength++] = currentLine;\n        return lines;\n    }\n    getLength() {\n        return this._length;\n    }\n    getLineCount() {\n        return this._lineCnt;\n    }\n    getLineContent(lineNumber) {\n        if (this._lastVisitedLine.lineNumber === lineNumber) {\n            return this._lastVisitedLine.value;\n        }\n        this._lastVisitedLine.lineNumber = lineNumber;\n        if (lineNumber === this._lineCnt) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n        }\n        else if (this._EOLNormalized) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n        }\n        else {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n        }\n        return this._lastVisitedLine.value;\n    }\n    _getCharCode(nodePos) {\n        if (nodePos.remainder === nodePos.node.piece.length) {\n            // the char we want to fetch is at the head of next node.\n            const matchingNode = nodePos.node.next();\n            if (!matchingNode) {\n                return 0;\n            }\n            const buffer = this._buffers[matchingNode.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n            return buffer.buffer.charCodeAt(startOffset);\n        }\n        else {\n            const buffer = this._buffers[nodePos.node.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n            const targetOffset = startOffset + nodePos.remainder;\n            return buffer.buffer.charCodeAt(targetOffset);\n        }\n    }\n    getLineCharCode(lineNumber, index) {\n        const nodePos = this.nodeAt2(lineNumber, index + 1);\n        return this._getCharCode(nodePos);\n    }\n    getLineLength(lineNumber) {\n        if (lineNumber === this.getLineCount()) {\n            const startOffset = this.getOffsetAt(lineNumber, 1);\n            return this.getLength() - startOffset;\n        }\n        return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n    }\n    findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n        const start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n        const end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n        let m;\n        // Reset regex to search from the beginning\n        const ret = { line: 0, column: 0 };\n        let searchText;\n        let offsetInBuffer;\n        if (searcher._wordSeparators) {\n            searchText = buffer.buffer.substring(start, end);\n            offsetInBuffer = (offset) => offset + start;\n            searcher.reset(0);\n        }\n        else {\n            searchText = buffer.buffer;\n            offsetInBuffer = (offset) => offset;\n            searcher.reset(start);\n        }\n        do {\n            m = searcher.next(searchText);\n            if (m) {\n                if (offsetInBuffer(m.index) >= end) {\n                    return resultLen;\n                }\n                this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\n                const lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n                const retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n                const retEndColumn = retStartColumn + m[0].length;\n                result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n                if (offsetInBuffer(m.index) + m[0].length >= end) {\n                    return resultLen;\n                }\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n        if (startPosition === null) {\n            return [];\n        }\n        const endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n        if (endPosition === null) {\n            return [];\n        }\n        let start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        const end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n        if (startPosition.node === endPosition.node) {\n            this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n            return result;\n        }\n        let startLineNumber = searchRange.startLineNumber;\n        let currentNode = startPosition.node;\n        while (currentNode !== endPosition.node) {\n            const lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n            if (lineBreakCnt >= 1) {\n                // last line break position\n                const lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n                const startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n                const nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n                const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n                resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n                if (resultLen >= limitResultCount) {\n                    return result;\n                }\n                startLineNumber += lineBreakCnt;\n            }\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            // search for the remaining content\n            if (startLineNumber === searchRange.endLineNumber) {\n                const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n                resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n                return result;\n            }\n            resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn), startLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            if (resultLen >= limitResultCount) {\n                return result;\n            }\n            startLineNumber++;\n            startPosition = this.nodeAt2(startLineNumber, 1);\n            currentNode = startPosition.node;\n            start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        }\n        if (startLineNumber === searchRange.endLineNumber) {\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n        resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n        return result;\n    }\n    _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    // #endregion\n    // #region Piece Table\n    insert(offset, value, eolNormalized = false) {\n        this._EOLNormalized = this._EOLNormalized && eolNormalized;\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (this.root !== SENTINEL) {\n            const { node, remainder, nodeStartOffset } = this.nodeAt(offset);\n            const piece = node.piece;\n            const bufferIndex = piece.bufferIndex;\n            const insertPosInBuffer = this.positionInBuffer(node, remainder);\n            if (node.piece.bufferIndex === 0 &&\n                piece.end.line === this._lastChangeBufferPos.line &&\n                piece.end.column === this._lastChangeBufferPos.column &&\n                (nodeStartOffset + piece.length === offset) &&\n                value.length < AverageBufferSize) {\n                // changed buffer\n                this.appendToNode(node, value);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (nodeStartOffset === offset) {\n                this.insertContentToNodeLeft(value, node);\n                this._searchCache.validate(offset);\n            }\n            else if (nodeStartOffset + node.piece.length > offset) {\n                // we are inserting into the middle of a node.\n                const nodesToDel = [];\n                let newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));\n                if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n                    const headOfRight = this.nodeCharCodeAt(node, remainder);\n                    if (headOfRight === 10 /** \\n */) {\n                        const newStart = { line: newRightPiece.start.line + 1, column: 0 };\n                        newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);\n                        value += '\\n';\n                    }\n                }\n                // reuse node for content before insertion point.\n                if (this.shouldCheckCRLF() && this.startWithLF(value)) {\n                    const tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n                    if (tailOfLeft === 13 /** \\r */) {\n                        const previousPos = this.positionInBuffer(node, remainder - 1);\n                        this.deleteNodeTail(node, previousPos);\n                        value = '\\r' + value;\n                        if (node.piece.length === 0) {\n                            nodesToDel.push(node);\n                        }\n                    }\n                    else {\n                        this.deleteNodeTail(node, insertPosInBuffer);\n                    }\n                }\n                else {\n                    this.deleteNodeTail(node, insertPosInBuffer);\n                }\n                const newPieces = this.createNewPieces(value);\n                if (newRightPiece.length > 0) {\n                    this.rbInsertRight(node, newRightPiece);\n                }\n                let tmpNode = node;\n                for (let k = 0; k < newPieces.length; k++) {\n                    tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n                }\n                this.deleteNodes(nodesToDel);\n            }\n            else {\n                this.insertContentToNodeRight(value, node);\n            }\n        }\n        else {\n            // insert new node\n            const pieces = this.createNewPieces(value);\n            let node = this.rbInsertLeft(null, pieces[0]);\n            for (let k = 1; k < pieces.length; k++) {\n                node = this.rbInsertRight(node, pieces[k]);\n            }\n        }\n        // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n        this.computeBufferMetadata();\n    }\n    delete(offset, cnt) {\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (cnt <= 0 || this.root === SENTINEL) {\n            return;\n        }\n        const startPosition = this.nodeAt(offset);\n        const endPosition = this.nodeAt(offset + cnt);\n        const startNode = startPosition.node;\n        const endNode = endPosition.node;\n        if (startNode === endNode) {\n            const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n            const endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);\n            if (startPosition.nodeStartOffset === offset) {\n                if (cnt === startNode.piece.length) { // delete node\n                    const next = startNode.next();\n                    rbDelete(this, startNode);\n                    this.validateCRLFWithPrevNode(next);\n                    this.computeBufferMetadata();\n                    return;\n                }\n                this.deleteNodeHead(startNode, endSplitPosInBuffer);\n                this._searchCache.validate(offset);\n                this.validateCRLFWithPrevNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n                this.deleteNodeTail(startNode, startSplitPosInBuffer);\n                this.validateCRLFWithNextNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            // delete content in the middle, this node will be splitted to nodes\n            this.shrinkNode(startNode, startSplitPosInBuffer, endSplitPosInBuffer);\n            this.computeBufferMetadata();\n            return;\n        }\n        const nodesToDel = [];\n        const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n        this.deleteNodeTail(startNode, startSplitPosInBuffer);\n        this._searchCache.validate(offset);\n        if (startNode.piece.length === 0) {\n            nodesToDel.push(startNode);\n        }\n        // update last touched node\n        const endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n        this.deleteNodeHead(endNode, endSplitPosInBuffer);\n        if (endNode.piece.length === 0) {\n            nodesToDel.push(endNode);\n        }\n        // delete nodes in between\n        const secondNode = startNode.next();\n        for (let node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n            nodesToDel.push(node);\n        }\n        const prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n        this.deleteNodes(nodesToDel);\n        this.validateCRLFWithNextNode(prev);\n        this.computeBufferMetadata();\n    }\n    insertContentToNodeLeft(value, node) {\n        // we are inserting content to the beginning of node\n        const nodesToDel = [];\n        if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n            // move `\\n` to new node.\n            const piece = node.piece;\n            const newStart = { line: piece.start.line + 1, column: 0 };\n            const nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);\n            node.piece = nPiece;\n            value += '\\n';\n            updateTreeMetadata(this, node, -1, -1);\n            if (node.piece.length === 0) {\n                nodesToDel.push(node);\n            }\n        }\n        const newPieces = this.createNewPieces(value);\n        let newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n        for (let k = newPieces.length - 2; k >= 0; k--) {\n            newNode = this.rbInsertLeft(newNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n        this.deleteNodes(nodesToDel);\n    }\n    insertContentToNodeRight(value, node) {\n        // we are inserting to the right of this node.\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            // move \\n to the new node.\n            value += '\\n';\n        }\n        const newPieces = this.createNewPieces(value);\n        const newNode = this.rbInsertRight(node, newPieces[0]);\n        let tmpNode = newNode;\n        for (let k = 1; k < newPieces.length; k++) {\n            tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    positionInBuffer(node, remainder, ret) {\n        const piece = node.piece;\n        const bufferIndex = node.piece.bufferIndex;\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        const startOffset = lineStarts[piece.start.line] + piece.start.column;\n        const offset = startOffset + remainder;\n        // binary search offset between startOffset and endOffset\n        let low = piece.start.line;\n        let high = piece.end.line;\n        let mid = 0;\n        let midStop = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            midStart = lineStarts[mid];\n            if (mid === high) {\n                break;\n            }\n            midStop = lineStarts[mid + 1];\n            if (offset < midStart) {\n                high = mid - 1;\n            }\n            else if (offset >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        if (ret) {\n            ret.line = mid;\n            ret.column = offset - midStart;\n            return null;\n        }\n        return {\n            line: mid,\n            column: offset - midStart\n        };\n    }\n    getLineFeedCnt(bufferIndex, start, end) {\n        // we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n        // now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n        if (end.column === 0) {\n            return end.line - start.line;\n        }\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        if (end.line === lineStarts.length - 1) { // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n            return end.line - start.line;\n        }\n        const nextLineStartOffset = lineStarts[end.line + 1];\n        const endOffset = lineStarts[end.line] + end.column;\n        if (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \\n\n            return end.line - start.line;\n        }\n        // endOffset + 1 === nextLineStartOffset\n        // character at endOffset is \\n, so we check the character before first\n        // if character at endOffset is \\r, end.column is 0 and we can't get here.\n        const previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n        const buffer = this._buffers[bufferIndex].buffer;\n        if (buffer.charCodeAt(previousCharOffset) === 13) {\n            return end.line - start.line + 1;\n        }\n        else {\n            return end.line - start.line;\n        }\n    }\n    offsetInBuffer(bufferIndex, cursor) {\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        return lineStarts[cursor.line] + cursor.column;\n    }\n    deleteNodes(nodes) {\n        for (let i = 0; i < nodes.length; i++) {\n            rbDelete(this, nodes[i]);\n        }\n    }\n    createNewPieces(text) {\n        if (text.length > AverageBufferSize) {\n            // the content is large, operations like substring, charCode becomes slow\n            // so here we split it into smaller chunks, just like what we did for CR/LF normalization\n            const newPieces = [];\n            while (text.length > AverageBufferSize) {\n                const lastChar = text.charCodeAt(AverageBufferSize - 1);\n                let splitText;\n                if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n                    // last character is \\r or a high surrogate => keep it back\n                    splitText = text.substring(0, AverageBufferSize - 1);\n                    text = text.substring(AverageBufferSize - 1);\n                }\n                else {\n                    splitText = text.substring(0, AverageBufferSize);\n                    text = text.substring(AverageBufferSize);\n                }\n                const lineStarts = createLineStartsFast(splitText);\n                newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: splitText.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, splitText.length));\n                this._buffers.push(new StringBuffer(splitText, lineStarts));\n            }\n            const lineStarts = createLineStartsFast(text);\n            newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: text.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, text.length));\n            this._buffers.push(new StringBuffer(text, lineStarts));\n            return newPieces;\n        }\n        let startOffset = this._buffers[0].buffer.length;\n        const lineStarts = createLineStartsFast(text, false);\n        let start = this._lastChangeBufferPos;\n        if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset\n            && startOffset !== 0\n            && this.startWithLF(text)\n            && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n        ) {\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };\n            start = this._lastChangeBufferPos;\n            for (let i = 0; i < lineStarts.length; i++) {\n                lineStarts[i] += startOffset + 1;\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += '_' + text;\n            startOffset += 1;\n        }\n        else {\n            if (startOffset !== 0) {\n                for (let i = 0; i < lineStarts.length; i++) {\n                    lineStarts[i] += startOffset;\n                }\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += text;\n        }\n        const endOffset = this._buffers[0].buffer.length;\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n        const endPos = { line: endIndex, column: endColumn };\n        const newPiece = new Piece(0, /** todo@peng */ start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);\n        this._lastChangeBufferPos = endPos;\n        return [newPiece];\n    }\n    getLineRawContent(lineNumber, endOffset = 0) {\n        let x = this.root;\n        let ret = '';\n        const cache = this._searchCache.get2(lineNumber);\n        if (cache) {\n            x = cache.node;\n            const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n                ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n            }\n            else {\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n                return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n            }\n        }\n        else {\n            let nodeStartOffset = 0;\n            const originalLineNumber = lineNumber;\n            while (x !== SENTINEL) {\n                if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                    x = x.left;\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    nodeStartOffset += x.size_left;\n                    this._searchCache.set({\n                        node: x,\n                        nodeStartOffset,\n                        nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n                    });\n                    return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n                    break;\n                }\n                else {\n                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                    nodeStartOffset += x.size_left + x.piece.length;\n                    x = x.right;\n                }\n            }\n        }\n        // search in order, to find the node contains end column\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);\n                return ret;\n            }\n            else {\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    computeBufferMetadata() {\n        let x = this.root;\n        let lfCnt = 1;\n        let len = 0;\n        while (x !== SENTINEL) {\n            lfCnt += x.lf_left + x.piece.lineFeedCnt;\n            len += x.size_left + x.piece.length;\n            x = x.right;\n        }\n        this._lineCnt = lfCnt;\n        this._length = len;\n        this._searchCache.validate(this._length);\n    }\n    // #region node operations\n    getIndexOf(node, accumulatedValue) {\n        const piece = node.piece;\n        const pos = this.positionInBuffer(node, accumulatedValue);\n        const lineCnt = pos.line - piece.start.line;\n        if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n            // we are checking the end of this node, so a CRLF check is necessary.\n            const realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n            if (realLineCnt !== lineCnt) {\n                // aha yes, CRLF\n                return { index: realLineCnt, remainder: 0 };\n            }\n        }\n        return { index: lineCnt, remainder: pos.column };\n    }\n    getAccumulatedValue(node, index) {\n        if (index < 0) {\n            return 0;\n        }\n        const piece = node.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const expectedLineStartIndex = piece.start.line + index + 1;\n        if (expectedLineStartIndex > piece.end.line) {\n            return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n        }\n        else {\n            return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n        }\n    }\n    deleteNodeTail(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const newEnd = pos;\n        const newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = newEndOffset - originalEndOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    deleteNodeHead(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const newStart = pos;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n        const newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = originalStartOffset - newStartOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    shrinkNode(node, start, end) {\n        const piece = node.piece;\n        const originalStartPos = piece.start;\n        const originalEndPos = piece.end;\n        // old piece, originalStartPos, start\n        const oldLength = piece.length;\n        const oldLFCnt = piece.lineFeedCnt;\n        const newEnd = start;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\n        // new right piece, end, originalEndPos\n        const newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));\n        const newNode = this.rbInsertRight(node, newPiece);\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    appendToNode(node, value) {\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            value += '\\n';\n        }\n        const hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n        const startOffset = this._buffers[0].buffer.length;\n        this._buffers[0].buffer += value;\n        const lineStarts = createLineStartsFast(value, false);\n        for (let i = 0; i < lineStarts.length; i++) {\n            lineStarts[i] += startOffset;\n        }\n        if (hitCRLF) {\n            const prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n            this._buffers[0].lineStarts.pop();\n            // _lastChangeBufferPos is already wrong\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };\n        }\n        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n        const newEnd = { line: endIndex, column: endColumn };\n        const newLength = node.piece.length + value.length;\n        const oldLineFeedCnt = node.piece.lineFeedCnt;\n        const newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - oldLineFeedCnt;\n        node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);\n        this._lastChangeBufferPos = newEnd;\n        updateTreeMetadata(this, node, value.length, lf_delta);\n    }\n    nodeAt(offset) {\n        let x = this.root;\n        const cache = this._searchCache.get(offset);\n        if (cache) {\n            return {\n                node: cache.node,\n                nodeStartOffset: cache.nodeStartOffset,\n                remainder: offset - cache.nodeStartOffset\n            };\n        }\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.size_left > offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                nodeStartOffset += x.size_left;\n                const ret = {\n                    node: x,\n                    remainder: offset - x.size_left,\n                    nodeStartOffset\n                };\n                this._searchCache.set(ret);\n                return ret;\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return null;\n    }\n    nodeAt2(lineNumber, column) {\n        let x = this.root;\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                nodeStartOffset += x.size_left;\n                return {\n                    node: x,\n                    remainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                if (prevAccumualtedValue + column - 1 <= x.piece.length) {\n                    return {\n                        node: x,\n                        remainder: prevAccumualtedValue + column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length - prevAccumualtedValue;\n                    break;\n                }\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        // search in order, to find the node contains position.column\n        x = x.next();\n        while (x !== SENTINEL) {\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const nodeStartOffset = this.offsetOfNode(x);\n                return {\n                    node: x,\n                    remainder: Math.min(column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else {\n                if (x.piece.length >= column - 1) {\n                    const nodeStartOffset = this.offsetOfNode(x);\n                    return {\n                        node: x,\n                        remainder: column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length;\n                }\n            }\n            x = x.next();\n        }\n        return null;\n    }\n    nodeCharCodeAt(node, offset) {\n        if (node.piece.lineFeedCnt < 1) {\n            return -1;\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n        return buffer.buffer.charCodeAt(newOffset);\n    }\n    offsetOfNode(node) {\n        if (!node) {\n            return 0;\n        }\n        let pos = node.size_left;\n        while (node !== this.root) {\n            if (node.parent.right === node) {\n                pos += node.parent.size_left + node.parent.piece.length;\n            }\n            node = node.parent;\n        }\n        return pos;\n    }\n    // #endregion\n    // #region CRLF\n    shouldCheckCRLF() {\n        return !(this._EOLNormalized && this._EOL === '\\n');\n    }\n    startWithLF(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(0) === 10;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        const piece = val.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const line = piece.start.line;\n        const startOffset = lineStarts[line] + piece.start.column;\n        if (line === lineStarts.length - 1) {\n            // last line, so there is no line feed at the end of this line\n            return false;\n        }\n        const nextLineOffset = lineStarts[line + 1];\n        if (nextLineOffset > startOffset + 1) {\n            return false;\n        }\n        return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n    }\n    endWithCR(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(val.length - 1) === 13;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n    }\n    validateCRLFWithPrevNode(nextNode) {\n        if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n            const node = nextNode.prev();\n            if (this.endWithCR(node)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    validateCRLFWithNextNode(node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(node)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    fixCRLF(prev, next) {\n        const nodesToDel = [];\n        // update node\n        const lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n        let newEnd;\n        if (prev.piece.end.column === 0) {\n            // it means, last line ends with \\r, not \\r\\n\n            newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };\n        }\n        else {\n            // \\r\\n\n            newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };\n        }\n        const prevNewLength = prev.piece.length - 1;\n        const prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n        prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);\n        updateTreeMetadata(this, prev, -1, -1);\n        if (prev.piece.length === 0) {\n            nodesToDel.push(prev);\n        }\n        // update nextNode\n        const newStart = { line: next.piece.start.line + 1, column: 0 };\n        const newLength = next.piece.length - 1;\n        const newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n        next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, next, -1, -1);\n        if (next.piece.length === 0) {\n            nodesToDel.push(next);\n        }\n        // create new piece which contains \\r\\n\n        const pieces = this.createNewPieces('\\r\\n');\n        this.rbInsertRight(prev, pieces[0]);\n        // delete empty nodes\n        for (let i = 0; i < nodesToDel.length; i++) {\n            rbDelete(this, nodesToDel[i]);\n        }\n    }\n    adjustCarriageReturnFromNext(value, node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                // move `\\n` forward\n                value += '\\n';\n                if (nextNode.piece.length === 1) {\n                    rbDelete(this, nextNode);\n                }\n                else {\n                    const piece = nextNode.piece;\n                    const newStart = { line: piece.start.line + 1, column: 0 };\n                    const newLength = piece.length - 1;\n                    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n                    nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n                    updateTreeMetadata(this, nextNode, -1, -1);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    // #endregion\n    // #endregion\n    // #region Tree operations\n    iterate(node, callback) {\n        if (node === SENTINEL) {\n            return callback(SENTINEL);\n        }\n        const leftRet = this.iterate(node.left, callback);\n        if (!leftRet) {\n            return leftRet;\n        }\n        return callback(node) && this.iterate(node.right, callback);\n    }\n    getNodeContent(node) {\n        if (node === SENTINEL) {\n            return '';\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const piece = node.piece;\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    getPieceContent(piece) {\n        const buffer = this._buffers[piece.bufferIndex];\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b    <----   a    b\n     *                         /\n     *                        z\n     */\n    rbInsertRight(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        const x = this.root;\n        if (x === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.right === SENTINEL) {\n            node.right = z;\n            z.parent = node;\n        }\n        else {\n            const nextNode = leftest(node.right);\n            nextNode.left = z;\n            z.parent = nextNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b     ---->   a    b\n     *                       \\\n     *                        z\n     */\n    rbInsertLeft(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        if (this.root === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.left === SENTINEL) {\n            node.left = z;\n            z.parent = node;\n        }\n        else {\n            const prevNode = righttest(node.left); // a\n            prevNode.right = z;\n            z.parent = prevNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult } from '../../model.js';\nimport { PieceTreeBase } from './pieceTreeBase.js';\nimport { countEOL } from '../../core/eolCounter.js';\nimport { TextChange } from '../../core/textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nexport class PieceTreeTextBuffer extends Disposable {\n    constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {\n        super();\n        this._onDidChangeContent = this._register(new Emitter());\n        this._BOM = BOM;\n        this._mightContainNonBasicASCII = !isBasicASCII;\n        this._mightContainRTL = containsRTL;\n        this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n        this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n    }\n    mightContainRTL() {\n        return this._mightContainRTL;\n    }\n    mightContainUnusualLineTerminators() {\n        return this._mightContainUnusualLineTerminators;\n    }\n    resetMightContainUnusualLineTerminators() {\n        this._mightContainUnusualLineTerminators = false;\n    }\n    mightContainNonBasicASCII() {\n        return this._mightContainNonBasicASCII;\n    }\n    getBOM() {\n        return this._BOM;\n    }\n    getEOL() {\n        return this._pieceTree.getEOL();\n    }\n    createSnapshot(preserveBOM) {\n        return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n    }\n    getOffsetAt(lineNumber, column) {\n        return this._pieceTree.getOffsetAt(lineNumber, column);\n    }\n    getPositionAt(offset) {\n        return this._pieceTree.getPositionAt(offset);\n    }\n    getRangeAt(start, length) {\n        const end = start + length;\n        const startPosition = this.getPositionAt(start);\n        const endPosition = this.getPositionAt(end);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    getValueInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return '';\n        }\n        const lineEnding = this._getEndOfLine(eol);\n        return this._pieceTree.getValueInRange(range, lineEnding);\n    }\n    getValueLengthInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return 0;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            return (range.endColumn - range.startColumn);\n        }\n        const startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n        return endOffset - startOffset;\n    }\n    getCharacterCountInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (this._mightContainNonBasicASCII) {\n            // we must count by iterating\n            let result = 0;\n            const fromLineNumber = range.startLineNumber;\n            const toLineNumber = range.endLineNumber;\n            for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n                const lineContent = this.getLineContent(lineNumber);\n                const fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\n                const toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\n                for (let offset = fromOffset; offset < toOffset; offset++) {\n                    if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n                        result = result + 1;\n                        offset = offset + 1;\n                    }\n                    else {\n                        result = result + 1;\n                    }\n                }\n            }\n            result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n            return result;\n        }\n        return this.getValueLengthInRange(range, eol);\n    }\n    getLength() {\n        return this._pieceTree.getLength();\n    }\n    getLineCount() {\n        return this._pieceTree.getLineCount();\n    }\n    getLinesContent() {\n        return this._pieceTree.getLinesContent();\n    }\n    getLineContent(lineNumber) {\n        return this._pieceTree.getLineContent(lineNumber);\n    }\n    getLineCharCode(lineNumber, index) {\n        return this._pieceTree.getLineCharCode(lineNumber, index);\n    }\n    getLineLength(lineNumber) {\n        return this._pieceTree.getLineLength(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    _getEndOfLine(eol) {\n        switch (eol) {\n            case 1 /* EndOfLinePreference.LF */:\n                return '\\n';\n            case 2 /* EndOfLinePreference.CRLF */:\n                return '\\r\\n';\n            case 0 /* EndOfLinePreference.TextDefined */:\n                return this.getEOL();\n            default:\n                throw new Error('Unknown EOL preference');\n        }\n    }\n    setEOL(newEOL) {\n        this._pieceTree.setEOL(newEOL);\n    }\n    applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {\n        let mightContainRTL = this._mightContainRTL;\n        let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n        let mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n        let canReduceOperations = true;\n        let operations = [];\n        for (let i = 0; i < rawOperations.length; i++) {\n            const op = rawOperations[i];\n            if (canReduceOperations && op._isTracked) {\n                canReduceOperations = false;\n            }\n            const validatedRange = op.range;\n            if (op.text) {\n                let textMightContainNonBasicASCII = true;\n                if (!mightContainNonBasicASCII) {\n                    textMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n                    mightContainNonBasicASCII = textMightContainNonBasicASCII;\n                }\n                if (!mightContainRTL && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains RTL\n                    mightContainRTL = strings.containsRTL(op.text);\n                }\n                if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains unusual line terminators\n                    mightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n                }\n            }\n            let validText = '';\n            let eolCount = 0;\n            let firstLineLength = 0;\n            let lastLineLength = 0;\n            if (op.text) {\n                let strEOL;\n                [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n                const bufferEOL = this.getEOL();\n                const expectedStrEOL = (bufferEOL === '\\r\\n' ? 2 /* StringEOL.CRLF */ : 1 /* StringEOL.LF */);\n                if (strEOL === 0 /* StringEOL.Unknown */ || strEOL === expectedStrEOL) {\n                    validText = op.text;\n                }\n                else {\n                    validText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n                }\n            }\n            operations[i] = {\n                sortIndex: i,\n                identifier: op.identifier || null,\n                range: validatedRange,\n                rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n                rangeLength: this.getValueLengthInRange(validatedRange),\n                text: validText,\n                eolCount: eolCount,\n                firstLineLength: firstLineLength,\n                lastLineLength: lastLineLength,\n                forceMoveMarkers: Boolean(op.forceMoveMarkers),\n                isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n            };\n        }\n        // Sort operations ascending\n        operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n        let hasTouchingRanges = false;\n        for (let i = 0, count = operations.length - 1; i < count; i++) {\n            const rangeEnd = operations[i].range.getEndPosition();\n            const nextRangeStart = operations[i + 1].range.getStartPosition();\n            if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n                if (nextRangeStart.isBefore(rangeEnd)) {\n                    // overlapping ranges\n                    throw new Error('Overlapping ranges are not allowed!');\n                }\n                hasTouchingRanges = true;\n            }\n        }\n        if (canReduceOperations) {\n            operations = this._reduceOperations(operations);\n        }\n        // Delta encode operations\n        const reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);\n        const newTrimAutoWhitespaceCandidates = [];\n        if (recordTrimAutoWhitespace) {\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n                    // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n                    for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n                        let currentLineContent = '';\n                        if (lineNumber === reverseRange.startLineNumber) {\n                            currentLineContent = this.getLineContent(op.range.startLineNumber);\n                            if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n                                continue;\n                            }\n                        }\n                        newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n                    }\n                }\n            }\n        }\n        let reverseOperations = null;\n        if (computeUndoEdits) {\n            let reverseRangeDeltaOffset = 0;\n            reverseOperations = [];\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                const bufferText = this.getValueInRange(op.range);\n                const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n                reverseRangeDeltaOffset += (op.text.length - bufferText.length);\n                reverseOperations[i] = {\n                    sortIndex: op.sortIndex,\n                    identifier: op.identifier,\n                    range: reverseRange,\n                    text: bufferText,\n                    textChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n                };\n            }\n            // Can only sort reverse operations when the order is not significant\n            if (!hasTouchingRanges) {\n                reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n            }\n        }\n        this._mightContainRTL = mightContainRTL;\n        this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n        this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n        const contentChanges = this._doApplyEdits(operations);\n        let trimAutoWhitespaceLineNumbers = null;\n        if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n            // sort line numbers auto whitespace removal candidates for next edit descending\n            newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n            trimAutoWhitespaceLineNumbers = [];\n            for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n                const lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n                if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n                    // Do not have the same line number twice\n                    continue;\n                }\n                const prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n                const lineContent = this.getLineContent(lineNumber);\n                if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n                    continue;\n                }\n                trimAutoWhitespaceLineNumbers.push(lineNumber);\n            }\n        }\n        this._onDidChangeContent.fire();\n        return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n    }\n    /**\n     * Transform operations such that they represent the same logic edit,\n     * but that they also do not cause OOM crashes.\n     */\n    _reduceOperations(operations) {\n        if (operations.length < 1000) {\n            // We know from empirical testing that a thousand edits work fine regardless of their shape.\n            return operations;\n        }\n        // At one point, due to how events are emitted and how each operation is handled,\n        // some operations can trigger a high amount of temporary string allocations,\n        // that will immediately get edited again.\n        // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n        // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n        return [this._toSingleEditOperation(operations)];\n    }\n    _toSingleEditOperation(operations) {\n        let forceMoveMarkers = false;\n        const firstEditRange = operations[0].range;\n        const lastEditRange = operations[operations.length - 1].range;\n        const entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n        let lastEndLineNumber = firstEditRange.startLineNumber;\n        let lastEndColumn = firstEditRange.startColumn;\n        const result = [];\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const operation = operations[i];\n            const range = operation.range;\n            forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n            // (1) -- Push old text\n            result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n            // (2) -- Push new text\n            if (operation.text.length > 0) {\n                result.push(operation.text);\n            }\n            lastEndLineNumber = range.endLineNumber;\n            lastEndColumn = range.endColumn;\n        }\n        const text = result.join('');\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        return {\n            sortIndex: 0,\n            identifier: operations[0].identifier,\n            range: entireEditRange,\n            rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n            rangeLength: this.getValueLengthInRange(entireEditRange, 0 /* EndOfLinePreference.TextDefined */),\n            text: text,\n            eolCount: eolCount,\n            firstLineLength: firstLineLength,\n            lastLineLength: lastLineLength,\n            forceMoveMarkers: forceMoveMarkers,\n            isAutoWhitespaceEdit: false\n        };\n    }\n    _doApplyEdits(operations) {\n        operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n        const contentChanges = [];\n        // operations are from bottom to top\n        for (let i = 0; i < operations.length; i++) {\n            const op = operations[i];\n            const startLineNumber = op.range.startLineNumber;\n            const startColumn = op.range.startColumn;\n            const endLineNumber = op.range.endLineNumber;\n            const endColumn = op.range.endColumn;\n            if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n                // no-op\n                continue;\n            }\n            if (op.text) {\n                // replacement\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n                this._pieceTree.insert(op.rangeOffset, op.text, true);\n            }\n            else {\n                // deletion\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n            }\n            const contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            contentChanges.push({\n                range: contentChangeRange,\n                rangeLength: op.rangeLength,\n                text: op.text,\n                rangeOffset: op.rangeOffset,\n                forceMoveMarkers: op.forceMoveMarkers\n            });\n        }\n        return contentChanges;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Assumes `operations` are validated and sorted ascending\n     */\n    static _getInverseEditRanges(operations) {\n        const result = [];\n        let prevOpEndLineNumber = 0;\n        let prevOpEndColumn = 0;\n        let prevOp = null;\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const op = operations[i];\n            let startLineNumber;\n            let startColumn;\n            if (prevOp) {\n                if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n                    startLineNumber = prevOpEndLineNumber;\n                    startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n                }\n                else {\n                    startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n                    startColumn = op.range.startColumn;\n                }\n            }\n            else {\n                startLineNumber = op.range.startLineNumber;\n                startColumn = op.range.startColumn;\n            }\n            let resultRange;\n            if (op.text.length > 0) {\n                // the operation inserts something\n                const lineCount = op.eolCount + 1;\n                if (lineCount === 1) {\n                    // single line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n                }\n                else {\n                    // multi line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n                }\n            }\n            else {\n                // There is nothing to insert\n                resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n            }\n            prevOpEndLineNumber = resultRange.endLineNumber;\n            prevOpEndColumn = resultRange.endColumn;\n            result.push(resultRange);\n            prevOp = op;\n        }\n        return result;\n    }\n    static _sortOpsAscending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return a.sortIndex - b.sortIndex;\n        }\n        return r;\n    }\n    static _sortOpsDescending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return b.sortIndex - a.sortIndex;\n        }\n        return -r;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { StringBuffer, createLineStarts, createLineStartsFast } from './pieceTreeBase.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer.js';\nexport class PieceTreeTextBufferFactory {\n    constructor(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {\n        this._chunks = _chunks;\n        this._bom = _bom;\n        this._cr = _cr;\n        this._lf = _lf;\n        this._crlf = _crlf;\n        this._containsRTL = _containsRTL;\n        this._containsUnusualLineTerminators = _containsUnusualLineTerminators;\n        this._isBasicASCII = _isBasicASCII;\n        this._normalizeEOL = _normalizeEOL;\n    }\n    _getEOL(defaultEOL) {\n        const totalEOLCount = this._cr + this._lf + this._crlf;\n        const totalCRCount = this._cr + this._crlf;\n        if (totalEOLCount === 0) {\n            // This is an empty file or a file with precisely one line\n            return (defaultEOL === 1 /* DefaultEndOfLine.LF */ ? '\\n' : '\\r\\n');\n        }\n        if (totalCRCount > totalEOLCount / 2) {\n            // More than half of the file contains \\r\\n ending lines\n            return '\\r\\n';\n        }\n        // At least one line more ends in \\n\n        return '\\n';\n    }\n    create(defaultEOL) {\n        const eol = this._getEOL(defaultEOL);\n        const chunks = this._chunks;\n        if (this._normalizeEOL &&\n            ((eol === '\\r\\n' && (this._cr > 0 || this._lf > 0))\n                || (eol === '\\n' && (this._cr > 0 || this._crlf > 0)))) {\n            // Normalize pieces\n            for (let i = 0, len = chunks.length; i < len; i++) {\n                const str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n                const newLineStart = createLineStartsFast(str);\n                chunks[i] = new StringBuffer(str, newLineStart);\n            }\n        }\n        const textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);\n        return { textBuffer: textBuffer, disposable: textBuffer };\n    }\n}\nexport class PieceTreeTextBufferBuilder {\n    constructor() {\n        this.chunks = [];\n        this.BOM = '';\n        this._hasPreviousChar = false;\n        this._previousChar = 0;\n        this._tmpLineStarts = [];\n        this.cr = 0;\n        this.lf = 0;\n        this.crlf = 0;\n        this.containsRTL = false;\n        this.containsUnusualLineTerminators = false;\n        this.isBasicASCII = true;\n    }\n    acceptChunk(chunk) {\n        if (chunk.length === 0) {\n            return;\n        }\n        if (this.chunks.length === 0) {\n            if (strings.startsWithUTF8BOM(chunk)) {\n                this.BOM = strings.UTF8_BOM_CHARACTER;\n                chunk = chunk.substr(1);\n            }\n        }\n        const lastChar = chunk.charCodeAt(chunk.length - 1);\n        if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n            // last character is \\r or a high surrogate => keep it back\n            this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n            this._hasPreviousChar = true;\n            this._previousChar = lastChar;\n        }\n        else {\n            this._acceptChunk1(chunk, false);\n            this._hasPreviousChar = false;\n            this._previousChar = lastChar;\n        }\n    }\n    _acceptChunk1(chunk, allowEmptyStrings) {\n        if (!allowEmptyStrings && chunk.length === 0) {\n            // Nothing to do\n            return;\n        }\n        if (this._hasPreviousChar) {\n            this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n        }\n        else {\n            this._acceptChunk2(chunk);\n        }\n    }\n    _acceptChunk2(chunk) {\n        const lineStarts = createLineStarts(this._tmpLineStarts, chunk);\n        this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\n        this.cr += lineStarts.cr;\n        this.lf += lineStarts.lf;\n        this.crlf += lineStarts.crlf;\n        if (this.isBasicASCII) {\n            this.isBasicASCII = lineStarts.isBasicASCII;\n        }\n        if (!this.isBasicASCII && !this.containsRTL) {\n            // No need to check if it is basic ASCII\n            this.containsRTL = strings.containsRTL(chunk);\n        }\n        if (!this.isBasicASCII && !this.containsUnusualLineTerminators) {\n            // No need to check if it is basic ASCII\n            this.containsUnusualLineTerminators = strings.containsUnusualLineTerminators(chunk);\n        }\n    }\n    finish(normalizeEOL = true) {\n        this._finish();\n        return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, normalizeEOL);\n    }\n    _finish() {\n        if (this.chunks.length === 0) {\n            this._acceptChunk1('', true);\n        }\n        if (this._hasPreviousChar) {\n            this._hasPreviousChar = false;\n            // recreate last chunk\n            const lastChunk = this.chunks[this.chunks.length - 1];\n            lastChunk.buffer += String.fromCharCode(this._previousChar);\n            const newLineStarts = createLineStartsFast(lastChunk.buffer);\n            lastChunk.lineStarts = newLineStarts;\n            if (this._previousChar === 13 /* CharCode.CarriageReturn */) {\n                this.cr++;\n            }\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { nullTokenizeEncoded } from '../languages/nullTokenize.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { runWhenIdle } from '../../../base/common/async.js';\nimport { setTimeout0 } from '../../../base/common/platform.js';\n/**\n * An array that avoids being sparse by always\n * filling up unused indices with a default value.\n */\nclass ContiguousGrowingArray {\n    constructor(_default) {\n        this._default = _default;\n        this._store = [];\n    }\n    get(index) {\n        if (index < this._store.length) {\n            return this._store[index];\n        }\n        return this._default;\n    }\n    set(index, value) {\n        while (index >= this._store.length) {\n            this._store[this._store.length] = this._default;\n        }\n        this._store[index] = value;\n    }\n    delete(deleteIndex, deleteCount) {\n        if (deleteCount === 0 || deleteIndex >= this._store.length) {\n            return;\n        }\n        this._store.splice(deleteIndex, deleteCount);\n    }\n    insert(insertIndex, insertCount) {\n        if (insertCount === 0 || insertIndex >= this._store.length) {\n            return;\n        }\n        const arr = [];\n        for (let i = 0; i < insertCount; i++) {\n            arr[i] = this._default;\n        }\n        this._store = arrays.arrayInsert(this._store, insertIndex, arr);\n    }\n}\n/**\n * Stores the states at the start of each line and keeps track of which lines\n * must be retokenized. Also uses state equality to quickly validate lines\n * that don't need to be retokenized.\n *\n * For example, when typing on a line, the line gets marked as needing to be tokenized.\n * Once the line is tokenized, the end state is checked for equality against the begin\n * state of the next line. If the states are equal, tokenization doesn't need to run\n * again over the rest of the file. If the states are not equal, the next line gets marked\n * as needing to be tokenized.\n */\nexport class TokenizationStateStore {\n    constructor(tokenizationSupport, initialState) {\n        this.tokenizationSupport = tokenizationSupport;\n        this.initialState = initialState;\n        /**\n         * `lineBeginState[i]` contains the begin state used to tokenize line number `i + 1`.\n         */\n        this._lineBeginState = new ContiguousGrowingArray(null);\n        /**\n         * `lineNeedsTokenization[i]` describes if line number `i + 1` needs to be tokenized.\n         */\n        this._lineNeedsTokenization = new ContiguousGrowingArray(true);\n        this._firstLineNeedsTokenization = 0;\n        this._lineBeginState.set(0, this.initialState);\n    }\n    get invalidLineStartIndex() {\n        return this._firstLineNeedsTokenization;\n    }\n    markMustBeTokenized(lineIndex) {\n        this._lineNeedsTokenization.set(lineIndex, true);\n        this._firstLineNeedsTokenization = Math.min(this._firstLineNeedsTokenization, lineIndex);\n    }\n    getBeginState(lineIndex) {\n        return this._lineBeginState.get(lineIndex);\n    }\n    setEndState(linesLength, lineIndex, endState) {\n        this._lineNeedsTokenization.set(lineIndex, false);\n        this._firstLineNeedsTokenization = lineIndex + 1;\n        // Check if this was the last line\n        if (lineIndex === linesLength - 1) {\n            return;\n        }\n        // Check if the end state has changed\n        const previousEndState = this._lineBeginState.get(lineIndex + 1);\n        if (previousEndState === null || !endState.equals(previousEndState)) {\n            this._lineBeginState.set(lineIndex + 1, endState);\n            this.markMustBeTokenized(lineIndex + 1);\n            return;\n        }\n        // Perhaps we can skip tokenizing some lines...\n        let i = lineIndex + 1;\n        while (i < linesLength) {\n            if (this._lineNeedsTokenization.get(i)) {\n                break;\n            }\n            i++;\n        }\n        this._firstLineNeedsTokenization = i;\n    }\n    //#region Editing\n    applyEdits(range, eolCount) {\n        this.markMustBeTokenized(range.startLineNumber - 1);\n        this._lineBeginState.delete(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n        this._lineNeedsTokenization.delete(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n        this._lineBeginState.insert(range.startLineNumber, eolCount);\n        this._lineNeedsTokenization.insert(range.startLineNumber, eolCount);\n    }\n}\nexport class TextModelTokenization extends Disposable {\n    constructor(_textModel, _tokenizationPart, _languageIdCodec) {\n        super();\n        this._textModel = _textModel;\n        this._tokenizationPart = _tokenizationPart;\n        this._languageIdCodec = _languageIdCodec;\n        this._isScheduled = false;\n        this._isDisposed = false;\n        this._tokenizationStateStore = null;\n        this._register(TokenizationRegistry.onDidChange((e) => {\n            const languageId = this._textModel.getLanguageId();\n            if (e.changedLanguages.indexOf(languageId) === -1) {\n                return;\n            }\n            this._resetTokenizationState();\n            this._tokenizationPart.clearTokens();\n        }));\n        this._resetTokenizationState();\n    }\n    dispose() {\n        this._isDisposed = true;\n        super.dispose();\n    }\n    //#region TextModel events\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            this._resetTokenizationState();\n            return;\n        }\n        if (this._tokenizationStateStore) {\n            for (let i = 0, len = e.changes.length; i < len; i++) {\n                const change = e.changes[i];\n                const [eolCount] = countEOL(change.text);\n                this._tokenizationStateStore.applyEdits(change.range, eolCount);\n            }\n        }\n        this._beginBackgroundTokenization();\n    }\n    handleDidChangeAttached() {\n        this._beginBackgroundTokenization();\n    }\n    handleDidChangeLanguage(e) {\n        this._resetTokenizationState();\n        this._tokenizationPart.clearTokens();\n    }\n    //#endregion\n    _resetTokenizationState() {\n        const [tokenizationSupport, initialState] = initializeTokenization(this._textModel, this._tokenizationPart);\n        if (tokenizationSupport && initialState) {\n            this._tokenizationStateStore = new TokenizationStateStore(tokenizationSupport, initialState);\n        }\n        else {\n            this._tokenizationStateStore = null;\n        }\n        this._beginBackgroundTokenization();\n    }\n    _beginBackgroundTokenization() {\n        if (this._isScheduled || !this._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n            return;\n        }\n        this._isScheduled = true;\n        runWhenIdle((deadline) => {\n            this._isScheduled = false;\n            this._backgroundTokenizeWithDeadline(deadline);\n        });\n    }\n    /**\n     * Tokenize until the deadline occurs, but try to yield every 1-2ms.\n     */\n    _backgroundTokenizeWithDeadline(deadline) {\n        // Read the time remaining from the `deadline` immediately because it is unclear\n        // if the `deadline` object will be valid after execution leaves this function.\n        const endTime = Date.now() + deadline.timeRemaining();\n        const execute = () => {\n            if (this._isDisposed || !this._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n                // disposed in the meantime or detached or finished\n                return;\n            }\n            this._backgroundTokenizeForAtLeast1ms();\n            if (Date.now() < endTime) {\n                // There is still time before reaching the deadline, so yield to the browser and then\n                // continue execution\n                setTimeout0(execute);\n            }\n            else {\n                // The deadline has been reached, so schedule a new idle callback if necessary\n                this._beginBackgroundTokenization();\n            }\n        };\n        execute();\n    }\n    /**\n     * Tokenize for at least 1ms.\n     */\n    _backgroundTokenizeForAtLeast1ms() {\n        const lineCount = this._textModel.getLineCount();\n        const builder = new ContiguousMultilineTokensBuilder();\n        const sw = StopWatch.create(false);\n        do {\n            if (sw.elapsed() > 1) {\n                // the comparison is intentionally > 1 and not >= 1 to ensure that\n                // a full millisecond has elapsed, given how microseconds are rounded\n                // to milliseconds\n                break;\n            }\n            const tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n            if (tokenizedLineNumber >= lineCount) {\n                break;\n            }\n        } while (this._hasLinesToTokenize());\n        this._tokenizationPart.setTokens(builder.finalize(), this._isTokenizationComplete());\n    }\n    tokenizeViewport(startLineNumber, endLineNumber) {\n        const builder = new ContiguousMultilineTokensBuilder();\n        this._tokenizeViewport(builder, startLineNumber, endLineNumber);\n        this._tokenizationPart.setTokens(builder.finalize(), this._isTokenizationComplete());\n    }\n    reset() {\n        this._resetTokenizationState();\n        this._tokenizationPart.clearTokens();\n    }\n    forceTokenization(lineNumber) {\n        const builder = new ContiguousMultilineTokensBuilder();\n        this._updateTokensUntilLine(builder, lineNumber);\n        this._tokenizationPart.setTokens(builder.finalize(), this._isTokenizationComplete());\n    }\n    getTokenTypeIfInsertingCharacter(position, character) {\n        if (!this._tokenizationStateStore) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        this.forceTokenization(position.lineNumber);\n        const lineStartState = this._tokenizationStateStore.getBeginState(position.lineNumber - 1);\n        if (!lineStartState) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const languageId = this._textModel.getLanguageId();\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        // Create the text as if `character` was inserted\n        const text = (lineContent.substring(0, position.column - 1)\n            + character\n            + lineContent.substring(position.column - 1));\n        const r = safeTokenize(this._languageIdCodec, languageId, this._tokenizationStateStore.tokenizationSupport, text, true, lineStartState);\n        const lineTokens = new LineTokens(r.tokens, text, this._languageIdCodec);\n        if (lineTokens.getCount() === 0) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        return lineTokens.getStandardTokenType(tokenIndex);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        const lineNumber = position.lineNumber;\n        const column = position.column;\n        if (!this._tokenizationStateStore) {\n            return null;\n        }\n        this.forceTokenization(lineNumber);\n        const lineStartState = this._tokenizationStateStore.getBeginState(lineNumber - 1);\n        if (!lineStartState) {\n            return null;\n        }\n        const curLineContent = this._textModel.getLineContent(lineNumber);\n        const newLineContent = curLineContent.substring(0, column - 1)\n            + newText + curLineContent.substring(column - 1 + length);\n        const languageId = this._textModel.getLanguageIdAtPosition(lineNumber, 0);\n        const result = safeTokenize(this._languageIdCodec, languageId, this._tokenizationStateStore.tokenizationSupport, newLineContent, true, lineStartState);\n        const lineTokens = new LineTokens(result.tokens, newLineContent, this._languageIdCodec);\n        return lineTokens;\n    }\n    isCheapToTokenize(lineNumber) {\n        if (!this._tokenizationStateStore) {\n            return true;\n        }\n        const firstInvalidLineNumber = this._tokenizationStateStore.invalidLineStartIndex + 1;\n        if (lineNumber > firstInvalidLineNumber) {\n            return false;\n        }\n        if (lineNumber < firstInvalidLineNumber) {\n            return true;\n        }\n        if (this._textModel.getLineLength(lineNumber) < 2048 /* Constants.CHEAP_TOKENIZATION_LENGTH_LIMIT */) {\n            return true;\n        }\n        return false;\n    }\n    _hasLinesToTokenize() {\n        if (!this._tokenizationStateStore) {\n            return false;\n        }\n        return (this._tokenizationStateStore.invalidLineStartIndex < this._textModel.getLineCount());\n    }\n    _isTokenizationComplete() {\n        if (!this._tokenizationStateStore) {\n            return false;\n        }\n        return (this._tokenizationStateStore.invalidLineStartIndex >= this._textModel.getLineCount());\n    }\n    _tokenizeOneInvalidLine(builder) {\n        if (!this._tokenizationStateStore || !this._hasLinesToTokenize()) {\n            return this._textModel.getLineCount() + 1;\n        }\n        const lineNumber = this._tokenizationStateStore.invalidLineStartIndex + 1;\n        this._updateTokensUntilLine(builder, lineNumber);\n        return lineNumber;\n    }\n    _updateTokensUntilLine(builder, lineNumber) {\n        if (!this._tokenizationStateStore) {\n            return;\n        }\n        const languageId = this._textModel.getLanguageId();\n        const linesLength = this._textModel.getLineCount();\n        const endLineIndex = lineNumber - 1;\n        // Validate all states up to and including endLineIndex\n        for (let lineIndex = this._tokenizationStateStore.invalidLineStartIndex; lineIndex <= endLineIndex; lineIndex++) {\n            const text = this._textModel.getLineContent(lineIndex + 1);\n            const lineStartState = this._tokenizationStateStore.getBeginState(lineIndex);\n            const r = safeTokenize(this._languageIdCodec, languageId, this._tokenizationStateStore.tokenizationSupport, text, true, lineStartState);\n            builder.add(lineIndex + 1, r.tokens);\n            this._tokenizationStateStore.setEndState(linesLength, lineIndex, r.endState);\n            lineIndex = this._tokenizationStateStore.invalidLineStartIndex - 1; // -1 because the outer loop increments it\n        }\n    }\n    _tokenizeViewport(builder, startLineNumber, endLineNumber) {\n        if (!this._tokenizationStateStore) {\n            // nothing to do\n            return;\n        }\n        if (endLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {\n            // nothing to do\n            return;\n        }\n        if (startLineNumber <= this._tokenizationStateStore.invalidLineStartIndex) {\n            // tokenization has reached the viewport start...\n            this._updateTokensUntilLine(builder, endLineNumber);\n            return;\n        }\n        let nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(startLineNumber);\n        const fakeLines = [];\n        let initialState = null;\n        for (let i = startLineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {\n            const newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);\n            if (newNonWhitespaceIndex === 0) {\n                continue;\n            }\n            if (newNonWhitespaceIndex < nonWhitespaceColumn) {\n                fakeLines.push(this._textModel.getLineContent(i));\n                nonWhitespaceColumn = newNonWhitespaceIndex;\n                initialState = this._tokenizationStateStore.getBeginState(i - 1);\n                if (initialState) {\n                    break;\n                }\n            }\n        }\n        if (!initialState) {\n            initialState = this._tokenizationStateStore.initialState;\n        }\n        const languageId = this._textModel.getLanguageId();\n        let state = initialState;\n        for (let i = fakeLines.length - 1; i >= 0; i--) {\n            const r = safeTokenize(this._languageIdCodec, languageId, this._tokenizationStateStore.tokenizationSupport, fakeLines[i], false, state);\n            state = r.endState;\n        }\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const text = this._textModel.getLineContent(lineNumber);\n            const r = safeTokenize(this._languageIdCodec, languageId, this._tokenizationStateStore.tokenizationSupport, text, true, state);\n            builder.add(lineNumber, r.tokens);\n            this._tokenizationStateStore.markMustBeTokenized(lineNumber - 1);\n            state = r.endState;\n        }\n    }\n}\nfunction initializeTokenization(textModel, tokenizationPart) {\n    if (textModel.isTooLargeForTokenization()) {\n        return [null, null];\n    }\n    const tokenizationSupport = TokenizationRegistry.get(tokenizationPart.getLanguageId());\n    if (!tokenizationSupport) {\n        return [null, null];\n    }\n    let initialState;\n    try {\n        initialState = tokenizationSupport.getInitialState();\n    }\n    catch (e) {\n        onUnexpectedError(e);\n        return [null, null];\n    }\n    return [tokenizationSupport, initialState];\n}\nfunction safeTokenize(languageIdCodec, languageId, tokenizationSupport, text, hasEOL, state) {\n    let r = null;\n    if (tokenizationSupport) {\n        try {\n            r = tokenizationSupport.tokenizeEncoded(text, hasEOL, state.clone());\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n    }\n    if (!r) {\n        r = nullTokenizeEncoded(languageIdCodec.encodeLanguageId(languageId), state);\n    }\n    LineTokens.convertToEndOffset(r.tokens, text.length);\n    return r;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { Position } from '../core/position.js';\nimport { getWordAtText } from '../core/wordHelper.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { TextModelTokenization } from './textModelTokens.js';\nimport { ContiguousTokensStore } from '../tokens/contiguousTokensStore.js';\nimport { SparseTokensStore } from '../tokens/sparseTokensStore.js';\nexport class TokenizationTextModelPart extends TextModelPart {\n    constructor(_languageService, _languageConfigurationService, _textModel, bracketPairsTextModelPart, _languageId) {\n        super();\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this._textModel = _textModel;\n        this.bracketPairsTextModelPart = bracketPairsTextModelPart;\n        this._languageId = _languageId;\n        this._onDidChangeLanguage = this._register(new Emitter());\n        this.onDidChangeLanguage = this._onDidChangeLanguage.event;\n        this._onDidChangeLanguageConfiguration = this._register(new Emitter());\n        this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n        this._backgroundTokenizationState = 0 /* BackgroundTokenizationState.Uninitialized */;\n        this._onBackgroundTokenizationStateChanged = this._register(new Emitter());\n        this._tokens = new ContiguousTokensStore(this._languageService.languageIdCodec);\n        this._semanticTokens = new SparseTokensStore(this._languageService.languageIdCodec);\n        this._tokenization = new TextModelTokenization(_textModel, this, this._languageService.languageIdCodec);\n        this._languageRegistryListener = this._languageConfigurationService.onDidChange(e => {\n            if (e.affects(this._languageId)) {\n                this._onDidChangeLanguageConfiguration.fire({});\n            }\n        });\n    }\n    acceptEdit(range, text, eolCount, firstLineLength, lastLineLength) {\n        this._tokens.acceptEdit(range, eolCount, firstLineLength);\n        this._semanticTokens.acceptEdit(range, eolCount, firstLineLength, lastLineLength, text.length > 0 ? text.charCodeAt(0) : 0 /* CharCode.Null */);\n    }\n    handleDidChangeAttached() {\n        this._tokenization.handleDidChangeAttached();\n    }\n    flush() {\n        this._tokens.flush();\n        this._semanticTokens.flush();\n    }\n    handleDidChangeContent(change) {\n        this._tokenization.handleDidChangeContent(change);\n    }\n    dispose() {\n        this._languageRegistryListener.dispose();\n        this._tokenization.dispose();\n        super.dispose();\n    }\n    get backgroundTokenizationState() {\n        return this._backgroundTokenizationState;\n    }\n    handleTokenizationProgress(completed) {\n        if (this._backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            // We already did a full tokenization and don't go back to progressing.\n            return;\n        }\n        const newState = completed ? 2 /* BackgroundTokenizationState.Completed */ : 1 /* BackgroundTokenizationState.InProgress */;\n        if (this._backgroundTokenizationState !== newState) {\n            this._backgroundTokenizationState = newState;\n            this.bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();\n            this._onBackgroundTokenizationStateChanged.fire();\n        }\n    }\n    setTokens(tokens, backgroundTokenizationCompleted = false) {\n        if (tokens.length !== 0) {\n            const ranges = [];\n            for (let i = 0, len = tokens.length; i < len; i++) {\n                const element = tokens[i];\n                let minChangedLineNumber = 0;\n                let maxChangedLineNumber = 0;\n                let hasChange = false;\n                for (let lineNumber = element.startLineNumber; lineNumber <= element.endLineNumber; lineNumber++) {\n                    if (hasChange) {\n                        this._tokens.setTokens(this._languageId, lineNumber - 1, this._textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), false);\n                        maxChangedLineNumber = lineNumber;\n                    }\n                    else {\n                        const lineHasChange = this._tokens.setTokens(this._languageId, lineNumber - 1, this._textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), true);\n                        if (lineHasChange) {\n                            hasChange = true;\n                            minChangedLineNumber = lineNumber;\n                            maxChangedLineNumber = lineNumber;\n                        }\n                    }\n                }\n                if (hasChange) {\n                    ranges.push({\n                        fromLineNumber: minChangedLineNumber,\n                        toLineNumber: maxChangedLineNumber,\n                    });\n                }\n            }\n            if (ranges.length > 0) {\n                this._emitModelTokensChangedEvent({\n                    tokenizationSupportChanged: false,\n                    semanticTokensApplied: false,\n                    ranges: ranges,\n                });\n            }\n        }\n        this.handleTokenizationProgress(backgroundTokenizationCompleted);\n    }\n    setSemanticTokens(tokens, isComplete) {\n        this._semanticTokens.set(tokens, isComplete);\n        this._emitModelTokensChangedEvent({\n            tokenizationSupportChanged: false,\n            semanticTokensApplied: tokens !== null,\n            ranges: [{ fromLineNumber: 1, toLineNumber: this._textModel.getLineCount() }],\n        });\n    }\n    hasCompleteSemanticTokens() {\n        return this._semanticTokens.isComplete();\n    }\n    hasSomeSemanticTokens() {\n        return !this._semanticTokens.isEmpty();\n    }\n    setPartialSemanticTokens(range, tokens) {\n        if (this.hasCompleteSemanticTokens()) {\n            return;\n        }\n        const changedRange = this._textModel.validateRange(this._semanticTokens.setPartial(range, tokens));\n        this._emitModelTokensChangedEvent({\n            tokenizationSupportChanged: false,\n            semanticTokensApplied: true,\n            ranges: [\n                {\n                    fromLineNumber: changedRange.startLineNumber,\n                    toLineNumber: changedRange.endLineNumber,\n                },\n            ],\n        });\n    }\n    tokenizeViewport(startLineNumber, endLineNumber) {\n        startLineNumber = Math.max(1, startLineNumber);\n        endLineNumber = Math.min(this._textModel.getLineCount(), endLineNumber);\n        this._tokenization.tokenizeViewport(startLineNumber, endLineNumber);\n    }\n    clearTokens() {\n        this._tokens.flush();\n        this._emitModelTokensChangedEvent({\n            tokenizationSupportChanged: true,\n            semanticTokensApplied: false,\n            ranges: [\n                {\n                    fromLineNumber: 1,\n                    toLineNumber: this._textModel.getLineCount(),\n                },\n            ],\n        });\n    }\n    _emitModelTokensChangedEvent(e) {\n        if (!this._textModel._isDisposing()) {\n            this.bracketPairsTextModelPart.handleDidChangeTokens(e);\n            this._onDidChangeTokens.fire(e);\n        }\n    }\n    resetTokenization() {\n        this._tokenization.reset();\n    }\n    forceTokenization(lineNumber) {\n        if (lineNumber < 1 || lineNumber > this._textModel.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        this._tokenization.forceTokenization(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        return this._tokenization.isCheapToTokenize(lineNumber);\n    }\n    tokenizeIfCheap(lineNumber) {\n        if (this.isCheapToTokenize(lineNumber)) {\n            this.forceTokenization(lineNumber);\n        }\n    }\n    getLineTokens(lineNumber) {\n        if (lineNumber < 1 || lineNumber > this._textModel.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._getLineTokens(lineNumber);\n    }\n    _getLineTokens(lineNumber) {\n        const lineText = this._textModel.getLineContent(lineNumber);\n        const syntacticTokens = this._tokens.getTokens(this._languageId, lineNumber - 1, lineText);\n        return this._semanticTokens.addSparseTokens(lineNumber, syntacticTokens);\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        return this._tokenization.getTokenTypeIfInsertingCharacter(position, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        const validatedPosition = this._textModel.validatePosition(position);\n        return this._tokenization.tokenizeLineWithEdit(validatedPosition, length, newText);\n    }\n    getLanguageConfiguration(languageId) {\n        return this._languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    // Having tokens allows implementing additional helper methods\n    getWordAtPosition(_position) {\n        this.assertNotDisposed();\n        const position = this._textModel.validatePosition(_position);\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        const lineTokens = this._getLineTokens(position.lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        // (1). First try checking right biased word\n        const [rbStartOffset, rbEndOffset] = TokenizationTextModelPart._findLanguageBoundaries(lineTokens, tokenIndex);\n        const rightBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);\n        // Make sure the result touches the original passed in position\n        if (rightBiasedWord &&\n            rightBiasedWord.startColumn <= _position.column &&\n            _position.column <= rightBiasedWord.endColumn) {\n            return rightBiasedWord;\n        }\n        // (2). Else, if we were at a language boundary, check the left biased word\n        if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n            // edge case, where `position` sits between two tokens belonging to two different languages\n            const [lbStartOffset, lbEndOffset] = TokenizationTextModelPart._findLanguageBoundaries(lineTokens, tokenIndex - 1);\n            const leftBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);\n            // Make sure the result touches the original passed in position\n            if (leftBiasedWord &&\n                leftBiasedWord.startColumn <= _position.column &&\n                _position.column <= leftBiasedWord.endColumn) {\n                return leftBiasedWord;\n            }\n        }\n        return null;\n    }\n    static _findLanguageBoundaries(lineTokens, tokenIndex) {\n        const languageId = lineTokens.getLanguageId(tokenIndex);\n        // go left until a different language is hit\n        let startOffset = 0;\n        for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n            startOffset = lineTokens.getStartOffset(i);\n        }\n        // go right until a different language is hit\n        let endOffset = lineTokens.getLineContent().length;\n        for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\n            endOffset = lineTokens.getEndOffset(i);\n        }\n        return [startOffset, endOffset];\n    }\n    getWordUntilPosition(position) {\n        const wordAtPosition = this.getWordAtPosition(position);\n        if (!wordAtPosition) {\n            return {\n                word: '',\n                startColumn: position.column,\n                endColumn: position.column,\n            };\n        }\n        return {\n            word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n            startColumn: wordAtPosition.startColumn,\n            endColumn: position.column,\n        };\n    }\n    getLanguageId() {\n        return this._languageId;\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n    }\n    setLanguageId(languageId) {\n        if (this._languageId === languageId) {\n            // There's nothing to do\n            return;\n        }\n        const e = {\n            oldLanguage: this._languageId,\n            newLanguage: languageId\n        };\n        this._languageId = languageId;\n        this.bracketPairsTextModelPart.handleDidChangeLanguage(e);\n        this._tokenization.handleDidChangeLanguage(e);\n        this._onDidChangeLanguage.fire(e);\n        this._onDidChangeLanguageConfiguration.fire({});\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { ArrayQueue, pushMany } from '../../../base/common/arrays.js';\nimport { Color } from '../../../base/common/color.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { combinedDisposable, Disposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { normalizeIndentation } from '../core/indentation.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport * as model from '../model.js';\nimport { BracketPairsTextModelPart } from './bracketPairsTextModelPart/bracketPairsImpl.js';\nimport { ColorizedBracketPairsDecorationProvider } from './bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js';\nimport { EditStack } from './editStack.js';\nimport { GuidesTextModelPart } from './guidesTextModelPart.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TokenizationTextModelPart } from './tokenizationTextModelPart.js';\nimport { InternalModelContentChangeEvent, LineInjectedText, ModelInjectedTextChangedEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from '../textModelEvents.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nexport function createTextBufferFactory(text) {\n    const builder = new PieceTreeTextBufferBuilder();\n    builder.acceptChunk(text);\n    return builder.finish();\n}\nexport function createTextBufferFactoryFromSnapshot(snapshot) {\n    const builder = new PieceTreeTextBufferBuilder();\n    let chunk;\n    while (typeof (chunk = snapshot.read()) === 'string') {\n        builder.acceptChunk(chunk);\n    }\n    return builder.finish();\n}\nexport function createTextBuffer(value, defaultEOL) {\n    let factory;\n    if (typeof value === 'string') {\n        factory = createTextBufferFactory(value);\n    }\n    else if (model.isITextSnapshot(value)) {\n        factory = createTextBufferFactoryFromSnapshot(value);\n    }\n    else {\n        factory = value;\n    }\n    return factory.create(defaultEOL);\n}\nlet MODEL_ID = 0;\nconst LIMIT_FIND_COUNT = 999;\nexport const LONG_LINE_BOUNDARY = 10000;\nclass TextModelSnapshot {\n    constructor(source) {\n        this._source = source;\n        this._eos = false;\n    }\n    read() {\n        if (this._eos) {\n            return null;\n        }\n        const result = [];\n        let resultCnt = 0;\n        let resultLength = 0;\n        do {\n            const tmp = this._source.read();\n            if (tmp === null) {\n                // end-of-stream\n                this._eos = true;\n                if (resultCnt === 0) {\n                    return null;\n                }\n                else {\n                    return result.join('');\n                }\n            }\n            if (tmp.length > 0) {\n                result[resultCnt++] = tmp;\n                resultLength += tmp.length;\n            }\n            if (resultLength >= 64 * 1024) {\n                return result.join('');\n            }\n        } while (true);\n    }\n}\nconst invalidFunc = () => { throw new Error(`Invalid change accessor`); };\nlet TextModel = class TextModel extends Disposable {\n    constructor(source, languageId, creationOptions, associatedResource = null, _undoRedoService, _languageService, _languageConfigurationService) {\n        super();\n        this._undoRedoService = _undoRedoService;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        //#region Events\n        this._onWillDispose = this._register(new Emitter());\n        this.onWillDispose = this._onWillDispose.event;\n        this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter(affectedInjectedTextLines => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines)));\n        this.onDidChangeDecorations = this._onDidChangeDecorations.event;\n        this._onDidChangeOptions = this._register(new Emitter());\n        this.onDidChangeOptions = this._onDidChangeOptions.event;\n        this._onDidChangeAttached = this._register(new Emitter());\n        this.onDidChangeAttached = this._onDidChangeAttached.event;\n        this._onDidChangeInjectedText = this._register(new Emitter());\n        this._eventEmitter = this._register(new DidChangeContentEmitter());\n        this._deltaDecorationCallCnt = 0;\n        // Generate a new unique model id\n        MODEL_ID++;\n        this.id = '$model' + MODEL_ID;\n        this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n        if (typeof associatedResource === 'undefined' || associatedResource === null) {\n            this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n        }\n        else {\n            this._associatedResource = associatedResource;\n        }\n        this._attachedEditorCount = 0;\n        const { textBuffer, disposable } = createTextBuffer(source, creationOptions.defaultEOL);\n        this._buffer = textBuffer;\n        this._bufferDisposable = disposable;\n        this._options = TextModel.resolveOptions(this._buffer, creationOptions);\n        this._bracketPairs = this._register(new BracketPairsTextModelPart(this, this._languageConfigurationService));\n        this._guidesTextModelPart = this._register(new GuidesTextModelPart(this, this._languageConfigurationService));\n        this._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));\n        this._tokenizationTextModelPart = new TokenizationTextModelPart(this._languageService, this._languageConfigurationService, this, this._bracketPairs, languageId);\n        const bufferLineCount = this._buffer.getLineCount();\n        const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0 /* model.EndOfLinePreference.TextDefined */);\n        // !!! Make a decision in the ctor and permanently respect this decision !!!\n        // If a model is too large at construction time, it will never get tokenized,\n        // under no circumstances.\n        if (creationOptions.largeFileOptimizations) {\n            this._isTooLargeForTokenization = ((bufferTextLength > TextModel.LARGE_FILE_SIZE_THRESHOLD)\n                || (bufferLineCount > TextModel.LARGE_FILE_LINE_COUNT_THRESHOLD));\n        }\n        else {\n            this._isTooLargeForTokenization = false;\n        }\n        this._isTooLargeForSyncing = (bufferTextLength > TextModel.MODEL_SYNC_LIMIT);\n        this._versionId = 1;\n        this._alternativeVersionId = 1;\n        this._initialUndoRedoSnapshot = null;\n        this._isDisposed = false;\n        this.__isDisposing = false;\n        this._instanceId = strings.singleLetterHash(MODEL_ID);\n        this._lastDecorationId = 0;\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        this._commandManager = new EditStack(this, this._undoRedoService);\n        this._isUndoing = false;\n        this._isRedoing = false;\n        this._trimAutoWhitespaceLines = null;\n        this._register(this._decorationProvider.onDidChange(() => {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._onDidChangeDecorations.fire();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }));\n    }\n    static resolveOptions(textBuffer, options) {\n        if (options.detectIndentation) {\n            const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n            return new model.TextModelResolvedOptions({\n                tabSize: guessedIndentation.tabSize,\n                indentSize: guessedIndentation.tabSize,\n                insertSpaces: guessedIndentation.insertSpaces,\n                trimAutoWhitespace: options.trimAutoWhitespace,\n                defaultEOL: options.defaultEOL,\n                bracketPairColorizationOptions: options.bracketPairColorizationOptions,\n            });\n        }\n        return new model.TextModelResolvedOptions({\n            tabSize: options.tabSize,\n            indentSize: options.indentSize,\n            insertSpaces: options.insertSpaces,\n            trimAutoWhitespace: options.trimAutoWhitespace,\n            defaultEOL: options.defaultEOL,\n            bracketPairColorizationOptions: options.bracketPairColorizationOptions,\n        });\n    }\n    get onDidChangeLanguage() { return this._tokenizationTextModelPart.onDidChangeLanguage; }\n    get onDidChangeLanguageConfiguration() { return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration; }\n    get onDidChangeTokens() { return this._tokenizationTextModelPart.onDidChangeTokens; }\n    onDidChangeContent(listener) {\n        return this._eventEmitter.slowEvent((e) => listener(e.contentChangedEvent));\n    }\n    onDidChangeContentOrInjectedText(listener) {\n        return combinedDisposable(this._eventEmitter.fastEvent(e => listener(e)), this._onDidChangeInjectedText.event(e => listener(e)));\n    }\n    _isDisposing() { return this.__isDisposing; }\n    get tokenization() { return this._tokenizationTextModelPart; }\n    get bracketPairs() { return this._bracketPairs; }\n    get guides() { return this._guidesTextModelPart; }\n    dispose() {\n        this.__isDisposing = true;\n        this._onWillDispose.fire();\n        this._tokenizationTextModelPart.dispose();\n        this._isDisposed = true;\n        super.dispose();\n        this._bufferDisposable.dispose();\n        this.__isDisposing = false;\n        // Manually release reference to previous text buffer to avoid large leaks\n        // in case someone leaks a TextModel reference\n        const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n        emptyDisposedTextBuffer.dispose();\n        this._buffer = emptyDisposedTextBuffer;\n        this._bufferDisposable = Disposable.None;\n    }\n    _assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new Error('Model is disposed!');\n        }\n    }\n    _emitContentChangedEvent(rawChange, change) {\n        if (this.__isDisposing) {\n            // Do not confuse listeners by emitting any event after disposing\n            return;\n        }\n        this._tokenizationTextModelPart.handleDidChangeContent(change);\n        this._bracketPairs.handleDidChangeContent(change);\n        this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n    }\n    setValue(value) {\n        this._assertNotDisposed();\n        if (value === null) {\n            // There's nothing to do\n            return;\n        }\n        const { textBuffer, disposable } = createTextBuffer(value, this._options.defaultEOL);\n        this._setValueFromTextBuffer(textBuffer, disposable);\n    }\n    _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush) {\n        return {\n            changes: [{\n                    range: range,\n                    rangeOffset: rangeOffset,\n                    rangeLength: rangeLength,\n                    text: text,\n                }],\n            eol: this._buffer.getEOL(),\n            versionId: this.getVersionId(),\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush\n        };\n    }\n    _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\n        this._assertNotDisposed();\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._buffer = textBuffer;\n        this._bufferDisposable.dispose();\n        this._bufferDisposable = textBufferDisposable;\n        this._increaseVersionId();\n        // Flush all tokens\n        this._tokenizationTextModelPart.flush();\n        // Destroy all my decorations\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        // Destroy my edit history and settings\n        this._commandManager.clear();\n        this._trimAutoWhitespaceLines = null;\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawFlush()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true));\n    }\n    setEOL(eol) {\n        this._assertNotDisposed();\n        const newEOL = (eol === 1 /* model.EndOfLineSequence.CRLF */ ? '\\r\\n' : '\\n');\n        if (this._buffer.getEOL() === newEOL) {\n            // Nothing to do\n            return;\n        }\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._onBeforeEOLChange();\n        this._buffer.setEOL(newEOL);\n        this._increaseVersionId();\n        this._onAfterEOLChange();\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawEOLChanged()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false));\n    }\n    _onBeforeEOLChange() {\n        // Ensure all decorations get their `range` set.\n        this._decorationsTree.ensureAllNodesHaveRanges(this);\n    }\n    _onAfterEOLChange() {\n        // Transform back `range` to offsets\n        const versionId = this.getVersionId();\n        const allDecorations = this._decorationsTree.collectNodesPostOrder();\n        for (let i = 0, len = allDecorations.length; i < len; i++) {\n            const node = allDecorations[i];\n            const range = node.range; // the range is defined due to `_onBeforeEOLChange`\n            const delta = node.cachedAbsoluteStart - node.start;\n            const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n            const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n            node.cachedAbsoluteStart = startOffset;\n            node.cachedAbsoluteEnd = endOffset;\n            node.cachedVersionId = versionId;\n            node.start = startOffset - delta;\n            node.end = endOffset - delta;\n            recomputeMaxEnd(node);\n        }\n    }\n    onBeforeAttached() {\n        this._attachedEditorCount++;\n        if (this._attachedEditorCount === 1) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n    }\n    onBeforeDetached() {\n        this._attachedEditorCount--;\n        if (this._attachedEditorCount === 0) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n    }\n    isAttachedToEditor() {\n        return this._attachedEditorCount > 0;\n    }\n    getAttachedEditorCount() {\n        return this._attachedEditorCount;\n    }\n    isTooLargeForSyncing() {\n        return this._isTooLargeForSyncing;\n    }\n    isTooLargeForTokenization() {\n        return this._isTooLargeForTokenization;\n    }\n    isDisposed() {\n        return this._isDisposed;\n    }\n    isDominatedByLongLines() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForTokenization()) {\n            // Cannot word wrap huge files anyways, so it doesn't really matter\n            return false;\n        }\n        let smallLineCharCount = 0;\n        let longLineCharCount = 0;\n        const lineCount = this._buffer.getLineCount();\n        for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n            const lineLength = this._buffer.getLineLength(lineNumber);\n            if (lineLength >= LONG_LINE_BOUNDARY) {\n                longLineCharCount += lineLength;\n            }\n            else {\n                smallLineCharCount += lineLength;\n            }\n        }\n        return (longLineCharCount > smallLineCharCount);\n    }\n    get uri() {\n        return this._associatedResource;\n    }\n    //#region Options\n    getOptions() {\n        this._assertNotDisposed();\n        return this._options;\n    }\n    getFormattingOptions() {\n        return {\n            tabSize: this._options.indentSize,\n            insertSpaces: this._options.insertSpaces\n        };\n    }\n    updateOptions(_newOpts) {\n        this._assertNotDisposed();\n        const tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;\n        const indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.indentSize;\n        const insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;\n        const trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n        const bracketPairColorizationOptions = (typeof _newOpts.bracketColorizationOptions !== 'undefined') ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;\n        const newOpts = new model.TextModelResolvedOptions({\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            defaultEOL: this._options.defaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            bracketPairColorizationOptions,\n        });\n        if (this._options.equals(newOpts)) {\n            return;\n        }\n        const e = this._options.createChangeEvent(newOpts);\n        this._options = newOpts;\n        this._bracketPairs.handleDidChangeOptions(e);\n        this._decorationProvider.handleDidChangeOptions(e);\n        this._onDidChangeOptions.fire(e);\n    }\n    detectIndentation(defaultInsertSpaces, defaultTabSize) {\n        this._assertNotDisposed();\n        const guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n        this.updateOptions({\n            insertSpaces: guessedIndentation.insertSpaces,\n            tabSize: guessedIndentation.tabSize,\n            indentSize: guessedIndentation.tabSize, // TODO@Alex: guess indentSize independent of tabSize\n        });\n    }\n    normalizeIndentation(str) {\n        this._assertNotDisposed();\n        return normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n    }\n    //#endregion\n    //#region Reading\n    getVersionId() {\n        this._assertNotDisposed();\n        return this._versionId;\n    }\n    mightContainRTL() {\n        return this._buffer.mightContainRTL();\n    }\n    mightContainUnusualLineTerminators() {\n        return this._buffer.mightContainUnusualLineTerminators();\n    }\n    removeUnusualLineTerminators(selections = null) {\n        const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n        this._buffer.resetMightContainUnusualLineTerminators();\n        this.pushEditOperations(selections, matches.map(m => ({ range: m.range, text: null })), () => null);\n    }\n    mightContainNonBasicASCII() {\n        return this._buffer.mightContainNonBasicASCII();\n    }\n    getAlternativeVersionId() {\n        this._assertNotDisposed();\n        return this._alternativeVersionId;\n    }\n    getInitialUndoRedoSnapshot() {\n        this._assertNotDisposed();\n        return this._initialUndoRedoSnapshot;\n    }\n    getOffsetAt(rawPosition) {\n        this._assertNotDisposed();\n        const position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* StringOffsetValidationType.Relaxed */);\n        return this._buffer.getOffsetAt(position.lineNumber, position.column);\n    }\n    getPositionAt(rawOffset) {\n        this._assertNotDisposed();\n        const offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));\n        return this._buffer.getPositionAt(offset);\n    }\n    _increaseVersionId() {\n        this._versionId = this._versionId + 1;\n        this._alternativeVersionId = this._versionId;\n    }\n    _overwriteVersionId(versionId) {\n        this._versionId = versionId;\n    }\n    _overwriteAlternativeVersionId(newAlternativeVersionId) {\n        this._alternativeVersionId = newAlternativeVersionId;\n    }\n    _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\n        this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n    }\n    getValue(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM() + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    createSnapshot(preserveBOM = false) {\n        return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n    }\n    getValueLength(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM().length + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    getValueInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n    }\n    getValueLengthInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n    }\n    getCharacterCountInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n    }\n    getLineCount() {\n        this._assertNotDisposed();\n        return this._buffer.getLineCount();\n    }\n    getLineContent(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber);\n    }\n    getLinesContent() {\n        this._assertNotDisposed();\n        return this._buffer.getLinesContent();\n    }\n    getEOL() {\n        this._assertNotDisposed();\n        return this._buffer.getEOL();\n    }\n    getEndOfLineSequence() {\n        this._assertNotDisposed();\n        return (this._buffer.getEOL() === '\\n'\n            ? 0 /* model.EndOfLineSequence.LF */\n            : 1 /* model.EndOfLineSequence.CRLF */);\n    }\n    getLineMinColumn(lineNumber) {\n        this._assertNotDisposed();\n        return 1;\n    }\n    getLineMaxColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber) + 1;\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new Error('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n    }\n    /**\n     * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n     * Will try to not allocate if possible.\n     */\n    _validateRangeRelaxedNoAllocations(range) {\n        const linesCount = this._buffer.getLineCount();\n        const initialStartLineNumber = range.startLineNumber;\n        const initialStartColumn = range.startColumn;\n        let startLineNumber = Math.floor((typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber)) ? initialStartLineNumber : 1);\n        let startColumn = Math.floor((typeof initialStartColumn === 'number' && !isNaN(initialStartColumn)) ? initialStartColumn : 1);\n        if (startLineNumber < 1) {\n            startLineNumber = 1;\n            startColumn = 1;\n        }\n        else if (startLineNumber > linesCount) {\n            startLineNumber = linesCount;\n            startColumn = this.getLineMaxColumn(startLineNumber);\n        }\n        else {\n            if (startColumn <= 1) {\n                startColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(startLineNumber);\n                if (startColumn >= maxColumn) {\n                    startColumn = maxColumn;\n                }\n            }\n        }\n        const initialEndLineNumber = range.endLineNumber;\n        const initialEndColumn = range.endColumn;\n        let endLineNumber = Math.floor((typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber)) ? initialEndLineNumber : 1);\n        let endColumn = Math.floor((typeof initialEndColumn === 'number' && !isNaN(initialEndColumn)) ? initialEndColumn : 1);\n        if (endLineNumber < 1) {\n            endLineNumber = 1;\n            endColumn = 1;\n        }\n        else if (endLineNumber > linesCount) {\n            endLineNumber = linesCount;\n            endColumn = this.getLineMaxColumn(endLineNumber);\n        }\n        else {\n            if (endColumn <= 1) {\n                endColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(endLineNumber);\n                if (endColumn >= maxColumn) {\n                    endColumn = maxColumn;\n                }\n            }\n        }\n        if (initialStartLineNumber === startLineNumber\n            && initialStartColumn === startColumn\n            && initialEndLineNumber === endLineNumber\n            && initialEndColumn === endColumn\n            && range instanceof Range\n            && !(range instanceof Selection)) {\n            return range;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    _isValidPosition(lineNumber, column, validationType) {\n        if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n            return false;\n        }\n        if (isNaN(lineNumber) || isNaN(column)) {\n            return false;\n        }\n        if (lineNumber < 1 || column < 1) {\n            return false;\n        }\n        if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n            return false;\n        }\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber > lineCount) {\n            return false;\n        }\n        if (column === 1) {\n            return true;\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column > maxColumn) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _validatePosition(_lineNumber, _column, validationType) {\n        const lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);\n        const column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber < 1) {\n            return new Position(1, 1);\n        }\n        if (lineNumber > lineCount) {\n            return new Position(lineCount, this.getLineMaxColumn(lineCount));\n        }\n        if (column <= 1) {\n            return new Position(lineNumber, 1);\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column >= maxColumn) {\n            return new Position(lineNumber, maxColumn);\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // If the position would end up in the middle of a high-low surrogate pair,\n            // we move it to before the pair\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return new Position(lineNumber, column - 1);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    validatePosition(position) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if (position instanceof Position) {\n            if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n                return position;\n            }\n        }\n        return this._validatePosition(position.lineNumber, position.column, validationType);\n    }\n    _isValidRange(range, validationType) {\n        const startLineNumber = range.startLineNumber;\n        const startColumn = range.startColumn;\n        const endLineNumber = range.endLineNumber;\n        const endColumn = range.endColumn;\n        if (!this._isValidPosition(startLineNumber, startColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (!this._isValidPosition(endLineNumber, endColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    validateRange(_range) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if ((_range instanceof Range) && !(_range instanceof Selection)) {\n            if (this._isValidRange(_range, validationType)) {\n                return _range;\n            }\n        }\n        const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const startLineNumber = start.lineNumber;\n        const startColumn = start.column;\n        const endLineNumber = end.lineNumber;\n        const endColumn = end.column;\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            }\n            if (startLineNumber === endLineNumber && startColumn === endColumn) {\n                // do not expand a collapsed range, simply move it to a valid location\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n            }\n            if (startInsideSurrogatePair && endInsideSurrogatePair) {\n                // expand range at both ends\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n            }\n            if (startInsideSurrogatePair) {\n                // only expand range at the start\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n            }\n            // only expand range at the end\n            return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    modifyPosition(rawPosition, offset) {\n        this._assertNotDisposed();\n        const candidate = this.getOffsetAt(rawPosition) + offset;\n        return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n    }\n    getFullModelRange() {\n        this._assertNotDisposed();\n        const lineCount = this.getLineCount();\n        return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = LIMIT_FIND_COUNT) {\n        this._assertNotDisposed();\n        let searchRanges = null;\n        if (rawSearchScope !== null) {\n            if (!Array.isArray(rawSearchScope)) {\n                rawSearchScope = [rawSearchScope];\n            }\n            if (rawSearchScope.every((searchScope) => Range.isIRange(searchScope))) {\n                searchRanges = rawSearchScope.map((searchScope) => this.validateRange(searchScope));\n            }\n        }\n        if (searchRanges === null) {\n            searchRanges = [this.getFullModelRange()];\n        }\n        searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n        const uniqueSearchRanges = [];\n        uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n            if (Range.areIntersecting(prev, curr)) {\n                return prev.plusRange(curr);\n            }\n            uniqueSearchRanges.push(prev);\n            return curr;\n        }));\n        let matchMapper;\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            // not regex, not multi line\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return [];\n            }\n            matchMapper = (searchRange) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n        }\n        else {\n            matchMapper = (searchRange) => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n        }\n        return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\n    }\n    findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return null;\n            }\n            const lineCount = this.getLineCount();\n            let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n            let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n            ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            return null;\n        }\n        return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    //#endregion\n    //#region Editing\n    pushStackElement() {\n        this._commandManager.pushStackElement();\n    }\n    popStackElement() {\n        this._commandManager.popStackElement();\n    }\n    pushEOL(eol) {\n        const currentEOL = (this.getEOL() === '\\n' ? 0 /* model.EndOfLineSequence.LF */ : 1 /* model.EndOfLineSequence.CRLF */);\n        if (currentEOL === eol) {\n            return;\n        }\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            if (this._initialUndoRedoSnapshot === null) {\n                this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n            }\n            this._commandManager.pushEOL(eol);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _validateEditOperation(rawOperation) {\n        if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n            return rawOperation;\n        }\n        return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\n    }\n    _validateEditOperations(rawOperations) {\n        const result = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            result[i] = this._validateEditOperation(rawOperations[i]);\n        }\n        return result;\n    }\n    pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer) {\n        if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n            // Go through each saved line number and insert a trim whitespace edit\n            // if it is safe to do so (no conflicts with other edits).\n            const incomingEdits = editOperations.map((op) => {\n                return {\n                    range: this.validateRange(op.range),\n                    text: op.text\n                };\n            });\n            // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n            // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n            let editsAreNearCursors = true;\n            if (beforeCursorState) {\n                for (let i = 0, len = beforeCursorState.length; i < len; i++) {\n                    const sel = beforeCursorState[i];\n                    let foundEditNearSel = false;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n                        const selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n                        if (!selIsAbove && !selIsBelow) {\n                            foundEditNearSel = true;\n                            break;\n                        }\n                    }\n                    if (!foundEditNearSel) {\n                        editsAreNearCursors = false;\n                        break;\n                    }\n                }\n            }\n            if (editsAreNearCursors) {\n                for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n                    const trimLineNumber = this._trimAutoWhitespaceLines[i];\n                    const maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n                    let allowTrimLine = true;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const editText = incomingEdits[j].text;\n                        if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n                            // `trimLine` is completely outside this edit\n                            continue;\n                        }\n                        // At this point:\n                        //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) after `trimLine`\n                            continue;\n                        }\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) before `trimLine`\n                            continue;\n                        }\n                        // Looks like we can't trim this line as it would interfere with an incoming edit\n                        allowTrimLine = false;\n                        break;\n                    }\n                    if (allowTrimLine) {\n                        const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n                        editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n                    }\n                }\n            }\n            this._trimAutoWhitespaceLines = null;\n        }\n        if (this._initialUndoRedoSnapshot === null) {\n            this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n        }\n        return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer);\n    }\n    _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.newPosition);\n            const rangeEnd = this.getPositionAt(change.newEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.oldText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.oldPosition);\n            const rangeEnd = this.getPositionAt(change.oldEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.newText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            this._isUndoing = isUndoing;\n            this._isRedoing = isRedoing;\n            this.applyEdits(edits, false);\n            this.setEOL(eol);\n            this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n        }\n        finally {\n            this._isUndoing = false;\n            this._isRedoing = false;\n            this._eventEmitter.endDeferredEmit(resultingSelection);\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    applyEdits(rawOperations, computeUndoEdits = false) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            const operations = this._validateEditOperations(rawOperations);\n            return this._doApplyEdits(operations, computeUndoEdits);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _doApplyEdits(rawOperations, computeUndoEdits) {\n        const oldLineCount = this._buffer.getLineCount();\n        const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n        const newLineCount = this._buffer.getLineCount();\n        const contentChanges = result.changes;\n        this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n        if (contentChanges.length !== 0) {\n            // We do a first pass to update tokens and decorations\n            // because we want to read decorations in the second pass\n            // where we will emit content change events\n            // and we want to read the final decorations\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                const [eolCount, firstLineLength, lastLineLength] = countEOL(change.text);\n                this._tokenizationTextModelPart.acceptEdit(change.range, change.text, eolCount, firstLineLength, lastLineLength);\n                this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n            }\n            const rawContentChanges = [];\n            this._increaseVersionId();\n            let lineCount = oldLineCount;\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                const [eolCount] = countEOL(change.text);\n                this._onDidChangeDecorations.fire();\n                const startLineNumber = change.range.startLineNumber;\n                const endLineNumber = change.range.endLineNumber;\n                const deletingLinesCnt = endLineNumber - startLineNumber;\n                const insertingLinesCnt = eolCount;\n                const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n                const changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);\n                const currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;\n                const firstEditLineNumber = currentEditStartLineNumber;\n                const lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;\n                const decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new Position(firstEditLineNumber, 1)), this.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);\n                const injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);\n                const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                for (let j = editingLinesCnt; j >= 0; j--) {\n                    const editLineNumber = startLineNumber + j;\n                    const currentEditLineNumber = currentEditStartLineNumber + j;\n                    injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);\n                    const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);\n                    rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));\n                }\n                if (editingLinesCnt < deletingLinesCnt) {\n                    // Must delete some lines\n                    const spliceStartLineNumber = startLineNumber + editingLinesCnt;\n                    rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n                }\n                if (editingLinesCnt < insertingLinesCnt) {\n                    const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                    // Must insert some lines\n                    const spliceLineNumber = startLineNumber + editingLinesCnt;\n                    const cnt = insertingLinesCnt - editingLinesCnt;\n                    const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n                    const injectedTexts = [];\n                    const newLines = [];\n                    for (let i = 0; i < cnt; i++) {\n                        const lineNumber = fromLineNumber + i;\n                        newLines[i] = this.getLineContent(lineNumber);\n                        injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber < lineNumber);\n                        injectedTexts[i] = injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber === lineNumber);\n                    }\n                    rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines, injectedTexts));\n                }\n                lineCount += changeLineCountDelta;\n            }\n            this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n                changes: contentChanges,\n                eol: this._buffer.getEOL(),\n                versionId: this.getVersionId(),\n                isUndoing: this._isUndoing,\n                isRedoing: this._isRedoing,\n                isFlush: false\n            });\n        }\n        return (result.reverseEdits === null ? undefined : result.reverseEdits);\n    }\n    undo() {\n        return this._undoRedoService.undo(this.uri);\n    }\n    canUndo() {\n        return this._undoRedoService.canUndo(this.uri);\n    }\n    redo() {\n        return this._undoRedoService.redo(this.uri);\n    }\n    canRedo() {\n        return this._undoRedoService.canRedo(this.uri);\n    }\n    //#endregion\n    //#region Decorations\n    handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines) {\n        // This is called before the decoration changed event is fired.\n        if (affectedInjectedTextLines === null || affectedInjectedTextLines.size === 0) {\n            return;\n        }\n        const affectedLines = Array.from(affectedInjectedTextLines);\n        const lineChangeEvents = affectedLines.map(lineNumber => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));\n        this._onDidChangeInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));\n    }\n    changeDecorations(callback, ownerId = 0) {\n        this._assertNotDisposed();\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._changeDecorations(ownerId, callback);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _changeDecorations(ownerId, callback) {\n        const changeAccessor = {\n            addDecoration: (range, options) => {\n                return this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];\n            },\n            changeDecoration: (id, newRange) => {\n                this._changeDecorationImpl(id, newRange);\n            },\n            changeDecorationOptions: (id, options) => {\n                this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n            },\n            removeDecoration: (id) => {\n                this._deltaDecorationsImpl(ownerId, [id], []);\n            },\n            deltaDecorations: (oldDecorations, newDecorations) => {\n                if (oldDecorations.length === 0 && newDecorations.length === 0) {\n                    // nothing to do\n                    return [];\n                }\n                return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n            }\n        };\n        let result = null;\n        try {\n            result = callback(changeAccessor);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n        // Invalidate change accessor\n        changeAccessor.addDecoration = invalidFunc;\n        changeAccessor.changeDecoration = invalidFunc;\n        changeAccessor.changeDecorationOptions = invalidFunc;\n        changeAccessor.removeDecoration = invalidFunc;\n        changeAccessor.deltaDecorations = invalidFunc;\n        return result;\n    }\n    deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {\n        this._assertNotDisposed();\n        if (!oldDecorations) {\n            oldDecorations = [];\n        }\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n            // nothing to do\n            return [];\n        }\n        try {\n            this._deltaDecorationCallCnt++;\n            if (this._deltaDecorationCallCnt > 1) {\n                console.warn(`Invoking deltaDecorations recursively could lead to leaking decorations.`);\n                onUnexpectedError(new Error(`Invoking deltaDecorations recursively could lead to leaking decorations.`));\n            }\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n            this._deltaDecorationCallCnt--;\n        }\n    }\n    _getTrackedRange(id) {\n        return this.getDecorationRange(id);\n    }\n    _setTrackedRange(id, newRange, newStickiness) {\n        const node = (id ? this._decorations[id] : null);\n        if (!node) {\n            if (!newRange) {\n                // node doesn't exist, the request is to delete => nothing to do\n                return null;\n            }\n            // node doesn't exist, the request is to set => add the tracked range\n            return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }])[0];\n        }\n        if (!newRange) {\n            // node exists, the request is to delete => delete node\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n            return null;\n        }\n        // node exists, the request is to set => change the tracked range and its options\n        const range = this._validateRangeRelaxedNoAllocations(newRange);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n        this._decorationsTree.insert(node);\n        return node.id;\n    }\n    removeAllDecorationsWithOwnerId(ownerId) {\n        if (this._isDisposed) {\n            return;\n        }\n        const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i];\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n        }\n    }\n    getDecorationOptions(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return node.options;\n    }\n    getDecorationRange(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return this._decorationsTree.getNodeRange(this, node);\n    }\n    getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            return [];\n        }\n        return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n    }\n    getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false) {\n        const lineCount = this.getLineCount();\n        const startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n        const endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        const range = new Range(startLineNumber, 1, endLineNumber, endColumn);\n        const decorations = this._getDecorationsInRange(range, ownerId, filterOutValidation);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation));\n        return decorations;\n    }\n    getDecorationsInRange(range, ownerId = 0, filterOutValidation = false) {\n        const validatedRange = this.validateRange(range);\n        const decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation));\n        return decorations;\n    }\n    getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {\n        return this._decorationsTree.getAll(this, ownerId, filterOutValidation, true);\n    }\n    getInjectedTextDecorations(ownerId = 0) {\n        return this._decorationsTree.getAllInjectedText(this, ownerId);\n    }\n    _getInjectedTextInLine(lineNumber) {\n        const startOffset = this._buffer.getOffsetAt(lineNumber, 1);\n        const endOffset = startOffset + this._buffer.getLineLength(lineNumber);\n        const result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);\n        return LineInjectedText.fromDecorations(result).filter(t => t.lineNumber === lineNumber);\n    }\n    getAllDecorations(ownerId = 0, filterOutValidation = false) {\n        let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, false);\n        result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));\n        return result;\n    }\n    _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation) {\n        const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n        const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n        return this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation);\n    }\n    getRangeAt(start, end) {\n        return this._buffer.getRangeAt(start, end - start);\n    }\n    _changeDecorationImpl(decorationId, _range) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        if (node.options.after) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);\n        }\n        if (node.options.before) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.startLineNumber);\n        }\n        const range = this._validateRangeRelaxedNoAllocations(_range);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        this._decorationsTree.insert(node);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        if (node.options.after) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n        }\n        if (node.options.before) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n        }\n    }\n    _changeDecorationOptionsImpl(decorationId, options) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        const nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n        const nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        this._onDidChangeDecorations.checkAffectedAndFire(options);\n        if (node.options.after || options.after) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n        }\n        if (node.options.before || options.before) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n        }\n        if (nodeWasInOverviewRuler !== nodeIsInOverviewRuler) {\n            // Delete + Insert due to an overview ruler status change\n            this._decorationsTree.delete(node);\n            node.setOptions(options);\n            this._decorationsTree.insert(node);\n        }\n        else {\n            node.setOptions(options);\n        }\n    }\n    _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations) {\n        const versionId = this.getVersionId();\n        const oldDecorationsLen = oldDecorationsIds.length;\n        let oldDecorationIndex = 0;\n        const newDecorationsLen = newDecorations.length;\n        let newDecorationIndex = 0;\n        const result = new Array(newDecorationsLen);\n        while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n            let node = null;\n            if (oldDecorationIndex < oldDecorationsLen) {\n                // (1) get ourselves an old node\n                do {\n                    node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n                } while (!node && oldDecorationIndex < oldDecorationsLen);\n                // (2) remove the node from the tree (if it exists)\n                if (node) {\n                    if (node.options.after) {\n                        const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n                    }\n                    if (node.options.before) {\n                        const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n                    }\n                    this._decorationsTree.delete(node);\n                    this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n                }\n            }\n            if (newDecorationIndex < newDecorationsLen) {\n                // (3) create a new node if necessary\n                if (!node) {\n                    const internalDecorationId = (++this._lastDecorationId);\n                    const decorationId = `${this._instanceId};${internalDecorationId}`;\n                    node = new IntervalNode(decorationId, 0, 0);\n                    this._decorations[decorationId] = node;\n                }\n                // (4) initialize node\n                const newDecoration = newDecorations[newDecorationIndex];\n                const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n                const options = _normalizeOptions(newDecoration.options);\n                const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n                const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n                node.ownerId = ownerId;\n                node.reset(versionId, startOffset, endOffset, range);\n                node.setOptions(options);\n                if (node.options.after) {\n                    this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n                }\n                if (node.options.before) {\n                    this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n                }\n                this._onDidChangeDecorations.checkAffectedAndFire(options);\n                this._decorationsTree.insert(node);\n                result[newDecorationIndex] = node.id;\n                newDecorationIndex++;\n            }\n            else {\n                if (node) {\n                    delete this._decorations[node.id];\n                }\n            }\n        }\n        return result;\n    }\n    //#endregion\n    //#region Tokenization\n    // TODO move them to the tokenization part.\n    getLanguageId() {\n        return this.tokenization.getLanguageId();\n    }\n    setMode(languageId) {\n        this.tokenization.setLanguageId(languageId);\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        return this.tokenization.getLanguageIdAtPosition(lineNumber, column);\n    }\n    getWordAtPosition(position) {\n        return this._tokenizationTextModelPart.getWordAtPosition(position);\n    }\n    getWordUntilPosition(position) {\n        return this._tokenizationTextModelPart.getWordUntilPosition(position);\n    }\n    //#endregion\n    normalizePosition(position, affinity) {\n        return position;\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        // Columns start with 1.\n        return indentOfLine(this.getLineContent(lineNumber)) + 1;\n    }\n};\nTextModel.MODEL_SYNC_LIMIT = 50 * 1024 * 1024; // 50 MB\nTextModel.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; // 20 MB;\nTextModel.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; // 300K lines\nTextModel.DEFAULT_CREATION_OPTIONS = {\n    isForSimpleWidget: false,\n    tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n    indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n    insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n    detectIndentation: false,\n    defaultEOL: 1 /* model.DefaultEndOfLine.LF */,\n    trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n    largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n    bracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions,\n};\nTextModel = __decorate([\n    __param(4, IUndoRedoService),\n    __param(5, ILanguageService),\n    __param(6, ILanguageConfigurationService)\n], TextModel);\nexport { TextModel };\nfunction indentOfLine(line) {\n    let indent = 0;\n    for (const c of line) {\n        if (c === ' ' || c === '\\t') {\n            indent++;\n        }\n        else {\n            break;\n        }\n    }\n    return indent;\n}\n//#region Decorations\nfunction isNodeInOverviewRuler(node) {\n    return (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n}\nfunction isNodeInjectedText(node) {\n    return !!node.options.after || !!node.options.before;\n}\nclass DecorationsTrees {\n    constructor() {\n        this._decorationsTree0 = new IntervalTree();\n        this._decorationsTree1 = new IntervalTree();\n        this._injectedTextDecorationsTree = new IntervalTree();\n    }\n    ensureAllNodesHaveRanges(host) {\n        this.getAll(host, 0, false, false);\n    }\n    _ensureNodesHaveRanges(host, nodes) {\n        for (const node of nodes) {\n            if (node.range === null) {\n                node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n            }\n        }\n        return nodes;\n    }\n    getAllInInterval(host, start, end, filterOwnerId, filterOutValidation) {\n        const versionId = host.getVersionId();\n        const result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, versionId);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId) {\n        const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n        const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n        const r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId);\n        return r0.concat(r1).concat(r2);\n    }\n    getInjectedTextInInterval(host, start, end, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, versionId);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAllInjectedText(host, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.search(filterOwnerId, false, versionId);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAll(host, filterOwnerId, filterOutValidation, overviewRulerOnly) {\n        const versionId = host.getVersionId();\n        const result = this._search(filterOwnerId, filterOutValidation, overviewRulerOnly, versionId);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId) {\n        if (overviewRulerOnly) {\n            return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n        }\n        else {\n            const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId);\n            const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId);\n            const r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, cachedVersionId);\n            return r0.concat(r1).concat(r2);\n        }\n    }\n    collectNodesFromOwner(ownerId) {\n        const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n        const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n        const r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);\n        return r0.concat(r1).concat(r2);\n    }\n    collectNodesPostOrder() {\n        const r0 = this._decorationsTree0.collectNodesPostOrder();\n        const r1 = this._decorationsTree1.collectNodesPostOrder();\n        const r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();\n        return r0.concat(r1).concat(r2);\n    }\n    insert(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.insert(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.insert(node);\n        }\n        else {\n            this._decorationsTree0.insert(node);\n        }\n    }\n    delete(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.delete(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.delete(node);\n        }\n        else {\n            this._decorationsTree0.delete(node);\n        }\n    }\n    getNodeRange(host, node) {\n        const versionId = host.getVersionId();\n        if (node.cachedVersionId !== versionId) {\n            this._resolveNode(node, versionId);\n        }\n        if (node.range === null) {\n            node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n        }\n        return node.range;\n    }\n    _resolveNode(node, cachedVersionId) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.resolveNode(node, cachedVersionId);\n        }\n        else {\n            this._decorationsTree0.resolveNode(node, cachedVersionId);\n        }\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    }\n}\nfunction cleanClassName(className) {\n    return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\nclass DecorationOptions {\n    constructor(options) {\n        this.color = options.color || '';\n        this.darkColor = options.darkColor || '';\n    }\n}\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this._resolvedColor = null;\n        this.position = (typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center);\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = null;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return color;\n        }\n        const c = color ? theme.getColor(color.id) : null;\n        if (!c) {\n            return '';\n        }\n        return c.toString();\n    }\n}\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this.position = options.position;\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = undefined;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return Color.fromHex(color);\n        }\n        return theme.getColor(color.id);\n    }\n}\nexport class ModelDecorationInjectedTextOptions {\n    constructor(options) {\n        this.content = options.content || '';\n        this.inlineClassName = options.inlineClassName || null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.attachedData = options.attachedData || null;\n        this.cursorStops = options.cursorStops || null;\n    }\n    static from(options) {\n        if (options instanceof ModelDecorationInjectedTextOptions) {\n            return options;\n        }\n        return new ModelDecorationInjectedTextOptions(options);\n    }\n}\nexport class ModelDecorationOptions {\n    constructor(options) {\n        var _a, _b;\n        this.description = options.description;\n        this.blockClassName = options.blockClassName ? cleanClassName(options.blockClassName) : null;\n        this.stickiness = options.stickiness || 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */;\n        this.zIndex = options.zIndex || 0;\n        this.className = options.className ? cleanClassName(options.className) : null;\n        this.hoverMessage = options.hoverMessage || null;\n        this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n        this.isWholeLine = options.isWholeLine || false;\n        this.showIfCollapsed = options.showIfCollapsed || false;\n        this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n        this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n        this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n        this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n        this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n        this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n        this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n        this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n        this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n        this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;\n        this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;\n        this.hideInCommentTokens = (_a = options.hideInCommentTokens) !== null && _a !== void 0 ? _a : false;\n        this.hideInStringTokens = (_b = options.hideInStringTokens) !== null && _b !== void 0 ? _b : false;\n    }\n    static register(options) {\n        return new ModelDecorationOptions(options);\n    }\n    static createDynamic(options) {\n        return new ModelDecorationOptions(options);\n    }\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({ description: 'empty' });\n/**\n * The order carefully matches the values of the enum.\n */\nconst TRACKED_RANGE_OPTIONS = [\n    ModelDecorationOptions.register({ description: 'tracked-range-always-grows-when-typing-at-edges', stickiness: 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-never-grows-when-typing-at-edges', stickiness: 1 /* model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-before', stickiness: 2 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-after', stickiness: 3 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */ }),\n];\nfunction _normalizeOptions(options) {\n    if (options instanceof ModelDecorationOptions) {\n        return options;\n    }\n    return ModelDecorationOptions.createDynamic(options);\n}\nexport class DidChangeDecorationsEmitter extends Disposable {\n    constructor(handleBeforeFire) {\n        super();\n        this.handleBeforeFire = handleBeforeFire;\n        this._actual = this._register(new Emitter());\n        this.event = this._actual.event;\n        this._affectedInjectedTextLines = null;\n        this._deferredCnt = 0;\n        this._shouldFire = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit() {\n        var _a;\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._shouldFire) {\n                this.handleBeforeFire(this._affectedInjectedTextLines);\n                const event = {\n                    affectsMinimap: this._affectsMinimap,\n                    affectsOverviewRuler: this._affectsOverviewRuler\n                };\n                this._shouldFire = false;\n                this._affectsMinimap = false;\n                this._affectsOverviewRuler = false;\n                this._actual.fire(event);\n            }\n            (_a = this._affectedInjectedTextLines) === null || _a === void 0 ? void 0 : _a.clear();\n            this._affectedInjectedTextLines = null;\n        }\n    }\n    recordLineAffectedByInjectedText(lineNumber) {\n        if (!this._affectedInjectedTextLines) {\n            this._affectedInjectedTextLines = new Set();\n        }\n        this._affectedInjectedTextLines.add(lineNumber);\n    }\n    checkAffectedAndFire(options) {\n        if (!this._affectsMinimap) {\n            this._affectsMinimap = options.minimap && options.minimap.position ? true : false;\n        }\n        if (!this._affectsOverviewRuler) {\n            this._affectsOverviewRuler = options.overviewRuler && options.overviewRuler.color ? true : false;\n        }\n        this._shouldFire = true;\n    }\n    fire() {\n        this._affectsMinimap = true;\n        this._affectsOverviewRuler = true;\n        this._shouldFire = true;\n    }\n}\n//#endregion\nexport class DidChangeContentEmitter extends Disposable {\n    constructor() {\n        super();\n        /**\n         * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n         */\n        this._fastEmitter = this._register(new Emitter());\n        this.fastEvent = this._fastEmitter.event;\n        this._slowEmitter = this._register(new Emitter());\n        this.slowEvent = this._slowEmitter.event;\n        this._deferredCnt = 0;\n        this._deferredEvent = null;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit(resultingSelection = null) {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._deferredEvent !== null) {\n                this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n                const e = this._deferredEvent;\n                this._deferredEvent = null;\n                this._fastEmitter.fire(e);\n                this._slowEmitter.fire(e);\n            }\n        }\n    }\n    fire(e) {\n        if (this._deferredCnt > 0) {\n            if (this._deferredEvent) {\n                this._deferredEvent = this._deferredEvent.merge(e);\n            }\n            else {\n                this._deferredEvent = e;\n            }\n            return;\n        }\n        this._fastEmitter.fire(e);\n        this._slowEmitter.fire(e);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Disposable } from '../../../base/common/lifecycle.js';\nexport class TextModelPart extends Disposable {\n    constructor() {\n        super(...arguments);\n        this._isDisposed = false;\n    }\n    dispose() {\n        super.dispose();\n        this._isDisposed = true;\n    }\n    assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new Error('TextModelPart is disposed!');\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { FindMatch, SearchData } from '../model.js';\nconst LIMIT_FIND_COUNT = 999;\nexport class SearchParams {\n    constructor(searchString, isRegex, matchCase, wordSeparators) {\n        this.searchString = searchString;\n        this.isRegex = isRegex;\n        this.matchCase = matchCase;\n        this.wordSeparators = wordSeparators;\n    }\n    parseSearchRequest() {\n        if (this.searchString === '') {\n            return null;\n        }\n        // Try to create a RegExp out of the params\n        let multiline;\n        if (this.isRegex) {\n            multiline = isMultilineRegexSource(this.searchString);\n        }\n        else {\n            multiline = (this.searchString.indexOf('\\n') >= 0);\n        }\n        let regex = null;\n        try {\n            regex = strings.createRegExp(this.searchString, this.isRegex, {\n                matchCase: this.matchCase,\n                wholeWord: false,\n                multiline: multiline,\n                global: true,\n                unicode: true\n            });\n        }\n        catch (err) {\n            return null;\n        }\n        if (!regex) {\n            return null;\n        }\n        let canUseSimpleSearch = (!this.isRegex && !multiline);\n        if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\n            // casing might make a difference\n            canUseSimpleSearch = this.matchCase;\n        }\n        return new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators) : null, canUseSimpleSearch ? this.searchString : null);\n    }\n}\nexport function isMultilineRegexSource(searchString) {\n    if (!searchString || searchString.length === 0) {\n        return false;\n    }\n    for (let i = 0, len = searchString.length; i < len; i++) {\n        const chCode = searchString.charCodeAt(i);\n        if (chCode === 10 /* CharCode.LineFeed */) {\n            return true;\n        }\n        if (chCode === 92 /* CharCode.Backslash */) {\n            // move to next char\n            i++;\n            if (i >= len) {\n                // string ends with a \\\n                break;\n            }\n            const nextChCode = searchString.charCodeAt(i);\n            if (nextChCode === 110 /* CharCode.n */ || nextChCode === 114 /* CharCode.r */ || nextChCode === 87 /* CharCode.W */) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexport function createFindMatch(range, rawMatches, captureMatches) {\n    if (!captureMatches) {\n        return new FindMatch(range, null);\n    }\n    const matches = [];\n    for (let i = 0, len = rawMatches.length; i < len; i++) {\n        matches[i] = rawMatches[i];\n    }\n    return new FindMatch(range, matches);\n}\nclass LineFeedCounter {\n    constructor(text) {\n        const lineFeedsOffsets = [];\n        let lineFeedsOffsetsLen = 0;\n        for (let i = 0, textLen = text.length; i < textLen; i++) {\n            if (text.charCodeAt(i) === 10 /* CharCode.LineFeed */) {\n                lineFeedsOffsets[lineFeedsOffsetsLen++] = i;\n            }\n        }\n        this._lineFeedsOffsets = lineFeedsOffsets;\n    }\n    findLineFeedCountBeforeOffset(offset) {\n        const lineFeedsOffsets = this._lineFeedsOffsets;\n        let min = 0;\n        let max = lineFeedsOffsets.length - 1;\n        if (max === -1) {\n            // no line feeds\n            return 0;\n        }\n        if (offset <= lineFeedsOffsets[0]) {\n            // before first line feed\n            return 0;\n        }\n        while (min < max) {\n            const mid = min + ((max - min) / 2 >> 0);\n            if (lineFeedsOffsets[mid] >= offset) {\n                max = mid - 1;\n            }\n            else {\n                if (lineFeedsOffsets[mid + 1] >= offset) {\n                    // bingo!\n                    min = mid;\n                    max = mid;\n                }\n                else {\n                    min = mid + 1;\n                }\n            }\n        }\n        return min + 1;\n    }\n}\nexport class TextModelSearch {\n    static findMatches(model, searchParams, searchRange, captureMatches, limitResultCount) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return [];\n        }\n        if (searchData.regex.multiline) {\n            return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\n        }\n        return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Multiline search always executes on the lines concatenated with \\n.\n     * We must therefore compensate for the count of \\n in case the model is CRLF\n     */\n    static _getMultilineMatchRange(model, deltaOffset, text, lfCounter, matchIndex, match0) {\n        let startOffset;\n        let lineFeedCountBeforeMatch = 0;\n        if (lfCounter) {\n            lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\n            startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \\r as there were \\n */;\n        }\n        else {\n            startOffset = deltaOffset + matchIndex;\n        }\n        let endOffset;\n        if (lfCounter) {\n            const lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\n            const lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\n            endOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \\r as there were \\n */;\n        }\n        else {\n            endOffset = startOffset + match0.length;\n        }\n        const startPosition = model.getPositionAt(startOffset);\n        const endPosition = model.getPositionAt(endOffset);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    static _doFindMatchesMultiline(model, searchRange, searcher, captureMatches, limitResultCount) {\n        const deltaOffset = model.getOffsetAt(searchRange.getStartPosition());\n        // We always execute multiline search over the lines joined with \\n\n        // This makes it that \\n will match the EOL for both CRLF and LF models\n        // We compensate for offset errors in `_getMultilineMatchRange`\n        const text = model.getValueInRange(searchRange, 1 /* EndOfLinePreference.LF */);\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n        const result = [];\n        let counter = 0;\n        let m;\n        searcher.reset(0);\n        while ((m = searcher.next(text))) {\n            result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n            if (counter >= limitResultCount) {\n                return result;\n            }\n        }\n        return result;\n    }\n    static _doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        // Early case for a search range that starts & stops on the same line number\n        if (searchRange.startLineNumber === searchRange.endLineNumber) {\n            const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        // Collect results from first line\n        const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\n        resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n        // Collect results from middle lines\n        for (let lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\n            resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n        }\n        // Collect results from last line\n        if (resultLen < limitResultCount) {\n            const text = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n        }\n        return result;\n    }\n    static _findMatchesInLine(searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    static findNextMatch(model, searchParams, searchStart, captureMatches) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return null;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        if (searchData.regex.multiline) {\n            return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\n        }\n        return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n    static _doFindNextMatchMultiline(model, searchStart, searcher, captureMatches) {\n        const searchTextStart = new Position(searchStart.lineNumber, 1);\n        const deltaOffset = model.getOffsetAt(searchTextStart);\n        const lineCount = model.getLineCount();\n        // We always execute multiline search over the lines joined with \\n\n        // This makes it that \\n will match the EOL for both CRLF and LF models\n        // We compensate for offset errors in `_getMultilineMatchRange`\n        const text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), 1 /* EndOfLinePreference.LF */);\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n        searcher.reset(searchStart.column - 1);\n        const m = searcher.next(text);\n        if (m) {\n            return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n        }\n        if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\n            // Try again from the top\n            return this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);\n        }\n        return null;\n    }\n    static _doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches) {\n        const lineCount = model.getLineCount();\n        const startLineNumber = searchStart.lineNumber;\n        // Look in first line\n        const text = model.getLineContent(startLineNumber);\n        const r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\n        if (r) {\n            return r;\n        }\n        for (let i = 1; i <= lineCount; i++) {\n            const lineIndex = (startLineNumber + i - 1) % lineCount;\n            const text = model.getLineContent(lineIndex + 1);\n            const r = this._findFirstMatchInLine(searcher, text, lineIndex + 1, 1, captureMatches);\n            if (r) {\n                return r;\n            }\n        }\n        return null;\n    }\n    static _findFirstMatchInLine(searcher, text, lineNumber, fromColumn, captureMatches) {\n        // Set regex to search from column\n        searcher.reset(fromColumn - 1);\n        const m = searcher.next(text);\n        if (m) {\n            return createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n        }\n        return null;\n    }\n    static findPreviousMatch(model, searchParams, searchStart, captureMatches) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return null;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        if (searchData.regex.multiline) {\n            return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\n        }\n        return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n    static _doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches) {\n        const matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\n        if (matches.length > 0) {\n            return matches[matches.length - 1];\n        }\n        const lineCount = model.getLineCount();\n        if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\n            // Try again with all content\n            return this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\n        }\n        return null;\n    }\n    static _doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches) {\n        const lineCount = model.getLineCount();\n        const startLineNumber = searchStart.lineNumber;\n        // Look in first line\n        const text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\n        const r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\n        if (r) {\n            return r;\n        }\n        for (let i = 1; i <= lineCount; i++) {\n            const lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\n            const text = model.getLineContent(lineIndex + 1);\n            const r = this._findLastMatchInLine(searcher, text, lineIndex + 1, captureMatches);\n            if (r) {\n                return r;\n            }\n        }\n        return null;\n    }\n    static _findLastMatchInLine(searcher, text, lineNumber, captureMatches) {\n        let bestResult = null;\n        let m;\n        searcher.reset(0);\n        while ((m = searcher.next(text))) {\n            bestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n        }\n        return bestResult;\n    }\n}\nfunction leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    if (matchStartIndex === 0) {\n        // Match starts at start of string\n        return true;\n    }\n    const charBefore = text.charCodeAt(matchStartIndex - 1);\n    if (wordSeparators.get(charBefore) !== 0 /* WordCharacterClass.Regular */) {\n        // The character before the match is a word separator\n        return true;\n    }\n    if (charBefore === 13 /* CharCode.CarriageReturn */ || charBefore === 10 /* CharCode.LineFeed */) {\n        // The character before the match is line break or carriage return.\n        return true;\n    }\n    if (matchLength > 0) {\n        const firstCharInMatch = text.charCodeAt(matchStartIndex);\n        if (wordSeparators.get(firstCharInMatch) !== 0 /* WordCharacterClass.Regular */) {\n            // The first character inside the match is a word separator\n            return true;\n        }\n    }\n    return false;\n}\nfunction rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    if (matchStartIndex + matchLength === textLength) {\n        // Match ends at end of string\n        return true;\n    }\n    const charAfter = text.charCodeAt(matchStartIndex + matchLength);\n    if (wordSeparators.get(charAfter) !== 0 /* WordCharacterClass.Regular */) {\n        // The character after the match is a word separator\n        return true;\n    }\n    if (charAfter === 13 /* CharCode.CarriageReturn */ || charAfter === 10 /* CharCode.LineFeed */) {\n        // The character after the match is line break or carriage return.\n        return true;\n    }\n    if (matchLength > 0) {\n        const lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\n        if (wordSeparators.get(lastCharInMatch) !== 0 /* WordCharacterClass.Regular */) {\n            // The last character in the match is a word separator\n            return true;\n        }\n    }\n    return false;\n}\nexport function isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    return (leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\n        && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength));\n}\nexport class Searcher {\n    constructor(wordSeparators, searchRegex) {\n        this._wordSeparators = wordSeparators;\n        this._searchRegex = searchRegex;\n        this._prevMatchStartIndex = -1;\n        this._prevMatchLength = 0;\n    }\n    reset(lastIndex) {\n        this._searchRegex.lastIndex = lastIndex;\n        this._prevMatchStartIndex = -1;\n        this._prevMatchLength = 0;\n    }\n    next(text) {\n        const textLength = text.length;\n        let m;\n        do {\n            if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\n                // Reached the end of the line\n                return null;\n            }\n            m = this._searchRegex.exec(text);\n            if (!m) {\n                return null;\n            }\n            const matchStartIndex = m.index;\n            const matchLength = m[0].length;\n            if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\n                if (matchLength === 0) {\n                    // the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\n                    // we attempt to recover from that by advancing by two if surrogate pair found and by one otherwise\n                    if (strings.getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 0xFFFF) {\n                        this._searchRegex.lastIndex += 2;\n                    }\n                    else {\n                        this._searchRegex.lastIndex += 1;\n                    }\n                    continue;\n                }\n                // Exit early if the regex matches the same range twice\n                return null;\n            }\n            this._prevMatchStartIndex = matchStartIndex;\n            this._prevMatchLength = matchLength;\n            if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\n                return m;\n            }\n        } while (m);\n        return null;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Returns:\n *  - -1 => the line consists of whitespace\n *  - otherwise => the indent level is returned value\n */\nexport function computeIndentLevel(line, tabSize) {\n    let indent = 0;\n    let i = 0;\n    const len = line.length;\n    while (i < len) {\n        const chCode = line.charCodeAt(i);\n        if (chCode === 32 /* CharCode.Space */) {\n            indent++;\n        }\n        else if (chCode === 9 /* CharCode.Tab */) {\n            indent = indent - indent % tabSize + tabSize;\n        }\n        else {\n            break;\n        }\n        i++;\n    }\n    if (i === len) {\n        return -1; // line only consists of whitespace\n    }\n    return indent;\n}\n"],"names":["MirrorTextModel","uri","lines","eol","versionId","this","_uri","_lines","_eol","_versionId","_lineStarts","_cachedTextValue","length","join","e","changes","change","_acceptDeleteRange","range","_acceptInsertText","Position","startLineNumber","startColumn","text","eolLength","linesLength","lineStartValues","Uint32Array","i","PrefixSumComputer","lineIndex","newValue","setValue","endLineNumber","_setLineText","substring","endColumn","splice","removeValues","position","insertText","insertLines","splitLines","lineNumber","column","newLengths","insertValues","values","prefixSum","prefixSumValidIndex","Int32Array","insertIndex","toUint32","oldValues","oldPrefixSum","insertValuesLen","set","subarray","index","value","startIndex","count","maxCount","_getPrefixSum","Math","max","sum","floor","getTotalSum","low","high","mid","midStop","midStart","PrefixSumIndexOfResult","ConstantTimePrefixSumComputer","_values","_isValid","_validEndIndex","_prefixSum","_indexBySum","_ensureValid","idx","viewLinesAbove","start","deleteCount","_invalidate","insertArr","arrayInsert","min","len","sumAbove","j","remainder","_prefixSumIndexOfResultBrand","undefined","TreeNode","piece","color","size_left","lf_left","parent","left","right","SENTINEL","leftest","node","righttest","calculateSize","calculateLF","lineFeedCnt","resetSentinel","leftRotate","tree","x","y","root","rightRotate","rbDelete","z","detach","yWasRed","recomputeTreeMetadata","newSizeLeft","newLFLeft","delta","lf_delta","updateTreeMetadata","w","fixInsert","lineFeedCntDelta","AverageBufferSize","createUintArray","arr","r","Uint16Array","LineStarts","lineStarts","cr","lf","crlf","isBasicASCII","createLineStartsFast","str","readonly","rLength","chr","charCodeAt","Piece","bufferIndex","end","StringBuffer","buffer","PieceTreeSnapshot","BOM","_pieces","_tree","_BOM","_index","iterate","push","getPieceContent","PieceTreeSearchCache","limit","_limit","_cache","offset","nodePos","nodeStartOffset","nodeStartLineNumber","nodePosition","shift","hasInvalidVal","tmp","newArr","entry","PieceTreeBase","chunks","eolNormalized","create","_buffers","_lastChangeBufferPos","line","_lineCnt","_length","_EOL","_EOLLength","_EOLNormalized","lastNode","rbInsertRight","_searchCache","_lastVisitedLine","computeBufferMetadata","averageBufferSize","tempChunk","tempChunkLen","getNodeContent","replace","newEOL","normalizeEOL","leftLen","getAccumulatedValue","lfCnt","originalOffset","out","getIndexOf","getOffsetAt","startPosition","nodeAt2","endPosition","getValueInRange2","getEOL","startOffset","offsetInBuffer","ret","next","substr","currentLine","danglingCR","pieceLength","pieceStartLine","pieceEndLine","pieceStartOffset","getLineRawContent","matchingNode","targetOffset","_getCharCode","getLineCount","getLength","searcher","startCursor","endCursor","searchData","captureMatches","limitResultCount","resultLen","result","m","searchText","startOffsetInBuffer","_wordSeparators","reset","positionInBuffer","getLineFeedCnt","retStartColumn","retEndColumn","createFindMatch","Range","searchRange","Searcher","wordSeparators","regex","findMatchesInNode","currentNode","lineBreakCnt","nextLineStartOffset","getLineContent","_findMatchesInLine","deltaOffset","simpleSearch","searchString","searchStringLen","textLength","lastMatchIndex","indexOf","isValidMatch","FindMatch","nodeAt","insertPosInBuffer","appendToNode","insertContentToNodeLeft","validate","nodesToDel","newRightPiece","shouldCheckCRLF","endWithCR","headOfRight","nodeCharCodeAt","newStart","startWithLF","tailOfLeft","previousPos","deleteNodeTail","newPieces","createNewPieces","tmpNode","k","deleteNodes","insertContentToNodeRight","pieces","rbInsertLeft","cnt","startNode","endNode","startSplitPosInBuffer","endSplitPosInBuffer","validateCRLFWithPrevNode","deleteNodeHead","validateCRLFWithNextNode","shrinkNode","prev","nPiece","newNode","adjustCarriageReturnFromNext","endOffset","previousCharOffset","cursor","nodes","lastChar","splitText","concat","slice","endIndex","endPos","newPiece","cache","get2","prevAccumulatedValue","accumulatedValue","originalLineNumber","pos","lineCnt","realLineCnt","expectedLineStartIndex","originalLFCnt","originalEndOffset","newEnd","newEndOffset","newLineFeedCnt","size_delta","newLength","originalStartOffset","originalStartPos","originalEndPos","oldLength","oldLFCnt","hitCRLF","prevStartOffset","pop","oldLineFeedCnt","get","prevAccumualtedValue","offsetOfNode","newOffset","val","nextNode","fixCRLF","prevNewLength","prevNewLFCnt","callback","leftRet","p","prevNode","PieceTreeTextBuffer","containsRTL","containsUnusualLineTerminators","_onDidChangeContent","_register","Emitter","_mightContainNonBasicASCII","_mightContainRTL","_mightContainUnusualLineTerminators","_pieceTree","preserveBOM","createSnapshot","getPositionAt","isEmpty","lineEnding","_getEndOfLine","getValueInRange","fromLineNumber","toLineNumber","lineContent","fromOffset","toOffset","strings","getValueLengthInRange","getLinesContent","getLineCharCode","getLineLength","Error","setEOL","rawOperations","recordTrimAutoWhitespace","computeUndoEdits","mightContainRTL","mightContainUnusualLineTerminators","mightContainNonBasicASCII","canReduceOperations","operations","op","_isTracked","validatedRange","textMightContainNonBasicASCII","validText","eolCount","firstLineLength","lastLineLength","strEOL","countEOL","bufferEOL","sortIndex","identifier","rangeOffset","rangeLength","forceMoveMarkers","Boolean","isAutoWhitespaceEdit","sort","_sortOpsAscending","hasTouchingRanges","rangeEnd","getEndPosition","nextRangeStart","getStartPosition","isBeforeOrEqual","isBefore","_reduceOperations","reverseRanges","_getInverseEditRanges","newTrimAutoWhitespaceCandidates","reverseRange","currentLineContent","oldContent","reverseOperations","reverseRangeDeltaOffset","bufferText","reverseRangeOffset","textChange","TextChange","a","b","contentChanges","_doApplyEdits","trimAutoWhitespaceLineNumbers","prevContent","fire","ApplyEditsResult","_toSingleEditOperation","firstEditRange","lastEditRange","entireEditRange","lastEndLineNumber","lastEndColumn","operation","_sortOpsDescending","delete","insert","contentChangeRange","findMatchesLineByLine","prevOpEndLineNumber","prevOpEndColumn","prevOp","resultRange","lineCount","Disposable","PieceTreeTextBufferFactory","_chunks","_bom","_cr","_lf","_crlf","_containsRTL","_containsUnusualLineTerminators","_isBasicASCII","_normalizeEOL","defaultEOL","totalEOLCount","totalCRCount","_getEOL","newLineStart","textBuffer","disposable","PieceTreeTextBufferBuilder","_hasPreviousChar","_previousChar","_tmpLineStarts","chunk","_acceptChunk1","allowEmptyStrings","_acceptChunk2","String","fromCharCode","createLineStarts","_finish","lastChunk","newLineStarts","ContiguousGrowingArray","_default","_store","deleteIndex","insertCount","arrays","TokenizationStateStore","tokenizationSupport","initialState","_lineBeginState","_lineNeedsTokenization","_firstLineNeedsTokenization","endState","previousEndState","equals","markMustBeTokenized","TextModelTokenization","_textModel","_tokenizationPart","_languageIdCodec","_isScheduled","_isDisposed","_tokenizationStateStore","TokenizationRegistry","languageId","getLanguageId","changedLanguages","_resetTokenizationState","clearTokens","isFlush","applyEdits","_beginBackgroundTokenization","textModel","tokenizationPart","isTooLargeForTokenization","getInitialState","onUnexpectedError","initializeTokenization","isAttachedToEditor","_hasLinesToTokenize","runWhenIdle","deadline","_backgroundTokenizeWithDeadline","endTime","Date","now","timeRemaining","execute","_backgroundTokenizeForAtLeast1ms","setTimeout0","builder","ContiguousMultilineTokensBuilder","sw","StopWatch","elapsed","_tokenizeOneInvalidLine","setTokens","finalize","_isTokenizationComplete","_tokenizeViewport","_updateTokensUntilLine","character","forceTokenization","lineStartState","getBeginState","safeTokenize","lineTokens","LineTokens","tokens","getCount","tokenIndex","findTokenIndexAtOffset","getStandardTokenType","newText","curLineContent","newLineContent","getLanguageIdAtPosition","firstInvalidLineNumber","invalidLineStartIndex","endLineIndex","add","setEndState","nonWhitespaceColumn","getLineFirstNonWhitespaceColumn","fakeLines","newNonWhitespaceIndex","state","languageIdCodec","hasEOL","tokenizeEncoded","clone","nullTokenizeEncoded","encodeLanguageId","TokenizationTextModelPart","_languageService","_languageConfigurationService","bracketPairsTextModelPart","_languageId","_onDidChangeLanguage","onDidChangeLanguage","event","_onDidChangeLanguageConfiguration","onDidChangeLanguageConfiguration","_onDidChangeTokens","onDidChangeTokens","_backgroundTokenizationState","_onBackgroundTokenizationStateChanged","_tokens","ContiguousTokensStore","_semanticTokens","SparseTokensStore","_tokenization","_languageRegistryListener","onDidChange","affects","acceptEdit","handleDidChangeAttached","flush","handleDidChangeContent","dispose","completed","newState","handleDidChangeBackgroundTokenizationState","backgroundTokenizationCompleted","ranges","element","minChangedLineNumber","maxChangedLineNumber","hasChange","getLineTokens","lineHasChange","_emitModelTokensChangedEvent","tokenizationSupportChanged","semanticTokensApplied","handleTokenizationProgress","isComplete","hasCompleteSemanticTokens","changedRange","validateRange","setPartial","tokenizeViewport","_isDisposing","handleDidChangeTokens","isCheapToTokenize","_getLineTokens","lineText","syntacticTokens","getTokens","addSparseTokens","validatePosition","getTokenTypeIfInsertingCharacter","validatedPosition","tokenizeLineWithEdit","getLanguageConfiguration","_position","assertNotDisposed","_findLanguageBoundaries","rbStartOffset","rbEndOffset","rightBiasedWord","getWordAtText","getWordDefinition","lbStartOffset","lbEndOffset","leftBiasedWord","wordAtPosition","getWordAtPosition","word","oldLanguage","newLanguage","handleDidChangeLanguage","getStartOffset","tokenCount","getEndOffset","TextModelPart","__decorate","decorators","target","key","desc","d","c","arguments","Object","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__param","paramIndex","decorator","createTextBuffer","acceptChunk","finish","createTextBufferFactory","model","snapshot","read","createTextBufferFactoryFromSnapshot","MODEL_ID","TextModelSnapshot","source","_source","_eos","resultCnt","resultLength","invalidFunc","TextModel","creationOptions","associatedResource","_undoRedoService","_onWillDispose","onWillDispose","_onDidChangeDecorations","DidChangeDecorationsEmitter","affectedInjectedTextLines","handleBeforeFireDecorationsChangedEvent","onDidChangeDecorations","_onDidChangeOptions","onDidChangeOptions","_onDidChangeAttached","onDidChangeAttached","_onDidChangeInjectedText","_eventEmitter","DidChangeContentEmitter","_deltaDecorationCallCnt","id","isForSimpleWidget","_associatedResource","URI","_attachedEditorCount","_buffer","_bufferDisposable","_options","resolveOptions","_bracketPairs","BracketPairsTextModelPart","_guidesTextModelPart","GuidesTextModelPart","_decorationProvider","ColorizedBracketPairsDecorationProvider","_tokenizationTextModelPart","bufferLineCount","bufferTextLength","largeFileOptimizations","_isTooLargeForTokenization","LARGE_FILE_SIZE_THRESHOLD","LARGE_FILE_LINE_COUNT_THRESHOLD","_isTooLargeForSyncing","MODEL_SYNC_LIMIT","_alternativeVersionId","_initialUndoRedoSnapshot","__isDisposing","_instanceId","_lastDecorationId","_decorations","_decorationsTree","DecorationsTrees","_commandManager","EditStack","_isUndoing","_isRedoing","_trimAutoWhitespaceLines","beginDeferredEmit","endDeferredEmit","listener","slowEvent","contentChangedEvent","combinedDisposable","fastEvent","emptyDisposedTextBuffer","rawChange","InternalModelContentChangeEvent","_assertNotDisposed","_setValueFromTextBuffer","isUndoing","isRedoing","getVersionId","textBufferDisposable","oldFullModelRange","getFullModelRange","oldModelValueLength","getLineMaxColumn","_increaseVersionId","clear","_emitContentChangedEvent","ModelRawContentChangedEvent","ModelRawFlush","_createContentChanged2","getValue","_onBeforeEOLChange","_onAfterEOLChange","ModelRawEOLChanged","ensureAllNodesHaveRanges","allDecorations","collectNodesPostOrder","cachedAbsoluteStart","cachedAbsoluteEnd","cachedVersionId","recomputeMaxEnd","smallLineCharCount","longLineCharCount","lineLength","tabSize","indentSize","insertSpaces","_newOpts","trimAutoWhitespace","bracketPairColorizationOptions","bracketColorizationOptions","newOpts","createChangeEvent","handleDidChangeOptions","defaultInsertSpaces","defaultTabSize","guessedIndentation","guessIndentation","updateOptions","normalizeIndentation","selections","matches","findMatches","resetMightContainUnusualLineTerminators","pushEditOperations","map","rawPosition","_validatePosition","rawOffset","newAlternativeVersionId","newInitialUndoRedoSnapshot","fullModelRange","fullModelValue","getBOM","rawRange","getCharacterCountInRange","getLineLastNonWhitespaceColumn","linesCount","initialStartLineNumber","initialStartColumn","isNaN","maxColumn","initialEndLineNumber","initialEndColumn","Selection","validationType","charCodeBefore","_lineNumber","_column","_isValidPosition","charCodeBeforeStart","charCodeBeforeEnd","startInsideSurrogatePair","endInsideSurrogatePair","_range","_isValidRange","candidate","rawSearchScope","isRegex","matchCase","searchRanges","Array","isArray","every","searchScope","d1","d2","matchMapper","uniqueSearchRanges","reduce","curr","plusRange","searchParams","SearchParams","parseSearchRequest","TextModelSearch","rawSearchStart","searchStart","pushStackElement","popStackElement","pushEOL","rawOperation","_validateEditOperation","beforeCursorState","editOperations","cursorStateComputer","_pushEditOperations","_validateEditOperations","incomingEdits","editsAreNearCursors","sel","foundEditNearSel","lenJ","editRange","selIsAbove","selIsBelow","trimLineNumber","maxLineColumn","allowTrimLine","editText","charAt","trimRange","pushEditOperation","resultingAlternativeVersionId","resultingSelection","edits","rangeStart","newPosition","oldText","_applyUndoRedoEdits","oldPosition","oldEnd","_overwriteAlternativeVersionId","oldLineCount","newLineCount","acceptReplace","rawContentChanges","deletingLinesCnt","insertingLinesCnt","editingLinesCnt","changeLineCountDelta","currentEditStartLineNumber","firstEditLineNumber","lastInsertedLineNumber","decorationsWithInjectedTextInEditedRange","getInjectedTextInInterval","injectedTextInEditedRange","LineInjectedText","injectedTextInEditedRangeQueue","ArrayQueue","editLineNumber","currentEditLineNumber","takeFromEndWhile","decorationsInCurrentLine","ModelRawLineChanged","spliceStartLineNumber","ModelRawLinesDeleted","spliceLineNumber","injectedTexts","newLines","takeWhile","ModelRawLinesInserted","reverseEdits","undo","canUndo","redo","canRedo","size","lineChangeEvents","from","_getInjectedTextInLine","ModelInjectedTextChangedEvent","ownerId","_changeDecorations","changeAccessor","addDecoration","options","_deltaDecorationsImpl","changeDecoration","newRange","_changeDecorationImpl","changeDecorationOptions","_changeDecorationOptionsImpl","_normalizeOptions","removeDecoration","deltaDecorations","oldDecorations","newDecorations","console","warn","getDecorationRange","newStickiness","TRACKED_RANGE_OPTIONS","_validateRangeRelaxedNoAllocations","setOptions","collectNodesFromOwner","decorationId","getNodeRange","filterOutValidation","getLinesDecorations","_startLineNumber","_endLineNumber","decorations","_getDecorationsInRange","pushMany","getDecorationsInRange","getAll","getAllInjectedText","filter","t","getAllDecorations","filterRange","filterOwnerId","getAllInInterval","getRangeAt","after","oldRange","recordLineAffectedByInjectedText","before","checkAffectedAndFire","nodeWasInOverviewRuler","overviewRuler","nodeIsInOverviewRuler","nodeRange","oldDecorationsIds","oldDecorationsLen","oldDecorationIndex","newDecorationsLen","newDecorationIndex","internalDecorationId","IntervalNode","newDecoration","tokenization","setLanguageId","getWordUntilPosition","affinity","indent","indentOfLine","detectIndentation","isNodeInOverviewRuler","isNodeInjectedText","DEFAULT_CREATION_OPTIONS","EDITOR_MODEL_DEFAULTS","IUndoRedoService","ILanguageService","ILanguageConfigurationService","_decorationsTree0","IntervalTree","_decorationsTree1","_injectedTextDecorationsTree","host","_intervalSearch","_ensureNodesHaveRanges","r0","intervalSearch","r1","r2","showIfCollapsed","search","overviewRulerOnly","_search","_resolveNode","resolveNode","cleanClassName","className","DecorationOptions","darkColor","ModelDecorationOverviewRulerOptions","_resolvedColor","theme","type","_resolveColor","getColor","toString","ModelDecorationMinimapOptions","Color","ModelDecorationInjectedTextOptions","content","inlineClassName","inlineClassNameAffectsLetterSpacing","attachedData","cursorStops","ModelDecorationOptions","_a","_b","description","blockClassName","stickiness","zIndex","hoverMessage","glyphMarginHoverMessage","isWholeLine","collapseOnReplaceEdit","minimap","glyphMarginClassName","linesDecorationsClassName","firstLineDecorationClassName","marginClassName","beforeContentClassName","afterContentClassName","hideInCommentTokens","hideInStringTokens","EMPTY","register","createDynamic","handleBeforeFire","_actual","_affectedInjectedTextLines","_deferredCnt","_shouldFire","_affectsMinimap","_affectsOverviewRuler","affectsMinimap","affectsOverviewRuler","Set","_fastEmitter","_slowEmitter","_deferredEvent","rawContentChangedEvent","merge","multiline","chCode","nextChCode","isMultilineRegexSource","wholeWord","global","unicode","err","canUseSimpleSearch","toLowerCase","toUpperCase","SearchData","getMapForWordSeparators","rawMatches","LineFeedCounter","lineFeedsOffsets","lineFeedsOffsetsLen","textLen","_lineFeedsOffsets","_doFindMatchesMultiline","_doFindMatchesLineByLine","lfCounter","matchIndex","match0","lineFeedCountBeforeMatch","findLineFeedCountBeforeOffset","lineFeedCountInMatch","counter","_getMultilineMatchRange","_doFindNextMatchMultiline","_doFindNextMatchLineByLine","searchTextStart","_findFirstMatchInLine","fromColumn","_doFindPreviousMatchMultiline","_doFindPreviousMatchLineByLine","_findLastMatchInLine","bestResult","matchStartIndex","matchLength","charBefore","firstCharInMatch","leftIsWordBounday","charAfter","lastCharInMatch","rightIsWordBounday","searchRegex","_searchRegex","_prevMatchStartIndex","_prevMatchLength","lastIndex","exec","computeIndentLevel"],"sourceRoot":""}