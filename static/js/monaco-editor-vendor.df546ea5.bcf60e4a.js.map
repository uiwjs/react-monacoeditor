{"version":3,"file":"static/js/monaco-editor-vendor.df546ea5.bcf60e4a.js","mappings":"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","sources":["../node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js","../node_modules/monaco-editor/esm/vs/editor/common/core/cursorColumns.js","../node_modules/monaco-editor/esm/vs/editor/common/core/editOperation.js","../node_modules/monaco-editor/esm/vs/editor/common/core/editorColorRegistry.js","../node_modules/monaco-editor/esm/vs/editor/common/core/eolCounter.js","../node_modules/monaco-editor/esm/vs/editor/common/core/indentation.js","../node_modules/monaco-editor/esm/vs/editor/common/core/position.js","../node_modules/monaco-editor/esm/vs/editor/common/core/range.js","../node_modules/monaco-editor/esm/vs/editor/common/core/rgba.js","../node_modules/monaco-editor/esm/vs/editor/common/core/selection.js","../node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js","../node_modules/monaco-editor/esm/vs/editor/common/core/textChange.js","../node_modules/monaco-editor/esm/vs/editor/common/core/textModelDefaults.js","../node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js","../node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/oneCursor.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorCollection.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorContext.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursor.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorAtomicMoveOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorColumnSelection.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorDeleteOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorMoveCommands.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorMoveOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorTypeOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorWordOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursorCommon.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/diffComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/editorAction.js","../node_modules/monaco-editor/esm/vs/editor/common/editorCommon.js","../node_modules/monaco-editor/esm/vs/editor/common/editorContextKeys.js","../node_modules/monaco-editor/esm/vs/editor/common/editorTheme.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { toUint8 } from '../../../base/common/uint.js';\n/**\n * A fast character classifier that uses a compact array for ASCII values.\n */\nexport class CharacterClassifier {\n    constructor(_defaultValue) {\n        const defaultValue = toUint8(_defaultValue);\n        this._defaultValue = defaultValue;\n        this._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);\n        this._map = new Map();\n    }\n    static _createAsciiMap(defaultValue) {\n        const asciiMap = new Uint8Array(256);\n        for (let i = 0; i < 256; i++) {\n            asciiMap[i] = defaultValue;\n        }\n        return asciiMap;\n    }\n    set(charCode, _value) {\n        const value = toUint8(_value);\n        if (charCode >= 0 && charCode < 256) {\n            this._asciiMap[charCode] = value;\n        }\n        else {\n            this._map.set(charCode, value);\n        }\n    }\n    get(charCode) {\n        if (charCode >= 0 && charCode < 256) {\n            return this._asciiMap[charCode];\n        }\n        else {\n            return (this._map.get(charCode) || this._defaultValue);\n        }\n    }\n}\nexport class CharacterSet {\n    constructor() {\n        this._actual = new CharacterClassifier(0 /* Boolean.False */);\n    }\n    add(charCode) {\n        this._actual.set(charCode, 1 /* Boolean.True */);\n    }\n    has(charCode) {\n        return (this._actual.get(charCode) === 1 /* Boolean.True */);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\n/**\n * A column in a position is the gap between two adjacent characters. The methods here\n * work with a concept called \"visible column\". A visible column is a very rough approximation\n * of the horizontal screen position of a column. For example, using a tab size of 4:\n * ```txt\n * |<TAB>|<TAB>|T|ext\n * |     |     | \\---- column = 4, visible column = 9\n * |     |     \\------ column = 3, visible column = 8\n * |     \\------------ column = 2, visible column = 4\n * \\------------------ column = 1, visible column = 0\n * ```\n *\n * **NOTE**: Visual columns do not work well for RTL text or variable-width fonts or characters.\n *\n * **NOTE**: These methods work and make sense both on the model and on the view model.\n */\nexport class CursorColumns {\n    static _nextVisibleColumn(codePoint, visibleColumn, tabSize) {\n        if (codePoint === 9 /* CharCode.Tab */) {\n            return CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        }\n        if (strings.isFullWidthCharacter(codePoint) || strings.isEmojiImprecise(codePoint)) {\n            return visibleColumn + 2;\n        }\n        return visibleColumn + 1;\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    static visibleColumnFromColumn(lineContent, column, tabSize) {\n        const textLen = Math.min(column - 1, lineContent.length);\n        const text = lineContent.substring(0, textLen);\n        const iterator = new strings.GraphemeIterator(text);\n        let result = 0;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(text, textLen, iterator.offset);\n            iterator.nextGraphemeLength();\n            result = this._nextVisibleColumn(codePoint, result, tabSize);\n        }\n        return result;\n    }\n    /**\n     * Returns a column from a visible column.\n     * @see {@link CursorColumns}\n     */\n    static columnFromVisibleColumn(lineContent, visibleColumn, tabSize) {\n        if (visibleColumn <= 0) {\n            return 1;\n        }\n        const lineContentLength = lineContent.length;\n        const iterator = new strings.GraphemeIterator(lineContent);\n        let beforeVisibleColumn = 0;\n        let beforeColumn = 1;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(lineContent, lineContentLength, iterator.offset);\n            iterator.nextGraphemeLength();\n            const afterVisibleColumn = this._nextVisibleColumn(codePoint, beforeVisibleColumn, tabSize);\n            const afterColumn = iterator.offset + 1;\n            if (afterVisibleColumn >= visibleColumn) {\n                const beforeDelta = visibleColumn - beforeVisibleColumn;\n                const afterDelta = afterVisibleColumn - visibleColumn;\n                if (afterDelta < beforeDelta) {\n                    return afterColumn;\n                }\n                else {\n                    return beforeColumn;\n                }\n            }\n            beforeVisibleColumn = afterVisibleColumn;\n            beforeColumn = afterColumn;\n        }\n        // walked the entire string\n        return lineContentLength + 1;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextRenderTabStop(visibleColumn, tabSize) {\n        return visibleColumn + tabSize - visibleColumn % tabSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextIndentTabStop(visibleColumn, indentSize) {\n        return visibleColumn + indentSize - visibleColumn % indentSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevRenderTabStop(column, tabSize) {\n        return Math.max(0, column - 1 - (column - 1) % tabSize);\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevIndentTabStop(column, indentSize) {\n        return Math.max(0, column - 1 - (column - 1) % indentSize);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from './range.js';\nexport class EditOperation {\n    static insert(position, text) {\n        return {\n            range: new Range(position.lineNumber, position.column, position.lineNumber, position.column),\n            text: text,\n            forceMoveMarkers: true\n        };\n    }\n    static delete(range) {\n        return {\n            range: range,\n            text: null\n        };\n    }\n    static replace(range, text) {\n        return {\n            range: range,\n            text: text\n        };\n    }\n    static replaceMove(range, text) {\n        return {\n            range: range,\n            text: text,\n            forceMoveMarkers: true\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { Color, RGBA } from '../../../base/common/color.js';\nimport { activeContrastBorder, editorBackground, editorForeground, registerColor, editorWarningForeground, editorInfoForeground, editorWarningBorder, editorInfoBorder, contrastBorder, editorFindMatchHighlight } from '../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../platform/theme/common/themeService.js';\nimport { isHighContrast } from '../../../platform/theme/common/theme.js';\n/**\n * Definition of the editor colors\n */\nexport const editorLineHighlight = registerColor('editor.lineHighlightBackground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('lineHighlight', 'Background color for the highlight of line at the cursor position.'));\nexport const editorLineHighlightBorder = registerColor('editor.lineHighlightBorder', { dark: '#282828', light: '#eeeeee', hcDark: '#f38518', hcLight: contrastBorder }, nls.localize('lineHighlightBorderBox', 'Background color for the border around the line at the cursor position.'));\nexport const editorRangeHighlight = registerColor('editor.rangeHighlightBackground', { dark: '#ffffff0b', light: '#fdff0033', hcDark: null, hcLight: null }, nls.localize('rangeHighlight', 'Background color of highlighted ranges, like by quick open and find features. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorRangeHighlightBorder = registerColor('editor.rangeHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('rangeHighlightBorder', 'Background color of the border around highlighted ranges.'), true);\nexport const editorSymbolHighlight = registerColor('editor.symbolHighlightBackground', { dark: editorFindMatchHighlight, light: editorFindMatchHighlight, hcDark: null, hcLight: null }, nls.localize('symbolHighlight', 'Background color of highlighted symbol, like for go to definition or go next/previous symbol. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorSymbolHighlightBorder = registerColor('editor.symbolHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('symbolHighlightBorder', 'Background color of the border around highlighted symbols.'), true);\nexport const editorCursorForeground = registerColor('editorCursor.foreground', { dark: '#AEAFAD', light: Color.black, hcDark: Color.white, hcLight: '#0F4A85' }, nls.localize('caret', 'Color of the editor cursor.'));\nexport const editorCursorBackground = registerColor('editorCursor.background', null, nls.localize('editorCursorBackground', 'The background color of the editor cursor. Allows customizing the color of a character overlapped by a block cursor.'));\nexport const editorWhitespaces = registerColor('editorWhitespace.foreground', { dark: '#e3e4e229', light: '#33333333', hcDark: '#e3e4e229', hcLight: '#CCCCCC' }, nls.localize('editorWhitespaces', 'Color of whitespace characters in the editor.'));\nexport const editorIndentGuides = registerColor('editorIndentGuide.background', { dark: editorWhitespaces, light: editorWhitespaces, hcDark: editorWhitespaces, hcLight: editorWhitespaces }, nls.localize('editorIndentGuides', 'Color of the editor indentation guides.'));\nexport const editorActiveIndentGuides = registerColor('editorIndentGuide.activeBackground', { dark: editorWhitespaces, light: editorWhitespaces, hcDark: editorWhitespaces, hcLight: editorWhitespaces }, nls.localize('editorActiveIndentGuide', 'Color of the active editor indentation guides.'));\nexport const editorLineNumbers = registerColor('editorLineNumber.foreground', { dark: '#858585', light: '#237893', hcDark: Color.white, hcLight: '#292929' }, nls.localize('editorLineNumbers', 'Color of editor line numbers.'));\nconst deprecatedEditorActiveLineNumber = registerColor('editorActiveLineNumber.foreground', { dark: '#c6c6c6', light: '#0B216F', hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('editorActiveLineNumber', 'Color of editor active line number'), false, nls.localize('deprecatedEditorActiveLineNumber', 'Id is deprecated. Use \\'editorLineNumber.activeForeground\\' instead.'));\nexport const editorActiveLineNumber = registerColor('editorLineNumber.activeForeground', { dark: deprecatedEditorActiveLineNumber, light: deprecatedEditorActiveLineNumber, hcDark: deprecatedEditorActiveLineNumber, hcLight: deprecatedEditorActiveLineNumber }, nls.localize('editorActiveLineNumber', 'Color of editor active line number'));\nexport const editorRuler = registerColor('editorRuler.foreground', { dark: '#5A5A5A', light: Color.lightgrey, hcDark: Color.white, hcLight: '#292929' }, nls.localize('editorRuler', 'Color of the editor rulers.'));\nexport const editorCodeLensForeground = registerColor('editorCodeLens.foreground', { dark: '#999999', light: '#919191', hcDark: '#999999', hcLight: '#292929' }, nls.localize('editorCodeLensForeground', 'Foreground color of editor CodeLens'));\nexport const editorBracketMatchBackground = registerColor('editorBracketMatch.background', { dark: '#0064001a', light: '#0064001a', hcDark: '#0064001a', hcLight: '#0000' }, nls.localize('editorBracketMatchBackground', 'Background color behind matching brackets'));\nexport const editorBracketMatchBorder = registerColor('editorBracketMatch.border', { dark: '#888', light: '#B9B9B9', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('editorBracketMatchBorder', 'Color for matching brackets boxes'));\nexport const editorOverviewRulerBorder = registerColor('editorOverviewRuler.border', { dark: '#7f7f7f4d', light: '#7f7f7f4d', hcDark: '#7f7f7f4d', hcLight: '#666666' }, nls.localize('editorOverviewRulerBorder', 'Color of the overview ruler border.'));\nexport const editorOverviewRulerBackground = registerColor('editorOverviewRuler.background', null, nls.localize('editorOverviewRulerBackground', 'Background color of the editor overview ruler. Only used when the minimap is enabled and placed on the right side of the editor.'));\nexport const editorGutter = registerColor('editorGutter.background', { dark: editorBackground, light: editorBackground, hcDark: editorBackground, hcLight: editorBackground }, nls.localize('editorGutter', 'Background color of the editor gutter. The gutter contains the glyph margins and the line numbers.'));\nexport const editorUnnecessaryCodeBorder = registerColor('editorUnnecessaryCode.border', { dark: null, light: null, hcDark: Color.fromHex('#fff').transparent(0.8), hcLight: contrastBorder }, nls.localize('unnecessaryCodeBorder', 'Border color of unnecessary (unused) source code in the editor.'));\nexport const editorUnnecessaryCodeOpacity = registerColor('editorUnnecessaryCode.opacity', { dark: Color.fromHex('#000a'), light: Color.fromHex('#0007'), hcDark: null, hcLight: null }, nls.localize('unnecessaryCodeOpacity', 'Opacity of unnecessary (unused) source code in the editor. For example, \"#000000c0\" will render the code with 75% opacity. For high contrast themes, use the  \\'editorUnnecessaryCode.border\\' theme color to underline unnecessary code instead of fading it out.'));\nexport const ghostTextBorder = registerColor('editorGhostText.border', { dark: null, light: null, hcDark: Color.fromHex('#fff').transparent(0.8), hcLight: Color.fromHex('#292929').transparent(0.8) }, nls.localize('editorGhostTextBorder', 'Border color of ghost text in the editor.'));\nexport const ghostTextForeground = registerColor('editorGhostText.foreground', { dark: Color.fromHex('#ffffff56'), light: Color.fromHex('#0007'), hcDark: null, hcLight: null }, nls.localize('editorGhostTextForeground', 'Foreground color of the ghost text in the editor.'));\nexport const ghostTextBackground = registerColor('editorGhostText.background', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('editorGhostTextBackground', 'Background color of the ghost text in the editor.'));\nconst rulerRangeDefault = new Color(new RGBA(0, 122, 204, 0.6));\nexport const overviewRulerRangeHighlight = registerColor('editorOverviewRuler.rangeHighlightForeground', { dark: rulerRangeDefault, light: rulerRangeDefault, hcDark: rulerRangeDefault, hcLight: rulerRangeDefault }, nls.localize('overviewRulerRangeHighlight', 'Overview ruler marker color for range highlights. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const overviewRulerError = registerColor('editorOverviewRuler.errorForeground', { dark: new Color(new RGBA(255, 18, 18, 0.7)), light: new Color(new RGBA(255, 18, 18, 0.7)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: '#B5200D' }, nls.localize('overviewRuleError', 'Overview ruler marker color for errors.'));\nexport const overviewRulerWarning = registerColor('editorOverviewRuler.warningForeground', { dark: editorWarningForeground, light: editorWarningForeground, hcDark: editorWarningBorder, hcLight: editorWarningBorder }, nls.localize('overviewRuleWarning', 'Overview ruler marker color for warnings.'));\nexport const overviewRulerInfo = registerColor('editorOverviewRuler.infoForeground', { dark: editorInfoForeground, light: editorInfoForeground, hcDark: editorInfoBorder, hcLight: editorInfoBorder }, nls.localize('overviewRuleInfo', 'Overview ruler marker color for infos.'));\nexport const editorBracketHighlightingForeground1 = registerColor('editorBracketHighlight.foreground1', { dark: '#FFD700', light: '#0431FAFF', hcDark: '#FFD700', hcLight: '#0431FAFF' }, nls.localize('editorBracketHighlightForeground1', 'Foreground color of brackets (1). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground2 = registerColor('editorBracketHighlight.foreground2', { dark: '#DA70D6', light: '#319331FF', hcDark: '#DA70D6', hcLight: '#319331FF' }, nls.localize('editorBracketHighlightForeground2', 'Foreground color of brackets (2). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground3 = registerColor('editorBracketHighlight.foreground3', { dark: '#179FFF', light: '#7B3814FF', hcDark: '#87CEFA', hcLight: '#7B3814FF' }, nls.localize('editorBracketHighlightForeground3', 'Foreground color of brackets (3). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground4 = registerColor('editorBracketHighlight.foreground4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketHighlightForeground4', 'Foreground color of brackets (4). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground5 = registerColor('editorBracketHighlight.foreground5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketHighlightForeground5', 'Foreground color of brackets (5). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground6 = registerColor('editorBracketHighlight.foreground6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketHighlightForeground6', 'Foreground color of brackets (6). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingUnexpectedBracketForeground = registerColor('editorBracketHighlight.unexpectedBracket.foreground', { dark: new Color(new RGBA(255, 18, 18, 0.8)), light: new Color(new RGBA(255, 18, 18, 0.8)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: '' }, nls.localize('editorBracketHighlightUnexpectedBracketForeground', 'Foreground color of unexpected brackets.'));\nexport const editorBracketPairGuideBackground1 = registerColor('editorBracketPairGuide.background1', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background1', 'Background color of inactive bracket pair guides (1). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground2 = registerColor('editorBracketPairGuide.background2', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background2', 'Background color of inactive bracket pair guides (2). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground3 = registerColor('editorBracketPairGuide.background3', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background3', 'Background color of inactive bracket pair guides (3). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground4 = registerColor('editorBracketPairGuide.background4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background4', 'Background color of inactive bracket pair guides (4). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground5 = registerColor('editorBracketPairGuide.background5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background5', 'Background color of inactive bracket pair guides (5). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground6 = registerColor('editorBracketPairGuide.background6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background6', 'Background color of inactive bracket pair guides (6). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground1 = registerColor('editorBracketPairGuide.activeBackground1', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground1', 'Background color of active bracket pair guides (1). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground2 = registerColor('editorBracketPairGuide.activeBackground2', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground2', 'Background color of active bracket pair guides (2). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground3 = registerColor('editorBracketPairGuide.activeBackground3', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground3', 'Background color of active bracket pair guides (3). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground4 = registerColor('editorBracketPairGuide.activeBackground4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground4', 'Background color of active bracket pair guides (4). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground5 = registerColor('editorBracketPairGuide.activeBackground5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground5', 'Background color of active bracket pair guides (5). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground6 = registerColor('editorBracketPairGuide.activeBackground6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground6', 'Background color of active bracket pair guides (6). Requires enabling bracket pair guides.'));\nexport const editorUnicodeHighlightBorder = registerColor('editorUnicodeHighlight.border', { dark: '#BD9B03', light: '#CEA33D', hcDark: '#ff0000', hcLight: '' }, nls.localize('editorUnicodeHighlight.border', 'Border color used to highlight unicode characters.'));\nexport const editorUnicodeHighlightBackground = registerColor('editorUnicodeHighlight.background', { dark: '#bd9b0326', light: '#cea33d14', hcDark: '#00000000', hcLight: '' }, nls.localize('editorUnicodeHighlight.background', 'Background color used to highlight unicode characters.'));\n// contains all color rules that used to defined in editor/browser/widget/editor.css\nregisterThemingParticipant((theme, collector) => {\n    const background = theme.getColor(editorBackground);\n    if (background) {\n        collector.addRule(`.monaco-editor, .monaco-editor-background { background-color: ${background}; }`);\n    }\n    const lineHighlight = theme.getColor(editorLineHighlight);\n    const imeBackground = (lineHighlight && !lineHighlight.isTransparent() ? lineHighlight : background);\n    if (imeBackground) {\n        collector.addRule(`.monaco-editor .inputarea.ime-input { background-color: ${imeBackground}; }`);\n    }\n    const foreground = theme.getColor(editorForeground);\n    if (foreground) {\n        collector.addRule(`.monaco-editor, .monaco-editor .inputarea.ime-input { color: ${foreground}; }`);\n    }\n    const gutter = theme.getColor(editorGutter);\n    if (gutter) {\n        collector.addRule(`.monaco-editor .margin { background-color: ${gutter}; }`);\n    }\n    const rangeHighlight = theme.getColor(editorRangeHighlight);\n    if (rangeHighlight) {\n        collector.addRule(`.monaco-editor .rangeHighlight { background-color: ${rangeHighlight}; }`);\n    }\n    const rangeHighlightBorder = theme.getColor(editorRangeHighlightBorder);\n    if (rangeHighlightBorder) {\n        collector.addRule(`.monaco-editor .rangeHighlight { border: 1px ${isHighContrast(theme.type) ? 'dotted' : 'solid'} ${rangeHighlightBorder}; }`);\n    }\n    const symbolHighlight = theme.getColor(editorSymbolHighlight);\n    if (symbolHighlight) {\n        collector.addRule(`.monaco-editor .symbolHighlight { background-color: ${symbolHighlight}; }`);\n    }\n    const symbolHighlightBorder = theme.getColor(editorSymbolHighlightBorder);\n    if (symbolHighlightBorder) {\n        collector.addRule(`.monaco-editor .symbolHighlight { border: 1px ${isHighContrast(theme.type) ? 'dotted' : 'solid'} ${symbolHighlightBorder}; }`);\n    }\n    const invisibles = theme.getColor(editorWhitespaces);\n    if (invisibles) {\n        collector.addRule(`.monaco-editor .mtkw { color: ${invisibles} !important; }`);\n        collector.addRule(`.monaco-editor .mtkz { color: ${invisibles} !important; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function countEOL(text) {\n    let eolCount = 0;\n    let firstLineLength = 0;\n    let lastLineStart = 0;\n    let eol = 0 /* StringEOL.Unknown */;\n    for (let i = 0, len = text.length; i < len; i++) {\n        const chr = text.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            if (i + 1 < len && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                eol |= 2 /* StringEOL.CRLF */;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                eol |= 3 /* StringEOL.Invalid */;\n            }\n            lastLineStart = i + 1;\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            // \\n... case\n            eol |= 1 /* StringEOL.LF */;\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            lastLineStart = i + 1;\n        }\n    }\n    if (eolCount === 0) {\n        firstLineLength = text.length;\n    }\n    return [eolCount, firstLineLength, text.length - lastLineStart, eol];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from './cursorColumns.js';\nfunction _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {\n    let spacesCnt = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str.charAt(i) === '\\t') {\n            spacesCnt = CursorColumns.nextIndentTabStop(spacesCnt, indentSize);\n        }\n        else {\n            spacesCnt++;\n        }\n    }\n    let result = '';\n    if (!insertSpaces) {\n        const tabsCnt = Math.floor(spacesCnt / indentSize);\n        spacesCnt = spacesCnt % indentSize;\n        for (let i = 0; i < tabsCnt; i++) {\n            result += '\\t';\n        }\n    }\n    for (let i = 0; i < spacesCnt; i++) {\n        result += ' ';\n    }\n    return result;\n}\nexport function normalizeIndentation(str, indentSize, insertSpaces) {\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\n    if (firstNonWhitespaceIndex === -1) {\n        firstNonWhitespaceIndex = str.length;\n    }\n    return _normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A position in the editor.\n */\nexport class Position {\n    constructor(lineNumber, column) {\n        this.lineNumber = lineNumber;\n        this.column = column;\n    }\n    /**\n     * Create a new position from this position.\n     *\n     * @param newLineNumber new line number\n     * @param newColumn new column\n     */\n    with(newLineNumber = this.lineNumber, newColumn = this.column) {\n        if (newLineNumber === this.lineNumber && newColumn === this.column) {\n            return this;\n        }\n        else {\n            return new Position(newLineNumber, newColumn);\n        }\n    }\n    /**\n     * Derive a new position from this position.\n     *\n     * @param deltaLineNumber line number delta\n     * @param deltaColumn column delta\n     */\n    delta(deltaLineNumber = 0, deltaColumn = 0) {\n        return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);\n    }\n    /**\n     * Test if this position equals other position\n     */\n    equals(other) {\n        return Position.equals(this, other);\n    }\n    /**\n     * Test if position `a` equals position `b`\n     */\n    static equals(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        return (!!a &&\n            !!b &&\n            a.lineNumber === b.lineNumber &&\n            a.column === b.column);\n    }\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be false.\n     */\n    isBefore(other) {\n        return Position.isBefore(this, other);\n    }\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be false.\n     */\n    static isBefore(a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column < b.column;\n    }\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be true.\n     */\n    isBeforeOrEqual(other) {\n        return Position.isBeforeOrEqual(this, other);\n    }\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be true.\n     */\n    static isBeforeOrEqual(a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column <= b.column;\n    }\n    /**\n     * A function that compares positions, useful for sorting\n     */\n    static compare(a, b) {\n        const aLineNumber = a.lineNumber | 0;\n        const bLineNumber = b.lineNumber | 0;\n        if (aLineNumber === bLineNumber) {\n            const aColumn = a.column | 0;\n            const bColumn = b.column | 0;\n            return aColumn - bColumn;\n        }\n        return aLineNumber - bLineNumber;\n    }\n    /**\n     * Clone this position.\n     */\n    clone() {\n        return new Position(this.lineNumber, this.column);\n    }\n    /**\n     * Convert to a human-readable representation.\n     */\n    toString() {\n        return '(' + this.lineNumber + ',' + this.column + ')';\n    }\n    // ---\n    /**\n     * Create a `Position` from an `IPosition`.\n     */\n    static lift(pos) {\n        return new Position(pos.lineNumber, pos.column);\n    }\n    /**\n     * Test if `obj` is an `IPosition`.\n     */\n    static isIPosition(obj) {\n        return (obj\n            && (typeof obj.lineNumber === 'number')\n            && (typeof obj.column === 'number'));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\n/**\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\n */\nexport class Range {\n    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {\n        if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\n            this.startLineNumber = endLineNumber;\n            this.startColumn = endColumn;\n            this.endLineNumber = startLineNumber;\n            this.endColumn = startColumn;\n        }\n        else {\n            this.startLineNumber = startLineNumber;\n            this.startColumn = startColumn;\n            this.endLineNumber = endLineNumber;\n            this.endColumn = endColumn;\n        }\n    }\n    /**\n     * Test if this range is empty.\n     */\n    isEmpty() {\n        return Range.isEmpty(this);\n    }\n    /**\n     * Test if `range` is empty.\n     */\n    static isEmpty(range) {\n        return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\n    }\n    /**\n     * Test if position is in this range. If the position is at the edges, will return true.\n     */\n    containsPosition(position) {\n        return Range.containsPosition(this, position);\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return true.\n     */\n    static containsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return false.\n     * @internal\n     */\n    static strictContainsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if range is in this range. If the range is equal to this range, will return true.\n     */\n    containsRange(range) {\n        return Range.containsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\n     */\n    static containsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\n     */\n    strictContainsRange(range) {\n        return Range.strictContainsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.\n     */\n    static strictContainsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    plusRange(range) {\n        return Range.plusRange(this, range);\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    static plusRange(a, b) {\n        let startLineNumber;\n        let startColumn;\n        let endLineNumber;\n        let endColumn;\n        if (b.startLineNumber < a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = b.startColumn;\n        }\n        else if (b.startLineNumber === a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = Math.min(b.startColumn, a.startColumn);\n        }\n        else {\n            startLineNumber = a.startLineNumber;\n            startColumn = a.startColumn;\n        }\n        if (b.endLineNumber > a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = b.endColumn;\n        }\n        else if (b.endLineNumber === a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = Math.max(b.endColumn, a.endColumn);\n        }\n        else {\n            endLineNumber = a.endLineNumber;\n            endColumn = a.endColumn;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    intersectRanges(range) {\n        return Range.intersectRanges(this, range);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    static intersectRanges(a, b) {\n        let resultStartLineNumber = a.startLineNumber;\n        let resultStartColumn = a.startColumn;\n        let resultEndLineNumber = a.endLineNumber;\n        let resultEndColumn = a.endColumn;\n        const otherStartLineNumber = b.startLineNumber;\n        const otherStartColumn = b.startColumn;\n        const otherEndLineNumber = b.endLineNumber;\n        const otherEndColumn = b.endColumn;\n        if (resultStartLineNumber < otherStartLineNumber) {\n            resultStartLineNumber = otherStartLineNumber;\n            resultStartColumn = otherStartColumn;\n        }\n        else if (resultStartLineNumber === otherStartLineNumber) {\n            resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n        }\n        if (resultEndLineNumber > otherEndLineNumber) {\n            resultEndLineNumber = otherEndLineNumber;\n            resultEndColumn = otherEndColumn;\n        }\n        else if (resultEndLineNumber === otherEndLineNumber) {\n            resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n        }\n        // Check if selection is now empty\n        if (resultStartLineNumber > resultEndLineNumber) {\n            return null;\n        }\n        if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n            return null;\n        }\n        return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n    }\n    /**\n     * Test if this range equals other.\n     */\n    equalsRange(other) {\n        return Range.equalsRange(this, other);\n    }\n    /**\n     * Test if range `a` equals `b`.\n     */\n    static equalsRange(a, b) {\n        return (!!a &&\n            !!b &&\n            a.startLineNumber === b.startLineNumber &&\n            a.startColumn === b.startColumn &&\n            a.endLineNumber === b.endLineNumber &&\n            a.endColumn === b.endColumn);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    getEndPosition() {\n        return Range.getEndPosition(this);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    static getEndPosition(range) {\n        return new Position(range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    getStartPosition() {\n        return Range.getStartPosition(this);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    static getStartPosition(range) {\n        return new Position(range.startLineNumber, range.startColumn);\n    }\n    /**\n     * Transform to a user presentable string representation.\n     */\n    toString() {\n        return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\n    }\n    /**\n     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    collapseToStart() {\n        return Range.collapseToStart(this);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    static collapseToStart(range) {\n        return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n    }\n    // ---\n    static fromPositions(start, end = start) {\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    static lift(range) {\n        if (!range) {\n            return null;\n        }\n        return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Test if `obj` is an `IRange`.\n     */\n    static isIRange(obj) {\n        return (obj\n            && (typeof obj.startLineNumber === 'number')\n            && (typeof obj.startColumn === 'number')\n            && (typeof obj.endLineNumber === 'number')\n            && (typeof obj.endColumn === 'number'));\n    }\n    /**\n     * Test if the two ranges are touching in any way.\n     */\n    static areIntersectingOrTouching(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * Test if the two ranges are intersecting. If the ranges are touching it returns true.\n     */\n    static areIntersecting(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the startPosition and then on the endPosition\n     */\n    static compareRangesUsingStarts(a, b) {\n        if (a && b) {\n            const aStartLineNumber = a.startLineNumber | 0;\n            const bStartLineNumber = b.startLineNumber | 0;\n            if (aStartLineNumber === bStartLineNumber) {\n                const aStartColumn = a.startColumn | 0;\n                const bStartColumn = b.startColumn | 0;\n                if (aStartColumn === bStartColumn) {\n                    const aEndLineNumber = a.endLineNumber | 0;\n                    const bEndLineNumber = b.endLineNumber | 0;\n                    if (aEndLineNumber === bEndLineNumber) {\n                        const aEndColumn = a.endColumn | 0;\n                        const bEndColumn = b.endColumn | 0;\n                        return aEndColumn - bEndColumn;\n                    }\n                    return aEndLineNumber - bEndLineNumber;\n                }\n                return aStartColumn - bStartColumn;\n            }\n            return aStartLineNumber - bStartLineNumber;\n        }\n        const aExists = (a ? 1 : 0);\n        const bExists = (b ? 1 : 0);\n        return aExists - bExists;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the endPosition and then on the startPosition\n     */\n    static compareRangesUsingEnds(a, b) {\n        if (a.endLineNumber === b.endLineNumber) {\n            if (a.endColumn === b.endColumn) {\n                if (a.startLineNumber === b.startLineNumber) {\n                    return a.startColumn - b.startColumn;\n                }\n                return a.startLineNumber - b.startLineNumber;\n            }\n            return a.endColumn - b.endColumn;\n        }\n        return a.endLineNumber - b.endLineNumber;\n    }\n    /**\n     * Test if the range spans multiple lines.\n     */\n    static spansMultipleLines(range) {\n        return range.endLineNumber > range.startLineNumber;\n    }\n    toJSON() {\n        return this;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A very VM friendly rgba datastructure.\n * Please don't touch unless you take a look at the IR.\n */\nexport class RGBA8 {\n    constructor(r, g, b, a) {\n        this._rgba8Brand = undefined;\n        this.r = RGBA8._clamp(r);\n        this.g = RGBA8._clamp(g);\n        this.b = RGBA8._clamp(b);\n        this.a = RGBA8._clamp(a);\n    }\n    equals(other) {\n        return (this.r === other.r\n            && this.g === other.g\n            && this.b === other.b\n            && this.a === other.a);\n    }\n    static _clamp(c) {\n        if (c < 0) {\n            return 0;\n        }\n        if (c > 255) {\n            return 255;\n        }\n        return c | 0;\n    }\n}\nRGBA8.Empty = new RGBA8(0, 0, 0, 0);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\nimport { Range } from './range.js';\n/**\n * A selection in the editor.\n * The selection is a range that has an orientation.\n */\nexport class Selection extends Range {\n    constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {\n        super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);\n        this.selectionStartLineNumber = selectionStartLineNumber;\n        this.selectionStartColumn = selectionStartColumn;\n        this.positionLineNumber = positionLineNumber;\n        this.positionColumn = positionColumn;\n    }\n    /**\n     * Transform to a human-readable representation.\n     */\n    toString() {\n        return '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';\n    }\n    /**\n     * Test if equals other selection.\n     */\n    equalsSelection(other) {\n        return (Selection.selectionsEqual(this, other));\n    }\n    /**\n     * Test if the two selections are equal.\n     */\n    static selectionsEqual(a, b) {\n        return (a.selectionStartLineNumber === b.selectionStartLineNumber &&\n            a.selectionStartColumn === b.selectionStartColumn &&\n            a.positionLineNumber === b.positionLineNumber &&\n            a.positionColumn === b.positionColumn);\n    }\n    /**\n     * Get directions (LTR or RTL).\n     */\n    getDirection() {\n        if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {\n            return 0 /* SelectionDirection.LTR */;\n        }\n        return 1 /* SelectionDirection.RTL */;\n    }\n    /**\n     * Create a new selection with a different `positionLineNumber` and `positionColumn`.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        if (this.getDirection() === 0 /* SelectionDirection.LTR */) {\n            return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);\n    }\n    /**\n     * Get the position at `positionLineNumber` and `positionColumn`.\n     */\n    getPosition() {\n        return new Position(this.positionLineNumber, this.positionColumn);\n    }\n    /**\n     * Get the position at the start of the selection.\n    */\n    getSelectionStart() {\n        return new Position(this.selectionStartLineNumber, this.selectionStartColumn);\n    }\n    /**\n     * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        if (this.getDirection() === 0 /* SelectionDirection.LTR */) {\n            return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n        }\n        return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);\n    }\n    // ----\n    /**\n     * Create a `Selection` from one or two positions\n     */\n    static fromPositions(start, end = start) {\n        return new Selection(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    /**\n     * Creates a `Selection` from a range, given a direction.\n     */\n    static fromRange(range, direction) {\n        if (direction === 0 /* SelectionDirection.LTR */) {\n            return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n        }\n        else {\n            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n        }\n    }\n    /**\n     * Create a `Selection` from an `ISelection`.\n     */\n    static liftSelection(sel) {\n        return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);\n    }\n    /**\n     * `a` equals `b`.\n     */\n    static selectionsArrEqual(a, b) {\n        if (a && !b || !a && b) {\n            return false;\n        }\n        if (!a && !b) {\n            return true;\n        }\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (!this.selectionsEqual(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Test if `obj` is an `ISelection`.\n     */\n    static isISelection(obj) {\n        return (obj\n            && (typeof obj.selectionStartLineNumber === 'number')\n            && (typeof obj.selectionStartColumn === 'number')\n            && (typeof obj.positionLineNumber === 'number')\n            && (typeof obj.positionColumn === 'number'));\n    }\n    /**\n     * Create with a direction.\n     */\n    static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {\n        if (direction === 0 /* SelectionDirection.LTR */) {\n            return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as buffer from '../../../base/common/buffer.js';\nlet _utf16LE_TextDecoder;\nfunction getUTF16LE_TextDecoder() {\n    if (!_utf16LE_TextDecoder) {\n        _utf16LE_TextDecoder = new TextDecoder('UTF-16LE');\n    }\n    return _utf16LE_TextDecoder;\n}\nlet _utf16BE_TextDecoder;\nfunction getUTF16BE_TextDecoder() {\n    if (!_utf16BE_TextDecoder) {\n        _utf16BE_TextDecoder = new TextDecoder('UTF-16BE');\n    }\n    return _utf16BE_TextDecoder;\n}\nlet _platformTextDecoder;\nexport function getPlatformTextDecoder() {\n    if (!_platformTextDecoder) {\n        _platformTextDecoder = platform.isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n    }\n    return _platformTextDecoder;\n}\nexport const hasTextDecoder = (typeof TextDecoder !== 'undefined');\nexport let createStringBuilder;\nexport let decodeUTF16LE;\nif (hasTextDecoder) {\n    createStringBuilder = (capacity) => new StringBuilder(capacity);\n    decodeUTF16LE = standardDecodeUTF16LE;\n}\nelse {\n    createStringBuilder = (capacity) => new CompatStringBuilder();\n    decodeUTF16LE = compatDecodeUTF16LE;\n}\nfunction standardDecodeUTF16LE(source, offset, len) {\n    const view = new Uint16Array(source.buffer, offset, len);\n    if (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n        // UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n        // It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n        // We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n        // So we use the manual decoder\n        return compatDecodeUTF16LE(source, offset, len);\n    }\n    return getUTF16LE_TextDecoder().decode(view);\n}\nfunction compatDecodeUTF16LE(source, offset, len) {\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0; i < len; i++) {\n        const charCode = buffer.readUInt16LE(source, offset);\n        offset += 2;\n        result[resultLen++] = String.fromCharCode(charCode);\n    }\n    return result.join('');\n}\nclass StringBuilder {\n    constructor(capacity) {\n        this._capacity = capacity | 0;\n        this._buffer = new Uint16Array(this._capacity);\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    reset() {\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    build() {\n        if (this._completedStrings !== null) {\n            this._flushBuffer();\n            return this._completedStrings.join('');\n        }\n        return this._buildBuffer();\n    }\n    _buildBuffer() {\n        if (this._bufferLength === 0) {\n            return '';\n        }\n        const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);\n        return getPlatformTextDecoder().decode(view);\n    }\n    _flushBuffer() {\n        const bufferString = this._buildBuffer();\n        this._bufferLength = 0;\n        if (this._completedStrings === null) {\n            this._completedStrings = [bufferString];\n        }\n        else {\n            this._completedStrings[this._completedStrings.length] = bufferString;\n        }\n    }\n    write1(charCode) {\n        const remainingSpace = this._capacity - this._bufferLength;\n        if (remainingSpace <= 1) {\n            if (remainingSpace === 0 || strings.isHighSurrogate(charCode)) {\n                this._flushBuffer();\n            }\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendASCII(charCode) {\n        if (this._bufferLength === this._capacity) {\n            // buffer is full\n            this._flushBuffer();\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendASCIIString(str) {\n        const strLen = str.length;\n        if (this._bufferLength + strLen >= this._capacity) {\n            // This string does not fit in the remaining buffer space\n            this._flushBuffer();\n            this._completedStrings[this._completedStrings.length] = str;\n            return;\n        }\n        for (let i = 0; i < strLen; i++) {\n            this._buffer[this._bufferLength++] = str.charCodeAt(i);\n        }\n    }\n}\nclass CompatStringBuilder {\n    constructor() {\n        this._pieces = [];\n        this._piecesLen = 0;\n    }\n    reset() {\n        this._pieces = [];\n        this._piecesLen = 0;\n    }\n    build() {\n        return this._pieces.join('');\n    }\n    write1(charCode) {\n        this._pieces[this._piecesLen++] = String.fromCharCode(charCode);\n    }\n    appendASCII(charCode) {\n        this._pieces[this._piecesLen++] = String.fromCharCode(charCode);\n    }\n    appendASCIIString(str) {\n        this._pieces[this._piecesLen++] = str;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as buffer from '../../../base/common/buffer.js';\nimport { decodeUTF16LE } from './stringBuilder.js';\nfunction escapeNewLine(str) {\n    return (str\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r'));\n}\nexport class TextChange {\n    constructor(oldPosition, oldText, newPosition, newText) {\n        this.oldPosition = oldPosition;\n        this.oldText = oldText;\n        this.newPosition = newPosition;\n        this.newText = newText;\n    }\n    get oldLength() {\n        return this.oldText.length;\n    }\n    get oldEnd() {\n        return this.oldPosition + this.oldText.length;\n    }\n    get newLength() {\n        return this.newText.length;\n    }\n    get newEnd() {\n        return this.newPosition + this.newText.length;\n    }\n    toString() {\n        if (this.oldText.length === 0) {\n            return `(insert@${this.oldPosition} \"${escapeNewLine(this.newText)}\")`;\n        }\n        if (this.newText.length === 0) {\n            return `(delete@${this.oldPosition} \"${escapeNewLine(this.oldText)}\")`;\n        }\n        return `(replace@${this.oldPosition} \"${escapeNewLine(this.oldText)}\" with \"${escapeNewLine(this.newText)}\")`;\n    }\n    static _writeStringSize(str) {\n        return (4 + 2 * str.length);\n    }\n    static _writeString(b, str, offset) {\n        const len = str.length;\n        buffer.writeUInt32BE(b, len, offset);\n        offset += 4;\n        for (let i = 0; i < len; i++) {\n            buffer.writeUInt16LE(b, str.charCodeAt(i), offset);\n            offset += 2;\n        }\n        return offset;\n    }\n    static _readString(b, offset) {\n        const len = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        return decodeUTF16LE(b, offset, len);\n    }\n    writeSize() {\n        return (+4 // oldPosition\n            + 4 // newPosition\n            + TextChange._writeStringSize(this.oldText)\n            + TextChange._writeStringSize(this.newText));\n    }\n    write(b, offset) {\n        buffer.writeUInt32BE(b, this.oldPosition, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.newPosition, offset);\n        offset += 4;\n        offset = TextChange._writeString(b, this.oldText, offset);\n        offset = TextChange._writeString(b, this.newText, offset);\n        return offset;\n    }\n    static read(b, offset, dest) {\n        const oldPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const newPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const oldText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(oldText);\n        const newText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(newText);\n        dest.push(new TextChange(oldPosition, oldText, newPosition, newText));\n        return offset;\n    }\n}\nexport function compressConsecutiveTextChanges(prevEdits, currEdits) {\n    if (prevEdits === null || prevEdits.length === 0) {\n        return currEdits;\n    }\n    const compressor = new TextChangeCompressor(prevEdits, currEdits);\n    return compressor.compress();\n}\nclass TextChangeCompressor {\n    constructor(prevEdits, currEdits) {\n        this._prevEdits = prevEdits;\n        this._currEdits = currEdits;\n        this._result = [];\n        this._resultLen = 0;\n        this._prevLen = this._prevEdits.length;\n        this._prevDeltaOffset = 0;\n        this._currLen = this._currEdits.length;\n        this._currDeltaOffset = 0;\n    }\n    compress() {\n        let prevIndex = 0;\n        let currIndex = 0;\n        let prevEdit = this._getPrev(prevIndex);\n        let currEdit = this._getCurr(currIndex);\n        while (prevIndex < this._prevLen || currIndex < this._currLen) {\n            if (prevEdit === null) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (currEdit === null) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldEnd <= prevEdit.newPosition) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (prevEdit.newEnd <= currEdit.oldPosition) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldPosition < prevEdit.newPosition) {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newPosition - currEdit.oldPosition);\n                this._acceptCurr(e1);\n                currEdit = e2;\n                continue;\n            }\n            if (prevEdit.newPosition < currEdit.oldPosition) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldPosition - prevEdit.newPosition);\n                this._acceptPrev(e1);\n                prevEdit = e2;\n                continue;\n            }\n            // At this point, currEdit.oldPosition === prevEdit.newPosition\n            let mergePrev;\n            let mergeCurr;\n            if (currEdit.oldEnd === prevEdit.newEnd) {\n                mergePrev = prevEdit;\n                mergeCurr = currEdit;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = this._getCurr(++currIndex);\n            }\n            else if (currEdit.oldEnd < prevEdit.newEnd) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldLength);\n                mergePrev = e1;\n                mergeCurr = currEdit;\n                prevEdit = e2;\n                currEdit = this._getCurr(++currIndex);\n            }\n            else {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newLength);\n                mergePrev = prevEdit;\n                mergeCurr = e1;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = e2;\n            }\n            this._result[this._resultLen++] = new TextChange(mergePrev.oldPosition, mergePrev.oldText, mergeCurr.newPosition, mergeCurr.newText);\n            this._prevDeltaOffset += mergePrev.newLength - mergePrev.oldLength;\n            this._currDeltaOffset += mergeCurr.newLength - mergeCurr.oldLength;\n        }\n        const merged = TextChangeCompressor._merge(this._result);\n        const cleaned = TextChangeCompressor._removeNoOps(merged);\n        return cleaned;\n    }\n    _acceptCurr(currEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebaseCurr(this._prevDeltaOffset, currEdit);\n        this._currDeltaOffset += currEdit.newLength - currEdit.oldLength;\n    }\n    _getCurr(currIndex) {\n        return (currIndex < this._currLen ? this._currEdits[currIndex] : null);\n    }\n    _acceptPrev(prevEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebasePrev(this._currDeltaOffset, prevEdit);\n        this._prevDeltaOffset += prevEdit.newLength - prevEdit.oldLength;\n    }\n    _getPrev(prevIndex) {\n        return (prevIndex < this._prevLen ? this._prevEdits[prevIndex] : null);\n    }\n    static _rebaseCurr(prevDeltaOffset, currEdit) {\n        return new TextChange(currEdit.oldPosition - prevDeltaOffset, currEdit.oldText, currEdit.newPosition, currEdit.newText);\n    }\n    static _rebasePrev(currDeltaOffset, prevEdit) {\n        return new TextChange(prevEdit.oldPosition, prevEdit.oldText, prevEdit.newPosition + currDeltaOffset, prevEdit.newText);\n    }\n    static _splitPrev(edit, offset) {\n        const preText = edit.newText.substr(0, offset);\n        const postText = edit.newText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, edit.oldText, edit.newPosition, preText),\n            new TextChange(edit.oldEnd, '', edit.newPosition + offset, postText)\n        ];\n    }\n    static _splitCurr(edit, offset) {\n        const preText = edit.oldText.substr(0, offset);\n        const postText = edit.oldText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, preText, edit.newPosition, edit.newText),\n            new TextChange(edit.oldPosition + offset, postText, edit.newEnd, '')\n        ];\n    }\n    static _merge(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        let prev = edits[0];\n        for (let i = 1; i < edits.length; i++) {\n            const curr = edits[i];\n            if (prev.oldEnd === curr.oldPosition) {\n                // Merge into `prev`\n                prev = new TextChange(prev.oldPosition, prev.oldText + curr.oldText, prev.newPosition, prev.newText + curr.newText);\n            }\n            else {\n                result[resultLen++] = prev;\n                prev = curr;\n            }\n        }\n        result[resultLen++] = prev;\n        return result;\n    }\n    static _removeNoOps(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0; i < edits.length; i++) {\n            const edit = edits[i];\n            if (edit.oldText === edit.newText) {\n                continue;\n            }\n            result[resultLen++] = edit;\n        }\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const EDITOR_MODEL_DEFAULTS = {\n    tabSize: 4,\n    indentSize: 4,\n    insertSpaces: true,\n    detectIndentation: true,\n    trimAutoWhitespace: true,\n    largeFileOptimizations: true,\n    bracketPairColorizationOptions: {\n        enabled: true,\n        independentColorPoolPerBracketType: false,\n    },\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CharacterClassifier } from './characterClassifier.js';\nexport class WordCharacterClassifier extends CharacterClassifier {\n    constructor(wordSeparators) {\n        super(0 /* WordCharacterClass.Regular */);\n        for (let i = 0, len = wordSeparators.length; i < len; i++) {\n            this.set(wordSeparators.charCodeAt(i), 2 /* WordCharacterClass.WordSeparator */);\n        }\n        this.set(32 /* CharCode.Space */, 1 /* WordCharacterClass.Whitespace */);\n        this.set(9 /* CharCode.Tab */, 1 /* WordCharacterClass.Whitespace */);\n    }\n}\nfunction once(computeFn) {\n    const cache = {}; // TODO@Alex unbounded cache\n    return (input) => {\n        if (!cache.hasOwnProperty(input)) {\n            cache[input] = computeFn(input);\n        }\n        return cache[input];\n    };\n}\nexport const getMapForWordSeparators = once((input) => new WordCharacterClassifier(input));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\nexport const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n/**\n * Create a word definition regular expression based on default word separators.\n * Optionally provide allowed separators that should be included in words.\n *\n * The default would look like this:\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n */\nfunction createWordRegExp(allowInWords = '') {\n    let source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n    for (const sep of USUAL_WORD_SEPARATORS) {\n        if (allowInWords.indexOf(sep) >= 0) {\n            continue;\n        }\n        source += '\\\\' + sep;\n    }\n    source += '\\\\s]+)';\n    return new RegExp(source, 'g');\n}\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\nexport const DEFAULT_WORD_REGEXP = createWordRegExp();\nexport function ensureValidWordDefinition(wordDefinition) {\n    let result = DEFAULT_WORD_REGEXP;\n    if (wordDefinition && (wordDefinition instanceof RegExp)) {\n        if (!wordDefinition.global) {\n            let flags = 'g';\n            if (wordDefinition.ignoreCase) {\n                flags += 'i';\n            }\n            if (wordDefinition.multiline) {\n                flags += 'm';\n            }\n            if (wordDefinition.unicode) {\n                flags += 'u';\n            }\n            result = new RegExp(wordDefinition.source, flags);\n        }\n        else {\n            result = wordDefinition;\n        }\n    }\n    result.lastIndex = 0;\n    return result;\n}\nconst _defaultConfig = new LinkedList();\n_defaultConfig.unshift({\n    maxLen: 1000,\n    windowSize: 15,\n    timeBudget: 150\n});\nexport function getWordAtText(column, wordDefinition, text, textOffset, config) {\n    if (!config) {\n        config = Iterable.first(_defaultConfig);\n    }\n    if (text.length > config.maxLen) {\n        // don't throw strings that long at the regexp\n        // but use a sub-string in which a word must occur\n        let start = column - config.maxLen / 2;\n        if (start < 0) {\n            start = 0;\n        }\n        else {\n            textOffset += start;\n        }\n        text = text.substring(start, column + config.maxLen / 2);\n        return getWordAtText(column, wordDefinition, text, textOffset, config);\n    }\n    const t1 = Date.now();\n    const pos = column - 1 - textOffset;\n    let prevRegexIndex = -1;\n    let match = null;\n    for (let i = 1;; i++) {\n        // check time budget\n        if (Date.now() - t1 >= config.timeBudget) {\n            break;\n        }\n        // reset the index at which the regexp should start matching, also know where it\n        // should stop so that subsequent search don't repeat previous searches\n        const regexIndex = pos - config.windowSize * i;\n        wordDefinition.lastIndex = Math.max(0, regexIndex);\n        const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\n        if (!thisMatch && match) {\n            // stop: we have something\n            break;\n        }\n        match = thisMatch;\n        // stop: searched at start\n        if (regexIndex <= 0) {\n            break;\n        }\n        prevRegexIndex = regexIndex;\n    }\n    if (match) {\n        const result = {\n            word: match[0],\n            startColumn: textOffset + 1 + match.index,\n            endColumn: textOffset + 1 + match.index + match[0].length\n        };\n        wordDefinition.lastIndex = 0;\n        return result;\n    }\n    return null;\n}\nfunction _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {\n    let match;\n    while (match = wordDefinition.exec(text)) {\n        const matchIndex = match.index || 0;\n        if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n            return match;\n        }\n        else if (stopPos > 0 && matchIndex > stopPos) {\n            return null;\n        }\n    }\n    return null;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorState, SingleCursorState } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\n/**\n * Represents a single cursor.\n*/\nexport class Cursor {\n    constructor(context) {\n        this._selTrackedRange = null;\n        this._trackSelection = true;\n        this._setState(context, new SingleCursorState(new Range(1, 1, 1, 1), 0, new Position(1, 1), 0), new SingleCursorState(new Range(1, 1, 1, 1), 0, new Position(1, 1), 0));\n    }\n    dispose(context) {\n        this._removeTrackedRange(context);\n    }\n    startTrackingSelection(context) {\n        this._trackSelection = true;\n        this._updateTrackedRange(context);\n    }\n    stopTrackingSelection(context) {\n        this._trackSelection = false;\n        this._removeTrackedRange(context);\n    }\n    _updateTrackedRange(context) {\n        if (!this._trackSelection) {\n            // don't track the selection\n            return;\n        }\n        this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, this.modelState.selection, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n    }\n    _removeTrackedRange(context) {\n        this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, null, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n    }\n    asCursorState() {\n        return new CursorState(this.modelState, this.viewState);\n    }\n    readSelectionFromMarkers(context) {\n        const range = context.model._getTrackedRange(this._selTrackedRange);\n        return Selection.fromRange(range, this.modelState.selection.getDirection());\n    }\n    ensureValidState(context) {\n        this._setState(context, this.modelState, this.viewState);\n    }\n    setState(context, modelState, viewState) {\n        this._setState(context, modelState, viewState);\n    }\n    static _validatePositionWithCache(viewModel, position, cacheInput, cacheOutput) {\n        if (position.equals(cacheInput)) {\n            return cacheOutput;\n        }\n        return viewModel.normalizePosition(position, 2 /* PositionAffinity.None */);\n    }\n    static _validateViewState(viewModel, viewState) {\n        const position = viewState.position;\n        const sStartPosition = viewState.selectionStart.getStartPosition();\n        const sEndPosition = viewState.selectionStart.getEndPosition();\n        const validPosition = viewModel.normalizePosition(position, 2 /* PositionAffinity.None */);\n        const validSStartPosition = this._validatePositionWithCache(viewModel, sStartPosition, position, validPosition);\n        const validSEndPosition = this._validatePositionWithCache(viewModel, sEndPosition, sStartPosition, validSStartPosition);\n        if (position.equals(validPosition) && sStartPosition.equals(validSStartPosition) && sEndPosition.equals(validSEndPosition)) {\n            // fast path: the state is valid\n            return viewState;\n        }\n        return new SingleCursorState(Range.fromPositions(validSStartPosition, validSEndPosition), viewState.selectionStartLeftoverVisibleColumns + sStartPosition.column - validSStartPosition.column, validPosition, viewState.leftoverVisibleColumns + position.column - validPosition.column);\n    }\n    _setState(context, modelState, viewState) {\n        if (viewState) {\n            viewState = Cursor._validateViewState(context.viewModel, viewState);\n        }\n        if (!modelState) {\n            if (!viewState) {\n                return;\n            }\n            // We only have the view state => compute the model state\n            const selectionStart = context.model.validateRange(context.coordinatesConverter.convertViewRangeToModelRange(viewState.selectionStart));\n            const position = context.model.validatePosition(context.coordinatesConverter.convertViewPositionToModelPosition(viewState.position));\n            modelState = new SingleCursorState(selectionStart, viewState.selectionStartLeftoverVisibleColumns, position, viewState.leftoverVisibleColumns);\n        }\n        else {\n            // Validate new model state\n            const selectionStart = context.model.validateRange(modelState.selectionStart);\n            const selectionStartLeftoverVisibleColumns = modelState.selectionStart.equalsRange(selectionStart) ? modelState.selectionStartLeftoverVisibleColumns : 0;\n            const position = context.model.validatePosition(modelState.position);\n            const leftoverVisibleColumns = modelState.position.equals(position) ? modelState.leftoverVisibleColumns : 0;\n            modelState = new SingleCursorState(selectionStart, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns);\n        }\n        if (!viewState) {\n            // We only have the model state => compute the view state\n            const viewSelectionStart1 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.startLineNumber, modelState.selectionStart.startColumn));\n            const viewSelectionStart2 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.endLineNumber, modelState.selectionStart.endColumn));\n            const viewSelectionStart = new Range(viewSelectionStart1.lineNumber, viewSelectionStart1.column, viewSelectionStart2.lineNumber, viewSelectionStart2.column);\n            const viewPosition = context.coordinatesConverter.convertModelPositionToViewPosition(modelState.position);\n            viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n        }\n        else {\n            // Validate new view state\n            const viewSelectionStart = context.coordinatesConverter.validateViewRange(viewState.selectionStart, modelState.selectionStart);\n            const viewPosition = context.coordinatesConverter.validateViewPosition(viewState.position, modelState.position);\n            viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n        }\n        this.modelState = modelState;\n        this.viewState = viewState;\n        this._updateTrackedRange(context);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { compareBy, findLastMaxBy, findMinBy } from '../../../base/common/arrays.js';\nimport { CursorState } from '../cursorCommon.js';\nimport { Cursor } from './oneCursor.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nexport class CursorCollection {\n    constructor(context) {\n        this.context = context;\n        this.cursors = [new Cursor(context)];\n        this.lastAddedCursorIndex = 0;\n    }\n    dispose() {\n        for (const cursor of this.cursors) {\n            cursor.dispose(this.context);\n        }\n    }\n    startTrackingSelections() {\n        for (const cursor of this.cursors) {\n            cursor.startTrackingSelection(this.context);\n        }\n    }\n    stopTrackingSelections() {\n        for (const cursor of this.cursors) {\n            cursor.stopTrackingSelection(this.context);\n        }\n    }\n    updateContext(context) {\n        this.context = context;\n    }\n    ensureValidState() {\n        for (const cursor of this.cursors) {\n            cursor.ensureValidState(this.context);\n        }\n    }\n    readSelectionFromMarkers() {\n        return this.cursors.map(c => c.readSelectionFromMarkers(this.context));\n    }\n    getAll() {\n        return this.cursors.map(c => c.asCursorState());\n    }\n    getViewPositions() {\n        return this.cursors.map(c => c.viewState.position);\n    }\n    getTopMostViewPosition() {\n        return findMinBy(this.cursors, compareBy(c => c.viewState.position, Position.compare)).viewState.position;\n    }\n    getBottomMostViewPosition() {\n        return findLastMaxBy(this.cursors, compareBy(c => c.viewState.position, Position.compare)).viewState.position;\n    }\n    getSelections() {\n        return this.cursors.map(c => c.modelState.selection);\n    }\n    getViewSelections() {\n        return this.cursors.map(c => c.viewState.selection);\n    }\n    setSelections(selections) {\n        this.setStates(CursorState.fromModelSelections(selections));\n    }\n    getPrimaryCursor() {\n        return this.cursors[0].asCursorState();\n    }\n    setStates(states) {\n        if (states === null) {\n            return;\n        }\n        this.cursors[0].setState(this.context, states[0].modelState, states[0].viewState);\n        this._setSecondaryStates(states.slice(1));\n    }\n    /**\n     * Creates or disposes secondary cursors as necessary to match the number of `secondarySelections`.\n     */\n    _setSecondaryStates(secondaryStates) {\n        const secondaryCursorsLength = this.cursors.length - 1;\n        const secondaryStatesLength = secondaryStates.length;\n        if (secondaryCursorsLength < secondaryStatesLength) {\n            const createCnt = secondaryStatesLength - secondaryCursorsLength;\n            for (let i = 0; i < createCnt; i++) {\n                this._addSecondaryCursor();\n            }\n        }\n        else if (secondaryCursorsLength > secondaryStatesLength) {\n            const removeCnt = secondaryCursorsLength - secondaryStatesLength;\n            for (let i = 0; i < removeCnt; i++) {\n                this._removeSecondaryCursor(this.cursors.length - 2);\n            }\n        }\n        for (let i = 0; i < secondaryStatesLength; i++) {\n            this.cursors[i + 1].setState(this.context, secondaryStates[i].modelState, secondaryStates[i].viewState);\n        }\n    }\n    killSecondaryCursors() {\n        this._setSecondaryStates([]);\n    }\n    _addSecondaryCursor() {\n        this.cursors.push(new Cursor(this.context));\n        this.lastAddedCursorIndex = this.cursors.length - 1;\n    }\n    getLastAddedCursorIndex() {\n        if (this.cursors.length === 1 || this.lastAddedCursorIndex === 0) {\n            return 0;\n        }\n        return this.lastAddedCursorIndex;\n    }\n    _removeSecondaryCursor(removeIndex) {\n        if (this.lastAddedCursorIndex >= removeIndex + 1) {\n            this.lastAddedCursorIndex--;\n        }\n        this.cursors[removeIndex + 1].dispose(this.context);\n        this.cursors.splice(removeIndex + 1, 1);\n    }\n    normalize() {\n        if (this.cursors.length === 1) {\n            return;\n        }\n        const cursors = this.cursors.slice(0);\n        const sortedCursors = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            sortedCursors.push({\n                index: i,\n                selection: cursors[i].modelState.selection,\n            });\n        }\n        sortedCursors.sort(compareBy(s => s.selection, Range.compareRangesUsingStarts));\n        for (let sortedCursorIndex = 0; sortedCursorIndex < sortedCursors.length - 1; sortedCursorIndex++) {\n            const current = sortedCursors[sortedCursorIndex];\n            const next = sortedCursors[sortedCursorIndex + 1];\n            const currentSelection = current.selection;\n            const nextSelection = next.selection;\n            if (!this.context.cursorConfig.multiCursorMergeOverlapping) {\n                continue;\n            }\n            let shouldMergeCursors;\n            if (nextSelection.isEmpty() || currentSelection.isEmpty()) {\n                // Merge touching cursors if one of them is collapsed\n                shouldMergeCursors = nextSelection.getStartPosition().isBeforeOrEqual(currentSelection.getEndPosition());\n            }\n            else {\n                // Merge only overlapping cursors (i.e. allow touching ranges)\n                shouldMergeCursors = nextSelection.getStartPosition().isBefore(currentSelection.getEndPosition());\n            }\n            if (shouldMergeCursors) {\n                const winnerSortedCursorIndex = current.index < next.index ? sortedCursorIndex : sortedCursorIndex + 1;\n                const looserSortedCursorIndex = current.index < next.index ? sortedCursorIndex + 1 : sortedCursorIndex;\n                const looserIndex = sortedCursors[looserSortedCursorIndex].index;\n                const winnerIndex = sortedCursors[winnerSortedCursorIndex].index;\n                const looserSelection = sortedCursors[looserSortedCursorIndex].selection;\n                const winnerSelection = sortedCursors[winnerSortedCursorIndex].selection;\n                if (!looserSelection.equalsSelection(winnerSelection)) {\n                    const resultingRange = looserSelection.plusRange(winnerSelection);\n                    const looserSelectionIsLTR = (looserSelection.selectionStartLineNumber === looserSelection.startLineNumber && looserSelection.selectionStartColumn === looserSelection.startColumn);\n                    const winnerSelectionIsLTR = (winnerSelection.selectionStartLineNumber === winnerSelection.startLineNumber && winnerSelection.selectionStartColumn === winnerSelection.startColumn);\n                    // Give more importance to the last added cursor (think Ctrl-dragging + hitting another cursor)\n                    let resultingSelectionIsLTR;\n                    if (looserIndex === this.lastAddedCursorIndex) {\n                        resultingSelectionIsLTR = looserSelectionIsLTR;\n                        this.lastAddedCursorIndex = winnerIndex;\n                    }\n                    else {\n                        // Winner takes it all\n                        resultingSelectionIsLTR = winnerSelectionIsLTR;\n                    }\n                    let resultingSelection;\n                    if (resultingSelectionIsLTR) {\n                        resultingSelection = new Selection(resultingRange.startLineNumber, resultingRange.startColumn, resultingRange.endLineNumber, resultingRange.endColumn);\n                    }\n                    else {\n                        resultingSelection = new Selection(resultingRange.endLineNumber, resultingRange.endColumn, resultingRange.startLineNumber, resultingRange.startColumn);\n                    }\n                    sortedCursors[winnerSortedCursorIndex].selection = resultingSelection;\n                    const resultingState = CursorState.fromModelSelection(resultingSelection);\n                    cursors[winnerIndex].setState(this.context, resultingState.modelState, resultingState.viewState);\n                }\n                for (const sortedCursor of sortedCursors) {\n                    if (sortedCursor.index > looserIndex) {\n                        sortedCursor.index--;\n                    }\n                }\n                cursors.splice(looserIndex, 1);\n                sortedCursors.splice(looserSortedCursorIndex, 1);\n                this._removeSecondaryCursor(looserIndex - 1);\n                sortedCursorIndex--;\n            }\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class CursorContext {\n    constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n        this._cursorContextBrand = undefined;\n        this.model = model;\n        this.viewModel = viewModel;\n        this.coordinatesConverter = coordinatesConverter;\n        this.cursorConfig = cursorConfig;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorCollection } from './cursorCollection.js';\nimport { CursorState, EditOperationResult } from '../cursorCommon.js';\nimport { CursorContext } from './cursorContext.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { CompositionOutcome, TypeOperations, TypeWithAutoClosingCommand } from './cursorTypeOperations.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ModelInjectedTextChangedEvent } from '../textModelEvents.js';\nimport { ViewCursorStateChangedEvent, ViewRevealRangeRequestEvent } from '../viewEvents.js';\nimport { dispose, Disposable } from '../../../base/common/lifecycle.js';\nimport { CursorStateChangedEvent } from '../viewModelEventDispatcher.js';\nexport class CursorsController extends Disposable {\n    constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n        super();\n        this._model = model;\n        this._knownModelVersionId = this._model.getVersionId();\n        this._viewModel = viewModel;\n        this._coordinatesConverter = coordinatesConverter;\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors = new CursorCollection(this.context);\n        this._hasFocus = false;\n        this._isHandling = false;\n        this._compositionState = null;\n        this._columnSelectData = null;\n        this._autoClosedActions = [];\n        this._prevEditOperationType = 0 /* EditOperationType.Other */;\n    }\n    dispose() {\n        this._cursors.dispose();\n        this._autoClosedActions = dispose(this._autoClosedActions);\n        super.dispose();\n    }\n    updateConfiguration(cursorConfig) {\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors.updateContext(this.context);\n    }\n    onLineMappingChanged(eventsCollector) {\n        if (this._knownModelVersionId !== this._model.getVersionId()) {\n            // There are model change events that I didn't yet receive.\n            //\n            // This can happen when editing the model, and the view model receives the change events first,\n            // and the view model emits line mapping changed events, all before the cursor gets a chance to\n            // recover from markers.\n            //\n            // The model change listener above will be called soon and we'll ensure a valid cursor state there.\n            return;\n        }\n        // Ensure valid state\n        this.setStates(eventsCollector, 'viewModel', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n    }\n    _validateAutoClosedActions() {\n        if (this._autoClosedActions.length > 0) {\n            const selections = this._cursors.getSelections();\n            for (let i = 0; i < this._autoClosedActions.length; i++) {\n                const autoClosedAction = this._autoClosedActions[i];\n                if (!autoClosedAction.isValid(selections)) {\n                    autoClosedAction.dispose();\n                    this._autoClosedActions.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n    }\n    // ------ some getters/setters\n    getPrimaryCursorState() {\n        return this._cursors.getPrimaryCursor();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursors.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursors.getAll();\n    }\n    setStates(eventsCollector, source, reason, states) {\n        let reachedMaxCursorCount = false;\n        if (states !== null && states.length > CursorsController.MAX_CURSOR_COUNT) {\n            states = states.slice(0, CursorsController.MAX_CURSOR_COUNT);\n            reachedMaxCursorCount = true;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.setStates(states);\n        this._cursors.normalize();\n        this._columnSelectData = null;\n        this._validateAutoClosedActions();\n        return this._emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount);\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._columnSelectData = columnSelectData;\n    }\n    revealPrimary(eventsCollector, source, minimalReveal, verticalType, revealHorizontal, scrollType) {\n        const viewPositions = this._cursors.getViewPositions();\n        let revealViewRange = null;\n        let revealViewSelections = null;\n        if (viewPositions.length > 1) {\n            revealViewSelections = this._cursors.getViewSelections();\n        }\n        else {\n            revealViewRange = Range.fromPositions(viewPositions[0], viewPositions[0]);\n        }\n        eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, revealViewRange, revealViewSelections, verticalType, revealHorizontal, scrollType));\n    }\n    saveState() {\n        const result = [];\n        const selections = this._cursors.getSelections();\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            result.push({\n                inSelectionMode: !selection.isEmpty(),\n                selectionStart: {\n                    lineNumber: selection.selectionStartLineNumber,\n                    column: selection.selectionStartColumn,\n                },\n                position: {\n                    lineNumber: selection.positionLineNumber,\n                    column: selection.positionColumn,\n                }\n            });\n        }\n        return result;\n    }\n    restoreState(eventsCollector, states) {\n        const desiredSelections = [];\n        for (let i = 0, len = states.length; i < len; i++) {\n            const state = states[i];\n            let positionLineNumber = 1;\n            let positionColumn = 1;\n            // Avoid missing properties on the literal\n            if (state.position && state.position.lineNumber) {\n                positionLineNumber = state.position.lineNumber;\n            }\n            if (state.position && state.position.column) {\n                positionColumn = state.position.column;\n            }\n            let selectionStartLineNumber = positionLineNumber;\n            let selectionStartColumn = positionColumn;\n            // Avoid missing properties on the literal\n            if (state.selectionStart && state.selectionStart.lineNumber) {\n                selectionStartLineNumber = state.selectionStart.lineNumber;\n            }\n            if (state.selectionStart && state.selectionStart.column) {\n                selectionStartColumn = state.selectionStart.column;\n            }\n            desiredSelections.push({\n                selectionStartLineNumber: selectionStartLineNumber,\n                selectionStartColumn: selectionStartColumn,\n                positionLineNumber: positionLineNumber,\n                positionColumn: positionColumn\n            });\n        }\n        this.setStates(eventsCollector, 'restoreState', 0 /* CursorChangeReason.NotSet */, CursorState.fromModelSelections(desiredSelections));\n        this.revealPrimary(eventsCollector, 'restoreState', false, 0 /* VerticalRevealType.Simple */, true, 1 /* editorCommon.ScrollType.Immediate */);\n    }\n    onModelContentChanged(eventsCollector, event) {\n        if (event instanceof ModelInjectedTextChangedEvent) {\n            // If injected texts change, the view positions of all cursors need to be updated.\n            if (this._isHandling) {\n                // The view positions will be updated when handling finishes\n                return;\n            }\n            // setStates might remove markers, which could trigger a decoration change.\n            // If there are injected text decorations for that line, `onModelContentChanged` is emitted again\n            // and an endless recursion happens.\n            // _isHandling prevents that.\n            this._isHandling = true;\n            try {\n                this.setStates(eventsCollector, 'modelChange', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n            }\n            finally {\n                this._isHandling = false;\n            }\n        }\n        else {\n            const e = event.rawContentChangedEvent;\n            this._knownModelVersionId = e.versionId;\n            if (this._isHandling) {\n                return;\n            }\n            const hadFlushEvent = e.containsEvent(1 /* RawContentChangedType.Flush */);\n            this._prevEditOperationType = 0 /* EditOperationType.Other */;\n            if (hadFlushEvent) {\n                // a model.setValue() was called\n                this._cursors.dispose();\n                this._cursors = new CursorCollection(this.context);\n                this._validateAutoClosedActions();\n                this._emitStateChangedIfNecessary(eventsCollector, 'model', 1 /* CursorChangeReason.ContentFlush */, null, false);\n            }\n            else {\n                if (this._hasFocus && e.resultingSelection && e.resultingSelection.length > 0) {\n                    const cursorState = CursorState.fromModelSelections(e.resultingSelection);\n                    if (this.setStates(eventsCollector, 'modelChange', e.isUndoing ? 5 /* CursorChangeReason.Undo */ : e.isRedoing ? 6 /* CursorChangeReason.Redo */ : 2 /* CursorChangeReason.RecoverFromMarkers */, cursorState)) {\n                        this.revealPrimary(eventsCollector, 'modelChange', false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n                    }\n                }\n                else {\n                    const selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\n                    this.setStates(eventsCollector, 'modelChange', 2 /* CursorChangeReason.RecoverFromMarkers */, CursorState.fromModelSelections(selectionsFromMarkers));\n                }\n            }\n        }\n    }\n    getSelection() {\n        return this._cursors.getPrimaryCursor().modelState.selection;\n    }\n    getTopMostViewPosition() {\n        return this._cursors.getTopMostViewPosition();\n    }\n    getBottomMostViewPosition() {\n        return this._cursors.getBottomMostViewPosition();\n    }\n    getCursorColumnSelectData() {\n        if (this._columnSelectData) {\n            return this._columnSelectData;\n        }\n        const primaryCursor = this._cursors.getPrimaryCursor();\n        const viewSelectionStart = primaryCursor.viewState.selectionStart.getStartPosition();\n        const viewPosition = primaryCursor.viewState.position;\n        return {\n            isReal: false,\n            fromViewLineNumber: viewSelectionStart.lineNumber,\n            fromViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewSelectionStart),\n            toViewLineNumber: viewPosition.lineNumber,\n            toViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewPosition),\n        };\n    }\n    getSelections() {\n        return this._cursors.getSelections();\n    }\n    setSelections(eventsCollector, source, selections, reason) {\n        this.setStates(eventsCollector, source, reason, CursorState.fromModelSelections(selections));\n    }\n    getPrevEditOperationType() {\n        return this._prevEditOperationType;\n    }\n    setPrevEditOperationType(type) {\n        this._prevEditOperationType = type;\n    }\n    // ------ auxiliary handling logic\n    _pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges) {\n        const autoClosedCharactersDeltaDecorations = [];\n        const autoClosedEnclosingDeltaDecorations = [];\n        for (let i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {\n            autoClosedCharactersDeltaDecorations.push({\n                range: autoClosedCharactersRanges[i],\n                options: {\n                    description: 'auto-closed-character',\n                    inlineClassName: 'auto-closed-character',\n                    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n                }\n            });\n            autoClosedEnclosingDeltaDecorations.push({\n                range: autoClosedEnclosingRanges[i],\n                options: {\n                    description: 'auto-closed-enclosing',\n                    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n                }\n            });\n        }\n        const autoClosedCharactersDecorations = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);\n        const autoClosedEnclosingDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);\n        this._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations));\n    }\n    _executeEditOperation(opResult) {\n        if (!opResult) {\n            // Nothing to execute\n            return;\n        }\n        if (opResult.shouldPushStackElementBefore) {\n            this._model.pushStackElement();\n        }\n        const result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);\n        if (result) {\n            // The commands were applied correctly\n            this._interpretCommandResult(result);\n            // Check for auto-closing closed characters\n            const autoClosedCharactersRanges = [];\n            const autoClosedEnclosingRanges = [];\n            for (let i = 0; i < opResult.commands.length; i++) {\n                const command = opResult.commands[i];\n                if (command instanceof TypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange) {\n                    autoClosedCharactersRanges.push(command.closeCharacterRange);\n                    autoClosedEnclosingRanges.push(command.enclosingRange);\n                }\n            }\n            if (autoClosedCharactersRanges.length > 0) {\n                this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n            }\n            this._prevEditOperationType = opResult.type;\n        }\n        if (opResult.shouldPushStackElementAfter) {\n            this._model.pushStackElement();\n        }\n    }\n    _interpretCommandResult(cursorState) {\n        if (!cursorState || cursorState.length === 0) {\n            cursorState = this._cursors.readSelectionFromMarkers();\n        }\n        this._columnSelectData = null;\n        this._cursors.setSelections(cursorState);\n        this._cursors.normalize();\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- emitting events\n    _emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount) {\n        const newState = CursorModelState.from(this._model, this);\n        if (newState.equals(oldState)) {\n            return false;\n        }\n        const selections = this._cursors.getSelections();\n        const viewSelections = this._cursors.getViewSelections();\n        // Let the view get the event first.\n        eventsCollector.emitViewEvent(new ViewCursorStateChangedEvent(viewSelections, selections));\n        // Only after the view has been notified, let the rest of the world know...\n        if (!oldState\n            || oldState.cursorState.length !== newState.cursorState.length\n            || newState.cursorState.some((newCursorState, i) => !newCursorState.modelState.equals(oldState.cursorState[i].modelState))) {\n            const oldSelections = oldState ? oldState.cursorState.map(s => s.modelState.selection) : null;\n            const oldModelVersionId = oldState ? oldState.modelVersionId : 0;\n            eventsCollector.emitOutgoingEvent(new CursorStateChangedEvent(oldSelections, selections, oldModelVersionId, newState.modelVersionId, source || 'keyboard', reason, reachedMaxCursorCount));\n        }\n        return true;\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- handlers beyond this point\n    _findAutoClosingPairs(edits) {\n        if (!edits.length) {\n            return null;\n        }\n        const indices = [];\n        for (let i = 0, len = edits.length; i < len; i++) {\n            const edit = edits[i];\n            if (!edit.text || edit.text.indexOf('\\n') >= 0) {\n                return null;\n            }\n            const m = edit.text.match(/([)\\]}>'\"`])([^)\\]}>'\"`]*)$/);\n            if (!m) {\n                return null;\n            }\n            const closeChar = m[1];\n            const autoClosingPairsCandidates = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(closeChar);\n            if (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {\n                return null;\n            }\n            const openChar = autoClosingPairsCandidates[0].open;\n            const closeCharIndex = edit.text.length - m[2].length - 1;\n            const openCharIndex = edit.text.lastIndexOf(openChar, closeCharIndex - 1);\n            if (openCharIndex === -1) {\n                return null;\n            }\n            indices.push([openCharIndex, closeCharIndex]);\n        }\n        return indices;\n    }\n    executeEdits(eventsCollector, source, edits, cursorStateComputer) {\n        let autoClosingIndices = null;\n        if (source === 'snippet') {\n            autoClosingIndices = this._findAutoClosingPairs(edits);\n        }\n        if (autoClosingIndices) {\n            edits[0]._isTracked = true;\n        }\n        const autoClosedCharactersRanges = [];\n        const autoClosedEnclosingRanges = [];\n        const selections = this._model.pushEditOperations(this.getSelections(), edits, (undoEdits) => {\n            if (autoClosingIndices) {\n                for (let i = 0, len = autoClosingIndices.length; i < len; i++) {\n                    const [openCharInnerIndex, closeCharInnerIndex] = autoClosingIndices[i];\n                    const undoEdit = undoEdits[i];\n                    const lineNumber = undoEdit.range.startLineNumber;\n                    const openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;\n                    const closeCharIndex = undoEdit.range.startColumn - 1 + closeCharInnerIndex;\n                    autoClosedCharactersRanges.push(new Range(lineNumber, closeCharIndex + 1, lineNumber, closeCharIndex + 2));\n                    autoClosedEnclosingRanges.push(new Range(lineNumber, openCharIndex + 1, lineNumber, closeCharIndex + 2));\n                }\n            }\n            const selections = cursorStateComputer(undoEdits);\n            if (selections) {\n                // Don't recover the selection from markers because\n                // we know what it should be.\n                this._isHandling = true;\n            }\n            return selections;\n        });\n        if (selections) {\n            this._isHandling = false;\n            this.setSelections(eventsCollector, source, selections, 0 /* CursorChangeReason.NotSet */);\n        }\n        if (autoClosedCharactersRanges.length > 0) {\n            this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n        }\n    }\n    _executeEdit(callback, eventsCollector, source, cursorChangeReason = 0 /* CursorChangeReason.NotSet */) {\n        if (this.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            return;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.stopTrackingSelections();\n        this._isHandling = true;\n        try {\n            this._cursors.ensureValidState();\n            callback();\n        }\n        catch (err) {\n            onUnexpectedError(err);\n        }\n        this._isHandling = false;\n        this._cursors.startTrackingSelections();\n        this._validateAutoClosedActions();\n        if (this._emitStateChangedIfNecessary(eventsCollector, source, cursorChangeReason, oldState, false)) {\n            this.revealPrimary(eventsCollector, source, false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n        }\n    }\n    getAutoClosedCharacters() {\n        return AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\n    }\n    startComposition(eventsCollector) {\n        this._compositionState = new CompositionState(this._model, this.getSelections());\n    }\n    endComposition(eventsCollector, source) {\n        const compositionOutcome = this._compositionState ? this._compositionState.deduceOutcome(this._model, this.getSelections()) : null;\n        this._compositionState = null;\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // composition finishes, let's check if we need to auto complete if necessary.\n                this._executeEditOperation(TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, compositionOutcome, this.getSelections(), this.getAutoClosedCharacters()));\n            }\n        }, eventsCollector, source);\n    }\n    type(eventsCollector, text, source) {\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // If this event is coming straight from the keyboard, look for electric characters and enter\n                const len = text.length;\n                let offset = 0;\n                while (offset < len) {\n                    const charLength = strings.nextCharLength(text, offset);\n                    const chr = text.substr(offset, charLength);\n                    // Here we must interpret each typed character individually\n                    this._executeEditOperation(TypeOperations.typeWithInterceptors(!!this._compositionState, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), chr));\n                    offset += charLength;\n                }\n            }\n            else {\n                this._executeEditOperation(TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text));\n            }\n        }, eventsCollector, source);\n    }\n    compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        if (text.length === 0 && replacePrevCharCnt === 0 && replaceNextCharCnt === 0) {\n            // this edit is a no-op\n            if (positionDelta !== 0) {\n                // but it still wants to move the cursor\n                const newSelections = this.getSelections().map(selection => {\n                    const position = selection.getPosition();\n                    return new Selection(position.lineNumber, position.column + positionDelta, position.lineNumber, position.column + positionDelta);\n                });\n                this.setSelections(eventsCollector, source, newSelections, 0 /* CursorChangeReason.NotSet */);\n            }\n            return;\n        }\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        }, eventsCollector, source);\n    }\n    paste(eventsCollector, text, pasteOnNewLine, multicursorText, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.paste(this.context.cursorConfig, this._model, this.getSelections(), text, pasteOnNewLine, multicursorText || []));\n        }, eventsCollector, source, 4 /* CursorChangeReason.Paste */);\n    }\n    cut(eventsCollector, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(DeleteOperations.cut(this.context.cursorConfig, this._model, this.getSelections()));\n        }, eventsCollector, source);\n    }\n    executeCommand(eventsCollector, command, source) {\n        this._executeEdit(() => {\n            this._cursors.killSecondaryCursors();\n            this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, [command], {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n    executeCommands(eventsCollector, commands, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n}\nCursorsController.MAX_CURSOR_COUNT = 10000;\n/**\n * A snapshot of the cursor and the model state\n */\nclass CursorModelState {\n    constructor(modelVersionId, cursorState) {\n        this.modelVersionId = modelVersionId;\n        this.cursorState = cursorState;\n    }\n    static from(model, cursor) {\n        return new CursorModelState(model.getVersionId(), cursor.getCursorStates());\n    }\n    equals(other) {\n        if (!other) {\n            return false;\n        }\n        if (this.modelVersionId !== other.modelVersionId) {\n            return false;\n        }\n        if (this.cursorState.length !== other.cursorState.length) {\n            return false;\n        }\n        for (let i = 0, len = this.cursorState.length; i < len; i++) {\n            if (!this.cursorState[i].equals(other.cursorState[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass AutoClosedAction {\n    constructor(model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations) {\n        this._model = model;\n        this._autoClosedCharactersDecorations = autoClosedCharactersDecorations;\n        this._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;\n    }\n    static getAllAutoClosedCharacters(autoClosedActions) {\n        let autoClosedCharacters = [];\n        for (const autoClosedAction of autoClosedActions) {\n            autoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());\n        }\n        return autoClosedCharacters;\n    }\n    dispose() {\n        this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);\n        this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);\n    }\n    getAutoClosedCharactersRanges() {\n        const result = [];\n        for (let i = 0; i < this._autoClosedCharactersDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);\n            if (decorationRange) {\n                result.push(decorationRange);\n            }\n        }\n        return result;\n    }\n    isValid(selections) {\n        const enclosingRanges = [];\n        for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);\n            if (decorationRange) {\n                enclosingRanges.push(decorationRange);\n                if (decorationRange.startLineNumber !== decorationRange.endLineNumber) {\n                    // Stop tracking if the range becomes multiline...\n                    return false;\n                }\n            }\n        }\n        enclosingRanges.sort(Range.compareRangesUsingStarts);\n        selections.sort(Range.compareRangesUsingStarts);\n        for (let i = 0; i < selections.length; i++) {\n            if (i >= enclosingRanges.length) {\n                return false;\n            }\n            if (!enclosingRanges[i].strictContainsRange(selections[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass CommandExecutor {\n    static executeCommands(model, selectionsBefore, commands) {\n        const ctx = {\n            model: model,\n            selectionsBefore: selectionsBefore,\n            trackedRanges: [],\n            trackedRangesDirection: []\n        };\n        const result = this._innerExecuteCommands(ctx, commands);\n        for (let i = 0, len = ctx.trackedRanges.length; i < len; i++) {\n            ctx.model._setTrackedRange(ctx.trackedRanges[i], null, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n        }\n        return result;\n    }\n    static _innerExecuteCommands(ctx, commands) {\n        if (this._arrayIsEmpty(commands)) {\n            return null;\n        }\n        const commandsData = this._getEditOperations(ctx, commands);\n        if (commandsData.operations.length === 0) {\n            return null;\n        }\n        const rawOperations = commandsData.operations;\n        const loserCursorsMap = this._getLoserCursorMap(rawOperations);\n        if (loserCursorsMap.hasOwnProperty('0')) {\n            // These commands are very messed up\n            console.warn('Ignoring commands');\n            return null;\n        }\n        // Remove operations belonging to losing cursors\n        const filteredOperations = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {\n                filteredOperations.push(rawOperations[i]);\n            }\n        }\n        // TODO@Alex: find a better way to do this.\n        // give the hint that edit operations are tracked to the model\n        if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\n            filteredOperations[0]._isTracked = true;\n        }\n        let selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, (inverseEditOperations) => {\n            const groupedInverseEditOperations = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                groupedInverseEditOperations[i] = [];\n            }\n            for (const op of inverseEditOperations) {\n                if (!op.identifier) {\n                    // perhaps auto whitespace trim edits\n                    continue;\n                }\n                groupedInverseEditOperations[op.identifier.major].push(op);\n            }\n            const minorBasedSorter = (a, b) => {\n                return a.identifier.minor - b.identifier.minor;\n            };\n            const cursorSelections = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                if (groupedInverseEditOperations[i].length > 0) {\n                    groupedInverseEditOperations[i].sort(minorBasedSorter);\n                    cursorSelections[i] = commands[i].computeCursorState(ctx.model, {\n                        getInverseEditOperations: () => {\n                            return groupedInverseEditOperations[i];\n                        },\n                        getTrackedSelection: (id) => {\n                            const idx = parseInt(id, 10);\n                            const range = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);\n                            if (ctx.trackedRangesDirection[idx] === 0 /* SelectionDirection.LTR */) {\n                                return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n                            }\n                            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n                        }\n                    });\n                }\n                else {\n                    cursorSelections[i] = ctx.selectionsBefore[i];\n                }\n            }\n            return cursorSelections;\n        });\n        if (!selectionsAfter) {\n            selectionsAfter = ctx.selectionsBefore;\n        }\n        // Extract losing cursors\n        const losingCursors = [];\n        for (const losingCursorIndex in loserCursorsMap) {\n            if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\n                losingCursors.push(parseInt(losingCursorIndex, 10));\n            }\n        }\n        // Sort losing cursors descending\n        losingCursors.sort((a, b) => {\n            return b - a;\n        });\n        // Remove losing cursors\n        for (const losingCursor of losingCursors) {\n            selectionsAfter.splice(losingCursor, 1);\n        }\n        return selectionsAfter;\n    }\n    static _arrayIsEmpty(commands) {\n        for (let i = 0, len = commands.length; i < len; i++) {\n            if (commands[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _getEditOperations(ctx, commands) {\n        let operations = [];\n        let hadTrackedEditOperation = false;\n        for (let i = 0, len = commands.length; i < len; i++) {\n            const command = commands[i];\n            if (command) {\n                const r = this._getEditOperationsFromCommand(ctx, i, command);\n                operations = operations.concat(r.operations);\n                hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\n            }\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getEditOperationsFromCommand(ctx, majorIdentifier, command) {\n        // This method acts as a transaction, if the command fails\n        // everything it has done is ignored\n        const operations = [];\n        let operationMinor = 0;\n        const addEditOperation = (range, text, forceMoveMarkers = false) => {\n            if (Range.isEmpty(range) && text === '') {\n                // This command wants to add a no-op => no thank you\n                return;\n            }\n            operations.push({\n                identifier: {\n                    major: majorIdentifier,\n                    minor: operationMinor++\n                },\n                range: range,\n                text: text,\n                forceMoveMarkers: forceMoveMarkers,\n                isAutoWhitespaceEdit: command.insertsAutoWhitespace\n            });\n        };\n        let hadTrackedEditOperation = false;\n        const addTrackedEditOperation = (selection, text, forceMoveMarkers) => {\n            hadTrackedEditOperation = true;\n            addEditOperation(selection, text, forceMoveMarkers);\n        };\n        const trackSelection = (_selection, trackPreviousOnEmpty) => {\n            const selection = Selection.liftSelection(_selection);\n            let stickiness;\n            if (selection.isEmpty()) {\n                if (typeof trackPreviousOnEmpty === 'boolean') {\n                    if (trackPreviousOnEmpty) {\n                        stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n                else {\n                    // Try to lock it with surrounding text\n                    const maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn === maxLineColumn) {\n                        stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n            }\n            else {\n                stickiness = 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */;\n            }\n            const l = ctx.trackedRanges.length;\n            const id = ctx.model._setTrackedRange(null, selection, stickiness);\n            ctx.trackedRanges[l] = id;\n            ctx.trackedRangesDirection[l] = selection.getDirection();\n            return l.toString();\n        };\n        const editOperationBuilder = {\n            addEditOperation: addEditOperation,\n            addTrackedEditOperation: addTrackedEditOperation,\n            trackSelection: trackSelection\n        };\n        try {\n            command.getEditOperations(ctx.model, editOperationBuilder);\n        }\n        catch (e) {\n            // TODO@Alex use notification service if this should be user facing\n            // e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\n            onUnexpectedError(e);\n            return {\n                operations: [],\n                hadTrackedEditOperation: false\n            };\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getLoserCursorMap(operations) {\n        // This is destructive on the array\n        operations = operations.slice(0);\n        // Sort operations with last one first\n        operations.sort((a, b) => {\n            // Note the minus!\n            return -(Range.compareRangesUsingEnds(a.range, b.range));\n        });\n        // Operations can not overlap!\n        const loserCursorsMap = {};\n        for (let i = 1; i < operations.length; i++) {\n            const previousOp = operations[i - 1];\n            const currentOp = operations[i];\n            if (Range.getStartPosition(previousOp.range).isBefore(Range.getEndPosition(currentOp.range))) {\n                let loserMajor;\n                if (previousOp.identifier.major > currentOp.identifier.major) {\n                    // previousOp loses the battle\n                    loserMajor = previousOp.identifier.major;\n                }\n                else {\n                    loserMajor = currentOp.identifier.major;\n                }\n                loserCursorsMap[loserMajor.toString()] = true;\n                for (let j = 0; j < operations.length; j++) {\n                    if (operations[j].identifier.major === loserMajor) {\n                        operations.splice(j, 1);\n                        if (j < i) {\n                            i--;\n                        }\n                        j--;\n                    }\n                }\n                if (i > 0) {\n                    i--;\n                }\n            }\n        }\n        return loserCursorsMap;\n    }\n}\nclass CompositionLineState {\n    constructor(text, startSelection, endSelection) {\n        this.text = text;\n        this.startSelection = startSelection;\n        this.endSelection = endSelection;\n    }\n}\nclass CompositionState {\n    constructor(textModel, selections) {\n        this._original = CompositionState._capture(textModel, selections);\n    }\n    static _capture(textModel, selections) {\n        const result = [];\n        for (const selection of selections) {\n            if (selection.startLineNumber !== selection.endLineNumber) {\n                return null;\n            }\n            result.push(new CompositionLineState(textModel.getLineContent(selection.startLineNumber), selection.startColumn - 1, selection.endColumn - 1));\n        }\n        return result;\n    }\n    /**\n     * Returns the inserted text during this composition.\n     * If the composition resulted in existing text being changed (i.e. not a pure insertion) it returns null.\n     */\n    deduceOutcome(textModel, selections) {\n        if (!this._original) {\n            return null;\n        }\n        const current = CompositionState._capture(textModel, selections);\n        if (!current) {\n            return null;\n        }\n        if (this._original.length !== current.length) {\n            return null;\n        }\n        const result = [];\n        for (let i = 0, len = this._original.length; i < len; i++) {\n            result.push(CompositionState._deduceOutcome(this._original[i], current[i]));\n        }\n        return result;\n    }\n    static _deduceOutcome(original, current) {\n        const commonPrefix = Math.min(original.startSelection, current.startSelection, strings.commonPrefixLength(original.text, current.text));\n        const commonSuffix = Math.min(original.text.length - original.endSelection, current.text.length - current.endSelection, strings.commonSuffixLength(original.text, current.text));\n        const deletedText = original.text.substring(commonPrefix, original.text.length - commonSuffix);\n        const insertedText = current.text.substring(commonPrefix, current.text.length - commonSuffix);\n        return new CompositionOutcome(deletedText, original.startSelection - commonPrefix, original.endSelection - commonPrefix, insertedText, current.startSelection - commonPrefix, current.endSelection - commonPrefix);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorColumns } from '../core/cursorColumns.js';\nexport class AtomicTabMoveOperations {\n    /**\n     * Get the visible column at the position. If we get to a non-whitespace character first\n     * or past the end of string then return -1.\n     *\n     * **Note** `position` and the return value are 0-based.\n     */\n    static whitespaceVisibleColumn(lineContent, position, tabSize) {\n        const lineLength = lineContent.length;\n        let visibleColumn = 0;\n        let prevTabStopPosition = -1;\n        let prevTabStopVisibleColumn = -1;\n        for (let i = 0; i < lineLength; i++) {\n            if (i === position) {\n                return [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn];\n            }\n            if (visibleColumn % tabSize === 0) {\n                prevTabStopPosition = i;\n                prevTabStopVisibleColumn = visibleColumn;\n            }\n            const chCode = lineContent.charCodeAt(i);\n            switch (chCode) {\n                case 32 /* CharCode.Space */:\n                    visibleColumn += 1;\n                    break;\n                case 9 /* CharCode.Tab */:\n                    // Skip to the next multiple of tabSize.\n                    visibleColumn = CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n                    break;\n                default:\n                    return [-1, -1, -1];\n            }\n        }\n        if (position === lineLength) {\n            return [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn];\n        }\n        return [-1, -1, -1];\n    }\n    /**\n     * Return the position that should result from a move left, right or to the\n     * nearest tab, if atomic tabs are enabled. Left and right are used for the\n     * arrow key movements, nearest is used for mouse selection. It returns\n     * -1 if atomic tabs are not relevant and you should fall back to normal\n     * behaviour.\n     *\n     * **Note**: `position` and the return value are 0-based.\n     */\n    static atomicPosition(lineContent, position, tabSize, direction) {\n        const lineLength = lineContent.length;\n        // Get the 0-based visible column corresponding to the position, or return\n        // -1 if it is not in the initial whitespace.\n        const [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn] = AtomicTabMoveOperations.whitespaceVisibleColumn(lineContent, position, tabSize);\n        if (visibleColumn === -1) {\n            return -1;\n        }\n        // Is the output left or right of the current position. The case for nearest\n        // where it is the same as the current position is handled in the switch.\n        let left;\n        switch (direction) {\n            case 0 /* Direction.Left */:\n                left = true;\n                break;\n            case 1 /* Direction.Right */:\n                left = false;\n                break;\n            case 2 /* Direction.Nearest */:\n                // The code below assumes the output position is either left or right\n                // of the input position. If it is the same, return immediately.\n                if (visibleColumn % tabSize === 0) {\n                    return position;\n                }\n                // Go to the nearest indentation.\n                left = visibleColumn % tabSize <= (tabSize / 2);\n                break;\n        }\n        // If going left, we can just use the info about the last tab stop position and\n        // last tab stop visible column that we computed in the first walk over the whitespace.\n        if (left) {\n            if (prevTabStopPosition === -1) {\n                return -1;\n            }\n            // If the direction is left, we need to keep scanning right to ensure\n            // that targetVisibleColumn + tabSize is before non-whitespace.\n            // This is so that when we press left at the end of a partial\n            // indentation it only goes one character. For example '      foo' with\n            // tabSize 4, should jump from position 6 to position 5, not 4.\n            let currentVisibleColumn = prevTabStopVisibleColumn;\n            for (let i = prevTabStopPosition; i < lineLength; ++i) {\n                if (currentVisibleColumn === prevTabStopVisibleColumn + tabSize) {\n                    // It is a full indentation.\n                    return prevTabStopPosition;\n                }\n                const chCode = lineContent.charCodeAt(i);\n                switch (chCode) {\n                    case 32 /* CharCode.Space */:\n                        currentVisibleColumn += 1;\n                        break;\n                    case 9 /* CharCode.Tab */:\n                        currentVisibleColumn = CursorColumns.nextRenderTabStop(currentVisibleColumn, tabSize);\n                        break;\n                    default:\n                        return -1;\n                }\n            }\n            if (currentVisibleColumn === prevTabStopVisibleColumn + tabSize) {\n                return prevTabStopPosition;\n            }\n            // It must have been a partial indentation.\n            return -1;\n        }\n        // We are going right.\n        const targetVisibleColumn = CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        // We can just continue from where whitespaceVisibleColumn got to.\n        let currentVisibleColumn = visibleColumn;\n        for (let i = position; i < lineLength; i++) {\n            if (currentVisibleColumn === targetVisibleColumn) {\n                return i;\n            }\n            const chCode = lineContent.charCodeAt(i);\n            switch (chCode) {\n                case 32 /* CharCode.Space */:\n                    currentVisibleColumn += 1;\n                    break;\n                case 9 /* CharCode.Tab */:\n                    currentVisibleColumn = CursorColumns.nextRenderTabStop(currentVisibleColumn, tabSize);\n                    break;\n                default:\n                    return -1;\n            }\n        }\n        // This condition handles when the target column is at the end of the line.\n        if (currentVisibleColumn === targetVisibleColumn) {\n            return lineLength;\n        }\n        return -1;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class ColumnSelection {\n    static columnSelect(config, model, fromLineNumber, fromVisibleColumn, toLineNumber, toVisibleColumn) {\n        const lineCount = Math.abs(toLineNumber - fromLineNumber) + 1;\n        const reversed = (fromLineNumber > toLineNumber);\n        const isRTL = (fromVisibleColumn > toVisibleColumn);\n        const isLTR = (fromVisibleColumn < toVisibleColumn);\n        const result = [];\n        // console.log(`fromVisibleColumn: ${fromVisibleColumn}, toVisibleColumn: ${toVisibleColumn}`);\n        for (let i = 0; i < lineCount; i++) {\n            const lineNumber = fromLineNumber + (reversed ? -i : i);\n            const startColumn = config.columnFromVisibleColumn(model, lineNumber, fromVisibleColumn);\n            const endColumn = config.columnFromVisibleColumn(model, lineNumber, toVisibleColumn);\n            const visibleStartColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, startColumn));\n            const visibleEndColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, endColumn));\n            // console.log(`lineNumber: ${lineNumber}: visibleStartColumn: ${visibleStartColumn}, visibleEndColumn: ${visibleEndColumn}`);\n            if (isLTR) {\n                if (visibleStartColumn > toVisibleColumn) {\n                    continue;\n                }\n                if (visibleEndColumn < fromVisibleColumn) {\n                    continue;\n                }\n            }\n            if (isRTL) {\n                if (visibleEndColumn > fromVisibleColumn) {\n                    continue;\n                }\n                if (visibleStartColumn < toVisibleColumn) {\n                    continue;\n                }\n            }\n            result.push(new SingleCursorState(new Range(lineNumber, startColumn, lineNumber, startColumn), 0, new Position(lineNumber, endColumn), 0));\n        }\n        if (result.length === 0) {\n            // We are after all the lines, so add cursor at the end of each line\n            for (let i = 0; i < lineCount; i++) {\n                const lineNumber = fromLineNumber + (reversed ? -i : i);\n                const maxColumn = model.getLineMaxColumn(lineNumber);\n                result.push(new SingleCursorState(new Range(lineNumber, maxColumn, lineNumber, maxColumn), 0, new Position(lineNumber, maxColumn), 0));\n            }\n        }\n        return {\n            viewStates: result,\n            reversed: reversed,\n            fromLineNumber: fromLineNumber,\n            fromVisualColumn: fromVisibleColumn,\n            toLineNumber: toLineNumber,\n            toVisualColumn: toVisibleColumn\n        };\n    }\n    static columnSelectLeft(config, model, prevColumnSelectData) {\n        let toViewVisualColumn = prevColumnSelectData.toViewVisualColumn;\n        if (toViewVisualColumn > 0) {\n            toViewVisualColumn--;\n        }\n        return ColumnSelection.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, prevColumnSelectData.toViewLineNumber, toViewVisualColumn);\n    }\n    static columnSelectRight(config, model, prevColumnSelectData) {\n        let maxVisualViewColumn = 0;\n        const minViewLineNumber = Math.min(prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.toViewLineNumber);\n        const maxViewLineNumber = Math.max(prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.toViewLineNumber);\n        for (let lineNumber = minViewLineNumber; lineNumber <= maxViewLineNumber; lineNumber++) {\n            const lineMaxViewColumn = model.getLineMaxColumn(lineNumber);\n            const lineMaxVisualViewColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, lineMaxViewColumn));\n            maxVisualViewColumn = Math.max(maxVisualViewColumn, lineMaxVisualViewColumn);\n        }\n        let toViewVisualColumn = prevColumnSelectData.toViewVisualColumn;\n        if (toViewVisualColumn < maxVisualViewColumn) {\n            toViewVisualColumn++;\n        }\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, prevColumnSelectData.toViewLineNumber, toViewVisualColumn);\n    }\n    static columnSelectUp(config, model, prevColumnSelectData, isPaged) {\n        const linesCount = isPaged ? config.pageSize : 1;\n        const toViewLineNumber = Math.max(1, prevColumnSelectData.toViewLineNumber - linesCount);\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, toViewLineNumber, prevColumnSelectData.toViewVisualColumn);\n    }\n    static columnSelectDown(config, model, prevColumnSelectData, isPaged) {\n        const linesCount = isPaged ? config.pageSize : 1;\n        const toViewLineNumber = Math.min(model.getLineCount(), prevColumnSelectData.toViewLineNumber + linesCount);\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, toViewLineNumber, prevColumnSelectData.toViewVisualColumn);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand } from '../commands/replaceCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nexport class DeleteOperations {\n    static deleteRight(prevEditOperationType, config, model, selections) {\n        const commands = [];\n        let shouldPushStackElementBefore = (prevEditOperationType !== 3 /* EditOperationType.DeletingRight */);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            let deleteSelection = selection;\n            if (deleteSelection.isEmpty()) {\n                const position = selection.getPosition();\n                const rightOfPosition = MoveOperations.right(config, model, position);\n                deleteSelection = new Range(rightOfPosition.lineNumber, rightOfPosition.column, position.lineNumber, position.column);\n            }\n            if (deleteSelection.isEmpty()) {\n                // Probably at end of file => ignore\n                commands[i] = null;\n                continue;\n            }\n            if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {\n                shouldPushStackElementBefore = true;\n            }\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n        }\n        return [shouldPushStackElementBefore, commands];\n    }\n    static isAutoClosingPairDelete(autoClosingDelete, autoClosingBrackets, autoClosingQuotes, autoClosingPairsOpen, model, selections, autoClosedCharacters) {\n        if (autoClosingBrackets === 'never' && autoClosingQuotes === 'never') {\n            return false;\n        }\n        if (autoClosingDelete === 'never') {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            if (!selection.isEmpty()) {\n                return false;\n            }\n            const lineText = model.getLineContent(position.lineNumber);\n            if (position.column < 2 || position.column >= lineText.length + 1) {\n                return false;\n            }\n            const character = lineText.charAt(position.column - 2);\n            const autoClosingPairCandidates = autoClosingPairsOpen.get(character);\n            if (!autoClosingPairCandidates) {\n                return false;\n            }\n            if (isQuote(character)) {\n                if (autoClosingQuotes === 'never') {\n                    return false;\n                }\n            }\n            else {\n                if (autoClosingBrackets === 'never') {\n                    return false;\n                }\n            }\n            const afterCharacter = lineText.charAt(position.column - 1);\n            let foundAutoClosingPair = false;\n            for (const autoClosingPairCandidate of autoClosingPairCandidates) {\n                if (autoClosingPairCandidate.open === character && autoClosingPairCandidate.close === afterCharacter) {\n                    foundAutoClosingPair = true;\n                }\n            }\n            if (!foundAutoClosingPair) {\n                return false;\n            }\n            // Must delete the pair only if it was automatically inserted by the editor\n            if (autoClosingDelete === 'auto') {\n                let found = false;\n                for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                    const autoClosedCharacter = autoClosedCharacters[j];\n                    if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runAutoClosingPairDelete(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const position = selections[i].getPosition();\n            const deleteSelection = new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n        }\n        return [true, commands];\n    }\n    static deleteLeft(prevEditOperationType, config, model, selections, autoClosedCharacters) {\n        if (this.isAutoClosingPairDelete(config.autoClosingDelete, config.autoClosingBrackets, config.autoClosingQuotes, config.autoClosingPairs.autoClosingPairsOpenByEnd, model, selections, autoClosedCharacters)) {\n            return this._runAutoClosingPairDelete(config, model, selections);\n        }\n        const commands = [];\n        let shouldPushStackElementBefore = (prevEditOperationType !== 2 /* EditOperationType.DeletingLeft */);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const deleteRange = DeleteOperations.getDeleteRange(selections[i], model, config);\n            // Ignore empty delete ranges, as they have no effect\n            // They happen if the cursor is at the beginning of the file.\n            if (deleteRange.isEmpty()) {\n                commands[i] = null;\n                continue;\n            }\n            if (deleteRange.startLineNumber !== deleteRange.endLineNumber) {\n                shouldPushStackElementBefore = true;\n            }\n            commands[i] = new ReplaceCommand(deleteRange, '');\n        }\n        return [shouldPushStackElementBefore, commands];\n    }\n    static getDeleteRange(selection, model, config) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = selection.getPosition();\n        // Unintend when using tab stops and cursor is within indentation\n        if (config.useTabStops && position.column > 1) {\n            const lineContent = model.getLineContent(position.lineNumber);\n            const firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n            const lastIndentationColumn = (firstNonWhitespaceIndex === -1\n                ? /* entire string is whitespace */ lineContent.length + 1\n                : firstNonWhitespaceIndex + 1);\n            if (position.column <= lastIndentationColumn) {\n                const fromVisibleColumn = config.visibleColumnFromColumn(model, position);\n                const toVisibleColumn = CursorColumns.prevIndentTabStop(fromVisibleColumn, config.indentSize);\n                const toColumn = config.columnFromVisibleColumn(model, position.lineNumber, toVisibleColumn);\n                return new Range(position.lineNumber, toColumn, position.lineNumber, position.column);\n            }\n        }\n        return Range.fromPositions(DeleteOperations.getPositionAfterDeleteLeft(position, model), position);\n    }\n    static getPositionAfterDeleteLeft(position, model) {\n        if (position.column > 1) {\n            // Convert 1-based columns to 0-based offsets and back.\n            const idx = strings.getLeftDeleteOffset(position.column - 1, model.getLineContent(position.lineNumber));\n            return position.with(undefined, idx + 1);\n        }\n        else if (position.lineNumber > 1) {\n            const newLine = position.lineNumber - 1;\n            return new Position(newLine, model.getLineMaxColumn(newLine));\n        }\n        else {\n            return position;\n        }\n    }\n    static cut(config, model, selections) {\n        const commands = [];\n        let lastCutRange = null;\n        selections.sort((a, b) => Position.compare(a.getStartPosition(), b.getEndPosition()));\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                if (config.emptySelectionClipboard) {\n                    // This is a full line cut\n                    const position = selection.getPosition();\n                    let startLineNumber, startColumn, endLineNumber, endColumn;\n                    if (position.lineNumber < model.getLineCount()) {\n                        // Cutting a line in the middle of the model\n                        startLineNumber = position.lineNumber;\n                        startColumn = 1;\n                        endLineNumber = position.lineNumber + 1;\n                        endColumn = 1;\n                    }\n                    else if (position.lineNumber > 1 && (lastCutRange === null || lastCutRange === void 0 ? void 0 : lastCutRange.endLineNumber) !== position.lineNumber) {\n                        // Cutting the last line & there are more than 1 lines in the model & a previous cut operation does not touch the current cut operation\n                        startLineNumber = position.lineNumber - 1;\n                        startColumn = model.getLineMaxColumn(position.lineNumber - 1);\n                        endLineNumber = position.lineNumber;\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\n                    }\n                    else {\n                        // Cutting the single line that the model contains\n                        startLineNumber = position.lineNumber;\n                        startColumn = 1;\n                        endLineNumber = position.lineNumber;\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\n                    }\n                    const deleteSelection = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n                    lastCutRange = deleteSelection;\n                    if (!deleteSelection.isEmpty()) {\n                        commands[i] = new ReplaceCommand(deleteSelection, '');\n                    }\n                    else {\n                        commands[i] = null;\n                    }\n                }\n                else {\n                    // Cannot cut empty selection\n                    commands[i] = null;\n                }\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, '');\n            }\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as types from '../../../base/common/types.js';\nimport { CursorState, SingleCursorState } from '../cursorCommon.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { WordOperations } from './cursorWordOperations.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class CursorMoveCommands {\n    static addCursorDown(viewModel, cursors, useLogicalLine) {\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n            if (useLogicalLine) {\n                result[resultLen++] = CursorState.fromModelState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n            }\n            else {\n                result[resultLen++] = CursorState.fromViewState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel, cursor.viewState));\n            }\n        }\n        return result;\n    }\n    static addCursorUp(viewModel, cursors, useLogicalLine) {\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n            if (useLogicalLine) {\n                result[resultLen++] = CursorState.fromModelState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n            }\n            else {\n                result[resultLen++] = CursorState.fromViewState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel, cursor.viewState));\n            }\n        }\n        return result;\n    }\n    static moveToBeginningOfLine(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = this._moveToLineStart(viewModel, cursor, inSelectionMode);\n        }\n        return result;\n    }\n    static _moveToLineStart(viewModel, cursor, inSelectionMode) {\n        const currentViewStateColumn = cursor.viewState.position.column;\n        const currentModelStateColumn = cursor.modelState.position.column;\n        const isFirstLineOfWrappedLine = currentViewStateColumn === currentModelStateColumn;\n        const currentViewStatelineNumber = cursor.viewState.position.lineNumber;\n        const firstNonBlankColumn = viewModel.getLineFirstNonWhitespaceColumn(currentViewStatelineNumber);\n        const isBeginningOfViewLine = currentViewStateColumn === firstNonBlankColumn;\n        if (!isFirstLineOfWrappedLine && !isBeginningOfViewLine) {\n            return this._moveToLineStartByView(viewModel, cursor, inSelectionMode);\n        }\n        else {\n            return this._moveToLineStartByModel(viewModel, cursor, inSelectionMode);\n        }\n    }\n    static _moveToLineStartByView(viewModel, cursor, inSelectionMode) {\n        return CursorState.fromViewState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode));\n    }\n    static _moveToLineStartByModel(viewModel, cursor, inSelectionMode) {\n        return CursorState.fromModelState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n    }\n    static moveToEndOfLine(viewModel, cursors, inSelectionMode, sticky) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = this._moveToLineEnd(viewModel, cursor, inSelectionMode, sticky);\n        }\n        return result;\n    }\n    static _moveToLineEnd(viewModel, cursor, inSelectionMode, sticky) {\n        const viewStatePosition = cursor.viewState.position;\n        const viewModelMaxColumn = viewModel.getLineMaxColumn(viewStatePosition.lineNumber);\n        const isEndOfViewLine = viewStatePosition.column === viewModelMaxColumn;\n        const modelStatePosition = cursor.modelState.position;\n        const modelMaxColumn = viewModel.model.getLineMaxColumn(modelStatePosition.lineNumber);\n        const isEndLineOfWrappedLine = viewModelMaxColumn - viewStatePosition.column === modelMaxColumn - modelStatePosition.column;\n        if (isEndOfViewLine || isEndLineOfWrappedLine) {\n            return this._moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky);\n        }\n        else {\n            return this._moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky);\n        }\n    }\n    static _moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky) {\n        return CursorState.fromViewState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, sticky));\n    }\n    static _moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky) {\n        return CursorState.fromModelState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, sticky));\n    }\n    static expandLineSelection(viewModel, cursors) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const startLineNumber = cursor.modelState.selection.startLineNumber;\n            const lineCount = viewModel.model.getLineCount();\n            let endLineNumber = cursor.modelState.selection.endLineNumber;\n            let endColumn;\n            if (endLineNumber === lineCount) {\n                endColumn = viewModel.model.getLineMaxColumn(lineCount);\n            }\n            else {\n                endLineNumber++;\n                endColumn = 1;\n            }\n            result[i] = CursorState.fromModelState(new SingleCursorState(new Range(startLineNumber, 1, startLineNumber, 1), 0, new Position(endLineNumber, endColumn), 0));\n        }\n        return result;\n    }\n    static moveToBeginningOfBuffer(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveToBeginningOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n        }\n        return result;\n    }\n    static moveToEndOfBuffer(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveToEndOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n        }\n        return result;\n    }\n    static selectAll(viewModel, cursor) {\n        const lineCount = viewModel.model.getLineCount();\n        const maxColumn = viewModel.model.getLineMaxColumn(lineCount);\n        return CursorState.fromModelState(new SingleCursorState(new Range(1, 1, 1, 1), 0, new Position(lineCount, maxColumn), 0));\n    }\n    static line(viewModel, cursor, inSelectionMode, _position, _viewPosition) {\n        const position = viewModel.model.validatePosition(_position);\n        const viewPosition = (_viewPosition\n            ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\n            : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position));\n        if (!inSelectionMode || !cursor.modelState.hasSelection()) {\n            // Entering line selection for the first time\n            const lineCount = viewModel.model.getLineCount();\n            let selectToLineNumber = position.lineNumber + 1;\n            let selectToColumn = 1;\n            if (selectToLineNumber > lineCount) {\n                selectToLineNumber = lineCount;\n                selectToColumn = viewModel.model.getLineMaxColumn(selectToLineNumber);\n            }\n            return CursorState.fromModelState(new SingleCursorState(new Range(position.lineNumber, 1, selectToLineNumber, selectToColumn), 0, new Position(selectToLineNumber, selectToColumn), 0));\n        }\n        // Continuing line selection\n        const enteringLineNumber = cursor.modelState.selectionStart.getStartPosition().lineNumber;\n        if (position.lineNumber < enteringLineNumber) {\n            return CursorState.fromViewState(cursor.viewState.move(cursor.modelState.hasSelection(), viewPosition.lineNumber, 1, 0));\n        }\n        else if (position.lineNumber > enteringLineNumber) {\n            const lineCount = viewModel.getLineCount();\n            let selectToViewLineNumber = viewPosition.lineNumber + 1;\n            let selectToViewColumn = 1;\n            if (selectToViewLineNumber > lineCount) {\n                selectToViewLineNumber = lineCount;\n                selectToViewColumn = viewModel.getLineMaxColumn(selectToViewLineNumber);\n            }\n            return CursorState.fromViewState(cursor.viewState.move(cursor.modelState.hasSelection(), selectToViewLineNumber, selectToViewColumn, 0));\n        }\n        else {\n            const endPositionOfSelectionStart = cursor.modelState.selectionStart.getEndPosition();\n            return CursorState.fromModelState(cursor.modelState.move(cursor.modelState.hasSelection(), endPositionOfSelectionStart.lineNumber, endPositionOfSelectionStart.column, 0));\n        }\n    }\n    static word(viewModel, cursor, inSelectionMode, _position) {\n        const position = viewModel.model.validatePosition(_position);\n        return CursorState.fromModelState(WordOperations.word(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, position));\n    }\n    static cancelSelection(viewModel, cursor) {\n        if (!cursor.modelState.hasSelection()) {\n            return new CursorState(cursor.modelState, cursor.viewState);\n        }\n        const lineNumber = cursor.viewState.position.lineNumber;\n        const column = cursor.viewState.position.column;\n        return CursorState.fromViewState(new SingleCursorState(new Range(lineNumber, column, lineNumber, column), 0, new Position(lineNumber, column), 0));\n    }\n    static moveTo(viewModel, cursor, inSelectionMode, _position, _viewPosition) {\n        const position = viewModel.model.validatePosition(_position);\n        const viewPosition = (_viewPosition\n            ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\n            : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position));\n        return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, viewPosition.lineNumber, viewPosition.column, 0));\n    }\n    static simpleMove(viewModel, cursors, direction, inSelectionMode, value, unit) {\n        switch (direction) {\n            case 0 /* CursorMove.Direction.Left */: {\n                if (unit === 4 /* CursorMove.Unit.HalfLine */) {\n                    // Move left by half the current line length\n                    return this._moveHalfLineLeft(viewModel, cursors, inSelectionMode);\n                }\n                else {\n                    // Move left by `moveParams.value` columns\n                    return this._moveLeft(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 1 /* CursorMove.Direction.Right */: {\n                if (unit === 4 /* CursorMove.Unit.HalfLine */) {\n                    // Move right by half the current line length\n                    return this._moveHalfLineRight(viewModel, cursors, inSelectionMode);\n                }\n                else {\n                    // Move right by `moveParams.value` columns\n                    return this._moveRight(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 2 /* CursorMove.Direction.Up */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    // Move up by view lines\n                    return this._moveUpByViewLines(viewModel, cursors, inSelectionMode, value);\n                }\n                else {\n                    // Move up by model lines\n                    return this._moveUpByModelLines(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 3 /* CursorMove.Direction.Down */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    // Move down by view lines\n                    return this._moveDownByViewLines(viewModel, cursors, inSelectionMode, value);\n                }\n                else {\n                    // Move down by model lines\n                    return this._moveDownByModelLines(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 4 /* CursorMove.Direction.PrevBlankLine */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)));\n                }\n                else {\n                    return cursors.map(cursor => CursorState.fromModelState(MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)));\n                }\n            }\n            case 5 /* CursorMove.Direction.NextBlankLine */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)));\n                }\n                else {\n                    return cursors.map(cursor => CursorState.fromModelState(MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)));\n                }\n            }\n            case 6 /* CursorMove.Direction.WrappedLineStart */: {\n                // Move to the beginning of the current view line\n                return this._moveToViewMinColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 7 /* CursorMove.Direction.WrappedLineFirstNonWhitespaceCharacter */: {\n                // Move to the first non-whitespace column of the current view line\n                return this._moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 8 /* CursorMove.Direction.WrappedLineColumnCenter */: {\n                // Move to the \"center\" of the current view line\n                return this._moveToViewCenterColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 9 /* CursorMove.Direction.WrappedLineEnd */: {\n                // Move to the end of the current view line\n                return this._moveToViewMaxColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 10 /* CursorMove.Direction.WrappedLineLastNonWhitespaceCharacter */: {\n                // Move to the last non-whitespace column of the current view line\n                return this._moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n            }\n            default:\n                return null;\n        }\n    }\n    static viewportMove(viewModel, cursors, direction, inSelectionMode, value) {\n        const visibleViewRange = viewModel.getCompletelyVisibleViewRange();\n        const visibleModelRange = viewModel.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n        switch (direction) {\n            case 11 /* CursorMove.Direction.ViewPortTop */: {\n                // Move to the nth line start in the viewport (from the top)\n                const modelLineNumber = this._firstLineNumberInRange(viewModel.model, visibleModelRange, value);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 13 /* CursorMove.Direction.ViewPortBottom */: {\n                // Move to the nth line start in the viewport (from the bottom)\n                const modelLineNumber = this._lastLineNumberInRange(viewModel.model, visibleModelRange, value);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 12 /* CursorMove.Direction.ViewPortCenter */: {\n                // Move to the line start in the viewport center\n                const modelLineNumber = Math.round((visibleModelRange.startLineNumber + visibleModelRange.endLineNumber) / 2);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 14 /* CursorMove.Direction.ViewPortIfOutside */: {\n                // Move to a position inside the viewport\n                const result = [];\n                for (let i = 0, len = cursors.length; i < len; i++) {\n                    const cursor = cursors[i];\n                    result[i] = this.findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode);\n                }\n                return result;\n            }\n            default:\n                return null;\n        }\n    }\n    static findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode) {\n        const viewLineNumber = cursor.viewState.position.lineNumber;\n        if (visibleViewRange.startLineNumber <= viewLineNumber && viewLineNumber <= visibleViewRange.endLineNumber - 1) {\n            // Nothing to do, cursor is in viewport\n            return new CursorState(cursor.modelState, cursor.viewState);\n        }\n        else {\n            let newViewLineNumber;\n            if (viewLineNumber > visibleViewRange.endLineNumber - 1) {\n                newViewLineNumber = visibleViewRange.endLineNumber - 1;\n            }\n            else if (viewLineNumber < visibleViewRange.startLineNumber) {\n                newViewLineNumber = visibleViewRange.startLineNumber;\n            }\n            else {\n                newViewLineNumber = viewLineNumber;\n            }\n            const position = MoveOperations.vertical(viewModel.cursorConfig, viewModel, viewLineNumber, cursor.viewState.position.column, cursor.viewState.leftoverVisibleColumns, newViewLineNumber, false);\n            return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, position.lineNumber, position.column, position.leftoverVisibleColumns));\n        }\n    }\n    /**\n     * Find the nth line start included in the range (from the start).\n     */\n    static _firstLineNumberInRange(model, range, count) {\n        let startLineNumber = range.startLineNumber;\n        if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n            // Move on to the second line if the first line start is not included in the range\n            startLineNumber++;\n        }\n        return Math.min(range.endLineNumber, startLineNumber + count - 1);\n    }\n    /**\n     * Find the nth line start included in the range (from the end).\n     */\n    static _lastLineNumberInRange(model, range, count) {\n        let startLineNumber = range.startLineNumber;\n        if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n            // Move on to the second line if the first line start is not included in the range\n            startLineNumber++;\n        }\n        return Math.max(startLineNumber, range.endLineNumber - count + 1);\n    }\n    static _moveLeft(viewModel, cursors, inSelectionMode, noOfColumns) {\n        return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)));\n    }\n    static _moveHalfLineLeft(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const halfLine = Math.round(viewModel.getLineContent(viewLineNumber).length / 2);\n            result[i] = CursorState.fromViewState(MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n        }\n        return result;\n    }\n    static _moveRight(viewModel, cursors, inSelectionMode, noOfColumns) {\n        return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)));\n    }\n    static _moveHalfLineRight(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const halfLine = Math.round(viewModel.getLineContent(viewLineNumber).length / 2);\n            result[i] = CursorState.fromViewState(MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n        }\n        return result;\n    }\n    static _moveDownByViewLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromViewState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveDownByModelLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveUpByViewLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromViewState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveUpByModelLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveToViewPosition(viewModel, cursor, inSelectionMode, toViewLineNumber, toViewColumn) {\n        return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, toViewLineNumber, toViewColumn, 0));\n    }\n    static _moveToModelPosition(viewModel, cursor, inSelectionMode, toModelLineNumber, toModelColumn) {\n        return CursorState.fromModelState(cursor.modelState.move(inSelectionMode, toModelLineNumber, toModelColumn, 0));\n    }\n    static _moveToViewMinColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineMinColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineFirstNonWhitespaceColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewCenterColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = Math.round((viewModel.getLineMaxColumn(viewLineNumber) + viewModel.getLineMinColumn(viewLineNumber)) / 2);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewMaxColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineMaxColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineLastNonWhitespaceColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n}\nexport var CursorMove;\n(function (CursorMove) {\n    const isCursorMoveArgs = function (arg) {\n        if (!types.isObject(arg)) {\n            return false;\n        }\n        const cursorMoveArg = arg;\n        if (!types.isString(cursorMoveArg.to)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.select) && !types.isBoolean(cursorMoveArg.select)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.by) && !types.isString(cursorMoveArg.by)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.value) && !types.isNumber(cursorMoveArg.value)) {\n            return false;\n        }\n        return true;\n    };\n    CursorMove.description = {\n        description: 'Move cursor to a logical position in the view',\n        args: [\n            {\n                name: 'Cursor move argument object',\n                description: `Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'to': A mandatory logical position value providing where to move the cursor.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine',\n\t\t\t\t\t\t'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'\n\t\t\t\t\t\t'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'\n\t\t\t\t\t\t'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'by': Unit to move. Default is computed based on 'to' value.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'line', 'wrappedLine', 'character', 'halfLine'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'value': Number of units to move. Default is '1'.\n\t\t\t\t\t* 'select': If 'true' makes the selection. Default is 'false'.\n\t\t\t\t`,\n                constraint: isCursorMoveArgs,\n                schema: {\n                    'type': 'object',\n                    'required': ['to'],\n                    'properties': {\n                        'to': {\n                            'type': 'string',\n                            'enum': ['left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine', 'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter', 'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter', 'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside']\n                        },\n                        'by': {\n                            'type': 'string',\n                            'enum': ['line', 'wrappedLine', 'character', 'halfLine']\n                        },\n                        'value': {\n                            'type': 'number',\n                            'default': 1\n                        },\n                        'select': {\n                            'type': 'boolean',\n                            'default': false\n                        }\n                    }\n                }\n            }\n        ]\n    };\n    /**\n     * Positions in the view for cursor move command.\n     */\n    CursorMove.RawDirection = {\n        Left: 'left',\n        Right: 'right',\n        Up: 'up',\n        Down: 'down',\n        PrevBlankLine: 'prevBlankLine',\n        NextBlankLine: 'nextBlankLine',\n        WrappedLineStart: 'wrappedLineStart',\n        WrappedLineFirstNonWhitespaceCharacter: 'wrappedLineFirstNonWhitespaceCharacter',\n        WrappedLineColumnCenter: 'wrappedLineColumnCenter',\n        WrappedLineEnd: 'wrappedLineEnd',\n        WrappedLineLastNonWhitespaceCharacter: 'wrappedLineLastNonWhitespaceCharacter',\n        ViewPortTop: 'viewPortTop',\n        ViewPortCenter: 'viewPortCenter',\n        ViewPortBottom: 'viewPortBottom',\n        ViewPortIfOutside: 'viewPortIfOutside'\n    };\n    /**\n     * Units for Cursor move 'by' argument\n     */\n    CursorMove.RawUnit = {\n        Line: 'line',\n        WrappedLine: 'wrappedLine',\n        Character: 'character',\n        HalfLine: 'halfLine'\n    };\n    function parse(args) {\n        if (!args.to) {\n            // illegal arguments\n            return null;\n        }\n        let direction;\n        switch (args.to) {\n            case CursorMove.RawDirection.Left:\n                direction = 0 /* Direction.Left */;\n                break;\n            case CursorMove.RawDirection.Right:\n                direction = 1 /* Direction.Right */;\n                break;\n            case CursorMove.RawDirection.Up:\n                direction = 2 /* Direction.Up */;\n                break;\n            case CursorMove.RawDirection.Down:\n                direction = 3 /* Direction.Down */;\n                break;\n            case CursorMove.RawDirection.PrevBlankLine:\n                direction = 4 /* Direction.PrevBlankLine */;\n                break;\n            case CursorMove.RawDirection.NextBlankLine:\n                direction = 5 /* Direction.NextBlankLine */;\n                break;\n            case CursorMove.RawDirection.WrappedLineStart:\n                direction = 6 /* Direction.WrappedLineStart */;\n                break;\n            case CursorMove.RawDirection.WrappedLineFirstNonWhitespaceCharacter:\n                direction = 7 /* Direction.WrappedLineFirstNonWhitespaceCharacter */;\n                break;\n            case CursorMove.RawDirection.WrappedLineColumnCenter:\n                direction = 8 /* Direction.WrappedLineColumnCenter */;\n                break;\n            case CursorMove.RawDirection.WrappedLineEnd:\n                direction = 9 /* Direction.WrappedLineEnd */;\n                break;\n            case CursorMove.RawDirection.WrappedLineLastNonWhitespaceCharacter:\n                direction = 10 /* Direction.WrappedLineLastNonWhitespaceCharacter */;\n                break;\n            case CursorMove.RawDirection.ViewPortTop:\n                direction = 11 /* Direction.ViewPortTop */;\n                break;\n            case CursorMove.RawDirection.ViewPortBottom:\n                direction = 13 /* Direction.ViewPortBottom */;\n                break;\n            case CursorMove.RawDirection.ViewPortCenter:\n                direction = 12 /* Direction.ViewPortCenter */;\n                break;\n            case CursorMove.RawDirection.ViewPortIfOutside:\n                direction = 14 /* Direction.ViewPortIfOutside */;\n                break;\n            default:\n                // illegal arguments\n                return null;\n        }\n        let unit = 0 /* Unit.None */;\n        switch (args.by) {\n            case CursorMove.RawUnit.Line:\n                unit = 1 /* Unit.Line */;\n                break;\n            case CursorMove.RawUnit.WrappedLine:\n                unit = 2 /* Unit.WrappedLine */;\n                break;\n            case CursorMove.RawUnit.Character:\n                unit = 3 /* Unit.Character */;\n                break;\n            case CursorMove.RawUnit.HalfLine:\n                unit = 4 /* Unit.HalfLine */;\n                break;\n        }\n        return {\n            direction: direction,\n            unit: unit,\n            select: (!!args.select),\n            value: (args.value || 1)\n        };\n    }\n    CursorMove.parse = parse;\n})(CursorMove || (CursorMove = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { AtomicTabMoveOperations } from './cursorAtomicMoveOperations.js';\nexport class CursorPosition {\n    constructor(lineNumber, column, leftoverVisibleColumns) {\n        this._cursorPositionBrand = undefined;\n        this.lineNumber = lineNumber;\n        this.column = column;\n        this.leftoverVisibleColumns = leftoverVisibleColumns;\n    }\n}\nexport class MoveOperations {\n    static leftPosition(model, position) {\n        if (position.column > model.getLineMinColumn(position.lineNumber)) {\n            return position.delta(undefined, -strings.prevCharLength(model.getLineContent(position.lineNumber), position.column - 1));\n        }\n        else if (position.lineNumber > 1) {\n            const newLineNumber = position.lineNumber - 1;\n            return new Position(newLineNumber, model.getLineMaxColumn(newLineNumber));\n        }\n        else {\n            return position;\n        }\n    }\n    static leftPositionAtomicSoftTabs(model, position, tabSize) {\n        if (position.column <= model.getLineIndentColumn(position.lineNumber)) {\n            const minColumn = model.getLineMinColumn(position.lineNumber);\n            const lineContent = model.getLineContent(position.lineNumber);\n            const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, 0 /* Direction.Left */);\n            if (newPosition !== -1 && newPosition + 1 >= minColumn) {\n                return new Position(position.lineNumber, newPosition + 1);\n            }\n        }\n        return this.leftPosition(model, position);\n    }\n    static left(config, model, position) {\n        const pos = config.stickyTabStops\n            ? MoveOperations.leftPositionAtomicSoftTabs(model, position, config.tabSize)\n            : MoveOperations.leftPosition(model, position);\n        return new CursorPosition(pos.lineNumber, pos.column, 0);\n    }\n    /**\n     * @param noOfColumns Must be either `1`\n     * or `Math.round(viewModel.getLineContent(viewLineNumber).length / 2)` (for half lines).\n    */\n    static moveLeft(config, model, cursor, inSelectionMode, noOfColumns) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If the user has a selection and does not want to extend it,\n            // put the cursor at the beginning of the selection.\n            lineNumber = cursor.selection.startLineNumber;\n            column = cursor.selection.startColumn;\n        }\n        else {\n            // This has no effect if noOfColumns === 1.\n            // It is ok to do so in the half-line scenario.\n            const pos = cursor.position.delta(undefined, -(noOfColumns - 1));\n            // We clip the position before normalization, as normalization is not defined\n            // for possibly negative columns.\n            const normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 0 /* PositionAffinity.Left */);\n            const p = MoveOperations.left(config, model, normalizedPos);\n            lineNumber = p.lineNumber;\n            column = p.column;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    /**\n     * Adjusts the column so that it is within min/max of the line.\n    */\n    static clipPositionColumn(position, model) {\n        return new Position(position.lineNumber, MoveOperations.clipRange(position.column, model.getLineMinColumn(position.lineNumber), model.getLineMaxColumn(position.lineNumber)));\n    }\n    static clipRange(value, min, max) {\n        if (value < min) {\n            return min;\n        }\n        if (value > max) {\n            return max;\n        }\n        return value;\n    }\n    static rightPosition(model, lineNumber, column) {\n        if (column < model.getLineMaxColumn(lineNumber)) {\n            column = column + strings.nextCharLength(model.getLineContent(lineNumber), column - 1);\n        }\n        else if (lineNumber < model.getLineCount()) {\n            lineNumber = lineNumber + 1;\n            column = model.getLineMinColumn(lineNumber);\n        }\n        return new Position(lineNumber, column);\n    }\n    static rightPositionAtomicSoftTabs(model, lineNumber, column, tabSize, indentSize) {\n        if (column < model.getLineIndentColumn(lineNumber)) {\n            const lineContent = model.getLineContent(lineNumber);\n            const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, column - 1, tabSize, 1 /* Direction.Right */);\n            if (newPosition !== -1) {\n                return new Position(lineNumber, newPosition + 1);\n            }\n        }\n        return this.rightPosition(model, lineNumber, column);\n    }\n    static right(config, model, position) {\n        const pos = config.stickyTabStops\n            ? MoveOperations.rightPositionAtomicSoftTabs(model, position.lineNumber, position.column, config.tabSize, config.indentSize)\n            : MoveOperations.rightPosition(model, position.lineNumber, position.column);\n        return new CursorPosition(pos.lineNumber, pos.column, 0);\n    }\n    static moveRight(config, model, cursor, inSelectionMode, noOfColumns) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move right without selection cancels selection and puts cursor at the end of the selection\n            lineNumber = cursor.selection.endLineNumber;\n            column = cursor.selection.endColumn;\n        }\n        else {\n            const pos = cursor.position.delta(undefined, noOfColumns - 1);\n            const normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 1 /* PositionAffinity.Right */);\n            const r = MoveOperations.right(config, model, normalizedPos);\n            lineNumber = r.lineNumber;\n            column = r.column;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    static vertical(config, model, lineNumber, column, leftoverVisibleColumns, newLineNumber, allowMoveOnEdgeLine, normalizationAffinity) {\n        const currentVisibleColumn = CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize) + leftoverVisibleColumns;\n        const lineCount = model.getLineCount();\n        const wasOnFirstPosition = (lineNumber === 1 && column === 1);\n        const wasOnLastPosition = (lineNumber === lineCount && column === model.getLineMaxColumn(lineNumber));\n        const wasAtEdgePosition = (newLineNumber < lineNumber ? wasOnFirstPosition : wasOnLastPosition);\n        lineNumber = newLineNumber;\n        if (lineNumber < 1) {\n            lineNumber = 1;\n            if (allowMoveOnEdgeLine) {\n                column = model.getLineMinColumn(lineNumber);\n            }\n            else {\n                column = Math.min(model.getLineMaxColumn(lineNumber), column);\n            }\n        }\n        else if (lineNumber > lineCount) {\n            lineNumber = lineCount;\n            if (allowMoveOnEdgeLine) {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n            else {\n                column = Math.min(model.getLineMaxColumn(lineNumber), column);\n            }\n        }\n        else {\n            column = config.columnFromVisibleColumn(model, lineNumber, currentVisibleColumn);\n        }\n        if (wasAtEdgePosition) {\n            leftoverVisibleColumns = 0;\n        }\n        else {\n            leftoverVisibleColumns = currentVisibleColumn - CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize);\n        }\n        if (normalizationAffinity !== undefined) {\n            const position = new Position(lineNumber, column);\n            const newPosition = model.normalizePosition(position, normalizationAffinity);\n            leftoverVisibleColumns = leftoverVisibleColumns + (column - newPosition.column);\n            lineNumber = newPosition.lineNumber;\n            column = newPosition.column;\n        }\n        return new CursorPosition(lineNumber, column, leftoverVisibleColumns);\n    }\n    static down(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnLastLine) {\n        return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber + count, allowMoveOnLastLine, 4 /* PositionAffinity.RightOfInjectedText */);\n    }\n    static moveDown(config, model, cursor, inSelectionMode, linesCount) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move down acts relative to the end of selection\n            lineNumber = cursor.selection.endLineNumber;\n            column = cursor.selection.endColumn;\n        }\n        else {\n            lineNumber = cursor.position.lineNumber;\n            column = cursor.position.column;\n        }\n        const r = MoveOperations.down(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);\n        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n    }\n    static translateDown(config, model, cursor) {\n        const selection = cursor.selection;\n        const selectionStart = MoveOperations.down(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n        const position = MoveOperations.down(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n    }\n    static up(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnFirstLine) {\n        return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber - count, allowMoveOnFirstLine, 3 /* PositionAffinity.LeftOfInjectedText */);\n    }\n    static moveUp(config, model, cursor, inSelectionMode, linesCount) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move up acts relative to the beginning of selection\n            lineNumber = cursor.selection.startLineNumber;\n            column = cursor.selection.startColumn;\n        }\n        else {\n            lineNumber = cursor.position.lineNumber;\n            column = cursor.position.column;\n        }\n        const r = MoveOperations.up(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);\n        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n    }\n    static translateUp(config, model, cursor) {\n        const selection = cursor.selection;\n        const selectionStart = MoveOperations.up(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n        const position = MoveOperations.up(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n    }\n    static _isBlankLine(model, lineNumber) {\n        if (model.getLineFirstNonWhitespaceColumn(lineNumber) === 0) {\n            // empty or contains only whitespace\n            return true;\n        }\n        return false;\n    }\n    static moveToPrevBlankLine(config, model, cursor, inSelectionMode) {\n        let lineNumber = cursor.position.lineNumber;\n        // If our current line is blank, move to the previous non-blank line\n        while (lineNumber > 1 && this._isBlankLine(model, lineNumber)) {\n            lineNumber--;\n        }\n        // Find the previous blank line\n        while (lineNumber > 1 && !this._isBlankLine(model, lineNumber)) {\n            lineNumber--;\n        }\n        return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n    }\n    static moveToNextBlankLine(config, model, cursor, inSelectionMode) {\n        const lineCount = model.getLineCount();\n        let lineNumber = cursor.position.lineNumber;\n        // If our current line is blank, move to the next non-blank line\n        while (lineNumber < lineCount && this._isBlankLine(model, lineNumber)) {\n            lineNumber++;\n        }\n        // Find the next blank line\n        while (lineNumber < lineCount && !this._isBlankLine(model, lineNumber)) {\n            lineNumber++;\n        }\n        return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n    }\n    static moveToBeginningOfLine(config, model, cursor, inSelectionMode) {\n        const lineNumber = cursor.position.lineNumber;\n        const minColumn = model.getLineMinColumn(lineNumber);\n        const firstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(lineNumber) || minColumn;\n        let column;\n        const relevantColumnNumber = cursor.position.column;\n        if (relevantColumnNumber === firstNonBlankColumn) {\n            column = minColumn;\n        }\n        else {\n            column = firstNonBlankColumn;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    static moveToEndOfLine(config, model, cursor, inSelectionMode, sticky) {\n        const lineNumber = cursor.position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        return cursor.move(inSelectionMode, lineNumber, maxColumn, sticky ? 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */ - maxColumn : 0);\n    }\n    static moveToBeginningOfBuffer(config, model, cursor, inSelectionMode) {\n        return cursor.move(inSelectionMode, 1, 1, 0);\n    }\n    static moveToEndOfBuffer(config, model, cursor, inSelectionMode) {\n        const lastLineNumber = model.getLineCount();\n        const lastColumn = model.getLineMaxColumn(lastLineNumber);\n        return cursor.move(inSelectionMode, lastLineNumber, lastColumn, 0);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition, ReplaceCommandThatPreservesSelection } from '../commands/replaceCommand.js';\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { CompositionSurroundSelectionCommand, SurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nimport { IndentAction } from '../languages/languageConfiguration.js';\nimport { getIndentationAtPosition } from '../languages/languageConfigurationRegistry.js';\nimport { createScopedLineTokens } from '../languages/supports.js';\nimport { getIndentActionForType, getIndentForEnter, getInheritIndentForLine } from '../languages/autoIndent.js';\nimport { getEnterAction } from '../languages/enterAction.js';\nexport class TypeOperations {\n    static indent(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: false,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            }, config.languageConfigurationService);\n        }\n        return commands;\n    }\n    static outdent(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: true,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            }, config.languageConfigurationService);\n        }\n        return commands;\n    }\n    static shiftIndent(config, indentation, count) {\n        count = count || 1;\n        return ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n    static unshiftIndent(config, indentation, count) {\n        count = count || 1;\n        return ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n    static _distributedPaste(config, model, selections, text) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], text[i]);\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _simplePaste(config, model, selections, text, pasteOnNewLine) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            if (pasteOnNewLine && !selection.isEmpty()) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine) {\n                // Paste entire line at the beginning of line\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\n                commands[i] = new ReplaceCommandThatPreservesSelection(typeSelection, text, selection, true);\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, text);\n            }\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText) {\n        if (pasteOnNewLine) {\n            return null;\n        }\n        if (selections.length === 1) {\n            return null;\n        }\n        if (multicursorText && multicursorText.length === selections.length) {\n            return multicursorText;\n        }\n        if (config.multiCursorPaste === 'spread') {\n            // Try to spread the pasted text in case the line count matches the cursor count\n            // Remove trailing \\n if present\n            if (text.charCodeAt(text.length - 1) === 10 /* CharCode.LineFeed */) {\n                text = text.substr(0, text.length - 1);\n            }\n            // Remove trailing \\r if present\n            if (text.charCodeAt(text.length - 1) === 13 /* CharCode.CarriageReturn */) {\n                text = text.substr(0, text.length - 1);\n            }\n            const lines = strings.splitLines(text);\n            if (lines.length === selections.length) {\n                return lines;\n            }\n        }\n        return null;\n    }\n    static paste(config, model, selections, text, pasteOnNewLine, multicursorText) {\n        const distributedPaste = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText);\n        if (distributedPaste) {\n            selections = selections.sort(Range.compareRangesUsingStarts);\n            return this._distributedPaste(config, model, selections, distributedPaste);\n        }\n        else {\n            return this._simplePaste(config, model, selections, text, pasteOnNewLine);\n        }\n    }\n    static _goodIndentForLine(config, model, lineNumber) {\n        let action = null;\n        let indentation = '';\n        const expectedIndentAction = getInheritIndentForLine(config.autoIndent, model, lineNumber, false, config.languageConfigurationService);\n        if (expectedIndentAction) {\n            action = expectedIndentAction.action;\n            indentation = expectedIndentAction.indentation;\n        }\n        else if (lineNumber > 1) {\n            let lastLineNumber;\n            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n                const lineText = model.getLineContent(lastLineNumber);\n                const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n                if (nonWhitespaceIdx >= 0) {\n                    break;\n                }\n            }\n            if (lastLineNumber < 1) {\n                // No previous line with content found\n                return null;\n            }\n            const maxColumn = model.getLineMaxColumn(lastLineNumber);\n            const expectedEnterAction = getEnterAction(config.autoIndent, model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn), config.languageConfigurationService);\n            if (expectedEnterAction) {\n                indentation = expectedEnterAction.indentation + expectedEnterAction.appendText;\n            }\n        }\n        if (action) {\n            if (action === IndentAction.Indent) {\n                indentation = TypeOperations.shiftIndent(config, indentation);\n            }\n            if (action === IndentAction.Outdent) {\n                indentation = TypeOperations.unshiftIndent(config, indentation);\n            }\n            indentation = config.normalizeIndentation(indentation);\n        }\n        if (!indentation) {\n            return null;\n        }\n        return indentation;\n    }\n    static _replaceJumpToNextIndent(config, model, selection, insertsAutoWhitespace) {\n        let typeText = '';\n        const position = selection.getStartPosition();\n        if (config.insertSpaces) {\n            const visibleColumnFromColumn = config.visibleColumnFromColumn(model, position);\n            const indentSize = config.indentSize;\n            const spacesCnt = indentSize - (visibleColumnFromColumn % indentSize);\n            for (let i = 0; i < spacesCnt; i++) {\n                typeText += ' ';\n            }\n        }\n        else {\n            typeText = '\\t';\n        }\n        return new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n    }\n    static tab(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                const lineText = model.getLineContent(selection.startLineNumber);\n                if (/^\\s*$/.test(lineText) && model.tokenization.isCheapToTokenize(selection.startLineNumber)) {\n                    let goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n                    goodIndent = goodIndent || '\\t';\n                    const possibleTypeText = config.normalizeIndentation(goodIndent);\n                    if (!lineText.startsWith(possibleTypeText)) {\n                        commands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n                        continue;\n                    }\n                }\n                commands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n            }\n            else {\n                if (selection.startLineNumber === selection.endLineNumber) {\n                    const lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n                        // This is a single line selection that is not the entire line\n                        commands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n                        continue;\n                    }\n                }\n                commands[i] = new ShiftCommand(selection, {\n                    isUnshift: false,\n                    tabSize: config.tabSize,\n                    indentSize: config.indentSize,\n                    insertSpaces: config.insertSpaces,\n                    useTabStops: config.useTabStops,\n                    autoIndent: config.autoIndent\n                }, config.languageConfigurationService);\n            }\n        }\n        return commands;\n    }\n    static compositionType(prevEditOperationType, config, model, selections, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        const commands = selections.map(selection => this._compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        if (!selection.isEmpty()) {\n            // looks like https://github.com/microsoft/vscode/issues/2773\n            // where a cursor operation occurred before a canceled composition\n            // => ignore composition\n            return null;\n        }\n        const pos = selection.getPosition();\n        const startColumn = Math.max(1, pos.column - replacePrevCharCnt);\n        const endColumn = Math.min(model.getLineMaxColumn(pos.lineNumber), pos.column + replaceNextCharCnt);\n        const range = new Range(pos.lineNumber, startColumn, pos.lineNumber, endColumn);\n        const oldText = model.getValueInRange(range);\n        if (oldText === text && positionDelta === 0) {\n            // => ignore composition that doesn't do anything\n            return null;\n        }\n        return new ReplaceCommandWithOffsetCursorState(range, text, 0, positionDelta);\n    }\n    static _typeCommand(range, text, keepPosition) {\n        if (keepPosition) {\n            return new ReplaceCommandWithoutChangingPosition(range, text, true);\n        }\n        else {\n            return new ReplaceCommand(range, text, true);\n        }\n    }\n    static _enter(config, model, keepPosition, range) {\n        if (config.autoIndent === 0 /* EditorAutoIndentStrategy.None */) {\n            return TypeOperations._typeCommand(range, '\\n', keepPosition);\n        }\n        if (!model.tokenization.isCheapToTokenize(range.getStartPosition().lineNumber) || config.autoIndent === 1 /* EditorAutoIndentStrategy.Keep */) {\n            const lineText = model.getLineContent(range.startLineNumber);\n            const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n            return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n        }\n        const r = getEnterAction(config.autoIndent, model, range, config.languageConfigurationService);\n        if (r) {\n            if (r.indentAction === IndentAction.None) {\n                // Nothing special\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.Indent) {\n                // Indent once\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.IndentOutdent) {\n                // Ultra special\n                const normalIndent = config.normalizeIndentation(r.indentation);\n                const increasedIndent = config.normalizeIndentation(r.indentation + r.appendText);\n                const typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, typeText, true);\n                }\n                else {\n                    return new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n                }\n            }\n            else if (r.indentAction === IndentAction.Outdent) {\n                const actualIndentation = TypeOperations.unshiftIndent(config, r.indentation);\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + r.appendText), keepPosition);\n            }\n        }\n        const lineText = model.getLineContent(range.startLineNumber);\n        const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n        if (config.autoIndent >= 4 /* EditorAutoIndentStrategy.Full */) {\n            const ir = getIndentForEnter(config.autoIndent, model, range, {\n                unshiftIndent: (indent) => {\n                    return TypeOperations.unshiftIndent(config, indent);\n                },\n                shiftIndent: (indent) => {\n                    return TypeOperations.shiftIndent(config, indent);\n                },\n                normalizeIndentation: (indent) => {\n                    return config.normalizeIndentation(indent);\n                }\n            }, config.languageConfigurationService);\n            if (ir) {\n                let oldEndViewColumn = config.visibleColumnFromColumn(model, range.getEndPosition());\n                const oldEndColumn = range.endColumn;\n                const newLineContent = model.getLineContent(range.endLineNumber);\n                const firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n                if (firstNonWhitespace >= 0) {\n                    range = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n                }\n                else {\n                    range = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n                }\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, '\\n' + config.normalizeIndentation(ir.afterEnter), true);\n                }\n                else {\n                    let offset = 0;\n                    if (oldEndColumn <= firstNonWhitespace + 1) {\n                        if (!config.insertSpaces) {\n                            oldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n                        }\n                        offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n                    }\n                    return new ReplaceCommandWithOffsetCursorState(range, '\\n' + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n                }\n            }\n        }\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n    }\n    static _isAutoIndentType(config, model, selections) {\n        if (config.autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            if (!model.tokenization.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _runAutoIndentType(config, model, range, ch) {\n        const currentIndentation = getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n        const actualIndentation = getIndentActionForType(config.autoIndent, model, range, ch, {\n            shiftIndent: (indentation) => {\n                return TypeOperations.shiftIndent(config, indentation);\n            },\n            unshiftIndent: (indentation) => {\n                return TypeOperations.unshiftIndent(config, indentation);\n            },\n        }, config.languageConfigurationService);\n        if (actualIndentation === null) {\n            return null;\n        }\n        if (actualIndentation !== config.normalizeIndentation(currentIndentation)) {\n            const firstNonWhitespace = model.getLineFirstNonWhitespaceColumn(range.startLineNumber);\n            if (firstNonWhitespace === 0) {\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + ch, false);\n            }\n            else {\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) +\n                    model.getLineContent(range.startLineNumber).substring(firstNonWhitespace - 1, range.startColumn - 1) + ch, false);\n            }\n        }\n        return null;\n    }\n    static _isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch) {\n        if (config.autoClosingOvertype === 'never') {\n            return false;\n        }\n        if (!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (!selection.isEmpty()) {\n                return false;\n            }\n            const position = selection.getPosition();\n            const lineText = model.getLineContent(position.lineNumber);\n            const afterCharacter = lineText.charAt(position.column - 1);\n            if (afterCharacter !== ch) {\n                return false;\n            }\n            // Do not over-type quotes after a backslash\n            const chIsQuote = isQuote(ch);\n            const beforeCharacter = position.column > 2 ? lineText.charCodeAt(position.column - 2) : 0 /* CharCode.Null */;\n            if (beforeCharacter === 92 /* CharCode.Backslash */ && chIsQuote) {\n                return false;\n            }\n            // Must over-type a closing character typed by the editor\n            if (config.autoClosingOvertype === 'auto') {\n                let found = false;\n                for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                    const autoClosedCharacter = autoClosedCharacters[j];\n                    if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            const typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(typeSelection, ch);\n        }\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _isBeforeClosingBrace(config, lineAfter) {\n        // If the start of lineAfter can be interpretted as both a starting or ending brace, default to returning false\n        const nextChar = lineAfter.charAt(0);\n        const potentialStartingBraces = config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) || [];\n        const potentialClosingBraces = config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar) || [];\n        const isBeforeStartingBrace = potentialStartingBraces.some(x => lineAfter.startsWith(x.open));\n        const isBeforeClosingBrace = potentialClosingBraces.some(x => lineAfter.startsWith(x.close));\n        return !isBeforeStartingBrace && isBeforeClosingBrace;\n    }\n    /**\n     * Determine if typing `ch` at all `positions` in the `model` results in an\n     * auto closing open sequence being typed.\n     *\n     * Auto closing open sequences can consist of multiple characters, which\n     * can lead to ambiguities. In such a case, the longest auto-closing open\n     * sequence is returned.\n     */\n    static _findAutoClosingPairOpen(config, model, positions, ch) {\n        const candidates = config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n        if (!candidates) {\n            return null;\n        }\n        // Determine which auto-closing pair it is\n        let result = null;\n        for (const candidate of candidates) {\n            if (result === null || candidate.open.length > result.open.length) {\n                let candidateIsMatch = true;\n                for (const position of positions) {\n                    const relevantText = model.getValueInRange(new Range(position.lineNumber, position.column - candidate.open.length + 1, position.lineNumber, position.column));\n                    if (relevantText + ch !== candidate.open) {\n                        candidateIsMatch = false;\n                        break;\n                    }\n                }\n                if (candidateIsMatch) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Find another auto-closing pair that is contained by the one passed in.\n     *\n     * e.g. when having [(,)] and [(*,*)] as auto-closing pairs\n     * this method will find [(,)] as a containment pair for [(*,*)]\n     */\n    static _findContainedAutoClosingPair(config, pair) {\n        if (pair.open.length <= 1) {\n            return null;\n        }\n        const lastChar = pair.close.charAt(pair.close.length - 1);\n        // get candidates with the same last character as close\n        const candidates = config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) || [];\n        let result = null;\n        for (const candidate of candidates) {\n            if (candidate.open !== pair.open && pair.open.includes(candidate.open) && pair.close.endsWith(candidate.close)) {\n                if (!result || candidate.open.length > result.open.length) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    static _getAutoClosingPairClose(config, model, selections, ch, chIsAlreadyTyped) {\n        const chIsQuote = isQuote(ch);\n        const autoCloseConfig = (chIsQuote ? config.autoClosingQuotes : config.autoClosingBrackets);\n        const shouldAutoCloseBefore = (chIsQuote ? config.shouldAutoCloseBefore.quote : config.shouldAutoCloseBefore.bracket);\n        if (autoCloseConfig === 'never') {\n            return null;\n        }\n        for (const selection of selections) {\n            if (!selection.isEmpty()) {\n                return null;\n            }\n        }\n        // This method is called both when typing (regularly) and when composition ends\n        // This means that we need to work with a text buffer where sometimes `ch` is not\n        // there (it is being typed right now) or with a text buffer where `ch` has already been typed\n        //\n        // In order to avoid adding checks for `chIsAlreadyTyped` in all places, we will work\n        // with two conceptual positions, the position before `ch` and the position after `ch`\n        //\n        const positions = selections.map((s) => {\n            const position = s.getPosition();\n            if (chIsAlreadyTyped) {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column - ch.length, afterColumn: position.column };\n            }\n            else {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column, afterColumn: position.column };\n            }\n        });\n        // Find the longest auto-closing open pair in case of multiple ending in `ch`\n        // e.g. when having [f\",\"] and [\",\"], it picks [f\",\"] if the character before is f\n        const pair = this._findAutoClosingPairOpen(config, model, positions.map(p => new Position(p.lineNumber, p.beforeColumn)), ch);\n        if (!pair) {\n            return null;\n        }\n        // Sometimes, it is possible to have two auto-closing pairs that have a containment relationship\n        // e.g. when having [(,)] and [(*,*)]\n        // - when typing (, the resulting state is (|)\n        // - when typing *, the desired resulting state is (*|*), not (*|*))\n        const containedPair = this._findContainedAutoClosingPair(config, pair);\n        const containedPairClose = containedPair ? containedPair.close : '';\n        let isContainedPairPresent = true;\n        for (const position of positions) {\n            const { lineNumber, beforeColumn, afterColumn } = position;\n            const lineText = model.getLineContent(lineNumber);\n            const lineBefore = lineText.substring(0, beforeColumn - 1);\n            const lineAfter = lineText.substring(afterColumn - 1);\n            if (!lineAfter.startsWith(containedPairClose)) {\n                isContainedPairPresent = false;\n            }\n            // Only consider auto closing the pair if an allowed character follows or if another autoclosed pair closing brace follows\n            if (lineAfter.length > 0) {\n                const characterAfter = lineAfter.charAt(0);\n                const isBeforeCloseBrace = TypeOperations._isBeforeClosingBrace(config, lineAfter);\n                if (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n                    return null;\n                }\n            }\n            // Do not auto-close ' or \" after a word character\n            if (pair.open.length === 1 && (ch === '\\'' || ch === '\"') && autoCloseConfig !== 'always') {\n                const wordSeparators = getMapForWordSeparators(config.wordSeparators);\n                if (lineBefore.length > 0) {\n                    const characterBefore = lineBefore.charCodeAt(lineBefore.length - 1);\n                    if (wordSeparators.get(characterBefore) === 0 /* WordCharacterClass.Regular */) {\n                        return null;\n                    }\n                }\n            }\n            if (!model.tokenization.isCheapToTokenize(lineNumber)) {\n                // Do not force tokenization\n                return null;\n            }\n            model.tokenization.forceTokenization(lineNumber);\n            const lineTokens = model.tokenization.getLineTokens(lineNumber);\n            const scopedLineTokens = createScopedLineTokens(lineTokens, beforeColumn - 1);\n            if (!pair.shouldAutoClose(scopedLineTokens, beforeColumn - scopedLineTokens.firstCharOffset)) {\n                return null;\n            }\n            // Typing for example a quote could either start a new string, in which case auto-closing is desirable\n            // or it could end a previously started string, in which case auto-closing is not desirable\n            //\n            // In certain cases, it is really not possible to look at the previous token to determine\n            // what would happen. That's why we do something really unusual, we pretend to type a different\n            // character and ask the tokenizer what the outcome of doing that is: after typing a neutral\n            // character, are we in a string (i.e. the quote would most likely end a string) or not?\n            //\n            const neutralCharacter = pair.findNeutralCharacter();\n            if (neutralCharacter) {\n                const tokenType = model.tokenization.getTokenTypeIfInsertingCharacter(lineNumber, beforeColumn, neutralCharacter);\n                if (!pair.isOK(tokenType)) {\n                    return null;\n                }\n            }\n        }\n        if (isContainedPairPresent) {\n            return pair.close.substring(0, pair.close.length - containedPairClose.length);\n        }\n        else {\n            return pair.close;\n        }\n    }\n    static _runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, chIsAlreadyTyped, autoClosingPairClose) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            commands[i] = new TypeWithAutoClosingCommand(selection, ch, !chIsAlreadyTyped, autoClosingPairClose);\n        }\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _shouldSurroundChar(config, ch) {\n        if (isQuote(ch)) {\n            return (config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined');\n        }\n        else {\n            // Character is a bracket\n            return (config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined');\n        }\n    }\n    static _isSurroundSelectionType(config, model, selections, ch) {\n        if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n            return false;\n        }\n        const isTypingAQuoteCharacter = isQuote(ch);\n        for (const selection of selections) {\n            if (selection.isEmpty()) {\n                return false;\n            }\n            let selectionContainsOnlyWhitespace = true;\n            for (let lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n                const lineText = model.getLineContent(lineNumber);\n                const startIndex = (lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0);\n                const endIndex = (lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length);\n                const selectedText = lineText.substring(startIndex, endIndex);\n                if (/[^ \\t]/.test(selectedText)) {\n                    // this selected text contains something other than whitespace\n                    selectionContainsOnlyWhitespace = false;\n                    break;\n                }\n            }\n            if (selectionContainsOnlyWhitespace) {\n                return false;\n            }\n            if (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n                const selectionText = model.getValueInRange(selection);\n                if (isQuote(selectionText)) {\n                    // Typing a quote character on top of another quote character\n                    // => disable surround selection type\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runSurroundSelectionType(prevEditOperationType, config, model, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const closeCharacter = config.surroundingPairs[ch];\n            commands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _isTypeInterceptorElectricChar(config, model, selections) {\n        if (selections.length === 1 && model.tokenization.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n            return true;\n        }\n        return false;\n    }\n    static _typeInterceptorElectricChar(prevEditOperationType, config, model, selection, ch) {\n        if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n            return null;\n        }\n        const position = selection.getPosition();\n        model.tokenization.forceTokenization(position.lineNumber);\n        const lineTokens = model.tokenization.getLineTokens(position.lineNumber);\n        let electricAction;\n        try {\n            electricAction = config.onElectricCharacter(ch, lineTokens, position.column);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n        if (!electricAction) {\n            return null;\n        }\n        if (electricAction.matchOpenBracket) {\n            const endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n            const match = model.bracketPairs.findMatchingBracketUp(electricAction.matchOpenBracket, {\n                lineNumber: position.lineNumber,\n                column: endColumn\n            }, 500 /* give at most 500ms to compute */);\n            if (match) {\n                if (match.startLineNumber === position.lineNumber) {\n                    // matched something on the same line => no change in indentation\n                    return null;\n                }\n                const matchLine = model.getLineContent(match.startLineNumber);\n                const matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n                const newIndentation = config.normalizeIndentation(matchLineIndentation);\n                const lineText = model.getLineContent(position.lineNumber);\n                const lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n                const prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n                const typeText = newIndentation + prefix + ch;\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\n                const command = new ReplaceCommand(typeSelection, typeText);\n                return new EditOperationResult(getTypingOperation(typeText, prevEditOperationType), [command], {\n                    shouldPushStackElementBefore: false,\n                    shouldPushStackElementAfter: true\n                });\n            }\n        }\n        return null;\n    }\n    /**\n     * This is very similar with typing, but the character is already in the text buffer!\n     */\n    static compositionEndWithInterceptors(prevEditOperationType, config, model, compositions, selections, autoClosedCharacters) {\n        if (!compositions) {\n            // could not deduce what the composition did\n            return null;\n        }\n        let insertedText = null;\n        for (const composition of compositions) {\n            if (insertedText === null) {\n                insertedText = composition.insertedText;\n            }\n            else if (insertedText !== composition.insertedText) {\n                // not all selections agree on what was typed\n                return null;\n            }\n        }\n        if (!insertedText || insertedText.length !== 1) {\n            // we're only interested in the case where a single character was inserted\n            return null;\n        }\n        const ch = insertedText;\n        let hasDeletion = false;\n        for (const composition of compositions) {\n            if (composition.deletedText.length !== 0) {\n                hasDeletion = true;\n                break;\n            }\n        }\n        if (hasDeletion) {\n            // Check if this could have been a surround selection\n            if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n                return null;\n            }\n            const isTypingAQuoteCharacter = isQuote(ch);\n            for (const composition of compositions) {\n                if (composition.deletedSelectionStart !== 0 || composition.deletedSelectionEnd !== composition.deletedText.length) {\n                    // more text was deleted than was selected, so this could not have been a surround selection\n                    return null;\n                }\n                if (/^[ \\t]+$/.test(composition.deletedText)) {\n                    // deleted text was only whitespace\n                    return null;\n                }\n                if (isTypingAQuoteCharacter && isQuote(composition.deletedText)) {\n                    // deleted text was a quote\n                    return null;\n                }\n            }\n            const positions = [];\n            for (const selection of selections) {\n                if (!selection.isEmpty()) {\n                    return null;\n                }\n                positions.push(selection.getPosition());\n            }\n            if (positions.length !== compositions.length) {\n                return null;\n            }\n            const commands = [];\n            for (let i = 0, len = positions.length; i < len; i++) {\n                commands.push(new CompositionSurroundSelectionCommand(positions[i], compositions[i].deletedText, ch));\n            }\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            // Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\n            const commands = selections.map(s => new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), '', false));\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, true);\n        if (autoClosingPairClose !== null) {\n            return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, true, autoClosingPairClose);\n        }\n        return null;\n    }\n    static typeWithInterceptors(isDoingComposition, prevEditOperationType, config, model, selections, autoClosedCharacters, ch) {\n        if (!isDoingComposition && ch === '\\n') {\n            const commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = TypeOperations._enter(config, model, false, selections[i]);\n            }\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false,\n            });\n        }\n        if (!isDoingComposition && this._isAutoIndentType(config, model, selections)) {\n            const commands = [];\n            let autoIndentFails = false;\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = this._runAutoIndentType(config, model, selections[i], ch);\n                if (!commands[i]) {\n                    autoIndentFails = true;\n                    break;\n                }\n            }\n            if (!autoIndentFails) {\n                return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                    shouldPushStackElementBefore: true,\n                    shouldPushStackElementAfter: false,\n                });\n            }\n        }\n        if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            return this._runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch);\n        }\n        if (!isDoingComposition) {\n            const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, false);\n            if (autoClosingPairClose) {\n                return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, false, autoClosingPairClose);\n            }\n        }\n        if (!isDoingComposition && this._isSurroundSelectionType(config, model, selections, ch)) {\n            return this._runSurroundSelectionType(prevEditOperationType, config, model, selections, ch);\n        }\n        // Electric characters make sense only when dealing with a single cursor,\n        // as multiple cursors typing brackets for example would interfer with bracket matching\n        if (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model, selections)) {\n            const r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n            if (r) {\n                return r;\n            }\n        }\n        // A simple character type\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], ch);\n        }\n        const opType = getTypingOperation(ch, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static typeWithoutInterceptors(prevEditOperationType, config, model, selections, str) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], str);\n        }\n        const opType = getTypingOperation(str, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static lineInsertBefore(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            let lineNumber = selections[i].positionLineNumber;\n            if (lineNumber === 1) {\n                commands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\n            }\n            else {\n                lineNumber--;\n                const column = model.getLineMaxColumn(lineNumber);\n                commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n            }\n        }\n        return commands;\n    }\n    static lineInsertAfter(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const lineNumber = selections[i].positionLineNumber;\n            const column = model.getLineMaxColumn(lineNumber);\n            commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n        }\n        return commands;\n    }\n    static lineBreakInsert(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = this._enter(config, model, true, selections[i]);\n        }\n        return commands;\n    }\n}\nexport class TypeWithAutoClosingCommand extends ReplaceCommandWithOffsetCursorState {\n    constructor(selection, openCharacter, insertOpenCharacter, closeCharacter) {\n        super(selection, (insertOpenCharacter ? openCharacter : '') + closeCharacter, 0, -closeCharacter.length);\n        this._openCharacter = openCharacter;\n        this._closeCharacter = closeCharacter;\n        this.closeCharacterRange = null;\n        this.enclosingRange = null;\n    }\n    computeCursorState(model, helper) {\n        const inverseEditOperations = helper.getInverseEditOperations();\n        const range = inverseEditOperations[0].range;\n        this.closeCharacterRange = new Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        this.enclosingRange = new Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        return super.computeCursorState(model, helper);\n    }\n}\nexport class CompositionOutcome {\n    constructor(deletedText, deletedSelectionStart, deletedSelectionEnd, insertedText, insertedSelectionStart, insertedSelectionEnd) {\n        this.deletedText = deletedText;\n        this.deletedSelectionStart = deletedSelectionStart;\n        this.deletedSelectionEnd = deletedSelectionEnd;\n        this.insertedText = insertedText;\n        this.insertedSelectionStart = insertedSelectionStart;\n        this.insertedSelectionEnd = insertedSelectionEnd;\n    }\n}\nfunction getTypingOperation(typedText, previousTypingOperation) {\n    if (typedText === ' ') {\n        return previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */\n            || previousTypingOperation === 6 /* EditOperationType.TypingConsecutiveSpace */\n            ? 6 /* EditOperationType.TypingConsecutiveSpace */\n            : 5 /* EditOperationType.TypingFirstSpace */;\n    }\n    return 4 /* EditOperationType.TypingOther */;\n}\nfunction shouldPushStackElementBetween(previousTypingOperation, typingOperation) {\n    if (isTypingOperation(previousTypingOperation) && !isTypingOperation(typingOperation)) {\n        // Always set an undo stop before non-type operations\n        return true;\n    }\n    if (previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */) {\n        // `abc |d`: No undo stop\n        // `abc  |d`: Undo stop\n        return false;\n    }\n    // Insert undo stop between different operation types\n    return normalizeOperationType(previousTypingOperation) !== normalizeOperationType(typingOperation);\n}\nfunction normalizeOperationType(type) {\n    return (type === 6 /* EditOperationType.TypingConsecutiveSpace */ || type === 5 /* EditOperationType.TypingFirstSpace */)\n        ? 'space'\n        : type;\n}\nfunction isTypingOperation(type) {\n    return type === 4 /* EditOperationType.TypingOther */\n        || type === 5 /* EditOperationType.TypingFirstSpace */\n        || type === 6 /* EditOperationType.TypingConsecutiveSpace */;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class WordOperations {\n    static _createWord(lineContent, wordType, nextCharClass, start, end) {\n        // console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\n        return { start: start, end: end, wordType: wordType, nextCharClass: nextCharClass };\n    }\n    static _findPreviousWordOnLine(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\n    }\n    static _doFindPreviousWordOnLine(lineContent, wordSeparators, position) {\n        let wordType = 0 /* WordType.None */;\n        for (let chIndex = position.column - 2; chIndex >= 0; chIndex--) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 0 /* WordCharacterClass.Regular */) {\n                if (wordType === 2 /* WordType.Separator */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = 1 /* WordType.Regular */;\n            }\n            else if (chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                if (wordType === 1 /* WordType.Regular */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = 2 /* WordType.Separator */;\n            }\n            else if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                if (wordType !== 0 /* WordType.None */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n            }\n        }\n        if (wordType !== 0 /* WordType.None */) {\n            return this._createWord(lineContent, wordType, 1 /* WordCharacterClass.Whitespace */, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\n        }\n        return null;\n    }\n    static _findEndOfWord(lineContent, wordSeparators, wordType, startIndex) {\n        const len = lineContent.length;\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                return chIndex;\n            }\n            if (wordType === 1 /* WordType.Regular */ && chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                return chIndex;\n            }\n            if (wordType === 2 /* WordType.Separator */ && chClass === 0 /* WordCharacterClass.Regular */) {\n                return chIndex;\n            }\n        }\n        return len;\n    }\n    static _findNextWordOnLine(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindNextWordOnLine(lineContent, wordSeparators, position);\n    }\n    static _doFindNextWordOnLine(lineContent, wordSeparators, position) {\n        let wordType = 0 /* WordType.None */;\n        const len = lineContent.length;\n        for (let chIndex = position.column - 1; chIndex < len; chIndex++) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 0 /* WordCharacterClass.Regular */) {\n                if (wordType === 2 /* WordType.Separator */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = 1 /* WordType.Regular */;\n            }\n            else if (chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                if (wordType === 1 /* WordType.Regular */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = 2 /* WordType.Separator */;\n            }\n            else if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                if (wordType !== 0 /* WordType.None */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n            }\n        }\n        if (wordType !== 0 /* WordType.None */) {\n            return this._createWord(lineContent, wordType, 1 /* WordCharacterClass.Whitespace */, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\n        }\n        return null;\n    }\n    static _findStartOfWord(lineContent, wordSeparators, wordType, startIndex) {\n        for (let chIndex = startIndex; chIndex >= 0; chIndex--) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                return chIndex + 1;\n            }\n            if (wordType === 1 /* WordType.Regular */ && chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                return chIndex + 1;\n            }\n            if (wordType === 2 /* WordType.Separator */ && chClass === 0 /* WordCharacterClass.Regular */) {\n                return chIndex + 1;\n            }\n        }\n        return 0;\n    }\n    static moveWordLeft(wordSeparators, model, position, wordNavigationType) {\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        if (column === 1) {\n            if (lineNumber > 1) {\n                lineNumber = lineNumber - 1;\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n        if (wordNavigationType === 0 /* WordNavigationType.WordStart */) {\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        if (wordNavigationType === 1 /* WordNavigationType.WordStartFast */) {\n            if (prevWordOnLine\n                && prevWordOnLine.wordType === 2 /* WordType.Separator */\n                && prevWordOnLine.end - prevWordOnLine.start === 1\n                && prevWordOnLine.nextCharClass === 0 /* WordCharacterClass.Regular */) {\n                // Skip over a word made up of one single separator and followed by a regular character\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        if (wordNavigationType === 3 /* WordNavigationType.WordAccessibility */) {\n            while (prevWordOnLine\n                && prevWordOnLine.wordType === 2 /* WordType.Separator */) {\n                // Skip over words made up of only separators\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        // We are stopping at the ending of words\n        if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n            prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n        }\n        return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\n    }\n    static _moveWordPartLeft(model, position) {\n        const lineNumber = position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === 1) {\n            return (lineNumber > 1 ? new Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position);\n        }\n        const lineContent = model.getLineContent(lineNumber);\n        for (let column = position.column - 1; column > 1; column--) {\n            const left = lineContent.charCodeAt(column - 2);\n            const right = lineContent.charCodeAt(column - 1);\n            if (left === 95 /* CharCode.Underline */ && right !== 95 /* CharCode.Underline */) {\n                // snake_case_variables\n                return new Position(lineNumber, column);\n            }\n            if ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    const rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n                        return new Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new Position(lineNumber, 1);\n    }\n    static moveWordRight(wordSeparators, model, position, wordNavigationType) {\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        let movedDown = false;\n        if (column === model.getLineMaxColumn(lineNumber)) {\n            if (lineNumber < model.getLineCount()) {\n                movedDown = true;\n                lineNumber = lineNumber + 1;\n                column = 1;\n            }\n        }\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n        if (wordNavigationType === 2 /* WordNavigationType.WordEnd */) {\n            if (nextWordOnLine && nextWordOnLine.wordType === 2 /* WordType.Separator */) {\n                if (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === 0 /* WordCharacterClass.Regular */) {\n                    // Skip over a word made up of one single separator and followed by a regular character\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n                }\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        else if (wordNavigationType === 3 /* WordNavigationType.WordAccessibility */) {\n            if (movedDown) {\n                // If we move to the next line, pretend that the cursor is right before the first character.\n                // This is needed when the first word starts right at the first character - and in order not to miss it,\n                // we need to start before.\n                column = 0;\n            }\n            while (nextWordOnLine\n                && (nextWordOnLine.wordType === 2 /* WordType.Separator */\n                    || nextWordOnLine.start + 1 <= column)) {\n                // Skip over a word made up of one single separator\n                // Also skip over word if it begins before current cursor position to ascertain we're moving forward at least 1 character.\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        else {\n            if (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    static _moveWordPartRight(model, position) {\n        const lineNumber = position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === maxColumn) {\n            return (lineNumber < model.getLineCount() ? new Position(lineNumber + 1, 1) : position);\n        }\n        const lineContent = model.getLineContent(lineNumber);\n        for (let column = position.column + 1; column < maxColumn; column++) {\n            const left = lineContent.charCodeAt(column - 2);\n            const right = lineContent.charCodeAt(column - 1);\n            if (left !== 95 /* CharCode.Underline */ && right === 95 /* CharCode.Underline */) {\n                // snake_case_variables\n                return new Position(lineNumber, column);\n            }\n            if ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    const rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n                        return new Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new Position(lineNumber, maxColumn);\n    }\n    static _deleteWordLeftWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const startIndex = position.column - 2;\n        const lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\n        if (lastNonWhitespace + 1 < startIndex) {\n            return new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\n        }\n        return null;\n    }\n    static deleteWordLeft(ctx, wordNavigationType) {\n        const wordSeparators = ctx.wordSeparators;\n        const model = ctx.model;\n        const selection = ctx.selection;\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        if (DeleteOperations.isAutoClosingPairDelete(ctx.autoClosingDelete, ctx.autoClosingBrackets, ctx.autoClosingQuotes, ctx.autoClosingPairs.autoClosingPairsOpenByEnd, ctx.model, [ctx.selection], ctx.autoClosedCharacters)) {\n            const position = ctx.selection.getPosition();\n            return new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        if (lineNumber === 1 && column === 1) {\n            // Ignore deleting at beginning of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            const r = this._deleteWordLeftWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === 0 /* WordNavigationType.WordStart */) {\n            if (prevWordOnLine) {\n                column = prevWordOnLine.start + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        else {\n            if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            if (prevWordOnLine) {\n                column = prevWordOnLine.end + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n    static deleteInsideWord(wordSeparators, model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        const r = this._deleteInsideWordWhitespace(model, position);\n        if (r) {\n            return r;\n        }\n        return this._deleteInsideWordDetermineDeleteRange(wordSeparators, model, position);\n    }\n    static _charAtIsWhitespace(str, index) {\n        const charCode = str.charCodeAt(index);\n        return (charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */);\n    }\n    static _deleteInsideWordWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const lineContentLength = lineContent.length;\n        if (lineContentLength === 0) {\n            // empty line\n            return null;\n        }\n        let leftIndex = Math.max(position.column - 2, 0);\n        if (!this._charAtIsWhitespace(lineContent, leftIndex)) {\n            // touches a non-whitespace character to the left\n            return null;\n        }\n        let rightIndex = Math.min(position.column - 1, lineContentLength - 1);\n        if (!this._charAtIsWhitespace(lineContent, rightIndex)) {\n            // touches a non-whitespace character to the right\n            return null;\n        }\n        // walk over whitespace to the left\n        while (leftIndex > 0 && this._charAtIsWhitespace(lineContent, leftIndex - 1)) {\n            leftIndex--;\n        }\n        // walk over whitespace to the right\n        while (rightIndex + 1 < lineContentLength && this._charAtIsWhitespace(lineContent, rightIndex + 1)) {\n            rightIndex++;\n        }\n        return new Range(position.lineNumber, leftIndex + 1, position.lineNumber, rightIndex + 2);\n    }\n    static _deleteInsideWordDetermineDeleteRange(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const lineLength = lineContent.length;\n        if (lineLength === 0) {\n            // empty line\n            if (position.lineNumber > 1) {\n                return new Range(position.lineNumber - 1, model.getLineMaxColumn(position.lineNumber - 1), position.lineNumber, 1);\n            }\n            else {\n                if (position.lineNumber < model.getLineCount()) {\n                    return new Range(position.lineNumber, 1, position.lineNumber + 1, 1);\n                }\n                else {\n                    // empty model\n                    return new Range(position.lineNumber, 1, position.lineNumber, 1);\n                }\n            }\n        }\n        const touchesWord = (word) => {\n            return (word.start + 1 <= position.column && position.column <= word.end + 1);\n        };\n        const createRangeWithPosition = (startColumn, endColumn) => {\n            startColumn = Math.min(startColumn, position.column);\n            endColumn = Math.max(endColumn, position.column);\n            return new Range(position.lineNumber, startColumn, position.lineNumber, endColumn);\n        };\n        const deleteWordAndAdjacentWhitespace = (word) => {\n            let startColumn = word.start + 1;\n            let endColumn = word.end + 1;\n            let expandedToTheRight = false;\n            while (endColumn - 1 < lineLength && this._charAtIsWhitespace(lineContent, endColumn - 1)) {\n                expandedToTheRight = true;\n                endColumn++;\n            }\n            if (!expandedToTheRight) {\n                while (startColumn > 1 && this._charAtIsWhitespace(lineContent, startColumn - 2)) {\n                    startColumn--;\n                }\n            }\n            return createRangeWithPosition(startColumn, endColumn);\n        };\n        const prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (prevWordOnLine && touchesWord(prevWordOnLine)) {\n            return deleteWordAndAdjacentWhitespace(prevWordOnLine);\n        }\n        const nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (nextWordOnLine && touchesWord(nextWordOnLine)) {\n            return deleteWordAndAdjacentWhitespace(nextWordOnLine);\n        }\n        if (prevWordOnLine && nextWordOnLine) {\n            return createRangeWithPosition(prevWordOnLine.end + 1, nextWordOnLine.start + 1);\n        }\n        if (prevWordOnLine) {\n            return createRangeWithPosition(prevWordOnLine.start + 1, prevWordOnLine.end + 1);\n        }\n        if (nextWordOnLine) {\n            return createRangeWithPosition(nextWordOnLine.start + 1, nextWordOnLine.end + 1);\n        }\n        return createRangeWithPosition(1, lineLength + 1);\n    }\n    static _deleteWordPartLeft(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const pos = selection.getPosition();\n        const toPosition = WordOperations._moveWordPartLeft(model, pos);\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n    static _findFirstNonWhitespaceChar(str, startIndex) {\n        const len = str.length;\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\n            const ch = str.charAt(chIndex);\n            if (ch !== ' ' && ch !== '\\t') {\n                return chIndex;\n            }\n        }\n        return len;\n    }\n    static _deleteWordRightWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const startIndex = position.column - 1;\n        const firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\n        if (startIndex + 1 < firstNonWhitespace) {\n            // bingo\n            return new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\n        }\n        return null;\n    }\n    static deleteWordRight(ctx, wordNavigationType) {\n        const wordSeparators = ctx.wordSeparators;\n        const model = ctx.model;\n        const selection = ctx.selection;\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        const lineCount = model.getLineCount();\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (lineNumber === lineCount && column === maxColumn) {\n            // Ignore deleting at end of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            const r = this._deleteWordRightWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === 2 /* WordNavigationType.WordEnd */) {\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        else {\n            if (nextWordOnLine && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n    static _deleteWordPartRight(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const pos = selection.getPosition();\n        const toPosition = WordOperations._moveWordPartRight(model, pos);\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n    static _createWordAtPosition(model, lineNumber, word) {\n        const range = new Range(lineNumber, word.start + 1, lineNumber, word.end + 1);\n        return {\n            word: model.getValueInRange(range),\n            startColumn: range.startColumn,\n            endColumn: range.endColumn\n        };\n    }\n    static getWordAtPosition(model, _wordSeparators, position) {\n        const wordSeparators = getMapForWordSeparators(_wordSeparators);\n        const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n            return WordOperations._createWordAtPosition(model, position.lineNumber, prevWord);\n        }\n        const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n            return WordOperations._createWordAtPosition(model, position.lineNumber, nextWord);\n        }\n        return null;\n    }\n    static word(config, model, cursor, inSelectionMode, position) {\n        const wordSeparators = getMapForWordSeparators(config.wordSeparators);\n        const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (!inSelectionMode) {\n            // Entering word selection for the first time\n            let startColumn;\n            let endColumn;\n            if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n                // isTouchingPrevWord\n                startColumn = prevWord.start + 1;\n                endColumn = prevWord.end + 1;\n            }\n            else if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n                // isTouchingNextWord\n                startColumn = nextWord.start + 1;\n                endColumn = nextWord.end + 1;\n            }\n            else {\n                if (prevWord) {\n                    startColumn = prevWord.end + 1;\n                }\n                else {\n                    startColumn = 1;\n                }\n                if (nextWord) {\n                    endColumn = nextWord.start + 1;\n                }\n                else {\n                    endColumn = model.getLineMaxColumn(position.lineNumber);\n                }\n            }\n            return new SingleCursorState(new Range(position.lineNumber, startColumn, position.lineNumber, endColumn), 0, new Position(position.lineNumber, endColumn), 0);\n        }\n        let startColumn;\n        let endColumn;\n        if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\n            // isInsidePrevWord\n            startColumn = prevWord.start + 1;\n            endColumn = prevWord.end + 1;\n        }\n        else if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\n            // isInsideNextWord\n            startColumn = nextWord.start + 1;\n            endColumn = nextWord.end + 1;\n        }\n        else {\n            startColumn = position.column;\n            endColumn = position.column;\n        }\n        const lineNumber = position.lineNumber;\n        let column;\n        if (cursor.selectionStart.containsPosition(position)) {\n            column = cursor.selectionStart.endColumn;\n        }\n        else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\n            column = startColumn;\n            const possiblePosition = new Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.endColumn;\n            }\n        }\n        else {\n            column = endColumn;\n            const possiblePosition = new Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.startColumn;\n            }\n        }\n        return cursor.move(true, lineNumber, column, 0);\n    }\n}\nexport class WordPartOperations extends WordOperations {\n    static deleteWordPartLeft(ctx) {\n        const candidates = enforceDefined([\n            WordOperations.deleteWordLeft(ctx, 0 /* WordNavigationType.WordStart */),\n            WordOperations.deleteWordLeft(ctx, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._deleteWordPartLeft(ctx.model, ctx.selection)\n        ]);\n        candidates.sort(Range.compareRangesUsingEnds);\n        return candidates[2];\n    }\n    static deleteWordPartRight(ctx) {\n        const candidates = enforceDefined([\n            WordOperations.deleteWordRight(ctx, 0 /* WordNavigationType.WordStart */),\n            WordOperations.deleteWordRight(ctx, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._deleteWordPartRight(ctx.model, ctx.selection)\n        ]);\n        candidates.sort(Range.compareRangesUsingStarts);\n        return candidates[0];\n    }\n    static moveWordPartLeft(wordSeparators, model, position) {\n        const candidates = enforceDefined([\n            WordOperations.moveWordLeft(wordSeparators, model, position, 0 /* WordNavigationType.WordStart */),\n            WordOperations.moveWordLeft(wordSeparators, model, position, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._moveWordPartLeft(model, position)\n        ]);\n        candidates.sort(Position.compare);\n        return candidates[2];\n    }\n    static moveWordPartRight(wordSeparators, model, position) {\n        const candidates = enforceDefined([\n            WordOperations.moveWordRight(wordSeparators, model, position, 0 /* WordNavigationType.WordStart */),\n            WordOperations.moveWordRight(wordSeparators, model, position, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._moveWordPartRight(model, position)\n        ]);\n        candidates.sort(Position.compare);\n        return candidates[0];\n    }\n}\nfunction enforceDefined(arr) {\n    return arr.filter(el => Boolean(el));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './core/position.js';\nimport { Range } from './core/range.js';\nimport { Selection } from './core/selection.js';\nimport { createScopedLineTokens } from './languages/supports.js';\nimport { CursorColumns } from './core/cursorColumns.js';\nimport { normalizeIndentation } from './core/indentation.js';\nconst autoCloseAlways = () => true;\nconst autoCloseNever = () => false;\nconst autoCloseBeforeWhitespace = (chr) => (chr === ' ' || chr === '\\t');\nexport class CursorConfiguration {\n    constructor(languageId, modelOptions, configuration, languageConfigurationService) {\n        this.languageConfigurationService = languageConfigurationService;\n        this._cursorMoveConfigurationBrand = undefined;\n        this._languageId = languageId;\n        const options = configuration.options;\n        const layoutInfo = options.get(133 /* EditorOption.layoutInfo */);\n        this.readOnly = options.get(83 /* EditorOption.readOnly */);\n        this.tabSize = modelOptions.tabSize;\n        this.indentSize = modelOptions.indentSize;\n        this.insertSpaces = modelOptions.insertSpaces;\n        this.stickyTabStops = options.get(106 /* EditorOption.stickyTabStops */);\n        this.lineHeight = options.get(61 /* EditorOption.lineHeight */);\n        this.pageSize = Math.max(1, Math.floor(layoutInfo.height / this.lineHeight) - 2);\n        this.useTabStops = options.get(118 /* EditorOption.useTabStops */);\n        this.wordSeparators = options.get(119 /* EditorOption.wordSeparators */);\n        this.emptySelectionClipboard = options.get(33 /* EditorOption.emptySelectionClipboard */);\n        this.copyWithSyntaxHighlighting = options.get(21 /* EditorOption.copyWithSyntaxHighlighting */);\n        this.multiCursorMergeOverlapping = options.get(71 /* EditorOption.multiCursorMergeOverlapping */);\n        this.multiCursorPaste = options.get(73 /* EditorOption.multiCursorPaste */);\n        this.autoClosingBrackets = options.get(5 /* EditorOption.autoClosingBrackets */);\n        this.autoClosingQuotes = options.get(8 /* EditorOption.autoClosingQuotes */);\n        this.autoClosingDelete = options.get(6 /* EditorOption.autoClosingDelete */);\n        this.autoClosingOvertype = options.get(7 /* EditorOption.autoClosingOvertype */);\n        this.autoSurround = options.get(11 /* EditorOption.autoSurround */);\n        this.autoIndent = options.get(9 /* EditorOption.autoIndent */);\n        this.surroundingPairs = {};\n        this._electricChars = null;\n        this.shouldAutoCloseBefore = {\n            quote: this._getShouldAutoClose(languageId, this.autoClosingQuotes),\n            bracket: this._getShouldAutoClose(languageId, this.autoClosingBrackets)\n        };\n        this.autoClosingPairs = this.languageConfigurationService.getLanguageConfiguration(languageId).getAutoClosingPairs();\n        const surroundingPairs = this.languageConfigurationService.getLanguageConfiguration(languageId).getSurroundingPairs();\n        if (surroundingPairs) {\n            for (const pair of surroundingPairs) {\n                this.surroundingPairs[pair.open] = pair.close;\n            }\n        }\n    }\n    static shouldRecreate(e) {\n        return (e.hasChanged(133 /* EditorOption.layoutInfo */)\n            || e.hasChanged(119 /* EditorOption.wordSeparators */)\n            || e.hasChanged(33 /* EditorOption.emptySelectionClipboard */)\n            || e.hasChanged(71 /* EditorOption.multiCursorMergeOverlapping */)\n            || e.hasChanged(73 /* EditorOption.multiCursorPaste */)\n            || e.hasChanged(5 /* EditorOption.autoClosingBrackets */)\n            || e.hasChanged(8 /* EditorOption.autoClosingQuotes */)\n            || e.hasChanged(6 /* EditorOption.autoClosingDelete */)\n            || e.hasChanged(7 /* EditorOption.autoClosingOvertype */)\n            || e.hasChanged(11 /* EditorOption.autoSurround */)\n            || e.hasChanged(118 /* EditorOption.useTabStops */)\n            || e.hasChanged(61 /* EditorOption.lineHeight */)\n            || e.hasChanged(83 /* EditorOption.readOnly */));\n    }\n    get electricChars() {\n        var _a;\n        if (!this._electricChars) {\n            this._electricChars = {};\n            const electricChars = (_a = this.languageConfigurationService.getLanguageConfiguration(this._languageId).electricCharacter) === null || _a === void 0 ? void 0 : _a.getElectricCharacters();\n            if (electricChars) {\n                for (const char of electricChars) {\n                    this._electricChars[char] = true;\n                }\n            }\n        }\n        return this._electricChars;\n    }\n    /**\n     * Should return opening bracket type to match indentation with\n     */\n    onElectricCharacter(character, context, column) {\n        const scopedLineTokens = createScopedLineTokens(context, column - 1);\n        const electricCharacterSupport = this.languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId).electricCharacter;\n        if (!electricCharacterSupport) {\n            return null;\n        }\n        return electricCharacterSupport.onElectricCharacter(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\n    }\n    normalizeIndentation(str) {\n        return normalizeIndentation(str, this.indentSize, this.insertSpaces);\n    }\n    _getShouldAutoClose(languageId, autoCloseConfig) {\n        switch (autoCloseConfig) {\n            case 'beforeWhitespace':\n                return autoCloseBeforeWhitespace;\n            case 'languageDefined':\n                return this._getLanguageDefinedShouldAutoClose(languageId);\n            case 'always':\n                return autoCloseAlways;\n            case 'never':\n                return autoCloseNever;\n        }\n    }\n    _getLanguageDefinedShouldAutoClose(languageId) {\n        const autoCloseBeforeSet = this.languageConfigurationService.getLanguageConfiguration(languageId).getAutoCloseBeforeSet();\n        return c => autoCloseBeforeSet.indexOf(c) !== -1;\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    visibleColumnFromColumn(model, position) {\n        return CursorColumns.visibleColumnFromColumn(model.getLineContent(position.lineNumber), position.column, this.tabSize);\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    columnFromVisibleColumn(model, lineNumber, visibleColumn) {\n        const result = CursorColumns.columnFromVisibleColumn(model.getLineContent(lineNumber), visibleColumn, this.tabSize);\n        const minColumn = model.getLineMinColumn(lineNumber);\n        if (result < minColumn) {\n            return minColumn;\n        }\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (result > maxColumn) {\n            return maxColumn;\n        }\n        return result;\n    }\n}\nexport class CursorState {\n    constructor(modelState, viewState) {\n        this._cursorStateBrand = undefined;\n        this.modelState = modelState;\n        this.viewState = viewState;\n    }\n    static fromModelState(modelState) {\n        return new PartialModelCursorState(modelState);\n    }\n    static fromViewState(viewState) {\n        return new PartialViewCursorState(viewState);\n    }\n    static fromModelSelection(modelSelection) {\n        const selection = Selection.liftSelection(modelSelection);\n        const modelState = new SingleCursorState(Range.fromPositions(selection.getSelectionStart()), 0, selection.getPosition(), 0);\n        return CursorState.fromModelState(modelState);\n    }\n    static fromModelSelections(modelSelections) {\n        const states = [];\n        for (let i = 0, len = modelSelections.length; i < len; i++) {\n            states[i] = this.fromModelSelection(modelSelections[i]);\n        }\n        return states;\n    }\n    equals(other) {\n        return (this.viewState.equals(other.viewState) && this.modelState.equals(other.modelState));\n    }\n}\nexport class PartialModelCursorState {\n    constructor(modelState) {\n        this.modelState = modelState;\n        this.viewState = null;\n    }\n}\nexport class PartialViewCursorState {\n    constructor(viewState) {\n        this.modelState = null;\n        this.viewState = viewState;\n    }\n}\n/**\n * Represents the cursor state on either the model or on the view model.\n */\nexport class SingleCursorState {\n    constructor(selectionStart, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns) {\n        this._singleCursorStateBrand = undefined;\n        this.selectionStart = selectionStart;\n        this.selectionStartLeftoverVisibleColumns = selectionStartLeftoverVisibleColumns;\n        this.position = position;\n        this.leftoverVisibleColumns = leftoverVisibleColumns;\n        this.selection = SingleCursorState._computeSelection(this.selectionStart, this.position);\n    }\n    equals(other) {\n        return (this.selectionStartLeftoverVisibleColumns === other.selectionStartLeftoverVisibleColumns\n            && this.leftoverVisibleColumns === other.leftoverVisibleColumns\n            && this.position.equals(other.position)\n            && this.selectionStart.equalsRange(other.selectionStart));\n    }\n    hasSelection() {\n        return (!this.selection.isEmpty() || !this.selectionStart.isEmpty());\n    }\n    move(inSelectionMode, lineNumber, column, leftoverVisibleColumns) {\n        if (inSelectionMode) {\n            // move just position\n            return new SingleCursorState(this.selectionStart, this.selectionStartLeftoverVisibleColumns, new Position(lineNumber, column), leftoverVisibleColumns);\n        }\n        else {\n            // move everything\n            return new SingleCursorState(new Range(lineNumber, column, lineNumber, column), leftoverVisibleColumns, new Position(lineNumber, column), leftoverVisibleColumns);\n        }\n    }\n    static _computeSelection(selectionStart, position) {\n        if (selectionStart.isEmpty() || !position.isBeforeOrEqual(selectionStart.getStartPosition())) {\n            return Selection.fromPositions(selectionStart.getStartPosition(), position);\n        }\n        else {\n            return Selection.fromPositions(selectionStart.getEndPosition(), position);\n        }\n    }\n}\nexport class EditOperationResult {\n    constructor(type, commands, opts) {\n        this._editOperationResultBrand = undefined;\n        this.type = type;\n        this.commands = commands;\n        this.shouldPushStackElementBefore = opts.shouldPushStackElementBefore;\n        this.shouldPushStackElementAfter = opts.shouldPushStackElementAfter;\n    }\n}\nexport function isQuote(ch) {\n    return (ch === '\\'' || ch === '\"' || ch === '`');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../base/common/diff/diff.js';\nimport * as strings from '../../../base/common/strings.js';\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n    return diffAlgo.ComputeDiff(pretty);\n}\nclass LineSequence {\n    constructor(lines) {\n        const startColumns = [];\n        const endColumns = [];\n        for (let i = 0, length = lines.length; i < length; i++) {\n            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n            endColumns[i] = getLastNonBlankColumn(lines[i], 1);\n        }\n        this.lines = lines;\n        this._startColumns = startColumns;\n        this._endColumns = endColumns;\n    }\n    getElements() {\n        const elements = [];\n        for (let i = 0, len = this.lines.length; i < len; i++) {\n            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n        }\n        return elements;\n    }\n    getStrictElement(index) {\n        return this.lines[index];\n    }\n    getStartLineNumber(i) {\n        return i + 1;\n    }\n    getEndLineNumber(i) {\n        return i + 1;\n    }\n    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\n        const charCodes = [];\n        const lineNumbers = [];\n        const columns = [];\n        let len = 0;\n        for (let index = startIndex; index <= endIndex; index++) {\n            const lineContent = this.lines[index];\n            const startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\n            const endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\n            for (let col = startColumn; col < endColumn; col++) {\n                charCodes[len] = lineContent.charCodeAt(col - 1);\n                lineNumbers[len] = index + 1;\n                columns[len] = col;\n                len++;\n            }\n            if (!shouldIgnoreTrimWhitespace && index < endIndex) {\n                // Add \\n if trim whitespace is not ignored\n                charCodes[len] = 10 /* CharCode.LineFeed */;\n                lineNumbers[len] = index + 1;\n                columns[len] = lineContent.length + 1;\n                len++;\n            }\n        }\n        return new CharSequence(charCodes, lineNumbers, columns);\n    }\n}\nclass CharSequence {\n    constructor(charCodes, lineNumbers, columns) {\n        this._charCodes = charCodes;\n        this._lineNumbers = lineNumbers;\n        this._columns = columns;\n    }\n    toString() {\n        return ('[' + this._charCodes.map((s, idx) => (s === 10 /* CharCode.LineFeed */ ? '\\\\n' : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(', ') + ']');\n    }\n    _assertIndex(index, arr) {\n        if (index < 0 || index >= arr.length) {\n            throw new Error(`Illegal index`);\n        }\n    }\n    getElements() {\n        return this._charCodes;\n    }\n    getStartLineNumber(i) {\n        if (i > 0 && i === this._lineNumbers.length) {\n            // the start line number of the element after the last element\n            // is the end line number of the last element\n            return this.getEndLineNumber(i - 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        return this._lineNumbers[i];\n    }\n    getEndLineNumber(i) {\n        if (i === -1) {\n            // the end line number of the element before the first element\n            // is the start line number of the first element\n            return this.getStartLineNumber(i + 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return this._lineNumbers[i] + 1;\n        }\n        return this._lineNumbers[i];\n    }\n    getStartColumn(i) {\n        if (i > 0 && i === this._columns.length) {\n            // the start column of the element after the last element\n            // is the end column of the last element\n            return this.getEndColumn(i - 1);\n        }\n        this._assertIndex(i, this._columns);\n        return this._columns[i];\n    }\n    getEndColumn(i) {\n        if (i === -1) {\n            // the end column of the element before the first element\n            // is the start column of the first element\n            return this.getStartColumn(i + 1);\n        }\n        this._assertIndex(i, this._columns);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return 1;\n        }\n        return this._columns[i] + 1;\n    }\n}\nclass CharChange {\n    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalStartColumn = originalStartColumn;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.originalEndColumn = originalEndColumn;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedStartColumn = modifiedStartColumn;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.modifiedEndColumn = modifiedEndColumn;\n    }\n    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\n        const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n        const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n        const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n        const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n        const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n        const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\n    }\n}\nfunction postProcessCharChanges(rawChanges) {\n    if (rawChanges.length <= 1) {\n        return rawChanges;\n    }\n    const result = [rawChanges[0]];\n    let prevChange = result[0];\n    for (let i = 1, len = rawChanges.length; i < len; i++) {\n        const currChange = rawChanges[i];\n        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n        // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n            // Merge the current change into the previous one\n            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n        }\n        else {\n            // Add the current change\n            result.push(currChange);\n            prevChange = currChange;\n        }\n    }\n    return result;\n}\nclass LineChange {\n    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.charChanges = charChanges;\n    }\n    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\n        let originalStartLineNumber;\n        let originalEndLineNumber;\n        let modifiedStartLineNumber;\n        let modifiedEndLineNumber;\n        let charChanges = undefined;\n        if (diffChange.originalLength === 0) {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n            originalEndLineNumber = 0;\n        }\n        else {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        }\n        if (diffChange.modifiedLength === 0) {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n            modifiedEndLineNumber = 0;\n        }\n        else {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        }\n        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n            // Compute character changes for diff chunks of at most 20 lines...\n            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n            if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {\n                let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n                if (shouldPostProcessCharChanges) {\n                    rawChanges = postProcessCharChanges(rawChanges);\n                }\n                charChanges = [];\n                for (let i = 0, length = rawChanges.length; i < length; i++) {\n                    charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n                }\n            }\n        }\n        return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n    }\n}\nexport class DiffComputer {\n    constructor(originalLines, modifiedLines, opts) {\n        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n        this.originalLines = originalLines;\n        this.modifiedLines = modifiedLines;\n        this.original = new LineSequence(originalLines);\n        this.modified = new LineSequence(modifiedLines);\n        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n    }\n    computeDiff() {\n        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n            // empty original => fast path\n            if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n                return {\n                    quitEarly: false,\n                    changes: []\n                };\n            }\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: 1,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: this.modified.lines.length,\n                        charChanges: [{\n                                modifiedEndColumn: 0,\n                                modifiedEndLineNumber: 0,\n                                modifiedStartColumn: 0,\n                                modifiedStartLineNumber: 0,\n                                originalEndColumn: 0,\n                                originalEndLineNumber: 0,\n                                originalStartColumn: 0,\n                                originalStartLineNumber: 0\n                            }]\n                    }]\n            };\n        }\n        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n            // empty modified => fast path\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: this.original.lines.length,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: 1,\n                        charChanges: [{\n                                modifiedEndColumn: 0,\n                                modifiedEndLineNumber: 0,\n                                modifiedStartColumn: 0,\n                                modifiedStartLineNumber: 0,\n                                originalEndColumn: 0,\n                                originalEndLineNumber: 0,\n                                originalStartColumn: 0,\n                                originalStartLineNumber: 0\n                            }]\n                    }]\n            };\n        }\n        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n        const rawChanges = diffResult.changes;\n        const quitEarly = diffResult.quitEarly;\n        // The diff is always computed with ignoring trim whitespace\n        // This ensures we get the prettiest diff\n        if (this.shouldIgnoreTrimWhitespace) {\n            const lineChanges = [];\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\n                lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n            }\n            return {\n                quitEarly: quitEarly,\n                changes: lineChanges\n            };\n        }\n        // Need to post-process and introduce changes where the trim whitespace is different\n        // Note that we are looping starting at -1 to also cover the lines before the first change\n        const result = [];\n        let originalLineIndex = 0;\n        let modifiedLineIndex = 0;\n        for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n            const nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\n            const originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\n            const modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\n            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n                const originalLine = this.originalLines[originalLineIndex];\n                const modifiedLine = this.modifiedLines[modifiedLineIndex];\n                if (originalLine !== modifiedLine) {\n                    // These lines differ only in trim whitespace\n                    // Check the leading whitespace\n                    {\n                        let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n                        let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {\n                            const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n                            const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalStartColumn--;\n                            modifiedStartColumn--;\n                        }\n                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n                        }\n                    }\n                    // Check the trailing whitespace\n                    {\n                        let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n                        let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n                        const originalMaxColumn = originalLine.length + 1;\n                        const modifiedMaxColumn = modifiedLine.length + 1;\n                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n                            const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n                            const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalEndColumn++;\n                            modifiedEndColumn++;\n                        }\n                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n                        }\n                    }\n                }\n                originalLineIndex++;\n                modifiedLineIndex++;\n            }\n            if (nextChange) {\n                // Emit the actual change\n                result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n                originalLineIndex += nextChange.originalLength;\n                modifiedLineIndex += nextChange.modifiedLength;\n            }\n        }\n        return {\n            quitEarly: quitEarly,\n            changes: result\n        };\n    }\n    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n            // Merged into previous\n            return;\n        }\n        let charChanges = undefined;\n        if (this.shouldComputeCharChanges) {\n            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\n        }\n        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\n    }\n    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        const len = result.length;\n        if (len === 0) {\n            return false;\n        }\n        const prevChange = result[len - 1];\n        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n            // Don't merge with inserts/deletes\n            return false;\n        }\n        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n            prevChange.originalEndLineNumber = originalLineNumber;\n            prevChange.modifiedEndLineNumber = modifiedLineNumber;\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        return false;\n    }\n}\nfunction getFirstNonBlankColumn(txt, defaultValue) {\n    const r = strings.firstNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 1;\n}\nfunction getLastNonBlankColumn(txt, defaultValue) {\n    const r = strings.lastNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 2;\n}\nfunction createContinueProcessingPredicate(maximumRuntime) {\n    if (maximumRuntime === 0) {\n        return () => true;\n    }\n    const startTime = Date.now();\n    return () => {\n        return Date.now() - startTime < maximumRuntime;\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class InternalEditorAction {\n    constructor(id, label, alias, precondition, run, contextKeyService) {\n        this.id = id;\n        this.label = label;\n        this.alias = alias;\n        this._precondition = precondition;\n        this._run = run;\n        this._contextKeyService = contextKeyService;\n    }\n    isSupported() {\n        return this._contextKeyService.contextMatchesRules(this._precondition);\n    }\n    run() {\n        if (!this.isSupported()) {\n            return Promise.resolve(undefined);\n        }\n        return this._run();\n    }\n}\n","/**\n * The type of the `IEditor`.\n */\nexport const EditorType = {\n    ICodeEditor: 'vs.editor.ICodeEditor',\n    IDiffEditor: 'vs.editor.IDiffEditor'\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../nls.js';\nimport { RawContextKey } from '../../platform/contextkey/common/contextkey.js';\nexport var EditorContextKeys;\n(function (EditorContextKeys) {\n    EditorContextKeys.editorSimpleInput = new RawContextKey('editorSimpleInput', false, true);\n    /**\n     * A context key that is set when the editor's text has focus (cursor is blinking).\n     * Is false when focus is in simple editor widgets (repl input, scm commit input).\n     */\n    EditorContextKeys.editorTextFocus = new RawContextKey('editorTextFocus', false, nls.localize('editorTextFocus', \"Whether the editor text has focus (cursor is blinking)\"));\n    /**\n     * A context key that is set when the editor's text or an editor's widget has focus.\n     */\n    EditorContextKeys.focus = new RawContextKey('editorFocus', false, nls.localize('editorFocus', \"Whether the editor or an editor widget has focus (e.g. focus is in the find widget)\"));\n    /**\n     * A context key that is set when any editor input has focus (regular editor, repl input...).\n     */\n    EditorContextKeys.textInputFocus = new RawContextKey('textInputFocus', false, nls.localize('textInputFocus', \"Whether an editor or a rich text input has focus (cursor is blinking)\"));\n    EditorContextKeys.readOnly = new RawContextKey('editorReadonly', false, nls.localize('editorReadonly', \"Whether the editor is read only\"));\n    EditorContextKeys.inDiffEditor = new RawContextKey('inDiffEditor', false, nls.localize('inDiffEditor', \"Whether the context is a diff editor\"));\n    EditorContextKeys.columnSelection = new RawContextKey('editorColumnSelection', false, nls.localize('editorColumnSelection', \"Whether `editor.columnSelection` is enabled\"));\n    EditorContextKeys.writable = EditorContextKeys.readOnly.toNegated();\n    EditorContextKeys.hasNonEmptySelection = new RawContextKey('editorHasSelection', false, nls.localize('editorHasSelection', \"Whether the editor has text selected\"));\n    EditorContextKeys.hasOnlyEmptySelection = EditorContextKeys.hasNonEmptySelection.toNegated();\n    EditorContextKeys.hasMultipleSelections = new RawContextKey('editorHasMultipleSelections', false, nls.localize('editorHasMultipleSelections', \"Whether the editor has multiple selections\"));\n    EditorContextKeys.hasSingleSelection = EditorContextKeys.hasMultipleSelections.toNegated();\n    EditorContextKeys.tabMovesFocus = new RawContextKey('editorTabMovesFocus', false, nls.localize('editorTabMovesFocus', \"Whether `Tab` will move focus out of the editor\"));\n    EditorContextKeys.tabDoesNotMoveFocus = EditorContextKeys.tabMovesFocus.toNegated();\n    EditorContextKeys.isInWalkThroughSnippet = new RawContextKey('isInEmbeddedEditor', false, true);\n    EditorContextKeys.canUndo = new RawContextKey('canUndo', false, true);\n    EditorContextKeys.canRedo = new RawContextKey('canRedo', false, true);\n    EditorContextKeys.hoverVisible = new RawContextKey('editorHoverVisible', false, nls.localize('editorHoverVisible', \"Whether the editor hover is visible\"));\n    /**\n     * A context key that is set when an editor is part of a larger editor, like notebooks or\n     * (future) a diff editor\n     */\n    EditorContextKeys.inCompositeEditor = new RawContextKey('inCompositeEditor', undefined, nls.localize('inCompositeEditor', \"Whether the editor is part of a larger editor (e.g. notebooks)\"));\n    EditorContextKeys.notInCompositeEditor = EditorContextKeys.inCompositeEditor.toNegated();\n    // -- mode context keys\n    EditorContextKeys.languageId = new RawContextKey('editorLangId', '', nls.localize('editorLangId', \"The language identifier of the editor\"));\n    EditorContextKeys.hasCompletionItemProvider = new RawContextKey('editorHasCompletionItemProvider', false, nls.localize('editorHasCompletionItemProvider', \"Whether the editor has a completion item provider\"));\n    EditorContextKeys.hasCodeActionsProvider = new RawContextKey('editorHasCodeActionsProvider', false, nls.localize('editorHasCodeActionsProvider', \"Whether the editor has a code actions provider\"));\n    EditorContextKeys.hasCodeLensProvider = new RawContextKey('editorHasCodeLensProvider', false, nls.localize('editorHasCodeLensProvider', \"Whether the editor has a code lens provider\"));\n    EditorContextKeys.hasDefinitionProvider = new RawContextKey('editorHasDefinitionProvider', false, nls.localize('editorHasDefinitionProvider', \"Whether the editor has a definition provider\"));\n    EditorContextKeys.hasDeclarationProvider = new RawContextKey('editorHasDeclarationProvider', false, nls.localize('editorHasDeclarationProvider', \"Whether the editor has a declaration provider\"));\n    EditorContextKeys.hasImplementationProvider = new RawContextKey('editorHasImplementationProvider', false, nls.localize('editorHasImplementationProvider', \"Whether the editor has an implementation provider\"));\n    EditorContextKeys.hasTypeDefinitionProvider = new RawContextKey('editorHasTypeDefinitionProvider', false, nls.localize('editorHasTypeDefinitionProvider', \"Whether the editor has a type definition provider\"));\n    EditorContextKeys.hasHoverProvider = new RawContextKey('editorHasHoverProvider', false, nls.localize('editorHasHoverProvider', \"Whether the editor has a hover provider\"));\n    EditorContextKeys.hasDocumentHighlightProvider = new RawContextKey('editorHasDocumentHighlightProvider', false, nls.localize('editorHasDocumentHighlightProvider', \"Whether the editor has a document highlight provider\"));\n    EditorContextKeys.hasDocumentSymbolProvider = new RawContextKey('editorHasDocumentSymbolProvider', false, nls.localize('editorHasDocumentSymbolProvider', \"Whether the editor has a document symbol provider\"));\n    EditorContextKeys.hasReferenceProvider = new RawContextKey('editorHasReferenceProvider', false, nls.localize('editorHasReferenceProvider', \"Whether the editor has a reference provider\"));\n    EditorContextKeys.hasRenameProvider = new RawContextKey('editorHasRenameProvider', false, nls.localize('editorHasRenameProvider', \"Whether the editor has a rename provider\"));\n    EditorContextKeys.hasSignatureHelpProvider = new RawContextKey('editorHasSignatureHelpProvider', false, nls.localize('editorHasSignatureHelpProvider', \"Whether the editor has a signature help provider\"));\n    EditorContextKeys.hasInlayHintsProvider = new RawContextKey('editorHasInlayHintsProvider', false, nls.localize('editorHasInlayHintsProvider', \"Whether the editor has an inline hints provider\"));\n    // -- mode context keys: formatting\n    EditorContextKeys.hasDocumentFormattingProvider = new RawContextKey('editorHasDocumentFormattingProvider', false, nls.localize('editorHasDocumentFormattingProvider', \"Whether the editor has a document formatting provider\"));\n    EditorContextKeys.hasDocumentSelectionFormattingProvider = new RawContextKey('editorHasDocumentSelectionFormattingProvider', false, nls.localize('editorHasDocumentSelectionFormattingProvider', \"Whether the editor has a document selection formatting provider\"));\n    EditorContextKeys.hasMultipleDocumentFormattingProvider = new RawContextKey('editorHasMultipleDocumentFormattingProvider', false, nls.localize('editorHasMultipleDocumentFormattingProvider', \"Whether the editor has multiple document formatting providers\"));\n    EditorContextKeys.hasMultipleDocumentSelectionFormattingProvider = new RawContextKey('editorHasMultipleDocumentSelectionFormattingProvider', false, nls.localize('editorHasMultipleDocumentSelectionFormattingProvider', \"Whether the editor has multiple document selection formatting providers\"));\n})(EditorContextKeys || (EditorContextKeys = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class EditorTheme {\n    constructor(theme) {\n        this._theme = theme;\n    }\n    get type() {\n        return this._theme.type;\n    }\n    get value() {\n        return this._theme;\n    }\n    update(theme) {\n        this._theme = theme;\n    }\n    getColor(color) {\n        return this._theme.getColor(color);\n    }\n}\n"],"names":["CharacterClassifier","_defaultValue","defaultValue","toUint8","this","_asciiMap","_createAsciiMap","_map","Map","charCode","_value","value","set","get","asciiMap","Uint8Array","i","CharacterSet","_actual","CursorColumns","codePoint","visibleColumn","tabSize","nextRenderTabStop","strings","lineContent","column","textLen","Math","min","length","text","substring","iterator","result","eol","offset","nextGraphemeLength","_nextVisibleColumn","lineContentLength","beforeVisibleColumn","beforeColumn","afterVisibleColumn","afterColumn","indentSize","max","EditOperation","position","range","Range","lineNumber","forceMoveMarkers","editorLineHighlight","registerColor","dark","light","hcDark","hcLight","nls","editorLineHighlightBorder","contrastBorder","editorRangeHighlight","editorRangeHighlightBorder","activeContrastBorder","editorSymbolHighlight","editorFindMatchHighlight","editorSymbolHighlightBorder","editorCursorForeground","Color","editorCursorBackground","editorWhitespaces","editorIndentGuides","editorActiveIndentGuides","editorLineNumbers","deprecatedEditorActiveLineNumber","editorActiveLineNumber","editorRuler","editorBracketMatchBackground","editorBracketMatchBorder","editorOverviewRulerBorder","editorOverviewRulerBackground","editorGutter","editorBackground","editorUnnecessaryCodeBorder","transparent","editorUnnecessaryCodeOpacity","ghostTextBorder","ghostTextForeground","ghostTextBackground","rulerRangeDefault","RGBA","overviewRulerRangeHighlight","overviewRulerError","overviewRulerWarning","editorWarningForeground","editorWarningBorder","overviewRulerInfo","editorInfoForeground","editorInfoBorder","editorBracketHighlightingForeground1","editorBracketHighlightingForeground2","editorBracketHighlightingForeground3","editorBracketHighlightingForeground4","editorBracketHighlightingForeground5","editorBracketHighlightingForeground6","editorBracketHighlightingUnexpectedBracketForeground","editorBracketPairGuideBackground1","editorBracketPairGuideBackground2","editorBracketPairGuideBackground3","editorBracketPairGuideBackground4","editorBracketPairGuideBackground5","editorBracketPairGuideBackground6","editorBracketPairGuideActiveBackground1","editorBracketPairGuideActiveBackground2","editorBracketPairGuideActiveBackground3","editorBracketPairGuideActiveBackground4","editorBracketPairGuideActiveBackground5","editorBracketPairGuideActiveBackground6","registerThemingParticipant","theme","collector","background","getColor","addRule","lineHighlight","imeBackground","isTransparent","foreground","editorForeground","gutter","rangeHighlight","rangeHighlightBorder","isHighContrast","type","symbolHighlight","symbolHighlightBorder","invisibles","countEOL","eolCount","firstLineLength","lastLineStart","len","chr","charCodeAt","normalizeIndentation","str","insertSpaces","firstNonWhitespaceIndex","spacesCnt","charAt","tabsCnt","floor","_normalizeIndentationFromWhitespace","Position","newLineNumber","newColumn","deltaLineNumber","deltaColumn","with","other","equals","isBefore","isBeforeOrEqual","a","b","aLineNumber","bLineNumber","pos","obj","startLineNumber","startColumn","endLineNumber","endColumn","isEmpty","containsPosition","containsRange","strictContainsRange","plusRange","intersectRanges","equalsRange","getEndPosition","getStartPosition","collapseToStart","otherRange","resultStartLineNumber","resultStartColumn","resultEndLineNumber","resultEndColumn","otherStartLineNumber","otherStartColumn","otherEndLineNumber","otherEndColumn","start","end","aStartLineNumber","bStartLineNumber","aStartColumn","bStartColumn","aEndLineNumber","bEndLineNumber","RGBA8","r","g","_rgba8Brand","undefined","_clamp","c","Empty","Selection","selectionStartLineNumber","selectionStartColumn","positionLineNumber","positionColumn","selectionsEqual","getDirection","direction","sel","_utf16LE_TextDecoder","_utf16BE_TextDecoder","_platformTextDecoder","getUTF16LE_TextDecoder","TextDecoder","getPlatformTextDecoder","platform","createStringBuilder","decodeUTF16LE","hasTextDecoder","compatDecodeUTF16LE","source","resultLen","buffer","String","fromCharCode","join","capacity","StringBuilder","view","Uint16Array","decode","CompatStringBuilder","_capacity","_buffer","_completedStrings","_bufferLength","_flushBuffer","_buildBuffer","bufferString","remainingSpace","strLen","_pieces","_piecesLen","escapeNewLine","replace","TextChange","oldPosition","oldText","newPosition","newText","_writeStringSize","_writeString","dest","_readString","push","compressConsecutiveTextChanges","prevEdits","currEdits","TextChangeCompressor","compress","_prevEdits","_currEdits","_result","_resultLen","_prevLen","_prevDeltaOffset","_currLen","_currDeltaOffset","prevIndex","currIndex","prevEdit","_getPrev","currEdit","_getCurr","oldEnd","_acceptCurr","newEnd","_acceptPrev","_splitCurr","e1","e2","_splitPrev","mergePrev","mergeCurr","oldLength","newLength","merged","_merge","_removeNoOps","_rebaseCurr","_rebasePrev","prevDeltaOffset","currDeltaOffset","edit","preText","substr","postText","edits","prev","curr","EDITOR_MODEL_DEFAULTS","detectIndentation","trimAutoWhitespace","largeFileOptimizations","bracketPairColorizationOptions","enabled","independentColorPoolPerBracketType","WordCharacterClassifier","wordSeparators","getMapForWordSeparators","computeFn","cache","input","hasOwnProperty","once","USUAL_WORD_SEPARATORS","DEFAULT_WORD_REGEXP","allowInWords","sep","indexOf","RegExp","createWordRegExp","ensureValidWordDefinition","wordDefinition","global","flags","ignoreCase","multiline","unicode","lastIndex","_defaultConfig","LinkedList","getWordAtText","textOffset","config","Iterable","maxLen","t1","Date","now","prevRegexIndex","match","timeBudget","regexIndex","windowSize","thisMatch","_findRegexMatchEnclosingPosition","word","index","stopPos","exec","matchIndex","unshift","Cursor","context","_selTrackedRange","_trackSelection","_setState","SingleCursorState","_removeTrackedRange","_updateTrackedRange","model","_setTrackedRange","modelState","selection","CursorState","viewState","_getTrackedRange","_validateViewState","viewModel","selectionStart","validateRange","selectionStartLeftoverVisibleColumns","validatePosition","leftoverVisibleColumns","coordinatesConverter","convertViewRangeToModelRange","convertViewPositionToModelPosition","viewSelectionStart","validateViewRange","viewPosition","validateViewPosition","viewSelectionStart1","convertModelPositionToViewPosition","viewSelectionStart2","cacheInput","cacheOutput","normalizePosition","sStartPosition","sEndPosition","validPosition","validSStartPosition","_validatePositionWithCache","validSEndPosition","CursorCollection","cursors","lastAddedCursorIndex","dispose","startTrackingSelection","stopTrackingSelection","ensureValidState","map","readSelectionFromMarkers","asCursorState","findMinBy","compareBy","findLastMaxBy","selections","setStates","states","setState","_setSecondaryStates","slice","secondaryStates","secondaryCursorsLength","secondaryStatesLength","createCnt","_addSecondaryCursor","removeCnt","_removeSecondaryCursor","removeIndex","splice","sortedCursors","sort","s","sortedCursorIndex","current","next","currentSelection","nextSelection","cursorConfig","multiCursorMergeOverlapping","winnerSortedCursorIndex","looserSortedCursorIndex","looserIndex","winnerIndex","looserSelection","winnerSelection","equalsSelection","resultingRange","looserSelectionIsLTR","winnerSelectionIsLTR","resultingSelectionIsLTR","resultingSelection","resultingState","sortedCursor","CursorContext","_cursorContextBrand","CursorsController","_model","_knownModelVersionId","getVersionId","_viewModel","_coordinatesConverter","_cursors","_hasFocus","_isHandling","_compositionState","_columnSelectData","_autoClosedActions","_prevEditOperationType","updateContext","eventsCollector","getCursorStates","hasFocus","getSelections","autoClosedAction","isValid","getPrimaryCursor","getLastAddedCursorIndex","getAll","reason","reachedMaxCursorCount","MAX_CURSOR_COUNT","oldState","CursorModelState","from","normalize","_validateAutoClosedActions","_emitStateChangedIfNecessary","columnSelectData","minimalReveal","verticalType","revealHorizontal","scrollType","viewPositions","getViewPositions","revealViewRange","revealViewSelections","getViewSelections","emitViewEvent","ViewRevealRangeRequestEvent","inSelectionMode","desiredSelections","state","revealPrimary","event","ModelInjectedTextChangedEvent","e","rawContentChangedEvent","versionId","hadFlushEvent","containsEvent","cursorState","isUndoing","isRedoing","selectionsFromMarkers","getTopMostViewPosition","getBottomMostViewPosition","primaryCursor","isReal","fromViewLineNumber","fromViewVisualColumn","visibleColumnFromColumn","toViewLineNumber","toViewVisualColumn","autoClosedCharactersRanges","autoClosedEnclosingRanges","autoClosedCharactersDeltaDecorations","autoClosedEnclosingDeltaDecorations","options","description","inlineClassName","stickiness","autoClosedCharactersDecorations","deltaDecorations","autoClosedEnclosingDecorations","AutoClosedAction","opResult","shouldPushStackElementBefore","pushStackElement","CommandExecutor","executeCommands","commands","_interpretCommandResult","command","TypeWithAutoClosingCommand","enclosingRange","closeCharacterRange","_pushAutoClosedAction","shouldPushStackElementAfter","setSelections","newState","viewSelections","ViewCursorStateChangedEvent","some","newCursorState","oldSelections","oldModelVersionId","modelVersionId","emitOutgoingEvent","CursorStateChangedEvent","indices","m","closeChar","autoClosingPairsCandidates","autoClosingPairs","autoClosingPairsCloseSingleChar","openChar","open","closeCharIndex","openCharIndex","lastIndexOf","cursorStateComputer","autoClosingIndices","_findAutoClosingPairs","_isTracked","pushEditOperations","undoEdits","openCharInnerIndex","closeCharInnerIndex","undoEdit","callback","cursorChangeReason","readOnly","stopTrackingSelections","err","onUnexpectedError","startTrackingSelections","getAllAutoClosedCharacters","CompositionState","compositionOutcome","deduceOutcome","_executeEdit","_executeEditOperation","TypeOperations","getAutoClosedCharacters","charLength","replacePrevCharCnt","replaceNextCharCnt","positionDelta","newSelections","getPosition","pasteOnNewLine","multicursorText","DeleteOperations","killSecondaryCursors","EditOperationResult","Disposable","cursor","_autoClosedCharactersDecorations","_autoClosedEnclosingDecorations","decorationRange","getDecorationRange","enclosingRanges","autoClosedActions","autoClosedCharacters","concat","getAutoClosedCharactersRanges","selectionsBefore","ctx","trackedRanges","trackedRangesDirection","_innerExecuteCommands","_arrayIsEmpty","commandsData","_getEditOperations","operations","rawOperations","loserCursorsMap","_getLoserCursorMap","console","warn","filteredOperations","identifier","major","toString","hadTrackedEditOperation","selectionsAfter","inverseEditOperations","groupedInverseEditOperations","op","minorBasedSorter","minor","cursorSelections","computeCursorState","getInverseEditOperations","getTrackedSelection","id","idx","parseInt","losingCursors","losingCursorIndex","losingCursor","_getEditOperationsFromCommand","majorIdentifier","operationMinor","addEditOperation","isAutoWhitespaceEdit","insertsAutoWhitespace","editOperationBuilder","addTrackedEditOperation","trackSelection","_selection","trackPreviousOnEmpty","maxLineColumn","getLineMaxColumn","l","getEditOperations","previousOp","currentOp","loserMajor","j","CompositionLineState","startSelection","endSelection","textModel","_original","_capture","_deduceOutcome","getLineContent","original","commonPrefix","commonSuffix","deletedText","insertedText","CompositionOutcome","AtomicTabMoveOperations","lineLength","prevTabStopPosition","prevTabStopVisibleColumn","left","whitespaceVisibleColumn","currentVisibleColumn","targetVisibleColumn","ColumnSelection","fromLineNumber","fromVisibleColumn","toLineNumber","toVisibleColumn","lineCount","abs","reversed","isRTL","isLTR","columnFromVisibleColumn","visibleStartColumn","visibleEndColumn","maxColumn","viewStates","fromVisualColumn","toVisualColumn","prevColumnSelectData","columnSelect","maxVisualViewColumn","minViewLineNumber","maxViewLineNumber","lineMaxViewColumn","lineMaxVisualViewColumn","isPaged","linesCount","pageSize","getLineCount","prevEditOperationType","deleteSelection","rightOfPosition","MoveOperations","ReplaceCommand","autoClosingDelete","autoClosingBrackets","autoClosingQuotes","autoClosingPairsOpen","lineText","character","autoClosingPairCandidates","isQuote","afterCharacter","foundAutoClosingPair","autoClosingPairCandidate","close","found","lenJ","autoClosedCharacter","isAutoClosingPairDelete","autoClosingPairsOpenByEnd","_runAutoClosingPairDelete","deleteRange","getDeleteRange","useTabStops","lastIndentationColumn","toColumn","getPositionAfterDeleteLeft","newLine","lastCutRange","emptySelectionClipboard","CursorMove","CursorMoveCommands","useLogicalLine","_moveToLineStart","currentViewStateColumn","isFirstLineOfWrappedLine","currentViewStatelineNumber","firstNonBlankColumn","getLineFirstNonWhitespaceColumn","_moveToLineStartByModel","_moveToLineStartByView","sticky","_moveToLineEnd","viewStatePosition","viewModelMaxColumn","isEndOfViewLine","modelStatePosition","modelMaxColumn","isEndLineOfWrappedLine","_moveToLineEndByModel","_moveToLineEndByView","_position","_viewPosition","hasSelection","selectToLineNumber","selectToColumn","enteringLineNumber","move","selectToViewLineNumber","selectToViewColumn","endPositionOfSelectionStart","WordOperations","unit","_moveHalfLineLeft","_moveLeft","_moveHalfLineRight","_moveRight","_moveUpByViewLines","_moveUpByModelLines","_moveDownByViewLines","_moveDownByModelLines","_moveToViewMinColumn","_moveToViewFirstNonWhitespaceColumn","_moveToViewCenterColumn","_moveToViewMaxColumn","_moveToViewLastNonWhitespaceColumn","visibleViewRange","getCompletelyVisibleViewRange","visibleModelRange","modelLineNumber","_firstLineNumberInRange","modelColumn","_moveToModelPosition","_lastLineNumberInRange","round","findPositionInViewportIfOutside","newViewLineNumber","viewLineNumber","count","getLineMinColumn","noOfColumns","halfLine","toViewColumn","toModelLineNumber","toModelColumn","viewColumn","_moveToViewPosition","getLineLastNonWhitespaceColumn","args","name","constraint","arg","types","cursorMoveArg","to","select","by","schema","RawDirection","Left","Right","Up","Down","PrevBlankLine","NextBlankLine","WrappedLineStart","WrappedLineFirstNonWhitespaceCharacter","WrappedLineColumnCenter","WrappedLineEnd","WrappedLineLastNonWhitespaceCharacter","ViewPortTop","ViewPortCenter","ViewPortBottom","ViewPortIfOutside","RawUnit","Line","WrappedLine","Character","HalfLine","parse","CursorPosition","_cursorPositionBrand","delta","getLineIndentColumn","minColumn","leftPosition","stickyTabStops","leftPositionAtomicSoftTabs","normalizedPos","clipPositionColumn","p","clipRange","rightPosition","rightPositionAtomicSoftTabs","right","allowMoveOnEdgeLine","normalizationAffinity","wasOnFirstPosition","wasOnLastPosition","wasAtEdgePosition","allowMoveOnLastLine","vertical","down","allowMoveOnFirstLine","up","_isBlankLine","lastLineNumber","lastColumn","ShiftCommand","isUnshift","autoIndent","languageConfigurationService","indentation","typeSelection","ReplaceCommandThatPreservesSelection","multiCursorPaste","lines","distributedPaste","_distributePasteToCursors","_distributedPaste","_simplePaste","action","expectedIndentAction","getInheritIndentForLine","expectedEnterAction","getEnterAction","appendText","IndentAction","shiftIndent","unshiftIndent","typeText","test","tokenization","isCheapToTokenize","goodIndent","_goodIndentForLine","possibleTypeText","startsWith","_replaceJumpToNextIndent","lineMaxColumn","_compositionType","shouldPushStackElementBetween","getValueInRange","ReplaceCommandWithOffsetCursorState","keepPosition","ReplaceCommandWithoutChangingPosition","_typeCommand","indentAction","normalIndent","increasedIndent","actualIndentation","ir","getIndentForEnter","indent","oldEndViewColumn","oldEndColumn","newLineContent","firstNonWhitespace","setEndPosition","afterEnter","ceil","ch","currentIndentation","getIndentationAtPosition","getIndentActionForType","autoClosingOvertype","has","chIsQuote","lineAfter","nextChar","potentialStartingBraces","autoClosingPairsOpenByStart","potentialClosingBraces","autoClosingPairsCloseByStart","isBeforeStartingBrace","x","isBeforeClosingBrace","positions","candidates","candidate","candidateIsMatch","pair","lastChar","autoClosingPairsCloseByEnd","includes","endsWith","chIsAlreadyTyped","autoCloseConfig","shouldAutoCloseBefore","quote","bracket","_findAutoClosingPairOpen","containedPair","_findContainedAutoClosingPair","containedPairClose","isContainedPairPresent","lineBefore","characterAfter","_isBeforeClosingBrace","characterBefore","forceTokenization","lineTokens","getLineTokens","scopedLineTokens","createScopedLineTokens","shouldAutoClose","firstCharOffset","neutralCharacter","findNeutralCharacter","tokenType","getTokenTypeIfInsertingCharacter","isOK","autoClosingPairClose","autoSurround","_shouldSurroundChar","surroundingPairs","isTypingAQuoteCharacter","selectionContainsOnlyWhitespace","startIndex","endIndex","selectedText","selectionText","closeCharacter","SurroundSelectionCommand","electricChars","electricAction","onElectricCharacter","matchOpenBracket","bracketPairs","findMatchingBracketUp","matchLine","matchLineIndentation","newIndentation","lineFirstNonBlankColumn","getTypingOperation","compositions","composition","hasDeletion","deletedSelectionStart","deletedSelectionEnd","CompositionSurroundSelectionCommand","_isAutoClosingOvertype","_getAutoClosingPairClose","_runAutoClosingOpenCharType","isDoingComposition","_enter","_isAutoIndentType","autoIndentFails","_runAutoIndentType","_runAutoClosingOvertype","_isSurroundSelectionType","_runSurroundSelectionType","_isTypeInterceptorElectricChar","_typeInterceptorElectricChar","opType","openCharacter","insertOpenCharacter","_openCharacter","_closeCharacter","helper","insertedSelectionStart","insertedSelectionEnd","typedText","previousTypingOperation","typingOperation","isTypingOperation","normalizeOperationType","wordType","nextCharClass","_doFindPreviousWordOnLine","chIndex","chCode","chClass","_createWord","_findEndOfWord","_doFindNextWordOnLine","_findStartOfWord","wordNavigationType","prevWordOnLine","_findPreviousWordOnLine","rightRight","movedDown","nextWordOnLine","_findNextWordOnLine","lastNonWhitespace","whitespaceHeuristics","_deleteWordLeftWhitespace","_deleteInsideWordWhitespace","_deleteInsideWordDetermineDeleteRange","leftIndex","_charAtIsWhitespace","rightIndex","touchesWord","createRangeWithPosition","deleteWordAndAdjacentWhitespace","expandedToTheRight","toPosition","_moveWordPartLeft","_findFirstNonWhitespaceChar","_deleteWordRightWhitespace","_moveWordPartRight","_wordSeparators","prevWord","_createWordAtPosition","nextWord","possiblePosition","WordPartOperations","enforceDefined","deleteWordLeft","_deleteWordPartLeft","deleteWordRight","_deleteWordPartRight","moveWordLeft","moveWordRight","arr","filter","el","Boolean","autoCloseAlways","autoCloseNever","autoCloseBeforeWhitespace","CursorConfiguration","languageId","modelOptions","configuration","_cursorMoveConfigurationBrand","_languageId","layoutInfo","lineHeight","height","copyWithSyntaxHighlighting","_electricChars","_getShouldAutoClose","getLanguageConfiguration","getAutoClosingPairs","getSurroundingPairs","_a","electricCharacter","getElectricCharacters","char","electricCharacterSupport","_getLanguageDefinedShouldAutoClose","autoCloseBeforeSet","getAutoCloseBeforeSet","hasChanged","_cursorStateBrand","PartialModelCursorState","PartialViewCursorState","modelSelection","getSelectionStart","fromModelState","modelSelections","fromModelSelection","_singleCursorStateBrand","_computeSelection","opts","_editOperationResultBrand","computeDiff","originalSequence","modifiedSequence","continueProcessingPredicate","pretty","LcsDiff","ComputeDiff","LineSequence","startColumns","endColumns","getFirstNonBlankColumn","getLastNonBlankColumn","_startColumns","_endColumns","elements","shouldIgnoreTrimWhitespace","charCodes","lineNumbers","columns","col","CharSequence","_charCodes","_lineNumbers","_columns","Error","getEndLineNumber","_assertIndex","getStartLineNumber","getEndColumn","getStartColumn","CharChange","originalStartLineNumber","originalStartColumn","originalEndLineNumber","originalEndColumn","modifiedStartLineNumber","modifiedStartColumn","modifiedEndLineNumber","modifiedEndColumn","diffChange","originalCharSequence","modifiedCharSequence","originalStart","originalLength","modifiedStart","modifiedLength","LineChange","charChanges","originalLineSequence","modifiedLineSequence","continueCharDiff","shouldComputeCharChanges","shouldPostProcessCharChanges","createCharSequence","getElements","rawChanges","changes","prevChange","currChange","originalMatchingLength","modifiedMatchingLength","postProcessCharChanges","createFromDiffChange","DiffComputer","originalLines","modifiedLines","shouldMakePrettyDiff","modified","continueLineDiff","createContinueProcessingPredicate","maxComputationTime","quitEarly","diffResult","lineChanges","createFromDiffResult","originalLineIndex","modifiedLineIndex","nextChange","originalStop","modifiedStop","originalLine","modifiedLine","_pushTrimWhitespaceCharChange","originalMaxColumn","modifiedMaxColumn","originalLineNumber","modifiedLineNumber","_mergeTrimWhitespaceCharChange","txt","maximumRuntime","startTime","InternalEditorAction","label","alias","precondition","run","contextKeyService","_precondition","_run","_contextKeyService","contextMatchesRules","isSupported","Promise","resolve","EditorType","ICodeEditor","IDiffEditor","EditorContextKeys","editorSimpleInput","RawContextKey","editorTextFocus","focus","textInputFocus","inDiffEditor","columnSelection","writable","toNegated","hasNonEmptySelection","hasOnlyEmptySelection","hasMultipleSelections","hasSingleSelection","tabMovesFocus","tabDoesNotMoveFocus","isInWalkThroughSnippet","canUndo","canRedo","hoverVisible","inCompositeEditor","notInCompositeEditor","hasCompletionItemProvider","hasCodeActionsProvider","hasCodeLensProvider","hasDefinitionProvider","hasDeclarationProvider","hasImplementationProvider","hasTypeDefinitionProvider","hasHoverProvider","hasDocumentHighlightProvider","hasDocumentSymbolProvider","hasReferenceProvider","hasRenameProvider","hasSignatureHelpProvider","hasInlayHintsProvider","hasDocumentFormattingProvider","hasDocumentSelectionFormattingProvider","hasMultipleDocumentFormattingProvider","hasMultipleDocumentSelectionFormattingProvider","EditorTheme","_theme","color"],"sourceRoot":""}