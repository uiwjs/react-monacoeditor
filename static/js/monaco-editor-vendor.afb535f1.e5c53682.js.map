{"version":3,"file":"static/js/monaco-editor-vendor.afb535f1.e5c53682.js","mappings":"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","sources":["../../node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js","../../node_modules/monaco-editor/esm/vs/editor/common/diff/smartLinesDiffComputer.js","../../node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/diffAlgorithm.js","../../node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/utils.js","../../node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/dynamicProgrammingDiffing.js","../../node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/joinSequenceDiffs.js","../../node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/myersDiffAlgorithm.js","../../node_modules/monaco-editor/esm/vs/editor/common/diff/standardLinesDiffComputer.js","../../node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js","../../node_modules/monaco-editor/esm/vs/editor/common/editorAction.js","../../node_modules/monaco-editor/esm/vs/editor/common/editorCommon.js","../../node_modules/monaco-editor/esm/vs/editor/common/editorContextKeys.js","../../node_modules/monaco-editor/esm/vs/editor/common/editorFeatures.js","../../node_modules/monaco-editor/esm/vs/editor/common/editorTheme.js","../../node_modules/monaco-editor/esm/vs/editor/common/encodedTokenAttributes.js","../../node_modules/monaco-editor/esm/vs/editor/common/languageSelector.js","../../node_modules/monaco-editor/esm/vs/editor/common/languageFeatureRegistry.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/autoIndent.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/defaultDocumentColorsComputer.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/enterAction.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/language.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/characterPair.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/electricCharacter.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/indentRules.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/onEnter.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/languageBracketsConfiguration.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfigurationRegistry.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/modesRegistry.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/nullTokenize.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/richEditBrackets.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/tokenization.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/textToHtmlTokenizer.js","../../node_modules/monaco-editor/esm/vs/editor/common/model.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/nodeReader.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/fixBrackets.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/editStack.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/fixedArray.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/guidesTextModelPart.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/indentationGuesser.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js","../../node_modules/monaco-editor/esm/vs/editor/common/modelLineProjectionData.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineRange } from '../core/lineRange.js';\nexport class LinesDiff {\n    constructor(changes, \n    /**\n     * Indicates if the time out was reached.\n     * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n     */\n    hitTimeout) {\n        this.changes = changes;\n        this.hitTimeout = hitTimeout;\n    }\n}\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n */\nexport class LineRangeMapping {\n    static inverse(mapping, originalLineCount, modifiedLineCount) {\n        const result = [];\n        let lastOriginalEndLineNumber = 1;\n        let lastModifiedEndLineNumber = 1;\n        for (const m of mapping) {\n            const r = new LineRangeMapping(new LineRange(lastOriginalEndLineNumber, m.originalRange.startLineNumber), new LineRange(lastModifiedEndLineNumber, m.modifiedRange.startLineNumber), undefined);\n            if (!r.modifiedRange.isEmpty) {\n                result.push(r);\n            }\n            lastOriginalEndLineNumber = m.originalRange.endLineNumberExclusive;\n            lastModifiedEndLineNumber = m.modifiedRange.endLineNumberExclusive;\n        }\n        const r = new LineRangeMapping(new LineRange(lastOriginalEndLineNumber, originalLineCount + 1), new LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1), undefined);\n        if (!r.modifiedRange.isEmpty) {\n            result.push(r);\n        }\n        return result;\n    }\n    constructor(originalRange, modifiedRange, innerChanges) {\n        this.originalRange = originalRange;\n        this.modifiedRange = modifiedRange;\n        this.innerChanges = innerChanges;\n    }\n    toString() {\n        return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;\n    }\n    get changedLineCount() {\n        return Math.max(this.originalRange.length, this.modifiedRange.length);\n    }\n}\n/**\n * Maps a range in the original text model to a range in the modified text model.\n */\nexport class RangeMapping {\n    constructor(originalRange, modifiedRange) {\n        this.originalRange = originalRange;\n        this.modifiedRange = modifiedRange;\n    }\n    toString() {\n        return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../base/common/diff/diff.js';\nimport { RangeMapping, LineRangeMapping, LinesDiff } from './linesDiffComputer.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Range } from '../core/range.js';\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { LineRange } from '../core/lineRange.js';\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\nexport class SmartLinesDiffComputer {\n    computeDiff(originalLines, modifiedLines, options) {\n        var _a;\n        const diffComputer = new DiffComputer(originalLines, modifiedLines, {\n            maxComputationTime: options.maxComputationTimeMs,\n            shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,\n            shouldComputeCharChanges: true,\n            shouldMakePrettyDiff: true,\n            shouldPostProcessCharChanges: true,\n        });\n        const result = diffComputer.computeDiff();\n        const changes = [];\n        let lastChange = null;\n        for (const c of result.changes) {\n            let originalRange;\n            if (c.originalEndLineNumber === 0) {\n                // Insertion\n                originalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);\n            }\n            else {\n                originalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);\n            }\n            let modifiedRange;\n            if (c.modifiedEndLineNumber === 0) {\n                // Deletion\n                modifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);\n            }\n            else {\n                modifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);\n            }\n            let change = new LineRangeMapping(originalRange, modifiedRange, (_a = c.charChanges) === null || _a === void 0 ? void 0 : _a.map(c => new RangeMapping(new Range(c.originalStartLineNumber, c.originalStartColumn, c.originalEndLineNumber, c.originalEndColumn), new Range(c.modifiedStartLineNumber, c.modifiedStartColumn, c.modifiedEndLineNumber, c.modifiedEndColumn))));\n            if (lastChange) {\n                if (lastChange.modifiedRange.endLineNumberExclusive === change.modifiedRange.startLineNumber\n                    || lastChange.originalRange.endLineNumberExclusive === change.originalRange.startLineNumber) {\n                    // join touching diffs. Probably moving diffs up/down in the algorithm causes touching diffs.\n                    change = new LineRangeMapping(lastChange.originalRange.join(change.originalRange), lastChange.modifiedRange.join(change.modifiedRange), lastChange.innerChanges && change.innerChanges ?\n                        lastChange.innerChanges.concat(change.innerChanges) : undefined);\n                    changes.pop();\n                }\n            }\n            changes.push(change);\n            lastChange = change;\n        }\n        assertFn(() => {\n            return checkAdjacentItems(changes, (m1, m2) => m2.originalRange.startLineNumber - m1.originalRange.endLineNumberExclusive === m2.modifiedRange.startLineNumber - m1.modifiedRange.endLineNumberExclusive &&\n                // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n                m1.originalRange.endLineNumberExclusive < m2.originalRange.startLineNumber &&\n                m1.modifiedRange.endLineNumberExclusive < m2.modifiedRange.startLineNumber);\n        });\n        return new LinesDiff(changes, result.quitEarly);\n    }\n}\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n    return diffAlgo.ComputeDiff(pretty);\n}\nclass LineSequence {\n    constructor(lines) {\n        const startColumns = [];\n        const endColumns = [];\n        for (let i = 0, length = lines.length; i < length; i++) {\n            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n            endColumns[i] = getLastNonBlankColumn(lines[i], 1);\n        }\n        this.lines = lines;\n        this._startColumns = startColumns;\n        this._endColumns = endColumns;\n    }\n    getElements() {\n        const elements = [];\n        for (let i = 0, len = this.lines.length; i < len; i++) {\n            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n        }\n        return elements;\n    }\n    getStrictElement(index) {\n        return this.lines[index];\n    }\n    getStartLineNumber(i) {\n        return i + 1;\n    }\n    getEndLineNumber(i) {\n        return i + 1;\n    }\n    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\n        const charCodes = [];\n        const lineNumbers = [];\n        const columns = [];\n        let len = 0;\n        for (let index = startIndex; index <= endIndex; index++) {\n            const lineContent = this.lines[index];\n            const startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\n            const endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\n            for (let col = startColumn; col < endColumn; col++) {\n                charCodes[len] = lineContent.charCodeAt(col - 1);\n                lineNumbers[len] = index + 1;\n                columns[len] = col;\n                len++;\n            }\n            if (!shouldIgnoreTrimWhitespace && index < endIndex) {\n                // Add \\n if trim whitespace is not ignored\n                charCodes[len] = 10 /* CharCode.LineFeed */;\n                lineNumbers[len] = index + 1;\n                columns[len] = lineContent.length + 1;\n                len++;\n            }\n        }\n        return new CharSequence(charCodes, lineNumbers, columns);\n    }\n}\nclass CharSequence {\n    constructor(charCodes, lineNumbers, columns) {\n        this._charCodes = charCodes;\n        this._lineNumbers = lineNumbers;\n        this._columns = columns;\n    }\n    toString() {\n        return ('[' + this._charCodes.map((s, idx) => (s === 10 /* CharCode.LineFeed */ ? '\\\\n' : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(', ') + ']');\n    }\n    _assertIndex(index, arr) {\n        if (index < 0 || index >= arr.length) {\n            throw new Error(`Illegal index`);\n        }\n    }\n    getElements() {\n        return this._charCodes;\n    }\n    getStartLineNumber(i) {\n        if (i > 0 && i === this._lineNumbers.length) {\n            // the start line number of the element after the last element\n            // is the end line number of the last element\n            return this.getEndLineNumber(i - 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        return this._lineNumbers[i];\n    }\n    getEndLineNumber(i) {\n        if (i === -1) {\n            // the end line number of the element before the first element\n            // is the start line number of the first element\n            return this.getStartLineNumber(i + 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return this._lineNumbers[i] + 1;\n        }\n        return this._lineNumbers[i];\n    }\n    getStartColumn(i) {\n        if (i > 0 && i === this._columns.length) {\n            // the start column of the element after the last element\n            // is the end column of the last element\n            return this.getEndColumn(i - 1);\n        }\n        this._assertIndex(i, this._columns);\n        return this._columns[i];\n    }\n    getEndColumn(i) {\n        if (i === -1) {\n            // the end column of the element before the first element\n            // is the start column of the first element\n            return this.getStartColumn(i + 1);\n        }\n        this._assertIndex(i, this._columns);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return 1;\n        }\n        return this._columns[i] + 1;\n    }\n}\nclass CharChange {\n    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalStartColumn = originalStartColumn;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.originalEndColumn = originalEndColumn;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedStartColumn = modifiedStartColumn;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.modifiedEndColumn = modifiedEndColumn;\n    }\n    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\n        const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n        const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n        const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n        const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n        const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n        const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\n    }\n}\nfunction postProcessCharChanges(rawChanges) {\n    if (rawChanges.length <= 1) {\n        return rawChanges;\n    }\n    const result = [rawChanges[0]];\n    let prevChange = result[0];\n    for (let i = 1, len = rawChanges.length; i < len; i++) {\n        const currChange = rawChanges[i];\n        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n        // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n            // Merge the current change into the previous one\n            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n        }\n        else {\n            // Add the current change\n            result.push(currChange);\n            prevChange = currChange;\n        }\n    }\n    return result;\n}\nclass LineChange {\n    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.charChanges = charChanges;\n    }\n    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\n        let originalStartLineNumber;\n        let originalEndLineNumber;\n        let modifiedStartLineNumber;\n        let modifiedEndLineNumber;\n        let charChanges = undefined;\n        if (diffChange.originalLength === 0) {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n            originalEndLineNumber = 0;\n        }\n        else {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        }\n        if (diffChange.modifiedLength === 0) {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n            modifiedEndLineNumber = 0;\n        }\n        else {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        }\n        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n            // Compute character changes for diff chunks of at most 20 lines...\n            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n            if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {\n                let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n                if (shouldPostProcessCharChanges) {\n                    rawChanges = postProcessCharChanges(rawChanges);\n                }\n                charChanges = [];\n                for (let i = 0, length = rawChanges.length; i < length; i++) {\n                    charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n                }\n            }\n        }\n        return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n    }\n}\nexport class DiffComputer {\n    constructor(originalLines, modifiedLines, opts) {\n        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n        this.originalLines = originalLines;\n        this.modifiedLines = modifiedLines;\n        this.original = new LineSequence(originalLines);\n        this.modified = new LineSequence(modifiedLines);\n        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n    }\n    computeDiff() {\n        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n            // empty original => fast path\n            if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n                return {\n                    quitEarly: false,\n                    changes: []\n                };\n            }\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: 1,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: this.modified.lines.length,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n            // empty modified => fast path\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: this.original.lines.length,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: 1,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n        const rawChanges = diffResult.changes;\n        const quitEarly = diffResult.quitEarly;\n        // The diff is always computed with ignoring trim whitespace\n        // This ensures we get the prettiest diff\n        if (this.shouldIgnoreTrimWhitespace) {\n            const lineChanges = [];\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\n                lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n            }\n            return {\n                quitEarly: quitEarly,\n                changes: lineChanges\n            };\n        }\n        // Need to post-process and introduce changes where the trim whitespace is different\n        // Note that we are looping starting at -1 to also cover the lines before the first change\n        const result = [];\n        let originalLineIndex = 0;\n        let modifiedLineIndex = 0;\n        for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n            const nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\n            const originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\n            const modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\n            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n                const originalLine = this.originalLines[originalLineIndex];\n                const modifiedLine = this.modifiedLines[modifiedLineIndex];\n                if (originalLine !== modifiedLine) {\n                    // These lines differ only in trim whitespace\n                    // Check the leading whitespace\n                    {\n                        let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n                        let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {\n                            const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n                            const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalStartColumn--;\n                            modifiedStartColumn--;\n                        }\n                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n                        }\n                    }\n                    // Check the trailing whitespace\n                    {\n                        let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n                        let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n                        const originalMaxColumn = originalLine.length + 1;\n                        const modifiedMaxColumn = modifiedLine.length + 1;\n                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n                            const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n                            const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalEndColumn++;\n                            modifiedEndColumn++;\n                        }\n                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n                        }\n                    }\n                }\n                originalLineIndex++;\n                modifiedLineIndex++;\n            }\n            if (nextChange) {\n                // Emit the actual change\n                result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n                originalLineIndex += nextChange.originalLength;\n                modifiedLineIndex += nextChange.modifiedLength;\n            }\n        }\n        return {\n            quitEarly: quitEarly,\n            changes: result\n        };\n    }\n    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n            // Merged into previous\n            return;\n        }\n        let charChanges = undefined;\n        if (this.shouldComputeCharChanges) {\n            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\n        }\n        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\n    }\n    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        const len = result.length;\n        if (len === 0) {\n            return false;\n        }\n        const prevChange = result[len - 1];\n        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n            // Don't merge with inserts/deletes\n            return false;\n        }\n        if (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n            prevChange.originalEndLineNumber = originalLineNumber;\n            prevChange.modifiedEndLineNumber = modifiedLineNumber;\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        return false;\n    }\n}\nfunction getFirstNonBlankColumn(txt, defaultValue) {\n    const r = strings.firstNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 1;\n}\nfunction getLastNonBlankColumn(txt, defaultValue) {\n    const r = strings.lastNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 2;\n}\nfunction createContinueProcessingPredicate(maximumRuntime) {\n    if (maximumRuntime === 0) {\n        return () => true;\n    }\n    const startTime = Date.now();\n    return () => {\n        return Date.now() - startTime < maximumRuntime;\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nexport class DiffAlgorithmResult {\n    static trivial(seq1, seq2) {\n        return new DiffAlgorithmResult([new SequenceDiff(new OffsetRange(0, seq1.length), new OffsetRange(0, seq2.length))], false);\n    }\n    static trivialTimedOut(seq1, seq2) {\n        return new DiffAlgorithmResult([new SequenceDiff(new OffsetRange(0, seq1.length), new OffsetRange(0, seq2.length))], true);\n    }\n    constructor(diffs, \n    /**\n     * Indicates if the time out was reached.\n     * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n     */\n    hitTimeout) {\n        this.diffs = diffs;\n        this.hitTimeout = hitTimeout;\n    }\n}\nexport class SequenceDiff {\n    constructor(seq1Range, seq2Range) {\n        this.seq1Range = seq1Range;\n        this.seq2Range = seq2Range;\n    }\n    reverse() {\n        return new SequenceDiff(this.seq2Range, this.seq1Range);\n    }\n    toString() {\n        return `${this.seq1Range} <-> ${this.seq2Range}`;\n    }\n    join(other) {\n        return new SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range));\n    }\n}\nexport class InfiniteTimeout {\n    isValid() {\n        return true;\n    }\n}\nInfiniteTimeout.instance = new InfiniteTimeout();\nexport class DateTimeout {\n    constructor(timeout) {\n        this.timeout = timeout;\n        this.startTime = Date.now();\n        this.valid = true;\n        if (timeout <= 0) {\n            throw new BugIndicatingError('timeout must be positive');\n        }\n    }\n    // Recommendation: Set a log-point `{this.disable()}` in the body\n    isValid() {\n        const valid = Date.now() - this.startTime < this.timeout;\n        if (!valid && this.valid) {\n            this.valid = false; // timeout reached\n            // eslint-disable-next-line no-debugger\n            debugger; // WARNING: Most likely debugging caused the timeout. Call `this.disable()` to continue without timing out.\n        }\n        return this.valid;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class Array2D {\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n        this.array = [];\n        this.array = new Array(width * height);\n    }\n    get(x, y) {\n        return this.array[x + y * this.width];\n    }\n    set(x, y, value) {\n        this.array[x + y * this.width] = value;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { SequenceDiff, InfiniteTimeout, DiffAlgorithmResult } from './diffAlgorithm.js';\nimport { Array2D } from './utils.js';\n/**\n * A O(MN) diffing algorithm that supports a score function.\n * The algorithm can be improved by processing the 2d array diagonally.\n*/\nexport class DynamicProgrammingDiffing {\n    compute(sequence1, sequence2, timeout = InfiniteTimeout.instance, equalityScore) {\n        if (sequence1.length === 0 || sequence2.length === 0) {\n            return DiffAlgorithmResult.trivial(sequence1, sequence2);\n        }\n        /**\n         * lcsLengths.get(i, j): Length of the longest common subsequence of sequence1.substring(0, i + 1) and sequence2.substring(0, j + 1).\n         */\n        const lcsLengths = new Array2D(sequence1.length, sequence2.length);\n        const directions = new Array2D(sequence1.length, sequence2.length);\n        const lengths = new Array2D(sequence1.length, sequence2.length);\n        // ==== Initializing lcsLengths ====\n        for (let s1 = 0; s1 < sequence1.length; s1++) {\n            for (let s2 = 0; s2 < sequence2.length; s2++) {\n                if (!timeout.isValid()) {\n                    return DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);\n                }\n                const horizontalLen = s1 === 0 ? 0 : lcsLengths.get(s1 - 1, s2);\n                const verticalLen = s2 === 0 ? 0 : lcsLengths.get(s1, s2 - 1);\n                let extendedSeqScore;\n                if (sequence1.getElement(s1) === sequence2.getElement(s2)) {\n                    if (s1 === 0 || s2 === 0) {\n                        extendedSeqScore = 0;\n                    }\n                    else {\n                        extendedSeqScore = lcsLengths.get(s1 - 1, s2 - 1);\n                    }\n                    if (s1 > 0 && s2 > 0 && directions.get(s1 - 1, s2 - 1) === 3) {\n                        // Prefer consecutive diagonals\n                        extendedSeqScore += lengths.get(s1 - 1, s2 - 1);\n                    }\n                    extendedSeqScore += (equalityScore ? equalityScore(s1, s2) : 1);\n                }\n                else {\n                    extendedSeqScore = -1;\n                }\n                const newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);\n                if (newValue === extendedSeqScore) {\n                    // Prefer diagonals\n                    const prevLen = s1 > 0 && s2 > 0 ? lengths.get(s1 - 1, s2 - 1) : 0;\n                    lengths.set(s1, s2, prevLen + 1);\n                    directions.set(s1, s2, 3);\n                }\n                else if (newValue === horizontalLen) {\n                    lengths.set(s1, s2, 0);\n                    directions.set(s1, s2, 1);\n                }\n                else if (newValue === verticalLen) {\n                    lengths.set(s1, s2, 0);\n                    directions.set(s1, s2, 2);\n                }\n                lcsLengths.set(s1, s2, newValue);\n            }\n        }\n        // ==== Backtracking ====\n        const result = [];\n        let lastAligningPosS1 = sequence1.length;\n        let lastAligningPosS2 = sequence2.length;\n        function reportDecreasingAligningPositions(s1, s2) {\n            if (s1 + 1 !== lastAligningPosS1 || s2 + 1 !== lastAligningPosS2) {\n                result.push(new SequenceDiff(new OffsetRange(s1 + 1, lastAligningPosS1), new OffsetRange(s2 + 1, lastAligningPosS2)));\n            }\n            lastAligningPosS1 = s1;\n            lastAligningPosS2 = s2;\n        }\n        let s1 = sequence1.length - 1;\n        let s2 = sequence2.length - 1;\n        while (s1 >= 0 && s2 >= 0) {\n            if (directions.get(s1, s2) === 3) {\n                reportDecreasingAligningPositions(s1, s2);\n                s1--;\n                s2--;\n            }\n            else {\n                if (directions.get(s1, s2) === 1) {\n                    s1--;\n                }\n                else {\n                    s2--;\n                }\n            }\n        }\n        reportDecreasingAligningPositions(-1, -1);\n        result.reverse();\n        return new DiffAlgorithmResult(result, false);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { SequenceDiff } from './diffAlgorithm.js';\nexport function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    let result = sequenceDiffs;\n    result = joinSequenceDiffs(sequence1, sequence2, result);\n    result = shiftSequenceDiffs(sequence1, sequence2, result);\n    return result;\n}\nexport function smoothenSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    const result = [];\n    for (const s of sequenceDiffs) {\n        const last = result[result.length - 1];\n        if (!last) {\n            result.push(s);\n            continue;\n        }\n        if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {\n            result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));\n        }\n        else {\n            result.push(s);\n        }\n    }\n    return result;\n}\n/**\n * This function fixes issues like this:\n * ```\n * import { Baz, Bar } from \"foo\";\n * ```\n * <->\n * ```\n * import { Baz, Bar, Foo } from \"foo\";\n * ```\n * Computed diff: [ {Add \",\" after Bar}, {Add \"Foo \" after space} }\n * Improved diff: [{Add \", Foo\" after Bar}]\n */\nexport function joinSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    const result = [];\n    if (sequenceDiffs.length > 0) {\n        result.push(sequenceDiffs[0]);\n    }\n    for (let i = 1; i < sequenceDiffs.length; i++) {\n        const lastResult = result[result.length - 1];\n        const cur = sequenceDiffs[i];\n        if (cur.seq1Range.isEmpty) {\n            let all = true;\n            const length = cur.seq1Range.start - lastResult.seq1Range.endExclusive;\n            for (let i = 1; i <= length; i++) {\n                if (sequence2.getElement(cur.seq2Range.start - i) !== sequence2.getElement(cur.seq2Range.endExclusive - i)) {\n                    all = false;\n                    break;\n                }\n            }\n            if (all) {\n                // Merge previous and current diff\n                result[result.length - 1] = new SequenceDiff(lastResult.seq1Range, new OffsetRange(lastResult.seq2Range.start, cur.seq2Range.endExclusive - length));\n                continue;\n            }\n        }\n        result.push(cur);\n    }\n    return result;\n}\n// align character level diffs at whitespace characters\n// import { IBar } from \"foo\";\n// import { I[Arr, I]Bar } from \"foo\";\n// ->\n// import { [IArr, ]IBar } from \"foo\";\n// import { ITransaction, observableValue, transaction } from 'vs/base/common/observable';\n// import { ITransaction, observable[FromEvent, observable]Value, transaction } from 'vs/base/common/observable';\n// ->\n// import { ITransaction, [observableFromEvent, ]observableValue, transaction } from 'vs/base/common/observable';\n// collectBrackets(level + 1, levelPerBracketType);\n// collectBrackets(level + 1, levelPerBracket[ + 1, levelPerBracket]Type);\n// ->\n// collectBrackets(level + 1, [levelPerBracket + 1, ]levelPerBracketType);\nexport function shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\n        return sequenceDiffs;\n    }\n    for (let i = 0; i < sequenceDiffs.length; i++) {\n        const diff = sequenceDiffs[i];\n        if (diff.seq1Range.isEmpty) {\n            const seq2PrevEndExclusive = (i > 0 ? sequenceDiffs[i - 1].seq2Range.endExclusive : -1);\n            const seq2NextStart = (i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1].seq2Range.start : sequence2.length);\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq2NextStart, seq2PrevEndExclusive);\n        }\n        else if (diff.seq2Range.isEmpty) {\n            const seq1PrevEndExclusive = (i > 0 ? sequenceDiffs[i - 1].seq1Range.endExclusive : -1);\n            const seq1NextStart = (i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1].seq1Range.start : sequence1.length);\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff.reverse(), sequence2, sequence1, seq1NextStart, seq1PrevEndExclusive).reverse();\n        }\n    }\n    return sequenceDiffs;\n}\nfunction shiftDiffToBetterPosition(diff, sequence1, sequence2, seq2NextStart, seq2PrevEndExclusive) {\n    const maxShiftLimit = 20; // To prevent performance issues\n    // don't touch previous or next!\n    let deltaBefore = 1;\n    while (diff.seq2Range.start - deltaBefore > seq2PrevEndExclusive &&\n        sequence2.getElement(diff.seq2Range.start - deltaBefore) ===\n            sequence2.getElement(diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {\n        deltaBefore++;\n    }\n    deltaBefore--;\n    let deltaAfter = 0;\n    while (diff.seq2Range.start + deltaAfter < seq2NextStart &&\n        sequence2.getElement(diff.seq2Range.start + deltaAfter) ===\n            sequence2.getElement(diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {\n        deltaAfter++;\n    }\n    if (deltaBefore === 0 && deltaAfter === 0) {\n        return diff;\n    }\n    // Visualize `[sequence1.text, diff.seq1Range.start + deltaAfter]`\n    // and `[sequence2.text, diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter]`\n    let bestDelta = 0;\n    let bestScore = -1;\n    // find best scored delta\n    for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {\n        const seq2OffsetStart = diff.seq2Range.start + delta;\n        const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\n        const seq1Offset = diff.seq1Range.start + delta;\n        const score = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);\n        if (score > bestScore) {\n            bestScore = score;\n            bestDelta = delta;\n        }\n    }\n    if (bestDelta !== 0) {\n        return new SequenceDiff(diff.seq1Range.delta(bestDelta), diff.seq2Range.delta(bestDelta));\n    }\n    return diff;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { DiffAlgorithmResult, InfiniteTimeout, SequenceDiff } from './diffAlgorithm.js';\n/**\n * An O(ND) diff algorithm that has a quadratic space worst-case complexity.\n*/\nexport class MyersDiffAlgorithm {\n    compute(seq1, seq2, timeout = InfiniteTimeout.instance) {\n        // These are common special cases.\n        // The early return improves performance dramatically.\n        if (seq1.length === 0 || seq2.length === 0) {\n            return DiffAlgorithmResult.trivial(seq1, seq2);\n        }\n        function getXAfterSnake(x, y) {\n            while (x < seq1.length && y < seq2.length && seq1.getElement(x) === seq2.getElement(y)) {\n                x++;\n                y++;\n            }\n            return x;\n        }\n        let d = 0;\n        // V[k]: X value of longest d-line that ends in diagonal k.\n        // d-line: path from (0,0) to (x,y) that uses exactly d non-diagonals.\n        // diagonal k: Set of points (x,y) with x-y = k.\n        const V = new FastInt32Array();\n        V.set(0, getXAfterSnake(0, 0));\n        const paths = new FastArrayNegativeIndices();\n        paths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));\n        let k = 0;\n        loop: while (true) {\n            d++;\n            for (k = -d; k <= d; k += 2) {\n                if (!timeout.isValid()) {\n                    return DiffAlgorithmResult.trivialTimedOut(seq1, seq2);\n                }\n                const maxXofDLineTop = k === d ? -1 : V.get(k + 1); // We take a vertical non-diagonal\n                const maxXofDLineLeft = k === -d ? -1 : V.get(k - 1) + 1; // We take a horizontal non-diagonal (+1 x)\n                const x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seq1.length);\n                const y = x - k;\n                const newMaxX = getXAfterSnake(x, y);\n                V.set(k, newMaxX);\n                const lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);\n                paths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);\n                if (V.get(k) === seq1.length && V.get(k) - k === seq2.length) {\n                    break loop;\n                }\n            }\n        }\n        let path = paths.get(k);\n        const result = [];\n        let lastAligningPosS1 = seq1.length;\n        let lastAligningPosS2 = seq2.length;\n        while (true) {\n            const endX = path ? path.x + path.length : 0;\n            const endY = path ? path.y + path.length : 0;\n            if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {\n                result.push(new SequenceDiff(new OffsetRange(endX, lastAligningPosS1), new OffsetRange(endY, lastAligningPosS2)));\n            }\n            if (!path) {\n                break;\n            }\n            lastAligningPosS1 = path.x;\n            lastAligningPosS2 = path.y;\n            path = path.prev;\n        }\n        result.reverse();\n        return new DiffAlgorithmResult(result, false);\n    }\n}\nclass SnakePath {\n    constructor(prev, x, y, length) {\n        this.prev = prev;\n        this.x = x;\n        this.y = y;\n        this.length = length;\n    }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastInt32Array {\n    constructor() {\n        this.positiveArr = new Int32Array(10);\n        this.negativeArr = new Int32Array(10);\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            if (idx >= this.negativeArr.length) {\n                const arr = this.negativeArr;\n                this.negativeArr = new Int32Array(arr.length * 2);\n                this.negativeArr.set(arr);\n            }\n            this.negativeArr[idx] = value;\n        }\n        else {\n            if (idx >= this.positiveArr.length) {\n                const arr = this.positiveArr;\n                this.positiveArr = new Int32Array(arr.length * 2);\n                this.positiveArr.set(arr);\n            }\n            this.positiveArr[idx] = value;\n        }\n    }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastArrayNegativeIndices {\n    constructor() {\n        this.positiveArr = [];\n        this.negativeArr = [];\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            this.negativeArr[idx] = value;\n        }\n        else {\n            this.positiveArr[idx] = value;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { OffsetRange } from '../core/offsetRange.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { DateTimeout, InfiniteTimeout, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { DynamicProgrammingDiffing } from './algorithms/dynamicProgrammingDiffing.js';\nimport { optimizeSequenceDiffs, smoothenSequenceDiffs } from './algorithms/joinSequenceDiffs.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { LineRangeMapping, LinesDiff, RangeMapping } from './linesDiffComputer.js';\nexport class StandardLinesDiffComputer {\n    constructor() {\n        this.dynamicProgrammingDiffing = new DynamicProgrammingDiffing();\n        this.myersDiffingAlgorithm = new MyersDiffAlgorithm();\n    }\n    computeDiff(originalLines, modifiedLines, options) {\n        const timeout = options.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : new DateTimeout(options.maxComputationTimeMs);\n        const considerWhitespaceChanges = !options.ignoreTrimWhitespace;\n        const perfectHashes = new Map();\n        function getOrCreateHash(text) {\n            let hash = perfectHashes.get(text);\n            if (hash === undefined) {\n                hash = perfectHashes.size;\n                perfectHashes.set(text, hash);\n            }\n            return hash;\n        }\n        const srcDocLines = originalLines.map((l) => getOrCreateHash(l.trim()));\n        const tgtDocLines = modifiedLines.map((l) => getOrCreateHash(l.trim()));\n        const sequence1 = new LineSequence(srcDocLines, originalLines);\n        const sequence2 = new LineSequence(tgtDocLines, modifiedLines);\n        const lineAlignmentResult = (() => {\n            if (sequence1.length + sequence2.length < 1500) {\n                // Use the improved algorithm for small files\n                return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, timeout, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2]\n                    ? modifiedLines[offset2].length === 0\n                        ? 0.1\n                        : 1 + Math.log(1 + modifiedLines[offset2].length)\n                    : 0.99);\n            }\n            return this.myersDiffingAlgorithm.compute(sequence1, sequence2);\n        })();\n        let lineAlignments = lineAlignmentResult.diffs;\n        let hitTimeout = lineAlignmentResult.hitTimeout;\n        lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);\n        const alignments = [];\n        const scanForWhitespaceChanges = (equalLinesCount) => {\n            if (!considerWhitespaceChanges) {\n                return;\n            }\n            for (let i = 0; i < equalLinesCount; i++) {\n                const seq1Offset = seq1LastStart + i;\n                const seq2Offset = seq2LastStart + i;\n                if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {\n                    // This is because of whitespace changes, diff these lines\n                    const characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(seq1Offset, seq1Offset + 1), new OffsetRange(seq2Offset, seq2Offset + 1)), timeout, considerWhitespaceChanges);\n                    for (const a of characterDiffs.mappings) {\n                        alignments.push(a);\n                    }\n                    if (characterDiffs.hitTimeout) {\n                        hitTimeout = true;\n                    }\n                }\n            }\n        };\n        let seq1LastStart = 0;\n        let seq2LastStart = 0;\n        for (const diff of lineAlignments) {\n            assertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);\n            const equalLinesCount = diff.seq1Range.start - seq1LastStart;\n            scanForWhitespaceChanges(equalLinesCount);\n            seq1LastStart = diff.seq1Range.endExclusive;\n            seq2LastStart = diff.seq2Range.endExclusive;\n            const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges);\n            if (characterDiffs.hitTimeout) {\n                hitTimeout = true;\n            }\n            for (const a of characterDiffs.mappings) {\n                alignments.push(a);\n            }\n        }\n        scanForWhitespaceChanges(originalLines.length - seq1LastStart);\n        const changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);\n        return new LinesDiff(changes, hitTimeout);\n    }\n    refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges) {\n        const sourceSlice = new Slice(originalLines, diff.seq1Range, considerWhitespaceChanges);\n        const targetSlice = new Slice(modifiedLines, diff.seq2Range, considerWhitespaceChanges);\n        const diffResult = sourceSlice.length + targetSlice.length < 500\n            ? this.dynamicProgrammingDiffing.compute(sourceSlice, targetSlice, timeout)\n            : this.myersDiffingAlgorithm.compute(sourceSlice, targetSlice, timeout);\n        let diffs = diffResult.diffs;\n        diffs = optimizeSequenceDiffs(sourceSlice, targetSlice, diffs);\n        diffs = coverFullWords(sourceSlice, targetSlice, diffs);\n        diffs = smoothenSequenceDiffs(sourceSlice, targetSlice, diffs);\n        const result = diffs.map((d) => new RangeMapping(sourceSlice.translateRange(d.seq1Range), targetSlice.translateRange(d.seq2Range)));\n        // Assert: result applied on original should be the same as diff applied to original\n        return {\n            mappings: result,\n            hitTimeout: diffResult.hitTimeout,\n        };\n    }\n}\nfunction coverFullWords(sequence1, sequence2, sequenceDiffs) {\n    const additional = [];\n    let lastModifiedWord = undefined;\n    function maybePushWordToAdditional() {\n        if (!lastModifiedWord) {\n            return;\n        }\n        const originalLength1 = lastModifiedWord.s1Range.length - lastModifiedWord.deleted;\n        const originalLength2 = lastModifiedWord.s2Range.length - lastModifiedWord.added;\n        if (originalLength1 !== originalLength2) {\n            // TODO figure out why this happens\n        }\n        if (Math.max(lastModifiedWord.deleted, lastModifiedWord.added) + (lastModifiedWord.count - 1) > originalLength1) {\n            additional.push(new SequenceDiff(lastModifiedWord.s1Range, lastModifiedWord.s2Range));\n        }\n        lastModifiedWord = undefined;\n    }\n    for (const s of sequenceDiffs) {\n        function processWord(s1Range, s2Range) {\n            var _a, _b, _c, _d;\n            if (!lastModifiedWord || !lastModifiedWord.s1Range.containsRange(s1Range) || !lastModifiedWord.s2Range.containsRange(s2Range)) {\n                if (lastModifiedWord && !(lastModifiedWord.s1Range.endExclusive < s1Range.start && lastModifiedWord.s2Range.endExclusive < s2Range.start)) {\n                    const s1Added = OffsetRange.tryCreate(lastModifiedWord.s1Range.endExclusive, s1Range.start);\n                    const s2Added = OffsetRange.tryCreate(lastModifiedWord.s2Range.endExclusive, s2Range.start);\n                    lastModifiedWord.deleted += (_a = s1Added === null || s1Added === void 0 ? void 0 : s1Added.length) !== null && _a !== void 0 ? _a : 0;\n                    lastModifiedWord.added += (_b = s2Added === null || s2Added === void 0 ? void 0 : s2Added.length) !== null && _b !== void 0 ? _b : 0;\n                    lastModifiedWord.s1Range = lastModifiedWord.s1Range.join(s1Range);\n                    lastModifiedWord.s2Range = lastModifiedWord.s2Range.join(s2Range);\n                }\n                else {\n                    maybePushWordToAdditional();\n                    lastModifiedWord = { added: 0, deleted: 0, count: 0, s1Range: s1Range, s2Range: s2Range };\n                }\n            }\n            const changedS1 = s1Range.intersect(s.seq1Range);\n            const changedS2 = s2Range.intersect(s.seq2Range);\n            lastModifiedWord.count++;\n            lastModifiedWord.deleted += (_c = changedS1 === null || changedS1 === void 0 ? void 0 : changedS1.length) !== null && _c !== void 0 ? _c : 0;\n            lastModifiedWord.added += (_d = changedS2 === null || changedS2 === void 0 ? void 0 : changedS2.length) !== null && _d !== void 0 ? _d : 0;\n        }\n        const w1Before = sequence1.findWordContaining(s.seq1Range.start - 1);\n        const w2Before = sequence2.findWordContaining(s.seq2Range.start - 1);\n        const w1After = sequence1.findWordContaining(s.seq1Range.endExclusive);\n        const w2After = sequence2.findWordContaining(s.seq2Range.endExclusive);\n        if (w1Before && w1After && w2Before && w2After && w1Before.equals(w1After) && w2Before.equals(w2After)) {\n            processWord(w1Before, w2Before);\n        }\n        else {\n            if (w1Before && w2Before) {\n                processWord(w1Before, w2Before);\n            }\n            if (w1After && w2After) {\n                processWord(w1After, w2After);\n            }\n        }\n    }\n    maybePushWordToAdditional();\n    const merged = mergeSequenceDiffs(sequenceDiffs, additional);\n    return merged;\n}\nfunction mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {\n    const result = [];\n    while (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {\n        const sd1 = sequenceDiffs1[0];\n        const sd2 = sequenceDiffs2[0];\n        let next;\n        if (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {\n            next = sequenceDiffs1.shift();\n        }\n        else {\n            next = sequenceDiffs2.shift();\n        }\n        if (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {\n            result[result.length - 1] = result[result.length - 1].join(next);\n        }\n        else {\n            result.push(next);\n        }\n    }\n    return result;\n}\nexport function lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines) {\n    const changes = [];\n    for (const g of group(alignments.map(a => getLineRangeMapping(a, originalLines, modifiedLines)), (a1, a2) => a1.originalRange.overlapOrTouch(a2.originalRange)\n        || a1.modifiedRange.overlapOrTouch(a2.modifiedRange))) {\n        const first = g[0];\n        const last = g[g.length - 1];\n        changes.push(new LineRangeMapping(first.originalRange.join(last.originalRange), first.modifiedRange.join(last.modifiedRange), g.map(a => a.innerChanges[0])));\n    }\n    assertFn(() => {\n        return checkAdjacentItems(changes, (m1, m2) => m2.originalRange.startLineNumber - m1.originalRange.endLineNumberExclusive === m2.modifiedRange.startLineNumber - m1.modifiedRange.endLineNumberExclusive &&\n            // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n            m1.originalRange.endLineNumberExclusive < m2.originalRange.startLineNumber &&\n            m1.modifiedRange.endLineNumberExclusive < m2.modifiedRange.startLineNumber);\n    });\n    return changes;\n}\nexport function getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {\n    let lineStartDelta = 0;\n    let lineEndDelta = 0;\n    // rangeMapping describes the edit that replaces `rangeMapping.originalRange` with `newText := getText(modifiedLines, rangeMapping.modifiedRange)`.\n    // original: xxx[ \\n <- this line is not modified\n    // modified: xxx[ \\n\n    if (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length\n        && rangeMapping.originalRange.startColumn - 1 >= originalLines[rangeMapping.originalRange.startLineNumber - 1].length) {\n        lineStartDelta = 1; // +1 is always possible, as startLineNumber < endLineNumber + 1\n    }\n    // original: ]xxx \\n <- this line is not modified\n    // modified: ]xx  \\n\n    if (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1\n        && rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber\n        && rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {\n        lineEndDelta = -1; // We can only do this if the range is not empty yet\n    }\n    const originalLineRange = new LineRange(rangeMapping.originalRange.startLineNumber + lineStartDelta, rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta);\n    const modifiedLineRange = new LineRange(rangeMapping.modifiedRange.startLineNumber + lineStartDelta, rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta);\n    return new LineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);\n}\nfunction* group(items, shouldBeGrouped) {\n    let currentGroup;\n    let last;\n    for (const item of items) {\n        if (last !== undefined && shouldBeGrouped(last, item)) {\n            currentGroup.push(item);\n        }\n        else {\n            if (currentGroup) {\n                yield currentGroup;\n            }\n            currentGroup = [item];\n        }\n        last = item;\n    }\n    if (currentGroup) {\n        yield currentGroup;\n    }\n}\nexport class LineSequence {\n    constructor(trimmedHash, lines) {\n        this.trimmedHash = trimmedHash;\n        this.lines = lines;\n    }\n    getElement(offset) {\n        return this.trimmedHash[offset];\n    }\n    get length() {\n        return this.trimmedHash.length;\n    }\n    getBoundaryScore(length) {\n        const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);\n        const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);\n        return 1000 - (indentationBefore + indentationAfter);\n    }\n}\nfunction getIndentation(str) {\n    let i = 0;\n    while (i < str.length && (str.charCodeAt(i) === 32 /* CharCode.Space */ || str.charCodeAt(i) === 9 /* CharCode.Tab */)) {\n        i++;\n    }\n    return i;\n}\nclass Slice {\n    constructor(lines, lineRange, considerWhitespaceChanges) {\n        // This slice has to have lineRange.length many \\n! (otherwise diffing against an empty slice will be problematic)\n        // (Unless it covers the entire document, in that case the other slice also has to cover the entire document ands it's okay)\n        this.lines = lines;\n        this.considerWhitespaceChanges = considerWhitespaceChanges;\n        this.elements = [];\n        this.firstCharOffsetByLineMinusOne = [];\n        // To account for trimming\n        this.offsetByLine = [];\n        // If the slice covers the end, but does not start at the beginning, we include just the \\n of the previous line.\n        let trimFirstLineFully = false;\n        if (lineRange.start > 0 && lineRange.endExclusive >= lines.length) {\n            lineRange = new OffsetRange(lineRange.start - 1, lineRange.endExclusive);\n            trimFirstLineFully = true;\n        }\n        this.lineRange = lineRange;\n        for (let i = this.lineRange.start; i < this.lineRange.endExclusive; i++) {\n            let line = lines[i];\n            let offset = 0;\n            if (trimFirstLineFully) {\n                offset = line.length;\n                line = '';\n                trimFirstLineFully = false;\n            }\n            else if (!considerWhitespaceChanges) {\n                const trimmedStartLine = line.trimStart();\n                offset = line.length - trimmedStartLine.length;\n                line = trimmedStartLine.trimEnd();\n            }\n            this.offsetByLine.push(offset);\n            for (let i = 0; i < line.length; i++) {\n                this.elements.push(line.charCodeAt(i));\n            }\n            // Don't add an \\n that does not exist in the document.\n            if (i < lines.length - 1) {\n                this.elements.push('\\n'.charCodeAt(0));\n                this.firstCharOffsetByLineMinusOne[i - this.lineRange.start] = this.elements.length;\n            }\n        }\n        // To account for the last line\n        this.offsetByLine.push(0);\n    }\n    toString() {\n        return `Slice: \"${this.text}\"`;\n    }\n    get text() {\n        return [...this.elements].map(e => String.fromCharCode(e)).join('');\n    }\n    getElement(offset) {\n        return this.elements[offset];\n    }\n    get length() {\n        return this.elements.length;\n    }\n    getBoundaryScore(length) {\n        //   a   b   c   ,           d   e   f\n        // 11  0   0   12  15  6   13  0   0   11\n        const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n        const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n        if (prevCategory === 6 /* CharBoundaryCategory.LineBreakCR */ && nextCategory === 7 /* CharBoundaryCategory.LineBreakLF */) {\n            // don't break between \\r and \\n\n            return 0;\n        }\n        let score = 0;\n        if (prevCategory !== nextCategory) {\n            score += 10;\n            if (nextCategory === 1 /* CharBoundaryCategory.WordUpper */) {\n                score += 1;\n            }\n        }\n        score += getCategoryBoundaryScore(prevCategory);\n        score += getCategoryBoundaryScore(nextCategory);\n        return score;\n    }\n    translateOffset(offset) {\n        // find smallest i, so that lineBreakOffsets[i] <= offset using binary search\n        if (this.lineRange.isEmpty) {\n            return new Position(this.lineRange.start + 1, 1);\n        }\n        let i = 0;\n        let j = this.firstCharOffsetByLineMinusOne.length;\n        while (i < j) {\n            const k = Math.floor((i + j) / 2);\n            if (this.firstCharOffsetByLineMinusOne[k] > offset) {\n                j = k;\n            }\n            else {\n                i = k + 1;\n            }\n        }\n        const offsetOfPrevLineBreak = i === 0 ? 0 : this.firstCharOffsetByLineMinusOne[i - 1];\n        return new Position(this.lineRange.start + i + 1, offset - offsetOfPrevLineBreak + 1 + this.offsetByLine[i]);\n    }\n    translateRange(range) {\n        return Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));\n    }\n    /**\n     * Finds the word that contains the character at the given offset\n     */\n    findWordContaining(offset) {\n        if (offset < 0 || offset >= this.elements.length) {\n            return undefined;\n        }\n        if (!isWordChar(this.elements[offset])) {\n            return undefined;\n        }\n        // find start\n        let start = offset;\n        while (start > 0 && isWordChar(this.elements[start - 1])) {\n            start--;\n        }\n        // find end\n        let end = offset;\n        while (end < this.elements.length && isWordChar(this.elements[end])) {\n            end++;\n        }\n        return new OffsetRange(start, end);\n    }\n}\nfunction isWordChar(charCode) {\n    return charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */\n        || charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */\n        || charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */;\n}\nconst score = {\n    [0 /* CharBoundaryCategory.WordLower */]: 0,\n    [1 /* CharBoundaryCategory.WordUpper */]: 0,\n    [2 /* CharBoundaryCategory.WordNumber */]: 0,\n    [3 /* CharBoundaryCategory.End */]: 10,\n    [4 /* CharBoundaryCategory.Other */]: 2,\n    [5 /* CharBoundaryCategory.Space */]: 3,\n    [6 /* CharBoundaryCategory.LineBreakCR */]: 10,\n    [7 /* CharBoundaryCategory.LineBreakLF */]: 10,\n};\nfunction getCategoryBoundaryScore(category) {\n    return score[category];\n}\nfunction getCategory(charCode) {\n    if (charCode === 10 /* CharCode.LineFeed */) {\n        return 7 /* CharBoundaryCategory.LineBreakLF */;\n    }\n    else if (charCode === 13 /* CharCode.CarriageReturn */) {\n        return 6 /* CharBoundaryCategory.LineBreakCR */;\n    }\n    else if (isSpace(charCode)) {\n        return 5 /* CharBoundaryCategory.Space */;\n    }\n    else if (charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */) {\n        return 0 /* CharBoundaryCategory.WordLower */;\n    }\n    else if (charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */) {\n        return 1 /* CharBoundaryCategory.WordUpper */;\n    }\n    else if (charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */) {\n        return 2 /* CharBoundaryCategory.WordNumber */;\n    }\n    else if (charCode === -1) {\n        return 3 /* CharBoundaryCategory.End */;\n    }\n    else {\n        return 4 /* CharBoundaryCategory.Other */;\n    }\n}\nfunction isSpace(charCode) {\n    return charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SmartLinesDiffComputer } from './smartLinesDiffComputer.js';\nimport { StandardLinesDiffComputer } from './standardLinesDiffComputer.js';\nexport const linesDiffComputers = {\n    legacy: new SmartLinesDiffComputer(),\n    advanced: new StandardLinesDiffComputer(),\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class InternalEditorAction {\n    constructor(id, label, alias, precondition, run, contextKeyService) {\n        this.id = id;\n        this.label = label;\n        this.alias = alias;\n        this._precondition = precondition;\n        this._run = run;\n        this._contextKeyService = contextKeyService;\n    }\n    isSupported() {\n        return this._contextKeyService.contextMatchesRules(this._precondition);\n    }\n    run(args) {\n        if (!this.isSupported()) {\n            return Promise.resolve(undefined);\n        }\n        return this._run(args);\n    }\n}\n","/**\n * The type of the `IEditor`.\n */\nexport const EditorType = {\n    ICodeEditor: 'vs.editor.ICodeEditor',\n    IDiffEditor: 'vs.editor.IDiffEditor'\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../nls.js';\nimport { RawContextKey } from '../../platform/contextkey/common/contextkey.js';\nexport var EditorContextKeys;\n(function (EditorContextKeys) {\n    EditorContextKeys.editorSimpleInput = new RawContextKey('editorSimpleInput', false, true);\n    /**\n     * A context key that is set when the editor's text has focus (cursor is blinking).\n     * Is false when focus is in simple editor widgets (repl input, scm commit input).\n     */\n    EditorContextKeys.editorTextFocus = new RawContextKey('editorTextFocus', false, nls.localize('editorTextFocus', \"Whether the editor text has focus (cursor is blinking)\"));\n    /**\n     * A context key that is set when the editor's text or an editor's widget has focus.\n     */\n    EditorContextKeys.focus = new RawContextKey('editorFocus', false, nls.localize('editorFocus', \"Whether the editor or an editor widget has focus (e.g. focus is in the find widget)\"));\n    /**\n     * A context key that is set when any editor input has focus (regular editor, repl input...).\n     */\n    EditorContextKeys.textInputFocus = new RawContextKey('textInputFocus', false, nls.localize('textInputFocus', \"Whether an editor or a rich text input has focus (cursor is blinking)\"));\n    EditorContextKeys.readOnly = new RawContextKey('editorReadonly', false, nls.localize('editorReadonly', \"Whether the editor is read only\"));\n    EditorContextKeys.inDiffEditor = new RawContextKey('inDiffEditor', false, nls.localize('inDiffEditor', \"Whether the context is a diff editor\"));\n    EditorContextKeys.isEmbeddedDiffEditor = new RawContextKey('isEmbeddedDiffEditor', false, nls.localize('isEmbeddedDiffEditor', \"Whether the context is an embedded diff editor\"));\n    EditorContextKeys.columnSelection = new RawContextKey('editorColumnSelection', false, nls.localize('editorColumnSelection', \"Whether `editor.columnSelection` is enabled\"));\n    EditorContextKeys.writable = EditorContextKeys.readOnly.toNegated();\n    EditorContextKeys.hasNonEmptySelection = new RawContextKey('editorHasSelection', false, nls.localize('editorHasSelection', \"Whether the editor has text selected\"));\n    EditorContextKeys.hasOnlyEmptySelection = EditorContextKeys.hasNonEmptySelection.toNegated();\n    EditorContextKeys.hasMultipleSelections = new RawContextKey('editorHasMultipleSelections', false, nls.localize('editorHasMultipleSelections', \"Whether the editor has multiple selections\"));\n    EditorContextKeys.hasSingleSelection = EditorContextKeys.hasMultipleSelections.toNegated();\n    EditorContextKeys.tabMovesFocus = new RawContextKey('editorTabMovesFocus', false, nls.localize('editorTabMovesFocus', \"Whether `Tab` will move focus out of the editor\"));\n    EditorContextKeys.tabDoesNotMoveFocus = EditorContextKeys.tabMovesFocus.toNegated();\n    EditorContextKeys.isInWalkThroughSnippet = new RawContextKey('isInEmbeddedEditor', false, true);\n    EditorContextKeys.canUndo = new RawContextKey('canUndo', false, true);\n    EditorContextKeys.canRedo = new RawContextKey('canRedo', false, true);\n    EditorContextKeys.hoverVisible = new RawContextKey('editorHoverVisible', false, nls.localize('editorHoverVisible', \"Whether the editor hover is visible\"));\n    EditorContextKeys.hoverFocused = new RawContextKey('editorHoverFocused', false, nls.localize('editorHoverFocused', \"Whether the editor hover is focused\"));\n    EditorContextKeys.stickyScrollFocused = new RawContextKey('stickyScrollFocused', false, nls.localize('stickyScrollFocused', \"Whether the sticky scroll is focused\"));\n    EditorContextKeys.stickyScrollVisible = new RawContextKey('stickyScrollVisible', false, nls.localize('stickyScrollVisible', \"Whether the sticky scroll is visible\"));\n    EditorContextKeys.standaloneColorPickerVisible = new RawContextKey('standaloneColorPickerVisible', false, nls.localize('standaloneColorPickerVisible', \"Whether the standalone color picker is visible\"));\n    EditorContextKeys.standaloneColorPickerFocused = new RawContextKey('standaloneColorPickerFocused', false, nls.localize('standaloneColorPickerFocused', \"Whether the standalone color picker is focused\"));\n    /**\n     * A context key that is set when an editor is part of a larger editor, like notebooks or\n     * (future) a diff editor\n     */\n    EditorContextKeys.inCompositeEditor = new RawContextKey('inCompositeEditor', undefined, nls.localize('inCompositeEditor', \"Whether the editor is part of a larger editor (e.g. notebooks)\"));\n    EditorContextKeys.notInCompositeEditor = EditorContextKeys.inCompositeEditor.toNegated();\n    // -- mode context keys\n    EditorContextKeys.languageId = new RawContextKey('editorLangId', '', nls.localize('editorLangId', \"The language identifier of the editor\"));\n    EditorContextKeys.hasCompletionItemProvider = new RawContextKey('editorHasCompletionItemProvider', false, nls.localize('editorHasCompletionItemProvider', \"Whether the editor has a completion item provider\"));\n    EditorContextKeys.hasCodeActionsProvider = new RawContextKey('editorHasCodeActionsProvider', false, nls.localize('editorHasCodeActionsProvider', \"Whether the editor has a code actions provider\"));\n    EditorContextKeys.hasCodeLensProvider = new RawContextKey('editorHasCodeLensProvider', false, nls.localize('editorHasCodeLensProvider', \"Whether the editor has a code lens provider\"));\n    EditorContextKeys.hasDefinitionProvider = new RawContextKey('editorHasDefinitionProvider', false, nls.localize('editorHasDefinitionProvider', \"Whether the editor has a definition provider\"));\n    EditorContextKeys.hasDeclarationProvider = new RawContextKey('editorHasDeclarationProvider', false, nls.localize('editorHasDeclarationProvider', \"Whether the editor has a declaration provider\"));\n    EditorContextKeys.hasImplementationProvider = new RawContextKey('editorHasImplementationProvider', false, nls.localize('editorHasImplementationProvider', \"Whether the editor has an implementation provider\"));\n    EditorContextKeys.hasTypeDefinitionProvider = new RawContextKey('editorHasTypeDefinitionProvider', false, nls.localize('editorHasTypeDefinitionProvider', \"Whether the editor has a type definition provider\"));\n    EditorContextKeys.hasHoverProvider = new RawContextKey('editorHasHoverProvider', false, nls.localize('editorHasHoverProvider', \"Whether the editor has a hover provider\"));\n    EditorContextKeys.hasDocumentHighlightProvider = new RawContextKey('editorHasDocumentHighlightProvider', false, nls.localize('editorHasDocumentHighlightProvider', \"Whether the editor has a document highlight provider\"));\n    EditorContextKeys.hasDocumentSymbolProvider = new RawContextKey('editorHasDocumentSymbolProvider', false, nls.localize('editorHasDocumentSymbolProvider', \"Whether the editor has a document symbol provider\"));\n    EditorContextKeys.hasReferenceProvider = new RawContextKey('editorHasReferenceProvider', false, nls.localize('editorHasReferenceProvider', \"Whether the editor has a reference provider\"));\n    EditorContextKeys.hasRenameProvider = new RawContextKey('editorHasRenameProvider', false, nls.localize('editorHasRenameProvider', \"Whether the editor has a rename provider\"));\n    EditorContextKeys.hasSignatureHelpProvider = new RawContextKey('editorHasSignatureHelpProvider', false, nls.localize('editorHasSignatureHelpProvider', \"Whether the editor has a signature help provider\"));\n    EditorContextKeys.hasInlayHintsProvider = new RawContextKey('editorHasInlayHintsProvider', false, nls.localize('editorHasInlayHintsProvider', \"Whether the editor has an inline hints provider\"));\n    // -- mode context keys: formatting\n    EditorContextKeys.hasDocumentFormattingProvider = new RawContextKey('editorHasDocumentFormattingProvider', false, nls.localize('editorHasDocumentFormattingProvider', \"Whether the editor has a document formatting provider\"));\n    EditorContextKeys.hasDocumentSelectionFormattingProvider = new RawContextKey('editorHasDocumentSelectionFormattingProvider', false, nls.localize('editorHasDocumentSelectionFormattingProvider', \"Whether the editor has a document selection formatting provider\"));\n    EditorContextKeys.hasMultipleDocumentFormattingProvider = new RawContextKey('editorHasMultipleDocumentFormattingProvider', false, nls.localize('editorHasMultipleDocumentFormattingProvider', \"Whether the editor has multiple document formatting providers\"));\n    EditorContextKeys.hasMultipleDocumentSelectionFormattingProvider = new RawContextKey('editorHasMultipleDocumentSelectionFormattingProvider', false, nls.localize('editorHasMultipleDocumentSelectionFormattingProvider', \"Whether the editor has multiple document selection formatting providers\"));\n})(EditorContextKeys || (EditorContextKeys = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst editorFeatures = [];\n/**\n * Registers an editor feature. Editor features will be instantiated only once, as soon as\n * the first code editor is instantiated.\n */\nexport function registerEditorFeature(ctor) {\n    editorFeatures.push(ctor);\n}\nexport function getEditorFeatures() {\n    return editorFeatures.slice(0);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class EditorTheme {\n    get type() {\n        return this._theme.type;\n    }\n    get value() {\n        return this._theme;\n    }\n    constructor(theme) {\n        this._theme = theme;\n    }\n    update(theme) {\n        this._theme = theme;\n    }\n    getColor(color) {\n        return this._theme.getColor(color);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n */\nexport class TokenMetadata {\n    static getLanguageId(metadata) {\n        return (metadata & 255 /* MetadataConsts.LANGUAGEID_MASK */) >>> 0 /* MetadataConsts.LANGUAGEID_OFFSET */;\n    }\n    static getTokenType(metadata) {\n        return (metadata & 768 /* MetadataConsts.TOKEN_TYPE_MASK */) >>> 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */;\n    }\n    static containsBalancedBrackets(metadata) {\n        return (metadata & 1024 /* MetadataConsts.BALANCED_BRACKETS_MASK */) !== 0;\n    }\n    static getFontStyle(metadata) {\n        return (metadata & 30720 /* MetadataConsts.FONT_STYLE_MASK */) >>> 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n    }\n    static getForeground(metadata) {\n        return (metadata & 16744448 /* MetadataConsts.FOREGROUND_MASK */) >>> 15 /* MetadataConsts.FOREGROUND_OFFSET */;\n    }\n    static getBackground(metadata) {\n        return (metadata & 4278190080 /* MetadataConsts.BACKGROUND_MASK */) >>> 24 /* MetadataConsts.BACKGROUND_OFFSET */;\n    }\n    static getClassNameFromMetadata(metadata) {\n        const foreground = this.getForeground(metadata);\n        let className = 'mtk' + foreground;\n        const fontStyle = this.getFontStyle(metadata);\n        if (fontStyle & 1 /* FontStyle.Italic */) {\n            className += ' mtki';\n        }\n        if (fontStyle & 2 /* FontStyle.Bold */) {\n            className += ' mtkb';\n        }\n        if (fontStyle & 4 /* FontStyle.Underline */) {\n            className += ' mtku';\n        }\n        if (fontStyle & 8 /* FontStyle.Strikethrough */) {\n            className += ' mtks';\n        }\n        return className;\n    }\n    static getInlineStyleFromMetadata(metadata, colorMap) {\n        const foreground = this.getForeground(metadata);\n        const fontStyle = this.getFontStyle(metadata);\n        let result = `color: ${colorMap[foreground]};`;\n        if (fontStyle & 1 /* FontStyle.Italic */) {\n            result += 'font-style: italic;';\n        }\n        if (fontStyle & 2 /* FontStyle.Bold */) {\n            result += 'font-weight: bold;';\n        }\n        let textDecoration = '';\n        if (fontStyle & 4 /* FontStyle.Underline */) {\n            textDecoration += ' underline';\n        }\n        if (fontStyle & 8 /* FontStyle.Strikethrough */) {\n            textDecoration += ' line-through';\n        }\n        if (textDecoration) {\n            result += `text-decoration:${textDecoration};`;\n        }\n        return result;\n    }\n    static getPresentationFromMetadata(metadata) {\n        const foreground = this.getForeground(metadata);\n        const fontStyle = this.getFontStyle(metadata);\n        return {\n            foreground: foreground,\n            italic: Boolean(fontStyle & 1 /* FontStyle.Italic */),\n            bold: Boolean(fontStyle & 2 /* FontStyle.Bold */),\n            underline: Boolean(fontStyle & 4 /* FontStyle.Underline */),\n            strikethrough: Boolean(fontStyle & 8 /* FontStyle.Strikethrough */),\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { match as matchGlobPattern } from '../../base/common/glob.js';\nimport { normalize } from '../../base/common/path.js';\nexport function score(selector, candidateUri, candidateLanguage, candidateIsSynchronized, candidateNotebookUri, candidateNotebookType) {\n    if (Array.isArray(selector)) {\n        // array -> take max individual value\n        let ret = 0;\n        for (const filter of selector) {\n            const value = score(filter, candidateUri, candidateLanguage, candidateIsSynchronized, candidateNotebookUri, candidateNotebookType);\n            if (value === 10) {\n                return value; // already at the highest\n            }\n            if (value > ret) {\n                ret = value;\n            }\n        }\n        return ret;\n    }\n    else if (typeof selector === 'string') {\n        if (!candidateIsSynchronized) {\n            return 0;\n        }\n        // short-hand notion, desugars to\n        // 'fooLang' -> { language: 'fooLang'}\n        // '*' -> { language: '*' }\n        if (selector === '*') {\n            return 5;\n        }\n        else if (selector === candidateLanguage) {\n            return 10;\n        }\n        else {\n            return 0;\n        }\n    }\n    else if (selector) {\n        // filter -> select accordingly, use defaults for scheme\n        const { language, pattern, scheme, hasAccessToAllModels, notebookType } = selector; // TODO: microsoft/TypeScript#42768\n        if (!candidateIsSynchronized && !hasAccessToAllModels) {\n            return 0;\n        }\n        // selector targets a notebook -> use the notebook uri instead\n        // of the \"normal\" document uri.\n        if (notebookType && candidateNotebookUri) {\n            candidateUri = candidateNotebookUri;\n        }\n        let ret = 0;\n        if (scheme) {\n            if (scheme === candidateUri.scheme) {\n                ret = 10;\n            }\n            else if (scheme === '*') {\n                ret = 5;\n            }\n            else {\n                return 0;\n            }\n        }\n        if (language) {\n            if (language === candidateLanguage) {\n                ret = 10;\n            }\n            else if (language === '*') {\n                ret = Math.max(ret, 5);\n            }\n            else {\n                return 0;\n            }\n        }\n        if (notebookType) {\n            if (notebookType === candidateNotebookType) {\n                ret = 10;\n            }\n            else if (notebookType === '*' && candidateNotebookType !== undefined) {\n                ret = Math.max(ret, 5);\n            }\n            else {\n                return 0;\n            }\n        }\n        if (pattern) {\n            let normalizedPattern;\n            if (typeof pattern === 'string') {\n                normalizedPattern = pattern;\n            }\n            else {\n                // Since this pattern has a `base` property, we need\n                // to normalize this path first before passing it on\n                // because we will compare it against `Uri.fsPath`\n                // which uses platform specific separators.\n                // Refs: https://github.com/microsoft/vscode/issues/99938\n                normalizedPattern = Object.assign(Object.assign({}, pattern), { base: normalize(pattern.base) });\n            }\n            if (normalizedPattern === candidateUri.fsPath || matchGlobPattern(normalizedPattern, candidateUri.fsPath)) {\n                ret = 10;\n            }\n            else {\n                return 0;\n            }\n        }\n        return ret;\n    }\n    else {\n        return 0;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../base/common/event.js';\nimport { toDisposable } from '../../base/common/lifecycle.js';\nimport { shouldSynchronizeModel } from './model.js';\nimport { score } from './languageSelector.js';\nfunction isExclusive(selector) {\n    if (typeof selector === 'string') {\n        return false;\n    }\n    else if (Array.isArray(selector)) {\n        return selector.every(isExclusive);\n    }\n    else {\n        return !!selector.exclusive; // TODO: microsoft/TypeScript#42768\n    }\n}\nclass MatchCandidate {\n    constructor(uri, languageId, notebookUri, notebookType) {\n        this.uri = uri;\n        this.languageId = languageId;\n        this.notebookUri = notebookUri;\n        this.notebookType = notebookType;\n    }\n    equals(other) {\n        var _a, _b;\n        return this.notebookType === other.notebookType\n            && this.languageId === other.languageId\n            && this.uri.toString() === other.uri.toString()\n            && ((_a = this.notebookUri) === null || _a === void 0 ? void 0 : _a.toString()) === ((_b = other.notebookUri) === null || _b === void 0 ? void 0 : _b.toString());\n    }\n}\nexport class LanguageFeatureRegistry {\n    constructor(_notebookInfoResolver) {\n        this._notebookInfoResolver = _notebookInfoResolver;\n        this._clock = 0;\n        this._entries = [];\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n    }\n    register(selector, provider) {\n        let entry = {\n            selector,\n            provider,\n            _score: -1,\n            _time: this._clock++\n        };\n        this._entries.push(entry);\n        this._lastCandidate = undefined;\n        this._onDidChange.fire(this._entries.length);\n        return toDisposable(() => {\n            if (entry) {\n                const idx = this._entries.indexOf(entry);\n                if (idx >= 0) {\n                    this._entries.splice(idx, 1);\n                    this._lastCandidate = undefined;\n                    this._onDidChange.fire(this._entries.length);\n                    entry = undefined;\n                }\n            }\n        });\n    }\n    has(model) {\n        return this.all(model).length > 0;\n    }\n    all(model) {\n        if (!model) {\n            return [];\n        }\n        this._updateScores(model);\n        const result = [];\n        // from registry\n        for (const entry of this._entries) {\n            if (entry._score > 0) {\n                result.push(entry.provider);\n            }\n        }\n        return result;\n    }\n    ordered(model) {\n        const result = [];\n        this._orderedForEach(model, entry => result.push(entry.provider));\n        return result;\n    }\n    orderedGroups(model) {\n        const result = [];\n        let lastBucket;\n        let lastBucketScore;\n        this._orderedForEach(model, entry => {\n            if (lastBucket && lastBucketScore === entry._score) {\n                lastBucket.push(entry.provider);\n            }\n            else {\n                lastBucketScore = entry._score;\n                lastBucket = [entry.provider];\n                result.push(lastBucket);\n            }\n        });\n        return result;\n    }\n    _orderedForEach(model, callback) {\n        this._updateScores(model);\n        for (const entry of this._entries) {\n            if (entry._score > 0) {\n                callback(entry);\n            }\n        }\n    }\n    _updateScores(model) {\n        var _a, _b;\n        const notebookInfo = (_a = this._notebookInfoResolver) === null || _a === void 0 ? void 0 : _a.call(this, model.uri);\n        // use the uri (scheme, pattern) of the notebook info iff we have one\n        // otherwise it's the model's/document's uri\n        const candidate = notebookInfo\n            ? new MatchCandidate(model.uri, model.getLanguageId(), notebookInfo.uri, notebookInfo.type)\n            : new MatchCandidate(model.uri, model.getLanguageId(), undefined, undefined);\n        if ((_b = this._lastCandidate) === null || _b === void 0 ? void 0 : _b.equals(candidate)) {\n            // nothing has changed\n            return;\n        }\n        this._lastCandidate = candidate;\n        for (const entry of this._entries) {\n            entry._score = score(entry.selector, candidate.uri, candidate.languageId, shouldSynchronizeModel(model), candidate.notebookUri, candidate.notebookType);\n            if (isExclusive(entry.selector) && entry._score > 0) {\n                // support for one exclusive selector that overwrites\n                // any other selector\n                for (const entry of this._entries) {\n                    entry._score = 0;\n                }\n                entry._score = 1000;\n                break;\n            }\n        }\n        // needs sorting\n        this._entries.sort(LanguageFeatureRegistry._compareByScoreAndTime);\n    }\n    static _compareByScoreAndTime(a, b) {\n        if (a._score < b._score) {\n            return 1;\n        }\n        else if (a._score > b._score) {\n            return -1;\n        }\n        // De-prioritize built-in providers\n        if (isBuiltinSelector(a.selector) && !isBuiltinSelector(b.selector)) {\n            return 1;\n        }\n        else if (!isBuiltinSelector(a.selector) && isBuiltinSelector(b.selector)) {\n            return -1;\n        }\n        if (a._time < b._time) {\n            return 1;\n        }\n        else if (a._time > b._time) {\n            return -1;\n        }\n        else {\n            return 0;\n        }\n    }\n}\nfunction isBuiltinSelector(selector) {\n    if (typeof selector === 'string') {\n        return false;\n    }\n    if (Array.isArray(selector)) {\n        return selector.some(isBuiltinSelector);\n    }\n    return Boolean(selector.isBuiltin);\n}\n","import { Codicon } from '../../base/common/codicons.js';\nimport { URI } from '../../base/common/uri.js';\nimport { Range } from './core/range.js';\nimport { TokenizationRegistry as TokenizationRegistryImpl } from './tokenizationRegistry.js';\nexport class Token {\n    constructor(offset, type, language) {\n        this.offset = offset;\n        this.type = type;\n        this.language = language;\n        this._tokenBrand = undefined;\n    }\n    toString() {\n        return '(' + this.offset + ', ' + this.type + ')';\n    }\n}\n/**\n * @internal\n */\nexport class TokenizationResult {\n    constructor(tokens, endState) {\n        this.tokens = tokens;\n        this.endState = endState;\n        this._tokenizationResultBrand = undefined;\n    }\n}\n/**\n * @internal\n */\nexport class EncodedTokenizationResult {\n    constructor(\n    /**\n     * The tokens in binary format. Each token occupies two array indices. For token i:\n     *  - at offset 2*i => startIndex\n     *  - at offset 2*i + 1 => metadata\n     *\n     */\n    tokens, endState) {\n        this.tokens = tokens;\n        this.endState = endState;\n        this._encodedTokenizationResultBrand = undefined;\n    }\n}\n/**\n * @internal\n */\nexport var CompletionItemKinds;\n(function (CompletionItemKinds) {\n    const byKind = new Map();\n    byKind.set(0 /* CompletionItemKind.Method */, Codicon.symbolMethod);\n    byKind.set(1 /* CompletionItemKind.Function */, Codicon.symbolFunction);\n    byKind.set(2 /* CompletionItemKind.Constructor */, Codicon.symbolConstructor);\n    byKind.set(3 /* CompletionItemKind.Field */, Codicon.symbolField);\n    byKind.set(4 /* CompletionItemKind.Variable */, Codicon.symbolVariable);\n    byKind.set(5 /* CompletionItemKind.Class */, Codicon.symbolClass);\n    byKind.set(6 /* CompletionItemKind.Struct */, Codicon.symbolStruct);\n    byKind.set(7 /* CompletionItemKind.Interface */, Codicon.symbolInterface);\n    byKind.set(8 /* CompletionItemKind.Module */, Codicon.symbolModule);\n    byKind.set(9 /* CompletionItemKind.Property */, Codicon.symbolProperty);\n    byKind.set(10 /* CompletionItemKind.Event */, Codicon.symbolEvent);\n    byKind.set(11 /* CompletionItemKind.Operator */, Codicon.symbolOperator);\n    byKind.set(12 /* CompletionItemKind.Unit */, Codicon.symbolUnit);\n    byKind.set(13 /* CompletionItemKind.Value */, Codicon.symbolValue);\n    byKind.set(15 /* CompletionItemKind.Enum */, Codicon.symbolEnum);\n    byKind.set(14 /* CompletionItemKind.Constant */, Codicon.symbolConstant);\n    byKind.set(15 /* CompletionItemKind.Enum */, Codicon.symbolEnum);\n    byKind.set(16 /* CompletionItemKind.EnumMember */, Codicon.symbolEnumMember);\n    byKind.set(17 /* CompletionItemKind.Keyword */, Codicon.symbolKeyword);\n    byKind.set(27 /* CompletionItemKind.Snippet */, Codicon.symbolSnippet);\n    byKind.set(18 /* CompletionItemKind.Text */, Codicon.symbolText);\n    byKind.set(19 /* CompletionItemKind.Color */, Codicon.symbolColor);\n    byKind.set(20 /* CompletionItemKind.File */, Codicon.symbolFile);\n    byKind.set(21 /* CompletionItemKind.Reference */, Codicon.symbolReference);\n    byKind.set(22 /* CompletionItemKind.Customcolor */, Codicon.symbolCustomColor);\n    byKind.set(23 /* CompletionItemKind.Folder */, Codicon.symbolFolder);\n    byKind.set(24 /* CompletionItemKind.TypeParameter */, Codicon.symbolTypeParameter);\n    byKind.set(25 /* CompletionItemKind.User */, Codicon.account);\n    byKind.set(26 /* CompletionItemKind.Issue */, Codicon.issues);\n    /**\n     * @internal\n     */\n    function toIcon(kind) {\n        let codicon = byKind.get(kind);\n        if (!codicon) {\n            console.info('No codicon found for CompletionItemKind ' + kind);\n            codicon = Codicon.symbolProperty;\n        }\n        return codicon;\n    }\n    CompletionItemKinds.toIcon = toIcon;\n    const data = new Map();\n    data.set('method', 0 /* CompletionItemKind.Method */);\n    data.set('function', 1 /* CompletionItemKind.Function */);\n    data.set('constructor', 2 /* CompletionItemKind.Constructor */);\n    data.set('field', 3 /* CompletionItemKind.Field */);\n    data.set('variable', 4 /* CompletionItemKind.Variable */);\n    data.set('class', 5 /* CompletionItemKind.Class */);\n    data.set('struct', 6 /* CompletionItemKind.Struct */);\n    data.set('interface', 7 /* CompletionItemKind.Interface */);\n    data.set('module', 8 /* CompletionItemKind.Module */);\n    data.set('property', 9 /* CompletionItemKind.Property */);\n    data.set('event', 10 /* CompletionItemKind.Event */);\n    data.set('operator', 11 /* CompletionItemKind.Operator */);\n    data.set('unit', 12 /* CompletionItemKind.Unit */);\n    data.set('value', 13 /* CompletionItemKind.Value */);\n    data.set('constant', 14 /* CompletionItemKind.Constant */);\n    data.set('enum', 15 /* CompletionItemKind.Enum */);\n    data.set('enum-member', 16 /* CompletionItemKind.EnumMember */);\n    data.set('enumMember', 16 /* CompletionItemKind.EnumMember */);\n    data.set('keyword', 17 /* CompletionItemKind.Keyword */);\n    data.set('snippet', 27 /* CompletionItemKind.Snippet */);\n    data.set('text', 18 /* CompletionItemKind.Text */);\n    data.set('color', 19 /* CompletionItemKind.Color */);\n    data.set('file', 20 /* CompletionItemKind.File */);\n    data.set('reference', 21 /* CompletionItemKind.Reference */);\n    data.set('customcolor', 22 /* CompletionItemKind.Customcolor */);\n    data.set('folder', 23 /* CompletionItemKind.Folder */);\n    data.set('type-parameter', 24 /* CompletionItemKind.TypeParameter */);\n    data.set('typeParameter', 24 /* CompletionItemKind.TypeParameter */);\n    data.set('account', 25 /* CompletionItemKind.User */);\n    data.set('issue', 26 /* CompletionItemKind.Issue */);\n    /**\n     * @internal\n     */\n    function fromString(value, strict) {\n        let res = data.get(value);\n        if (typeof res === 'undefined' && !strict) {\n            res = 9 /* CompletionItemKind.Property */;\n        }\n        return res;\n    }\n    CompletionItemKinds.fromString = fromString;\n})(CompletionItemKinds || (CompletionItemKinds = {}));\n/**\n * How an {@link InlineCompletionsProvider inline completion provider} was triggered.\n */\nexport var InlineCompletionTriggerKind;\n(function (InlineCompletionTriggerKind) {\n    /**\n     * Completion was triggered automatically while editing.\n     * It is sufficient to return a single completion item in this case.\n     */\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Automatic\"] = 0] = \"Automatic\";\n    /**\n     * Completion was triggered explicitly by a user gesture.\n     * Return multiple completion items to enable cycling through them.\n     */\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Explicit\"] = 1] = \"Explicit\";\n})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));\nexport class SelectedSuggestionInfo {\n    constructor(range, text, completionKind, isSnippetText) {\n        this.range = range;\n        this.text = text;\n        this.completionKind = completionKind;\n        this.isSnippetText = isSnippetText;\n    }\n    equals(other) {\n        return Range.lift(this.range).equalsRange(other.range)\n            && this.text === other.text\n            && this.completionKind === other.completionKind\n            && this.isSnippetText === other.isSnippetText;\n    }\n}\nexport var SignatureHelpTriggerKind;\n(function (SignatureHelpTriggerKind) {\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"Invoke\"] = 1] = \"Invoke\";\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"TriggerCharacter\"] = 2] = \"TriggerCharacter\";\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"ContentChange\"] = 3] = \"ContentChange\";\n})(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));\n/**\n * A document highlight kind.\n */\nexport var DocumentHighlightKind;\n(function (DocumentHighlightKind) {\n    /**\n     * A textual occurrence.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Text\"] = 0] = \"Text\";\n    /**\n     * Read-access of a symbol, like reading a variable.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Read\"] = 1] = \"Read\";\n    /**\n     * Write-access of a symbol, like writing to a variable.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Write\"] = 2] = \"Write\";\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\n/**\n * @internal\n */\nexport function isLocationLink(thing) {\n    return thing\n        && URI.isUri(thing.uri)\n        && Range.isIRange(thing.range)\n        && (Range.isIRange(thing.originSelectionRange) || Range.isIRange(thing.targetSelectionRange));\n}\n/**\n * @internal\n */\nexport var SymbolKinds;\n(function (SymbolKinds) {\n    const byKind = new Map();\n    byKind.set(0 /* SymbolKind.File */, Codicon.symbolFile);\n    byKind.set(1 /* SymbolKind.Module */, Codicon.symbolModule);\n    byKind.set(2 /* SymbolKind.Namespace */, Codicon.symbolNamespace);\n    byKind.set(3 /* SymbolKind.Package */, Codicon.symbolPackage);\n    byKind.set(4 /* SymbolKind.Class */, Codicon.symbolClass);\n    byKind.set(5 /* SymbolKind.Method */, Codicon.symbolMethod);\n    byKind.set(6 /* SymbolKind.Property */, Codicon.symbolProperty);\n    byKind.set(7 /* SymbolKind.Field */, Codicon.symbolField);\n    byKind.set(8 /* SymbolKind.Constructor */, Codicon.symbolConstructor);\n    byKind.set(9 /* SymbolKind.Enum */, Codicon.symbolEnum);\n    byKind.set(10 /* SymbolKind.Interface */, Codicon.symbolInterface);\n    byKind.set(11 /* SymbolKind.Function */, Codicon.symbolFunction);\n    byKind.set(12 /* SymbolKind.Variable */, Codicon.symbolVariable);\n    byKind.set(13 /* SymbolKind.Constant */, Codicon.symbolConstant);\n    byKind.set(14 /* SymbolKind.String */, Codicon.symbolString);\n    byKind.set(15 /* SymbolKind.Number */, Codicon.symbolNumber);\n    byKind.set(16 /* SymbolKind.Boolean */, Codicon.symbolBoolean);\n    byKind.set(17 /* SymbolKind.Array */, Codicon.symbolArray);\n    byKind.set(18 /* SymbolKind.Object */, Codicon.symbolObject);\n    byKind.set(19 /* SymbolKind.Key */, Codicon.symbolKey);\n    byKind.set(20 /* SymbolKind.Null */, Codicon.symbolNull);\n    byKind.set(21 /* SymbolKind.EnumMember */, Codicon.symbolEnumMember);\n    byKind.set(22 /* SymbolKind.Struct */, Codicon.symbolStruct);\n    byKind.set(23 /* SymbolKind.Event */, Codicon.symbolEvent);\n    byKind.set(24 /* SymbolKind.Operator */, Codicon.symbolOperator);\n    byKind.set(25 /* SymbolKind.TypeParameter */, Codicon.symbolTypeParameter);\n    /**\n     * @internal\n     */\n    function toIcon(kind) {\n        let icon = byKind.get(kind);\n        if (!icon) {\n            console.info('No codicon found for SymbolKind ' + kind);\n            icon = Codicon.symbolProperty;\n        }\n        return icon;\n    }\n    SymbolKinds.toIcon = toIcon;\n})(SymbolKinds || (SymbolKinds = {}));\nexport class FoldingRangeKind {\n    /**\n     * Returns a {@link FoldingRangeKind} for the given value.\n     *\n     * @param value of the kind.\n     */\n    static fromValue(value) {\n        switch (value) {\n            case 'comment': return FoldingRangeKind.Comment;\n            case 'imports': return FoldingRangeKind.Imports;\n            case 'region': return FoldingRangeKind.Region;\n        }\n        return new FoldingRangeKind(value);\n    }\n    /**\n     * Creates a new {@link FoldingRangeKind}.\n     *\n     * @param value of the kind.\n     */\n    constructor(value) {\n        this.value = value;\n    }\n}\n/**\n * Kind for folding range representing a comment. The value of the kind is 'comment'.\n */\nFoldingRangeKind.Comment = new FoldingRangeKind('comment');\n/**\n * Kind for folding range representing a import. The value of the kind is 'imports'.\n */\nFoldingRangeKind.Imports = new FoldingRangeKind('imports');\n/**\n * Kind for folding range representing regions (for example marked by `#region`, `#endregion`).\n * The value of the kind is 'region'.\n */\nFoldingRangeKind.Region = new FoldingRangeKind('region');\n/**\n * @internal\n */\nexport var Command;\n(function (Command) {\n    /**\n     * @internal\n     */\n    function is(obj) {\n        if (!obj || typeof obj !== 'object') {\n            return false;\n        }\n        return typeof obj.id === 'string' &&\n            typeof obj.title === 'string';\n    }\n    Command.is = is;\n})(Command || (Command = {}));\nexport var InlayHintKind;\n(function (InlayHintKind) {\n    InlayHintKind[InlayHintKind[\"Type\"] = 1] = \"Type\";\n    InlayHintKind[InlayHintKind[\"Parameter\"] = 2] = \"Parameter\";\n})(InlayHintKind || (InlayHintKind = {}));\n/**\n * @internal\n */\nexport class LazyTokenizationSupport {\n    constructor(createSupport) {\n        this.createSupport = createSupport;\n        this._tokenizationSupport = null;\n    }\n    dispose() {\n        if (this._tokenizationSupport) {\n            this._tokenizationSupport.then((support) => {\n                if (support) {\n                    support.dispose();\n                }\n            });\n        }\n    }\n    get tokenizationSupport() {\n        if (!this._tokenizationSupport) {\n            this._tokenizationSupport = this.createSupport();\n        }\n        return this._tokenizationSupport;\n    }\n}\n/**\n * @internal\n */\nexport const TokenizationRegistry = new TokenizationRegistryImpl();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { IndentAction } from './languageConfiguration.js';\nimport { createScopedLineTokens } from './supports.js';\nimport { getScopedLineTokens } from './languageConfigurationRegistry.js';\n/**\n * Get nearest preceding line which doesn't match unIndentPattern or contains all whitespace.\n * Result:\n * -1: run into the boundary of embedded languages\n * 0: every line above are invalid\n * else: nearest preceding line of the same language\n */\nfunction getPrecedingValidLine(model, lineNumber, indentRulesSupport) {\n    const languageId = model.tokenization.getLanguageIdAtPosition(lineNumber, 0);\n    if (lineNumber > 1) {\n        let lastLineNumber;\n        let resultLineNumber = -1;\n        for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n            if (model.tokenization.getLanguageIdAtPosition(lastLineNumber, 0) !== languageId) {\n                return resultLineNumber;\n            }\n            const text = model.getLineContent(lastLineNumber);\n            if (indentRulesSupport.shouldIgnore(text) || /^\\s+$/.test(text) || text === '') {\n                resultLineNumber = lastLineNumber;\n                continue;\n            }\n            return lastLineNumber;\n        }\n    }\n    return -1;\n}\n/**\n * Get inherited indentation from above lines.\n * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.\n * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.\n * 3. If this line doesn't match any indent rules\n *   a. check whether the line above it matches indentNextLinePattern\n *   b. If not, the indent level of this line is the result\n *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).\n * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`\n *\n * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.\n */\nexport function getInheritIndentForLine(autoIndent, model, lineNumber, honorIntentialIndent = true, languageConfigurationService) {\n    if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n        return null;\n    }\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(model.tokenization.getLanguageId()).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    if (lineNumber <= 1) {\n        return {\n            indentation: '',\n            action: null\n        };\n    }\n    // Use no indent if this is the first non-blank line\n    for (let priorLineNumber = lineNumber - 1; priorLineNumber > 0; priorLineNumber--) {\n        if (model.getLineContent(priorLineNumber) !== '') {\n            break;\n        }\n        if (priorLineNumber === 1) {\n            return {\n                indentation: '',\n                action: null\n            };\n        }\n    }\n    const precedingUnIgnoredLine = getPrecedingValidLine(model, lineNumber, indentRulesSupport);\n    if (precedingUnIgnoredLine < 0) {\n        return null;\n    }\n    else if (precedingUnIgnoredLine < 1) {\n        return {\n            indentation: '',\n            action: null\n        };\n    }\n    const precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\n    if (indentRulesSupport.shouldIncrease(precedingUnIgnoredLineContent) || indentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLineContent)) {\n        return {\n            indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n            action: IndentAction.Indent,\n            line: precedingUnIgnoredLine\n        };\n    }\n    else if (indentRulesSupport.shouldDecrease(precedingUnIgnoredLineContent)) {\n        return {\n            indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n            action: null,\n            line: precedingUnIgnoredLine\n        };\n    }\n    else {\n        // precedingUnIgnoredLine can not be ignored.\n        // it doesn't increase indent of following lines\n        // it doesn't increase just next line\n        // so current line is not affect by precedingUnIgnoredLine\n        // and then we should get a correct inheritted indentation from above lines\n        if (precedingUnIgnoredLine === 1) {\n            return {\n                indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n                action: null,\n                line: precedingUnIgnoredLine\n            };\n        }\n        const previousLine = precedingUnIgnoredLine - 1;\n        const previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));\n        if (!(previousLineIndentMetadata & (1 /* IndentConsts.INCREASE_MASK */ | 2 /* IndentConsts.DECREASE_MASK */)) &&\n            (previousLineIndentMetadata & 4 /* IndentConsts.INDENT_NEXTLINE_MASK */)) {\n            let stopLine = 0;\n            for (let i = previousLine - 1; i > 0; i--) {\n                if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n                    continue;\n                }\n                stopLine = i;\n                break;\n            }\n            return {\n                indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n                action: null,\n                line: stopLine + 1\n            };\n        }\n        if (honorIntentialIndent) {\n            return {\n                indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n                action: null,\n                line: precedingUnIgnoredLine\n            };\n        }\n        else {\n            // search from precedingUnIgnoredLine until we find one whose indent is not temporary\n            for (let i = precedingUnIgnoredLine; i > 0; i--) {\n                const lineContent = model.getLineContent(i);\n                if (indentRulesSupport.shouldIncrease(lineContent)) {\n                    return {\n                        indentation: strings.getLeadingWhitespace(lineContent),\n                        action: IndentAction.Indent,\n                        line: i\n                    };\n                }\n                else if (indentRulesSupport.shouldIndentNextLine(lineContent)) {\n                    let stopLine = 0;\n                    for (let j = i - 1; j > 0; j--) {\n                        if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n                            continue;\n                        }\n                        stopLine = j;\n                        break;\n                    }\n                    return {\n                        indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n                        action: null,\n                        line: stopLine + 1\n                    };\n                }\n                else if (indentRulesSupport.shouldDecrease(lineContent)) {\n                    return {\n                        indentation: strings.getLeadingWhitespace(lineContent),\n                        action: null,\n                        line: i\n                    };\n                }\n            }\n            return {\n                indentation: strings.getLeadingWhitespace(model.getLineContent(1)),\n                action: null,\n                line: 1\n            };\n        }\n    }\n}\nexport function getGoodIndentForLine(autoIndent, virtualModel, languageId, lineNumber, indentConverter, languageConfigurationService) {\n    if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n        return null;\n    }\n    const richEditSupport = languageConfigurationService.getLanguageConfiguration(languageId);\n    if (!richEditSupport) {\n        return null;\n    }\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(languageId).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    const indent = getInheritIndentForLine(autoIndent, virtualModel, lineNumber, undefined, languageConfigurationService);\n    const lineContent = virtualModel.getLineContent(lineNumber);\n    if (indent) {\n        const inheritLine = indent.line;\n        if (inheritLine !== undefined) {\n            // Apply enter action as long as there are only whitespace lines between inherited line and this line.\n            let shouldApplyEnterRules = true;\n            for (let inBetweenLine = inheritLine; inBetweenLine < lineNumber - 1; inBetweenLine++) {\n                if (!/^\\s*$/.test(virtualModel.getLineContent(inBetweenLine))) {\n                    shouldApplyEnterRules = false;\n                    break;\n                }\n            }\n            if (shouldApplyEnterRules) {\n                const enterResult = richEditSupport.onEnter(autoIndent, '', virtualModel.getLineContent(inheritLine), '');\n                if (enterResult) {\n                    let indentation = strings.getLeadingWhitespace(virtualModel.getLineContent(inheritLine));\n                    if (enterResult.removeText) {\n                        indentation = indentation.substring(0, indentation.length - enterResult.removeText);\n                    }\n                    if ((enterResult.indentAction === IndentAction.Indent) ||\n                        (enterResult.indentAction === IndentAction.IndentOutdent)) {\n                        indentation = indentConverter.shiftIndent(indentation);\n                    }\n                    else if (enterResult.indentAction === IndentAction.Outdent) {\n                        indentation = indentConverter.unshiftIndent(indentation);\n                    }\n                    if (indentRulesSupport.shouldDecrease(lineContent)) {\n                        indentation = indentConverter.unshiftIndent(indentation);\n                    }\n                    if (enterResult.appendText) {\n                        indentation += enterResult.appendText;\n                    }\n                    return strings.getLeadingWhitespace(indentation);\n                }\n            }\n        }\n        if (indentRulesSupport.shouldDecrease(lineContent)) {\n            if (indent.action === IndentAction.Indent) {\n                return indent.indentation;\n            }\n            else {\n                return indentConverter.unshiftIndent(indent.indentation);\n            }\n        }\n        else {\n            if (indent.action === IndentAction.Indent) {\n                return indentConverter.shiftIndent(indent.indentation);\n            }\n            else {\n                return indent.indentation;\n            }\n        }\n    }\n    return null;\n}\nexport function getIndentForEnter(autoIndent, model, range, indentConverter, languageConfigurationService) {\n    if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n        return null;\n    }\n    model.tokenization.forceTokenization(range.startLineNumber);\n    const lineTokens = model.tokenization.getLineTokens(range.startLineNumber);\n    const scopedLineTokens = createScopedLineTokens(lineTokens, range.startColumn - 1);\n    const scopedLineText = scopedLineTokens.getLineContent();\n    let embeddedLanguage = false;\n    let beforeEnterText;\n    if (scopedLineTokens.firstCharOffset > 0 && lineTokens.getLanguageId(0) !== scopedLineTokens.languageId) {\n        // we are in the embeded language content\n        embeddedLanguage = true; // if embeddedLanguage is true, then we don't touch the indentation of current line\n        beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    else {\n        beforeEnterText = lineTokens.getLineContent().substring(0, range.startColumn - 1);\n    }\n    let afterEnterText;\n    if (range.isEmpty()) {\n        afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    else {\n        const endScopedLineTokens = getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n        afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    const beforeEnterResult = beforeEnterText;\n    const beforeEnterIndent = strings.getLeadingWhitespace(beforeEnterText);\n    const virtualModel = {\n        tokenization: {\n            getLineTokens: (lineNumber) => {\n                return model.tokenization.getLineTokens(lineNumber);\n            },\n            getLanguageId: () => {\n                return model.getLanguageId();\n            },\n            getLanguageIdAtPosition: (lineNumber, column) => {\n                return model.getLanguageIdAtPosition(lineNumber, column);\n            },\n        },\n        getLineContent: (lineNumber) => {\n            if (lineNumber === range.startLineNumber) {\n                return beforeEnterResult;\n            }\n            else {\n                return model.getLineContent(lineNumber);\n            }\n        }\n    };\n    const currentLineIndent = strings.getLeadingWhitespace(lineTokens.getLineContent());\n    const afterEnterAction = getInheritIndentForLine(autoIndent, virtualModel, range.startLineNumber + 1, undefined, languageConfigurationService);\n    if (!afterEnterAction) {\n        const beforeEnter = embeddedLanguage ? currentLineIndent : beforeEnterIndent;\n        return {\n            beforeEnter: beforeEnter,\n            afterEnter: beforeEnter\n        };\n    }\n    let afterEnterIndent = embeddedLanguage ? currentLineIndent : afterEnterAction.indentation;\n    if (afterEnterAction.action === IndentAction.Indent) {\n        afterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);\n    }\n    if (indentRulesSupport.shouldDecrease(afterEnterText)) {\n        afterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);\n    }\n    return {\n        beforeEnter: embeddedLanguage ? currentLineIndent : beforeEnterIndent,\n        afterEnter: afterEnterIndent\n    };\n}\n/**\n * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of\n * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.\n */\nexport function getIndentActionForType(autoIndent, model, range, ch, indentConverter, languageConfigurationService) {\n    if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n        return null;\n    }\n    const scopedLineTokens = getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n    if (scopedLineTokens.firstCharOffset) {\n        // this line has mixed languages and indentation rules will not work\n        return null;\n    }\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    const scopedLineText = scopedLineTokens.getLineContent();\n    const beforeTypeText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    // selection support\n    let afterTypeText;\n    if (range.isEmpty()) {\n        afterTypeText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    else {\n        const endScopedLineTokens = getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n        afterTypeText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    // If previous content already matches decreaseIndentPattern, it means indentation of this line should already be adjusted\n    // Users might change the indentation by purpose and we should honor that instead of readjusting.\n    if (!indentRulesSupport.shouldDecrease(beforeTypeText + afterTypeText) && indentRulesSupport.shouldDecrease(beforeTypeText + ch + afterTypeText)) {\n        // after typing `ch`, the content matches decreaseIndentPattern, we should adjust the indent to a good manner.\n        // 1. Get inherited indent action\n        const r = getInheritIndentForLine(autoIndent, model, range.startLineNumber, false, languageConfigurationService);\n        if (!r) {\n            return null;\n        }\n        let indentation = r.indentation;\n        if (r.action !== IndentAction.Indent) {\n            indentation = indentConverter.unshiftIndent(indentation);\n        }\n        return indentation;\n    }\n    return null;\n}\nexport function getIndentMetadata(model, lineNumber, languageConfigurationService) {\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    if (lineNumber < 1 || lineNumber > model.getLineCount()) {\n        return null;\n    }\n    return indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Color, HSLA } from '../../../base/common/color.js';\nfunction _parseCaptureGroups(captureGroups) {\n    const values = [];\n    for (const captureGroup of captureGroups) {\n        const parsedNumber = Number(captureGroup);\n        if (parsedNumber || parsedNumber === 0 && captureGroup.replace(/\\s/g, '') !== '') {\n            values.push(parsedNumber);\n        }\n    }\n    return values;\n}\nfunction _toIColor(r, g, b, a) {\n    return {\n        red: r / 255,\n        blue: b / 255,\n        green: g / 255,\n        alpha: a\n    };\n}\nfunction _findRange(model, match) {\n    const index = match.index;\n    const length = match[0].length;\n    if (!index) {\n        return;\n    }\n    const startPosition = model.positionAt(index);\n    const range = {\n        startLineNumber: startPosition.lineNumber,\n        startColumn: startPosition.column,\n        endLineNumber: startPosition.lineNumber,\n        endColumn: startPosition.column + length\n    };\n    return range;\n}\nfunction _findHexColorInformation(range, hexValue) {\n    if (!range) {\n        return;\n    }\n    const parsedHexColor = Color.Format.CSS.parseHex(hexValue);\n    if (!parsedHexColor) {\n        return;\n    }\n    return {\n        range: range,\n        color: _toIColor(parsedHexColor.rgba.r, parsedHexColor.rgba.g, parsedHexColor.rgba.b, parsedHexColor.rgba.a)\n    };\n}\nfunction _findRGBColorInformation(range, matches, isAlpha) {\n    if (!range || matches.length !== 1) {\n        return;\n    }\n    const match = matches[0];\n    const captureGroups = match.values();\n    const parsedRegex = _parseCaptureGroups(captureGroups);\n    return {\n        range: range,\n        color: _toIColor(parsedRegex[0], parsedRegex[1], parsedRegex[2], isAlpha ? parsedRegex[3] : 1)\n    };\n}\nfunction _findHSLColorInformation(range, matches, isAlpha) {\n    if (!range || matches.length !== 1) {\n        return;\n    }\n    const match = matches[0];\n    const captureGroups = match.values();\n    const parsedRegex = _parseCaptureGroups(captureGroups);\n    const colorEquivalent = new Color(new HSLA(parsedRegex[0], parsedRegex[1] / 100, parsedRegex[2] / 100, isAlpha ? parsedRegex[3] : 1));\n    return {\n        range: range,\n        color: _toIColor(colorEquivalent.rgba.r, colorEquivalent.rgba.g, colorEquivalent.rgba.b, colorEquivalent.rgba.a)\n    };\n}\nfunction _findMatches(model, regex) {\n    if (typeof model === 'string') {\n        return [...model.matchAll(regex)];\n    }\n    else {\n        return model.findMatches(regex);\n    }\n}\nfunction computeColors(model) {\n    const result = [];\n    // Early validation for RGB and HSL\n    const initialValidationRegex = /\\b(rgb|rgba|hsl|hsla)(\\([0-9\\s,.\\%]*\\))|(#)([A-Fa-f0-9]{6})\\b|(#)([A-Fa-f0-9]{8})\\b/gm;\n    const initialValidationMatches = _findMatches(model, initialValidationRegex);\n    // Potential colors have been found, validate the parameters\n    if (initialValidationMatches.length > 0) {\n        for (const initialMatch of initialValidationMatches) {\n            const initialCaptureGroups = initialMatch.filter(captureGroup => captureGroup !== undefined);\n            const colorScheme = initialCaptureGroups[1];\n            const colorParameters = initialCaptureGroups[2];\n            if (!colorParameters) {\n                continue;\n            }\n            let colorInformation;\n            if (colorScheme === 'rgb') {\n                const regexParameters = /^\\(\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*\\)$/gm;\n                colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);\n            }\n            else if (colorScheme === 'rgba') {\n                const regexParameters = /^\\(\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\\s*\\)$/gm;\n                colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);\n            }\n            else if (colorScheme === 'hsl') {\n                const regexParameters = /^\\(\\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*\\)$/gm;\n                colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);\n            }\n            else if (colorScheme === 'hsla') {\n                const regexParameters = /^\\(\\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*,\\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\\s*\\)$/gm;\n                colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);\n            }\n            else if (colorScheme === '#') {\n                colorInformation = _findHexColorInformation(_findRange(model, initialMatch), colorScheme + colorParameters);\n            }\n            if (colorInformation) {\n                result.push(colorInformation);\n            }\n        }\n    }\n    return result;\n}\n/**\n * Returns an array of all default document colors in the provided document\n */\nexport function computeDefaultDocumentColors(model) {\n    if (!model || typeof model.getValue !== 'function' || typeof model.positionAt !== 'function') {\n        // Unknown caller!\n        return [];\n    }\n    return computeColors(model);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IndentAction } from './languageConfiguration.js';\nimport { getIndentationAtPosition, getScopedLineTokens } from './languageConfigurationRegistry.js';\nexport function getEnterAction(autoIndent, model, range, languageConfigurationService) {\n    const scopedLineTokens = getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n    const richEditSupport = languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId);\n    if (!richEditSupport) {\n        return null;\n    }\n    const scopedLineText = scopedLineTokens.getLineContent();\n    const beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    // selection support\n    let afterEnterText;\n    if (range.isEmpty()) {\n        afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    else {\n        const endScopedLineTokens = getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n        afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    let previousLineText = '';\n    if (range.startLineNumber > 1 && scopedLineTokens.firstCharOffset === 0) {\n        // This is not the first line and the entire line belongs to this mode\n        const oneLineAboveScopedLineTokens = getScopedLineTokens(model, range.startLineNumber - 1);\n        if (oneLineAboveScopedLineTokens.languageId === scopedLineTokens.languageId) {\n            // The line above ends with text belonging to the same mode\n            previousLineText = oneLineAboveScopedLineTokens.getLineContent();\n        }\n    }\n    const enterResult = richEditSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n    if (!enterResult) {\n        return null;\n    }\n    const indentAction = enterResult.indentAction;\n    let appendText = enterResult.appendText;\n    const removeText = enterResult.removeText || 0;\n    // Here we add `\\t` to appendText first because enterAction is leveraging appendText and removeText to change indentation.\n    if (!appendText) {\n        if ((indentAction === IndentAction.Indent) ||\n            (indentAction === IndentAction.IndentOutdent)) {\n            appendText = '\\t';\n        }\n        else {\n            appendText = '';\n        }\n    }\n    else if (indentAction === IndentAction.Indent) {\n        appendText = '\\t' + appendText;\n    }\n    let indentation = getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n    if (removeText) {\n        indentation = indentation.substring(0, indentation.length - removeText);\n    }\n    return {\n        indentAction: indentAction,\n        appendText: appendText,\n        removeText: removeText,\n        indentation: indentation\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ILanguageService = createDecorator('languageService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Describes what to do with the indentation when pressing Enter.\n */\nexport var IndentAction;\n(function (IndentAction) {\n    /**\n     * Insert new line and copy the previous line's indentation.\n     */\n    IndentAction[IndentAction[\"None\"] = 0] = \"None\";\n    /**\n     * Insert new line and indent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Indent\"] = 1] = \"Indent\";\n    /**\n     * Insert two new lines:\n     *  - the first one indented which will hold the cursor\n     *  - the second one at the same indentation level\n     */\n    IndentAction[IndentAction[\"IndentOutdent\"] = 2] = \"IndentOutdent\";\n    /**\n     * Insert new line and outdent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Outdent\"] = 3] = \"Outdent\";\n})(IndentAction || (IndentAction = {}));\n/**\n * @internal\n */\nexport class StandardAutoClosingPairConditional {\n    constructor(source) {\n        this._neutralCharacter = null;\n        this._neutralCharacterSearched = false;\n        this.open = source.open;\n        this.close = source.close;\n        // initially allowed in all tokens\n        this._inString = true;\n        this._inComment = true;\n        this._inRegEx = true;\n        if (Array.isArray(source.notIn)) {\n            for (let i = 0, len = source.notIn.length; i < len; i++) {\n                const notIn = source.notIn[i];\n                switch (notIn) {\n                    case 'string':\n                        this._inString = false;\n                        break;\n                    case 'comment':\n                        this._inComment = false;\n                        break;\n                    case 'regex':\n                        this._inRegEx = false;\n                        break;\n                }\n            }\n        }\n    }\n    isOK(standardToken) {\n        switch (standardToken) {\n            case 0 /* StandardTokenType.Other */:\n                return true;\n            case 1 /* StandardTokenType.Comment */:\n                return this._inComment;\n            case 2 /* StandardTokenType.String */:\n                return this._inString;\n            case 3 /* StandardTokenType.RegEx */:\n                return this._inRegEx;\n        }\n    }\n    shouldAutoClose(context, column) {\n        // Always complete on empty line\n        if (context.getTokenCount() === 0) {\n            return true;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 2);\n        const standardTokenType = context.getStandardTokenType(tokenIndex);\n        return this.isOK(standardTokenType);\n    }\n    _findNeutralCharacterInRange(fromCharCode, toCharCode) {\n        for (let charCode = fromCharCode; charCode <= toCharCode; charCode++) {\n            const character = String.fromCharCode(charCode);\n            if (!this.open.includes(character) && !this.close.includes(character)) {\n                return character;\n            }\n        }\n        return null;\n    }\n    /**\n     * Find a character in the range [0-9a-zA-Z] that does not appear in the open or close\n     */\n    findNeutralCharacter() {\n        if (!this._neutralCharacterSearched) {\n            this._neutralCharacterSearched = true;\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(48 /* CharCode.Digit0 */, 57 /* CharCode.Digit9 */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(97 /* CharCode.a */, 122 /* CharCode.z */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(65 /* CharCode.A */, 90 /* CharCode.Z */);\n            }\n        }\n        return this._neutralCharacter;\n    }\n}\n/**\n * @internal\n */\nexport class AutoClosingPairs {\n    constructor(autoClosingPairs) {\n        this.autoClosingPairsOpenByStart = new Map();\n        this.autoClosingPairsOpenByEnd = new Map();\n        this.autoClosingPairsCloseByStart = new Map();\n        this.autoClosingPairsCloseByEnd = new Map();\n        this.autoClosingPairsCloseSingleChar = new Map();\n        for (const pair of autoClosingPairs) {\n            appendEntry(this.autoClosingPairsOpenByStart, pair.open.charAt(0), pair);\n            appendEntry(this.autoClosingPairsOpenByEnd, pair.open.charAt(pair.open.length - 1), pair);\n            appendEntry(this.autoClosingPairsCloseByStart, pair.close.charAt(0), pair);\n            appendEntry(this.autoClosingPairsCloseByEnd, pair.close.charAt(pair.close.length - 1), pair);\n            if (pair.close.length === 1 && pair.open.length === 1) {\n                appendEntry(this.autoClosingPairsCloseSingleChar, pair.close, pair);\n            }\n        }\n    }\n}\nfunction appendEntry(target, key, value) {\n    if (target.has(key)) {\n        target.get(key).push(value);\n    }\n    else {\n        target.set(key, [value]);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { StandardAutoClosingPairConditional } from '../languageConfiguration.js';\nexport class CharacterPairSupport {\n    constructor(config) {\n        if (config.autoClosingPairs) {\n            this._autoClosingPairs = config.autoClosingPairs.map(el => new StandardAutoClosingPairConditional(el));\n        }\n        else if (config.brackets) {\n            this._autoClosingPairs = config.brackets.map(b => new StandardAutoClosingPairConditional({ open: b[0], close: b[1] }));\n        }\n        else {\n            this._autoClosingPairs = [];\n        }\n        if (config.__electricCharacterSupport && config.__electricCharacterSupport.docComment) {\n            const docComment = config.__electricCharacterSupport.docComment;\n            // IDocComment is legacy, only partially supported\n            this._autoClosingPairs.push(new StandardAutoClosingPairConditional({ open: docComment.open, close: docComment.close || '' }));\n        }\n        this._autoCloseBeforeForQuotes = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES;\n        this._autoCloseBeforeForBrackets = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS;\n        this._surroundingPairs = config.surroundingPairs || this._autoClosingPairs;\n    }\n    getAutoClosingPairs() {\n        return this._autoClosingPairs;\n    }\n    getAutoCloseBeforeSet(forQuotes) {\n        return (forQuotes ? this._autoCloseBeforeForQuotes : this._autoCloseBeforeForBrackets);\n    }\n    getSurroundingPairs() {\n        return this._surroundingPairs;\n    }\n}\nCharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES = ';:.,=}])> \\n\\t';\nCharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS = '\\'\"`;:.,=}])> \\n\\t';\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { distinct } from '../../../../base/common/arrays.js';\nimport { ignoreBracketsInToken } from '../supports.js';\nimport { BracketsUtils } from './richEditBrackets.js';\nexport class BracketElectricCharacterSupport {\n    constructor(richEditBrackets) {\n        this._richEditBrackets = richEditBrackets;\n    }\n    getElectricCharacters() {\n        const result = [];\n        if (this._richEditBrackets) {\n            for (const bracket of this._richEditBrackets.brackets) {\n                for (const close of bracket.close) {\n                    const lastChar = close.charAt(close.length - 1);\n                    result.push(lastChar);\n                }\n            }\n        }\n        return distinct(result);\n    }\n    onElectricCharacter(character, context, column) {\n        if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) {\n            return null;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 1);\n        if (ignoreBracketsInToken(context.getStandardTokenType(tokenIndex))) {\n            return null;\n        }\n        const reversedBracketRegex = this._richEditBrackets.reversedRegex;\n        const text = context.getLineContent().substring(0, column - 1) + character;\n        const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, 1, text, 0, text.length);\n        if (!r) {\n            return null;\n        }\n        const bracketText = text.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n        const isOpen = this._richEditBrackets.textIsOpenBracket[bracketText];\n        if (isOpen) {\n            return null;\n        }\n        const textBeforeBracket = context.getActualLineContentBefore(r.startColumn - 1);\n        if (!/^\\s*$/.test(textBeforeBracket)) {\n            // There is other text on the line before the bracket\n            return null;\n        }\n        return {\n            matchOpenBracket: bracketText\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction resetGlobalRegex(reg) {\n    if (reg.global) {\n        reg.lastIndex = 0;\n    }\n    return true;\n}\nexport class IndentRulesSupport {\n    constructor(indentationRules) {\n        this._indentationRules = indentationRules;\n    }\n    shouldIncrease(text) {\n        if (this._indentationRules) {\n            if (this._indentationRules.increaseIndentPattern && resetGlobalRegex(this._indentationRules.increaseIndentPattern) && this._indentationRules.increaseIndentPattern.test(text)) {\n                return true;\n            }\n            // if (this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(text)) {\n            // \treturn true;\n            // }\n        }\n        return false;\n    }\n    shouldDecrease(text) {\n        if (this._indentationRules && this._indentationRules.decreaseIndentPattern && resetGlobalRegex(this._indentationRules.decreaseIndentPattern) && this._indentationRules.decreaseIndentPattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIndentNextLine(text) {\n        if (this._indentationRules && this._indentationRules.indentNextLinePattern && resetGlobalRegex(this._indentationRules.indentNextLinePattern) && this._indentationRules.indentNextLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIgnore(text) {\n        // the text matches `unIndentedLinePattern`\n        if (this._indentationRules && this._indentationRules.unIndentedLinePattern && resetGlobalRegex(this._indentationRules.unIndentedLinePattern) && this._indentationRules.unIndentedLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    getIndentMetadata(text) {\n        let ret = 0;\n        if (this.shouldIncrease(text)) {\n            ret += 1 /* IndentConsts.INCREASE_MASK */;\n        }\n        if (this.shouldDecrease(text)) {\n            ret += 2 /* IndentConsts.DECREASE_MASK */;\n        }\n        if (this.shouldIndentNextLine(text)) {\n            ret += 4 /* IndentConsts.INDENT_NEXTLINE_MASK */;\n        }\n        if (this.shouldIgnore(text)) {\n            ret += 8 /* IndentConsts.UNINDENT_MASK */;\n        }\n        return ret;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { IndentAction } from '../languageConfiguration.js';\nexport class OnEnterSupport {\n    constructor(opts) {\n        opts = opts || {};\n        opts.brackets = opts.brackets || [\n            ['(', ')'],\n            ['{', '}'],\n            ['[', ']']\n        ];\n        this._brackets = [];\n        opts.brackets.forEach((bracket) => {\n            const openRegExp = OnEnterSupport._createOpenBracketRegExp(bracket[0]);\n            const closeRegExp = OnEnterSupport._createCloseBracketRegExp(bracket[1]);\n            if (openRegExp && closeRegExp) {\n                this._brackets.push({\n                    open: bracket[0],\n                    openRegExp: openRegExp,\n                    close: bracket[1],\n                    closeRegExp: closeRegExp,\n                });\n            }\n        });\n        this._regExpRules = opts.onEnterRules || [];\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        // (1): `regExpRules`\n        if (autoIndent >= 3 /* EditorAutoIndentStrategy.Advanced */) {\n            for (let i = 0, len = this._regExpRules.length; i < len; i++) {\n                const rule = this._regExpRules[i];\n                const regResult = [{\n                        reg: rule.beforeText,\n                        text: beforeEnterText\n                    }, {\n                        reg: rule.afterText,\n                        text: afterEnterText\n                    }, {\n                        reg: rule.previousLineText,\n                        text: previousLineText\n                    }].every((obj) => {\n                    if (!obj.reg) {\n                        return true;\n                    }\n                    obj.reg.lastIndex = 0; // To disable the effect of the \"g\" flag.\n                    return obj.reg.test(obj.text);\n                });\n                if (regResult) {\n                    return rule.action;\n                }\n            }\n        }\n        // (2): Special indent-outdent\n        if (autoIndent >= 2 /* EditorAutoIndentStrategy.Brackets */) {\n            if (beforeEnterText.length > 0 && afterEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    const bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText) && bracket.closeRegExp.test(afterEnterText)) {\n                        return { indentAction: IndentAction.IndentOutdent };\n                    }\n                }\n            }\n        }\n        // (4): Open bracket based logic\n        if (autoIndent >= 2 /* EditorAutoIndentStrategy.Brackets */) {\n            if (beforeEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    const bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText)) {\n                        return { indentAction: IndentAction.Indent };\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    static _createOpenBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(0))) {\n            str = '\\\\b' + str;\n        }\n        str += '\\\\s*$';\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _createCloseBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(str.length - 1))) {\n            str = str + '\\\\b';\n        }\n        str = '^\\\\s*' + str;\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _safeRegExp(def) {\n        try {\n            return new RegExp(def);\n        }\n        catch (err) {\n            onUnexpectedError(err);\n            return null;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CachedFunction } from '../../../../base/common/cache.js';\n/**\n * Captures all bracket related configurations for a single language.\n * Immutable.\n*/\nexport class LanguageBracketsConfiguration {\n    constructor(languageId, config) {\n        this.languageId = languageId;\n        const bracketPairs = config.brackets ? filterValidBrackets(config.brackets) : [];\n        const openingBracketInfos = new CachedFunction((bracket) => {\n            const closing = new Set();\n            return {\n                info: new OpeningBracketKind(this, bracket, closing),\n                closing,\n            };\n        });\n        const closingBracketInfos = new CachedFunction((bracket) => {\n            const opening = new Set();\n            const openingColorized = new Set();\n            return {\n                info: new ClosingBracketKind(this, bracket, opening, openingColorized),\n                opening,\n                openingColorized,\n            };\n        });\n        for (const [open, close] of bracketPairs) {\n            const opening = openingBracketInfos.get(open);\n            const closing = closingBracketInfos.get(close);\n            opening.closing.add(closing.info);\n            closing.opening.add(opening.info);\n        }\n        // Treat colorized brackets as brackets, and mark them as colorized.\n        const colorizedBracketPairs = config.colorizedBracketPairs\n            ? filterValidBrackets(config.colorizedBracketPairs)\n            // If not configured: Take all brackets except `<` ... `>`\n            // Many languages set < ... > as bracket pair, even though they also use it as comparison operator.\n            // This leads to problems when colorizing this bracket, so we exclude it if not explicitly configured otherwise.\n            // https://github.com/microsoft/vscode/issues/132476\n            : bracketPairs.filter((p) => !(p[0] === '<' && p[1] === '>'));\n        for (const [open, close] of colorizedBracketPairs) {\n            const opening = openingBracketInfos.get(open);\n            const closing = closingBracketInfos.get(close);\n            opening.closing.add(closing.info);\n            closing.openingColorized.add(opening.info);\n            closing.opening.add(opening.info);\n        }\n        this._openingBrackets = new Map([...openingBracketInfos.cachedValues].map(([k, v]) => [k, v.info]));\n        this._closingBrackets = new Map([...closingBracketInfos.cachedValues].map(([k, v]) => [k, v.info]));\n    }\n    /**\n     * No two brackets have the same bracket text.\n    */\n    get openingBrackets() {\n        return [...this._openingBrackets.values()];\n    }\n    /**\n     * No two brackets have the same bracket text.\n    */\n    get closingBrackets() {\n        return [...this._closingBrackets.values()];\n    }\n    getOpeningBracketInfo(bracketText) {\n        return this._openingBrackets.get(bracketText);\n    }\n    getClosingBracketInfo(bracketText) {\n        return this._closingBrackets.get(bracketText);\n    }\n    getBracketInfo(bracketText) {\n        return this.getOpeningBracketInfo(bracketText) || this.getClosingBracketInfo(bracketText);\n    }\n}\nfunction filterValidBrackets(bracketPairs) {\n    return bracketPairs.filter(([open, close]) => open !== '' && close !== '');\n}\nexport class BracketKindBase {\n    constructor(config, bracketText) {\n        this.config = config;\n        this.bracketText = bracketText;\n    }\n    get languageId() {\n        return this.config.languageId;\n    }\n}\nexport class OpeningBracketKind extends BracketKindBase {\n    constructor(config, bracketText, openedBrackets) {\n        super(config, bracketText);\n        this.openedBrackets = openedBrackets;\n        this.isOpeningBracket = true;\n    }\n}\nexport class ClosingBracketKind extends BracketKindBase {\n    constructor(config, bracketText, \n    /**\n     * Non empty array of all opening brackets this bracket closes.\n    */\n    openingBrackets, openingColorizedBrackets) {\n        super(config, bracketText);\n        this.openingBrackets = openingBrackets;\n        this.openingColorizedBrackets = openingColorizedBrackets;\n        this.isOpeningBracket = false;\n    }\n    /**\n     * Checks if this bracket closes the given other bracket.\n     * If the bracket infos come from different configurations, this method will return false.\n    */\n    closes(other) {\n        if (other['config'] !== this.config) {\n            return false;\n        }\n        return this.openingBrackets.has(other);\n    }\n    closesColorized(other) {\n        if (other['config'] !== this.config) {\n            return false;\n        }\n        return this.openingColorizedBrackets.has(other);\n    }\n    getOpeningBrackets() {\n        return [...this.openingBrackets];\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { DEFAULT_WORD_REGEXP, ensureValidWordDefinition } from '../core/wordHelper.js';\nimport { AutoClosingPairs } from './languageConfiguration.js';\nimport { createScopedLineTokens } from './supports.js';\nimport { CharacterPairSupport } from './supports/characterPair.js';\nimport { BracketElectricCharacterSupport } from './supports/electricCharacter.js';\nimport { IndentRulesSupport } from './supports/indentRules.js';\nimport { OnEnterSupport } from './supports/onEnter.js';\nimport { RichEditBrackets } from './supports/richEditBrackets.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { ILanguageService } from './language.js';\nimport { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nimport { PLAINTEXT_LANGUAGE_ID } from './modesRegistry.js';\nimport { LanguageBracketsConfiguration } from './supports/languageBracketsConfiguration.js';\nexport class LanguageConfigurationServiceChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n    affects(languageId) {\n        return !this.languageId ? true : this.languageId === languageId;\n    }\n}\nexport const ILanguageConfigurationService = createDecorator('languageConfigurationService');\nexport let LanguageConfigurationService = class LanguageConfigurationService extends Disposable {\n    constructor(configurationService, languageService) {\n        super();\n        this.configurationService = configurationService;\n        this.languageService = languageService;\n        this._registry = this._register(new LanguageConfigurationRegistry());\n        this.onDidChangeEmitter = this._register(new Emitter());\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.configurations = new Map();\n        const languageConfigKeys = new Set(Object.values(customizedLanguageConfigKeys));\n        this._register(this.configurationService.onDidChangeConfiguration((e) => {\n            const globalConfigChanged = e.change.keys.some((k) => languageConfigKeys.has(k));\n            const localConfigChanged = e.change.overrides\n                .filter(([overrideLangName, keys]) => keys.some((k) => languageConfigKeys.has(k)))\n                .map(([overrideLangName]) => overrideLangName);\n            if (globalConfigChanged) {\n                this.configurations.clear();\n                this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(undefined));\n            }\n            else {\n                for (const languageId of localConfigChanged) {\n                    if (this.languageService.isRegisteredLanguageId(languageId)) {\n                        this.configurations.delete(languageId);\n                        this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(languageId));\n                    }\n                }\n            }\n        }));\n        this._register(this._registry.onDidChange((e) => {\n            this.configurations.delete(e.languageId);\n            this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(e.languageId));\n        }));\n    }\n    register(languageId, configuration, priority) {\n        return this._registry.register(languageId, configuration, priority);\n    }\n    getLanguageConfiguration(languageId) {\n        let result = this.configurations.get(languageId);\n        if (!result) {\n            result = computeConfig(languageId, this._registry, this.configurationService, this.languageService);\n            this.configurations.set(languageId, result);\n        }\n        return result;\n    }\n};\nLanguageConfigurationService = __decorate([\n    __param(0, IConfigurationService),\n    __param(1, ILanguageService)\n], LanguageConfigurationService);\nfunction computeConfig(languageId, registry, configurationService, languageService) {\n    let languageConfig = registry.getLanguageConfiguration(languageId);\n    if (!languageConfig) {\n        if (!languageService.isRegisteredLanguageId(languageId)) {\n            // this happens for the null language, which can be returned by monarch.\n            // Instead of throwing an error, we just return a default config.\n            return new ResolvedLanguageConfiguration(languageId, {});\n        }\n        languageConfig = new ResolvedLanguageConfiguration(languageId, {});\n    }\n    const customizedConfig = getCustomizedLanguageConfig(languageConfig.languageId, configurationService);\n    const data = combineLanguageConfigurations([languageConfig.underlyingConfig, customizedConfig]);\n    const config = new ResolvedLanguageConfiguration(languageConfig.languageId, data);\n    return config;\n}\nconst customizedLanguageConfigKeys = {\n    brackets: 'editor.language.brackets',\n    colorizedBracketPairs: 'editor.language.colorizedBracketPairs'\n};\nfunction getCustomizedLanguageConfig(languageId, configurationService) {\n    const brackets = configurationService.getValue(customizedLanguageConfigKeys.brackets, {\n        overrideIdentifier: languageId,\n    });\n    const colorizedBracketPairs = configurationService.getValue(customizedLanguageConfigKeys.colorizedBracketPairs, {\n        overrideIdentifier: languageId,\n    });\n    return {\n        brackets: validateBracketPairs(brackets),\n        colorizedBracketPairs: validateBracketPairs(colorizedBracketPairs),\n    };\n}\nfunction validateBracketPairs(data) {\n    if (!Array.isArray(data)) {\n        return undefined;\n    }\n    return data.map(pair => {\n        if (!Array.isArray(pair) || pair.length !== 2) {\n            return undefined;\n        }\n        return [pair[0], pair[1]];\n    }).filter((p) => !!p);\n}\nexport function getIndentationAtPosition(model, lineNumber, column) {\n    const lineText = model.getLineContent(lineNumber);\n    let indentation = strings.getLeadingWhitespace(lineText);\n    if (indentation.length > column - 1) {\n        indentation = indentation.substring(0, column - 1);\n    }\n    return indentation;\n}\nexport function getScopedLineTokens(model, lineNumber, columnNumber) {\n    model.tokenization.forceTokenization(lineNumber);\n    const lineTokens = model.tokenization.getLineTokens(lineNumber);\n    const column = (typeof columnNumber === 'undefined' ? model.getLineMaxColumn(lineNumber) - 1 : columnNumber - 1);\n    return createScopedLineTokens(lineTokens, column);\n}\nclass ComposedLanguageConfiguration {\n    constructor(languageId) {\n        this.languageId = languageId;\n        this._resolved = null;\n        this._entries = [];\n        this._order = 0;\n        this._resolved = null;\n    }\n    register(configuration, priority) {\n        const entry = new LanguageConfigurationContribution(configuration, priority, ++this._order);\n        this._entries.push(entry);\n        this._resolved = null;\n        return toDisposable(() => {\n            for (let i = 0; i < this._entries.length; i++) {\n                if (this._entries[i] === entry) {\n                    this._entries.splice(i, 1);\n                    this._resolved = null;\n                    break;\n                }\n            }\n        });\n    }\n    getResolvedConfiguration() {\n        if (!this._resolved) {\n            const config = this._resolve();\n            if (config) {\n                this._resolved = new ResolvedLanguageConfiguration(this.languageId, config);\n            }\n        }\n        return this._resolved;\n    }\n    _resolve() {\n        if (this._entries.length === 0) {\n            return null;\n        }\n        this._entries.sort(LanguageConfigurationContribution.cmp);\n        return combineLanguageConfigurations(this._entries.map(e => e.configuration));\n    }\n}\nfunction combineLanguageConfigurations(configs) {\n    let result = {\n        comments: undefined,\n        brackets: undefined,\n        wordPattern: undefined,\n        indentationRules: undefined,\n        onEnterRules: undefined,\n        autoClosingPairs: undefined,\n        surroundingPairs: undefined,\n        autoCloseBefore: undefined,\n        folding: undefined,\n        colorizedBracketPairs: undefined,\n        __electricCharacterSupport: undefined,\n    };\n    for (const entry of configs) {\n        result = {\n            comments: entry.comments || result.comments,\n            brackets: entry.brackets || result.brackets,\n            wordPattern: entry.wordPattern || result.wordPattern,\n            indentationRules: entry.indentationRules || result.indentationRules,\n            onEnterRules: entry.onEnterRules || result.onEnterRules,\n            autoClosingPairs: entry.autoClosingPairs || result.autoClosingPairs,\n            surroundingPairs: entry.surroundingPairs || result.surroundingPairs,\n            autoCloseBefore: entry.autoCloseBefore || result.autoCloseBefore,\n            folding: entry.folding || result.folding,\n            colorizedBracketPairs: entry.colorizedBracketPairs || result.colorizedBracketPairs,\n            __electricCharacterSupport: entry.__electricCharacterSupport || result.__electricCharacterSupport,\n        };\n    }\n    return result;\n}\nclass LanguageConfigurationContribution {\n    constructor(configuration, priority, order) {\n        this.configuration = configuration;\n        this.priority = priority;\n        this.order = order;\n    }\n    static cmp(a, b) {\n        if (a.priority === b.priority) {\n            // higher order last\n            return a.order - b.order;\n        }\n        // higher priority last\n        return a.priority - b.priority;\n    }\n}\nexport class LanguageConfigurationChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n}\nexport class LanguageConfigurationRegistry extends Disposable {\n    constructor() {\n        super();\n        this._entries = new Map();\n        this._onDidChange = this._register(new Emitter());\n        this.onDidChange = this._onDidChange.event;\n        this._register(this.register(PLAINTEXT_LANGUAGE_ID, {\n            brackets: [\n                ['(', ')'],\n                ['[', ']'],\n                ['{', '}'],\n            ],\n            surroundingPairs: [\n                { open: '{', close: '}' },\n                { open: '[', close: ']' },\n                { open: '(', close: ')' },\n                { open: '<', close: '>' },\n                { open: '\\\"', close: '\\\"' },\n                { open: '\\'', close: '\\'' },\n                { open: '`', close: '`' },\n            ],\n            colorizedBracketPairs: [],\n            folding: {\n                offSide: true\n            }\n        }, 0));\n    }\n    /**\n     * @param priority Use a higher number for higher priority\n     */\n    register(languageId, configuration, priority = 0) {\n        let entries = this._entries.get(languageId);\n        if (!entries) {\n            entries = new ComposedLanguageConfiguration(languageId);\n            this._entries.set(languageId, entries);\n        }\n        const disposable = entries.register(configuration, priority);\n        this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        return toDisposable(() => {\n            disposable.dispose();\n            this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        });\n    }\n    getLanguageConfiguration(languageId) {\n        const entries = this._entries.get(languageId);\n        return (entries === null || entries === void 0 ? void 0 : entries.getResolvedConfiguration()) || null;\n    }\n}\n/**\n * Immutable.\n*/\nexport class ResolvedLanguageConfiguration {\n    constructor(languageId, underlyingConfig) {\n        this.languageId = languageId;\n        this.underlyingConfig = underlyingConfig;\n        this._brackets = null;\n        this._electricCharacter = null;\n        this._onEnterSupport =\n            this.underlyingConfig.brackets ||\n                this.underlyingConfig.indentationRules ||\n                this.underlyingConfig.onEnterRules\n                ? new OnEnterSupport(this.underlyingConfig)\n                : null;\n        this.comments = ResolvedLanguageConfiguration._handleComments(this.underlyingConfig);\n        this.characterPair = new CharacterPairSupport(this.underlyingConfig);\n        this.wordDefinition = this.underlyingConfig.wordPattern || DEFAULT_WORD_REGEXP;\n        this.indentationRules = this.underlyingConfig.indentationRules;\n        if (this.underlyingConfig.indentationRules) {\n            this.indentRulesSupport = new IndentRulesSupport(this.underlyingConfig.indentationRules);\n        }\n        else {\n            this.indentRulesSupport = null;\n        }\n        this.foldingRules = this.underlyingConfig.folding || {};\n        this.bracketsNew = new LanguageBracketsConfiguration(languageId, this.underlyingConfig);\n    }\n    getWordDefinition() {\n        return ensureValidWordDefinition(this.wordDefinition);\n    }\n    get brackets() {\n        if (!this._brackets && this.underlyingConfig.brackets) {\n            this._brackets = new RichEditBrackets(this.languageId, this.underlyingConfig.brackets);\n        }\n        return this._brackets;\n    }\n    get electricCharacter() {\n        if (!this._electricCharacter) {\n            this._electricCharacter = new BracketElectricCharacterSupport(this.brackets);\n        }\n        return this._electricCharacter;\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        if (!this._onEnterSupport) {\n            return null;\n        }\n        return this._onEnterSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n    }\n    getAutoClosingPairs() {\n        return new AutoClosingPairs(this.characterPair.getAutoClosingPairs());\n    }\n    getAutoCloseBeforeSet(forQuotes) {\n        return this.characterPair.getAutoCloseBeforeSet(forQuotes);\n    }\n    getSurroundingPairs() {\n        return this.characterPair.getSurroundingPairs();\n    }\n    static _handleComments(conf) {\n        const commentRule = conf.comments;\n        if (!commentRule) {\n            return null;\n        }\n        // comment configuration\n        const comments = {};\n        if (commentRule.lineComment) {\n            comments.lineCommentToken = commentRule.lineComment;\n        }\n        if (commentRule.blockComment) {\n            const [blockStart, blockEnd] = commentRule.blockComment;\n            comments.blockCommentStartToken = blockStart;\n            comments.blockCommentEndToken = blockEnd;\n        }\n        return comments;\n    }\n}\nregisterSingleton(ILanguageConfigurationService, LanguageConfigurationService, 1 /* InstantiationType.Delayed */);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CharacterClassifier } from '../core/characterClassifier.js';\nclass Uint8Matrix {\n    constructor(rows, cols, defaultValue) {\n        const data = new Uint8Array(rows * cols);\n        for (let i = 0, len = rows * cols; i < len; i++) {\n            data[i] = defaultValue;\n        }\n        this._data = data;\n        this.rows = rows;\n        this.cols = cols;\n    }\n    get(row, col) {\n        return this._data[row * this.cols + col];\n    }\n    set(row, col, value) {\n        this._data[row * this.cols + col] = value;\n    }\n}\nexport class StateMachine {\n    constructor(edges) {\n        let maxCharCode = 0;\n        let maxState = 0 /* State.Invalid */;\n        for (let i = 0, len = edges.length; i < len; i++) {\n            const [from, chCode, to] = edges[i];\n            if (chCode > maxCharCode) {\n                maxCharCode = chCode;\n            }\n            if (from > maxState) {\n                maxState = from;\n            }\n            if (to > maxState) {\n                maxState = to;\n            }\n        }\n        maxCharCode++;\n        maxState++;\n        const states = new Uint8Matrix(maxState, maxCharCode, 0 /* State.Invalid */);\n        for (let i = 0, len = edges.length; i < len; i++) {\n            const [from, chCode, to] = edges[i];\n            states.set(from, chCode, to);\n        }\n        this._states = states;\n        this._maxCharCode = maxCharCode;\n    }\n    nextState(currentState, chCode) {\n        if (chCode < 0 || chCode >= this._maxCharCode) {\n            return 0 /* State.Invalid */;\n        }\n        return this._states.get(currentState, chCode);\n    }\n}\n// State machine for http:// or https:// or file://\nlet _stateMachine = null;\nfunction getStateMachine() {\n    if (_stateMachine === null) {\n        _stateMachine = new StateMachine([\n            [1 /* State.Start */, 104 /* CharCode.h */, 2 /* State.H */],\n            [1 /* State.Start */, 72 /* CharCode.H */, 2 /* State.H */],\n            [1 /* State.Start */, 102 /* CharCode.f */, 6 /* State.F */],\n            [1 /* State.Start */, 70 /* CharCode.F */, 6 /* State.F */],\n            [2 /* State.H */, 116 /* CharCode.t */, 3 /* State.HT */],\n            [2 /* State.H */, 84 /* CharCode.T */, 3 /* State.HT */],\n            [3 /* State.HT */, 116 /* CharCode.t */, 4 /* State.HTT */],\n            [3 /* State.HT */, 84 /* CharCode.T */, 4 /* State.HTT */],\n            [4 /* State.HTT */, 112 /* CharCode.p */, 5 /* State.HTTP */],\n            [4 /* State.HTT */, 80 /* CharCode.P */, 5 /* State.HTTP */],\n            [5 /* State.HTTP */, 115 /* CharCode.s */, 9 /* State.BeforeColon */],\n            [5 /* State.HTTP */, 83 /* CharCode.S */, 9 /* State.BeforeColon */],\n            [5 /* State.HTTP */, 58 /* CharCode.Colon */, 10 /* State.AfterColon */],\n            [6 /* State.F */, 105 /* CharCode.i */, 7 /* State.FI */],\n            [6 /* State.F */, 73 /* CharCode.I */, 7 /* State.FI */],\n            [7 /* State.FI */, 108 /* CharCode.l */, 8 /* State.FIL */],\n            [7 /* State.FI */, 76 /* CharCode.L */, 8 /* State.FIL */],\n            [8 /* State.FIL */, 101 /* CharCode.e */, 9 /* State.BeforeColon */],\n            [8 /* State.FIL */, 69 /* CharCode.E */, 9 /* State.BeforeColon */],\n            [9 /* State.BeforeColon */, 58 /* CharCode.Colon */, 10 /* State.AfterColon */],\n            [10 /* State.AfterColon */, 47 /* CharCode.Slash */, 11 /* State.AlmostThere */],\n            [11 /* State.AlmostThere */, 47 /* CharCode.Slash */, 12 /* State.End */],\n        ]);\n    }\n    return _stateMachine;\n}\nlet _classifier = null;\nfunction getClassifier() {\n    if (_classifier === null) {\n        _classifier = new CharacterClassifier(0 /* CharacterClass.None */);\n        // allow-any-unicode-next-line\n        const FORCE_TERMINATION_CHARACTERS = ' \\t<>\\'\\\"';\n        for (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {\n            _classifier.set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), 1 /* CharacterClass.ForceTermination */);\n        }\n        const CANNOT_END_WITH_CHARACTERS = '.,;:';\n        for (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {\n            _classifier.set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), 2 /* CharacterClass.CannotEndIn */);\n        }\n    }\n    return _classifier;\n}\nexport class LinkComputer {\n    static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {\n        // Do not allow to end link in certain characters...\n        let lastIncludedCharIndex = linkEndIndex - 1;\n        do {\n            const chCode = line.charCodeAt(lastIncludedCharIndex);\n            const chClass = classifier.get(chCode);\n            if (chClass !== 2 /* CharacterClass.CannotEndIn */) {\n                break;\n            }\n            lastIncludedCharIndex--;\n        } while (lastIncludedCharIndex > linkBeginIndex);\n        // Handle links enclosed in parens, square brackets and curlys.\n        if (linkBeginIndex > 0) {\n            const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);\n            const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);\n            if ((charCodeBeforeLink === 40 /* CharCode.OpenParen */ && lastCharCodeInLink === 41 /* CharCode.CloseParen */)\n                || (charCodeBeforeLink === 91 /* CharCode.OpenSquareBracket */ && lastCharCodeInLink === 93 /* CharCode.CloseSquareBracket */)\n                || (charCodeBeforeLink === 123 /* CharCode.OpenCurlyBrace */ && lastCharCodeInLink === 125 /* CharCode.CloseCurlyBrace */)) {\n                // Do not end in ) if ( is before the link start\n                // Do not end in ] if [ is before the link start\n                // Do not end in } if { is before the link start\n                lastIncludedCharIndex--;\n            }\n        }\n        return {\n            range: {\n                startLineNumber: lineNumber,\n                startColumn: linkBeginIndex + 1,\n                endLineNumber: lineNumber,\n                endColumn: lastIncludedCharIndex + 2\n            },\n            url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)\n        };\n    }\n    static computeLinks(model, stateMachine = getStateMachine()) {\n        const classifier = getClassifier();\n        const result = [];\n        for (let i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {\n            const line = model.getLineContent(i);\n            const len = line.length;\n            let j = 0;\n            let linkBeginIndex = 0;\n            let linkBeginChCode = 0;\n            let state = 1 /* State.Start */;\n            let hasOpenParens = false;\n            let hasOpenSquareBracket = false;\n            let inSquareBrackets = false;\n            let hasOpenCurlyBracket = false;\n            while (j < len) {\n                let resetStateMachine = false;\n                const chCode = line.charCodeAt(j);\n                if (state === 13 /* State.Accept */) {\n                    let chClass;\n                    switch (chCode) {\n                        case 40 /* CharCode.OpenParen */:\n                            hasOpenParens = true;\n                            chClass = 0 /* CharacterClass.None */;\n                            break;\n                        case 41 /* CharCode.CloseParen */:\n                            chClass = (hasOpenParens ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        case 91 /* CharCode.OpenSquareBracket */:\n                            inSquareBrackets = true;\n                            hasOpenSquareBracket = true;\n                            chClass = 0 /* CharacterClass.None */;\n                            break;\n                        case 93 /* CharCode.CloseSquareBracket */:\n                            inSquareBrackets = false;\n                            chClass = (hasOpenSquareBracket ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        case 123 /* CharCode.OpenCurlyBrace */:\n                            hasOpenCurlyBracket = true;\n                            chClass = 0 /* CharacterClass.None */;\n                            break;\n                        case 125 /* CharCode.CloseCurlyBrace */:\n                            chClass = (hasOpenCurlyBracket ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        // The following three rules make it that ' or \" or ` are allowed inside links\n                        // only if the link is wrapped by some other quote character\n                        case 39 /* CharCode.SingleQuote */:\n                        case 34 /* CharCode.DoubleQuote */:\n                        case 96 /* CharCode.BackTick */:\n                            if (linkBeginChCode === chCode) {\n                                chClass = 1 /* CharacterClass.ForceTermination */;\n                            }\n                            else if (linkBeginChCode === 39 /* CharCode.SingleQuote */ || linkBeginChCode === 34 /* CharCode.DoubleQuote */ || linkBeginChCode === 96 /* CharCode.BackTick */) {\n                                chClass = 0 /* CharacterClass.None */;\n                            }\n                            else {\n                                chClass = 1 /* CharacterClass.ForceTermination */;\n                            }\n                            break;\n                        case 42 /* CharCode.Asterisk */:\n                            // `*` terminates a link if the link began with `*`\n                            chClass = (linkBeginChCode === 42 /* CharCode.Asterisk */) ? 1 /* CharacterClass.ForceTermination */ : 0 /* CharacterClass.None */;\n                            break;\n                        case 124 /* CharCode.Pipe */:\n                            // `|` terminates a link if the link began with `|`\n                            chClass = (linkBeginChCode === 124 /* CharCode.Pipe */) ? 1 /* CharacterClass.ForceTermination */ : 0 /* CharacterClass.None */;\n                            break;\n                        case 32 /* CharCode.Space */:\n                            // ` ` allow space in between [ and ]\n                            chClass = (inSquareBrackets ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        default:\n                            chClass = classifier.get(chCode);\n                    }\n                    // Check if character terminates link\n                    if (chClass === 1 /* CharacterClass.ForceTermination */) {\n                        result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));\n                        resetStateMachine = true;\n                    }\n                }\n                else if (state === 12 /* State.End */) {\n                    let chClass;\n                    if (chCode === 91 /* CharCode.OpenSquareBracket */) {\n                        // Allow for the authority part to contain ipv6 addresses which contain [ and ]\n                        hasOpenSquareBracket = true;\n                        chClass = 0 /* CharacterClass.None */;\n                    }\n                    else {\n                        chClass = classifier.get(chCode);\n                    }\n                    // Check if character terminates link\n                    if (chClass === 1 /* CharacterClass.ForceTermination */) {\n                        resetStateMachine = true;\n                    }\n                    else {\n                        state = 13 /* State.Accept */;\n                    }\n                }\n                else {\n                    state = stateMachine.nextState(state, chCode);\n                    if (state === 0 /* State.Invalid */) {\n                        resetStateMachine = true;\n                    }\n                }\n                if (resetStateMachine) {\n                    state = 1 /* State.Start */;\n                    hasOpenParens = false;\n                    hasOpenSquareBracket = false;\n                    hasOpenCurlyBracket = false;\n                    // Record where the link started\n                    linkBeginIndex = j + 1;\n                    linkBeginChCode = chCode;\n                }\n                j++;\n            }\n            if (state === 13 /* State.Accept */) {\n                result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));\n            }\n        }\n        return result;\n    }\n}\n/**\n * Returns an array of all links contains in the provided\n * document. *Note* that this operation is computational\n * expensive and should not run in the UI thread.\n */\nexport function computeLinks(model) {\n    if (!model || typeof model.getLineCount !== 'function' || typeof model.getLineContent !== 'function') {\n        // Unknown caller!\n        return [];\n    }\n    return LinkComputer.computeLinks(model);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Registry } from '../../../platform/registry/common/platform.js';\nimport { Mimes } from '../../../base/common/mime.js';\nimport { Extensions as ConfigurationExtensions } from '../../../platform/configuration/common/configurationRegistry.js';\n// Define extension point ids\nexport const Extensions = {\n    ModesRegistry: 'editor.modesRegistry'\n};\nexport class EditorModesRegistry {\n    constructor() {\n        this._onDidChangeLanguages = new Emitter();\n        this.onDidChangeLanguages = this._onDidChangeLanguages.event;\n        this._languages = [];\n    }\n    registerLanguage(def) {\n        this._languages.push(def);\n        this._onDidChangeLanguages.fire(undefined);\n        return {\n            dispose: () => {\n                for (let i = 0, len = this._languages.length; i < len; i++) {\n                    if (this._languages[i] === def) {\n                        this._languages.splice(i, 1);\n                        return;\n                    }\n                }\n            }\n        };\n    }\n    getLanguages() {\n        return this._languages;\n    }\n}\nexport const ModesRegistry = new EditorModesRegistry();\nRegistry.add(Extensions.ModesRegistry, ModesRegistry);\nexport const PLAINTEXT_LANGUAGE_ID = 'plaintext';\nexport const PLAINTEXT_EXTENSION = '.txt';\nModesRegistry.registerLanguage({\n    id: PLAINTEXT_LANGUAGE_ID,\n    extensions: [PLAINTEXT_EXTENSION],\n    aliases: [nls.localize('plainText.alias', \"Plain Text\"), 'text'],\n    mimetypes: [Mimes.text]\n});\nRegistry.as(ConfigurationExtensions.Configuration)\n    .registerDefaultConfigurations([{\n        overrides: {\n            '[plaintext]': {\n                'editor.unicodeHighlight.ambiguousCharacters': false,\n                'editor.unicodeHighlight.invisibleCharacters': false\n            }\n        }\n    }]);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Token, TokenizationResult, EncodedTokenizationResult } from '../languages.js';\nexport const NullState = new class {\n    clone() {\n        return this;\n    }\n    equals(other) {\n        return (this === other);\n    }\n};\nexport function nullTokenize(languageId, state) {\n    return new TokenizationResult([new Token(0, '', languageId)], state);\n}\nexport function nullTokenizeEncoded(languageId, state) {\n    const tokens = new Uint32Array(2);\n    tokens[0] = 0;\n    tokens[1] = ((languageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)\n        | (0 /* StandardTokenType.Other */ << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)\n        | (0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    return new EncodedTokenizationResult(tokens, state === null ? NullState : state);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function createScopedLineTokens(context, offset) {\n    const tokenCount = context.getCount();\n    const tokenIndex = context.findTokenIndexAtOffset(offset);\n    const desiredLanguageId = context.getLanguageId(tokenIndex);\n    let lastTokenIndex = tokenIndex;\n    while (lastTokenIndex + 1 < tokenCount && context.getLanguageId(lastTokenIndex + 1) === desiredLanguageId) {\n        lastTokenIndex++;\n    }\n    let firstTokenIndex = tokenIndex;\n    while (firstTokenIndex > 0 && context.getLanguageId(firstTokenIndex - 1) === desiredLanguageId) {\n        firstTokenIndex--;\n    }\n    return new ScopedLineTokens(context, desiredLanguageId, firstTokenIndex, lastTokenIndex + 1, context.getStartOffset(firstTokenIndex), context.getEndOffset(lastTokenIndex));\n}\nexport class ScopedLineTokens {\n    constructor(actual, languageId, firstTokenIndex, lastTokenIndex, firstCharOffset, lastCharOffset) {\n        this._scopedLineTokensBrand = undefined;\n        this._actual = actual;\n        this.languageId = languageId;\n        this._firstTokenIndex = firstTokenIndex;\n        this._lastTokenIndex = lastTokenIndex;\n        this.firstCharOffset = firstCharOffset;\n        this._lastCharOffset = lastCharOffset;\n    }\n    getLineContent() {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(this.firstCharOffset, this._lastCharOffset);\n    }\n    getActualLineContentBefore(offset) {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(0, this.firstCharOffset + offset);\n    }\n    getTokenCount() {\n        return this._lastTokenIndex - this._firstTokenIndex;\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._actual.findTokenIndexAtOffset(offset + this.firstCharOffset) - this._firstTokenIndex;\n    }\n    getStandardTokenType(tokenIndex) {\n        return this._actual.getStandardTokenType(tokenIndex + this._firstTokenIndex);\n    }\n}\nexport function ignoreBracketsInToken(standardTokenType) {\n    return (standardTokenType & 3 /* IgnoreBracketsInTokens.value */) !== 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class BasicInplaceReplace {\n    constructor() {\n        this._defaultValueSet = [\n            ['true', 'false'],\n            ['True', 'False'],\n            ['Private', 'Public', 'Friend', 'ReadOnly', 'Partial', 'Protected', 'WriteOnly'],\n            ['public', 'protected', 'private'],\n        ];\n    }\n    navigateValueSet(range1, text1, range2, text2, up) {\n        if (range1 && text1) {\n            const result = this.doNavigateValueSet(text1, up);\n            if (result) {\n                return {\n                    range: range1,\n                    value: result\n                };\n            }\n        }\n        if (range2 && text2) {\n            const result = this.doNavigateValueSet(text2, up);\n            if (result) {\n                return {\n                    range: range2,\n                    value: result\n                };\n            }\n        }\n        return null;\n    }\n    doNavigateValueSet(text, up) {\n        const numberResult = this.numberReplace(text, up);\n        if (numberResult !== null) {\n            return numberResult;\n        }\n        return this.textReplace(text, up);\n    }\n    numberReplace(value, up) {\n        const precision = Math.pow(10, value.length - (value.lastIndexOf('.') + 1));\n        let n1 = Number(value);\n        const n2 = parseFloat(value);\n        if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {\n            if (n1 === 0 && !up) {\n                return null; // don't do negative\n                //\t\t\t} else if(n1 === 9 && up) {\n                //\t\t\t\treturn null; // don't insert 10 into a number\n            }\n            else {\n                n1 = Math.floor(n1 * precision);\n                n1 += up ? precision : -precision;\n                return String(n1 / precision);\n            }\n        }\n        return null;\n    }\n    textReplace(value, up) {\n        return this.valueSetsReplace(this._defaultValueSet, value, up);\n    }\n    valueSetsReplace(valueSets, value, up) {\n        let result = null;\n        for (let i = 0, len = valueSets.length; result === null && i < len; i++) {\n            result = this.valueSetReplace(valueSets[i], value, up);\n        }\n        return result;\n    }\n    valueSetReplace(valueSet, value, up) {\n        let idx = valueSet.indexOf(value);\n        if (idx >= 0) {\n            idx += up ? +1 : -1;\n            if (idx < 0) {\n                idx = valueSet.length - 1;\n            }\n            else {\n                idx %= valueSet.length;\n            }\n            return valueSet[idx];\n        }\n        return null;\n    }\n}\nBasicInplaceReplace.INSTANCE = new BasicInplaceReplace();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport * as stringBuilder from '../../core/stringBuilder.js';\nimport { Range } from '../../core/range.js';\n/**\n * Represents a grouping of colliding bracket pairs.\n *\n * Most of the times this contains a single bracket pair,\n * but sometimes this contains multiple bracket pairs in cases\n * where the same string appears as a closing bracket for multiple\n * bracket pairs, or the same string appears an opening bracket for\n * multiple bracket pairs.\n *\n * e.g. of a group containing a single pair:\n *   open: ['{'], close: ['}']\n *\n * e.g. of a group containing multiple pairs:\n *   open: ['if', 'for'], close: ['end', 'end']\n */\nexport class RichEditBracket {\n    constructor(languageId, index, open, close, forwardRegex, reversedRegex) {\n        this._richEditBracketBrand = undefined;\n        this.languageId = languageId;\n        this.index = index;\n        this.open = open;\n        this.close = close;\n        this.forwardRegex = forwardRegex;\n        this.reversedRegex = reversedRegex;\n        this._openSet = RichEditBracket._toSet(this.open);\n        this._closeSet = RichEditBracket._toSet(this.close);\n    }\n    /**\n     * Check if the provided `text` is an open bracket in this group.\n     */\n    isOpen(text) {\n        return this._openSet.has(text);\n    }\n    /**\n     * Check if the provided `text` is a close bracket in this group.\n     */\n    isClose(text) {\n        return this._closeSet.has(text);\n    }\n    static _toSet(arr) {\n        const result = new Set();\n        for (const element of arr) {\n            result.add(element);\n        }\n        return result;\n    }\n}\n/**\n * Groups together brackets that have equal open or close sequences.\n *\n * For example, if the following brackets are defined:\n *   ['IF','END']\n *   ['for','end']\n *   ['{','}']\n *\n * Then the grouped brackets would be:\n *   { open: ['if', 'for'], close: ['end', 'end'] }\n *   { open: ['{'], close: ['}'] }\n *\n */\nfunction groupFuzzyBrackets(brackets) {\n    const N = brackets.length;\n    brackets = brackets.map(b => [b[0].toLowerCase(), b[1].toLowerCase()]);\n    const group = [];\n    for (let i = 0; i < N; i++) {\n        group[i] = i;\n    }\n    const areOverlapping = (a, b) => {\n        const [aOpen, aClose] = a;\n        const [bOpen, bClose] = b;\n        return (aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose);\n    };\n    const mergeGroups = (g1, g2) => {\n        const newG = Math.min(g1, g2);\n        const oldG = Math.max(g1, g2);\n        for (let i = 0; i < N; i++) {\n            if (group[i] === oldG) {\n                group[i] = newG;\n            }\n        }\n    };\n    // group together brackets that have the same open or the same close sequence\n    for (let i = 0; i < N; i++) {\n        const a = brackets[i];\n        for (let j = i + 1; j < N; j++) {\n            const b = brackets[j];\n            if (areOverlapping(a, b)) {\n                mergeGroups(group[i], group[j]);\n            }\n        }\n    }\n    const result = [];\n    for (let g = 0; g < N; g++) {\n        const currentOpen = [];\n        const currentClose = [];\n        for (let i = 0; i < N; i++) {\n            if (group[i] === g) {\n                const [open, close] = brackets[i];\n                currentOpen.push(open);\n                currentClose.push(close);\n            }\n        }\n        if (currentOpen.length > 0) {\n            result.push({\n                open: currentOpen,\n                close: currentClose\n            });\n        }\n    }\n    return result;\n}\nexport class RichEditBrackets {\n    constructor(languageId, _brackets) {\n        this._richEditBracketsBrand = undefined;\n        const brackets = groupFuzzyBrackets(_brackets);\n        this.brackets = brackets.map((b, index) => {\n            return new RichEditBracket(languageId, index, b.open, b.close, getRegexForBracketPair(b.open, b.close, brackets, index), getReversedRegexForBracketPair(b.open, b.close, brackets, index));\n        });\n        this.forwardRegex = getRegexForBrackets(this.brackets);\n        this.reversedRegex = getReversedRegexForBrackets(this.brackets);\n        this.textIsBracket = {};\n        this.textIsOpenBracket = {};\n        this.maxBracketLength = 0;\n        for (const bracket of this.brackets) {\n            for (const open of bracket.open) {\n                this.textIsBracket[open] = bracket;\n                this.textIsOpenBracket[open] = true;\n                this.maxBracketLength = Math.max(this.maxBracketLength, open.length);\n            }\n            for (const close of bracket.close) {\n                this.textIsBracket[close] = bracket;\n                this.textIsOpenBracket[close] = false;\n                this.maxBracketLength = Math.max(this.maxBracketLength, close.length);\n            }\n        }\n    }\n}\nfunction collectSuperstrings(str, brackets, currentIndex, dest) {\n    for (let i = 0, len = brackets.length; i < len; i++) {\n        if (i === currentIndex) {\n            continue;\n        }\n        const bracket = brackets[i];\n        for (const open of bracket.open) {\n            if (open.indexOf(str) >= 0) {\n                dest.push(open);\n            }\n        }\n        for (const close of bracket.close) {\n            if (close.indexOf(str) >= 0) {\n                dest.push(close);\n            }\n        }\n    }\n}\nfunction lengthcmp(a, b) {\n    return a.length - b.length;\n}\nfunction unique(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n    const result = [];\n    const seen = new Set();\n    for (const element of arr) {\n        if (seen.has(element)) {\n            continue;\n        }\n        result.push(element);\n        seen.add(element);\n    }\n    return result;\n}\n/**\n * Create a regular expression that can be used to search forward in a piece of text\n * for a group of bracket pairs. But this regex must be built in a way in which\n * it is aware of the other bracket pairs defined for the language.\n *\n * For example, if a language contains the following bracket pairs:\n *   ['begin', 'end']\n *   ['if', 'end if']\n * The two bracket pairs do not collide because no open or close brackets are equal.\n * So the function getRegexForBracketPair is called twice, once with\n * the ['begin'], ['end'] group consisting of one bracket pair, and once with\n * the ['if'], ['end if'] group consiting of the other bracket pair.\n *\n * But there could be a situation where an occurrence of 'end if' is mistaken\n * for an occurrence of 'end'.\n *\n * Therefore, for the bracket pair ['begin', 'end'], the regex will also\n * target 'end if'. The regex will be something like:\n *   /(\\bend if\\b)|(\\bend\\b)|(\\bif\\b)/\n *\n * The regex also searches for \"superstrings\" (other brackets that might be mistaken with the current bracket).\n *\n */\nfunction getRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * This function also has the fine details of `getRegexForBracketPair`. For the same example\n * given above, the regex produced here would look like:\n *   /(\\bfi dne\\b)|(\\bdne\\b)|(\\bfi\\b)/\n */\nfunction getReversedRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\n/**\n * Creates a regular expression that targets all bracket pairs.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bbegin\\b)|(\\bend\\b)|(\\bfor\\b)/\n */\nfunction getRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bnigeb\\b)|(\\bdne\\b)|(\\brof\\b)/\n */\nfunction getReversedRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\nfunction prepareBracketForRegExp(str) {\n    // This bracket pair uses letters like e.g. \"begin\" - \"end\"\n    const insertWordBoundaries = (/^[\\w ]+$/.test(str));\n    str = strings.escapeRegExpCharacters(str);\n    return (insertWordBoundaries ? `\\\\b${str}\\\\b` : str);\n}\nfunction createBracketOrRegExp(pieces) {\n    const regexStr = `(${pieces.map(prepareBracketForRegExp).join(')|(')})`;\n    return strings.createRegExp(regexStr, true);\n}\nconst toReversedString = (function () {\n    function reverse(str) {\n        // create a Uint16Array and then use a TextDecoder to create a string\n        const arr = new Uint16Array(str.length);\n        let offset = 0;\n        for (let i = str.length - 1; i >= 0; i--) {\n            arr[offset++] = str.charCodeAt(i);\n        }\n        return stringBuilder.getPlatformTextDecoder().decode(arr);\n    }\n    let lastInput = null;\n    let lastOutput = null;\n    return function toReversedString(str) {\n        if (lastInput !== str) {\n            lastInput = str;\n            lastOutput = reverse(lastInput);\n        }\n        return lastOutput;\n    };\n})();\nexport class BracketsUtils {\n    static _findPrevBracketInText(reversedBracketRegex, lineNumber, reversedText, offset) {\n        const m = reversedText.match(reversedBracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = reversedText.length - (m.index || 0);\n        const matchLength = m[0].length;\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);\n    }\n    static findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)\n        const reversedLineText = toReversedString(lineText);\n        const reversedSubstr = reversedLineText.substring(lineText.length - endOffset, lineText.length - startOffset);\n        return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);\n    }\n    static findNextBracketInText(bracketRegex, lineNumber, text, offset) {\n        const m = text.match(bracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = m.index || 0;\n        const matchLength = m[0].length;\n        if (matchLength === 0) {\n            return null;\n        }\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);\n    }\n    static findNextBracketInRange(bracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        const substr = lineText.substring(startOffset, endOffset);\n        return this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Color } from '../../../../base/common/color.js';\nexport class ParsedTokenThemeRule {\n    constructor(token, index, fontStyle, foreground, background) {\n        this._parsedThemeRuleBrand = undefined;\n        this.token = token;\n        this.index = index;\n        this.fontStyle = fontStyle;\n        this.foreground = foreground;\n        this.background = background;\n    }\n}\n/**\n * Parse a raw theme into rules.\n */\nexport function parseTokenTheme(source) {\n    if (!source || !Array.isArray(source)) {\n        return [];\n    }\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0, len = source.length; i < len; i++) {\n        const entry = source[i];\n        let fontStyle = -1 /* FontStyle.NotSet */;\n        if (typeof entry.fontStyle === 'string') {\n            fontStyle = 0 /* FontStyle.None */;\n            const segments = entry.fontStyle.split(' ');\n            for (let j = 0, lenJ = segments.length; j < lenJ; j++) {\n                const segment = segments[j];\n                switch (segment) {\n                    case 'italic':\n                        fontStyle = fontStyle | 1 /* FontStyle.Italic */;\n                        break;\n                    case 'bold':\n                        fontStyle = fontStyle | 2 /* FontStyle.Bold */;\n                        break;\n                    case 'underline':\n                        fontStyle = fontStyle | 4 /* FontStyle.Underline */;\n                        break;\n                    case 'strikethrough':\n                        fontStyle = fontStyle | 8 /* FontStyle.Strikethrough */;\n                        break;\n                }\n            }\n        }\n        let foreground = null;\n        if (typeof entry.foreground === 'string') {\n            foreground = entry.foreground;\n        }\n        let background = null;\n        if (typeof entry.background === 'string') {\n            background = entry.background;\n        }\n        result[resultLen++] = new ParsedTokenThemeRule(entry.token || '', i, fontStyle, foreground, background);\n    }\n    return result;\n}\n/**\n * Resolve rules (i.e. inheritance).\n */\nfunction resolveParsedTokenThemeRules(parsedThemeRules, customTokenColors) {\n    // Sort rules lexicographically, and then by index if necessary\n    parsedThemeRules.sort((a, b) => {\n        const r = strcmp(a.token, b.token);\n        if (r !== 0) {\n            return r;\n        }\n        return a.index - b.index;\n    });\n    // Determine defaults\n    let defaultFontStyle = 0 /* FontStyle.None */;\n    let defaultForeground = '000000';\n    let defaultBackground = 'ffffff';\n    while (parsedThemeRules.length >= 1 && parsedThemeRules[0].token === '') {\n        const incomingDefaults = parsedThemeRules.shift();\n        if (incomingDefaults.fontStyle !== -1 /* FontStyle.NotSet */) {\n            defaultFontStyle = incomingDefaults.fontStyle;\n        }\n        if (incomingDefaults.foreground !== null) {\n            defaultForeground = incomingDefaults.foreground;\n        }\n        if (incomingDefaults.background !== null) {\n            defaultBackground = incomingDefaults.background;\n        }\n    }\n    const colorMap = new ColorMap();\n    // start with token colors from custom token themes\n    for (const color of customTokenColors) {\n        colorMap.getId(color);\n    }\n    const foregroundColorId = colorMap.getId(defaultForeground);\n    const backgroundColorId = colorMap.getId(defaultBackground);\n    const defaults = new ThemeTrieElementRule(defaultFontStyle, foregroundColorId, backgroundColorId);\n    const root = new ThemeTrieElement(defaults);\n    for (let i = 0, len = parsedThemeRules.length; i < len; i++) {\n        const rule = parsedThemeRules[i];\n        root.insert(rule.token, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));\n    }\n    return new TokenTheme(colorMap, root);\n}\nconst colorRegExp = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;\nexport class ColorMap {\n    constructor() {\n        this._lastColorId = 0;\n        this._id2color = [];\n        this._color2id = new Map();\n    }\n    getId(color) {\n        if (color === null) {\n            return 0;\n        }\n        const match = color.match(colorRegExp);\n        if (!match) {\n            throw new Error('Illegal value for token color: ' + color);\n        }\n        color = match[1].toUpperCase();\n        let value = this._color2id.get(color);\n        if (value) {\n            return value;\n        }\n        value = ++this._lastColorId;\n        this._color2id.set(color, value);\n        this._id2color[value] = Color.fromHex('#' + color);\n        return value;\n    }\n    getColorMap() {\n        return this._id2color.slice(0);\n    }\n}\nexport class TokenTheme {\n    static createFromRawTokenTheme(source, customTokenColors) {\n        return this.createFromParsedTokenTheme(parseTokenTheme(source), customTokenColors);\n    }\n    static createFromParsedTokenTheme(source, customTokenColors) {\n        return resolveParsedTokenThemeRules(source, customTokenColors);\n    }\n    constructor(colorMap, root) {\n        this._colorMap = colorMap;\n        this._root = root;\n        this._cache = new Map();\n    }\n    getColorMap() {\n        return this._colorMap.getColorMap();\n    }\n    _match(token) {\n        return this._root.match(token);\n    }\n    match(languageId, token) {\n        // The cache contains the metadata without the language bits set.\n        let result = this._cache.get(token);\n        if (typeof result === 'undefined') {\n            const rule = this._match(token);\n            const standardToken = toStandardTokenType(token);\n            result = (rule.metadata\n                | (standardToken << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)) >>> 0;\n            this._cache.set(token, result);\n        }\n        return (result\n            | (languageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)) >>> 0;\n    }\n}\nconst STANDARD_TOKEN_TYPE_REGEXP = /\\b(comment|string|regex|regexp)\\b/;\nexport function toStandardTokenType(tokenType) {\n    const m = tokenType.match(STANDARD_TOKEN_TYPE_REGEXP);\n    if (!m) {\n        return 0 /* StandardTokenType.Other */;\n    }\n    switch (m[1]) {\n        case 'comment':\n            return 1 /* StandardTokenType.Comment */;\n        case 'string':\n            return 2 /* StandardTokenType.String */;\n        case 'regex':\n            return 3 /* StandardTokenType.RegEx */;\n        case 'regexp':\n            return 3 /* StandardTokenType.RegEx */;\n    }\n    throw new Error('Unexpected match for standard token type!');\n}\nexport function strcmp(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nexport class ThemeTrieElementRule {\n    constructor(fontStyle, foreground, background) {\n        this._themeTrieElementRuleBrand = undefined;\n        this._fontStyle = fontStyle;\n        this._foreground = foreground;\n        this._background = background;\n        this.metadata = ((this._fontStyle << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n            | (this._foreground << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n            | (this._background << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    }\n    clone() {\n        return new ThemeTrieElementRule(this._fontStyle, this._foreground, this._background);\n    }\n    acceptOverwrite(fontStyle, foreground, background) {\n        if (fontStyle !== -1 /* FontStyle.NotSet */) {\n            this._fontStyle = fontStyle;\n        }\n        if (foreground !== 0 /* ColorId.None */) {\n            this._foreground = foreground;\n        }\n        if (background !== 0 /* ColorId.None */) {\n            this._background = background;\n        }\n        this.metadata = ((this._fontStyle << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n            | (this._foreground << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n            | (this._background << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    }\n}\nexport class ThemeTrieElement {\n    constructor(mainRule) {\n        this._themeTrieElementBrand = undefined;\n        this._mainRule = mainRule;\n        this._children = new Map();\n    }\n    match(token) {\n        if (token === '') {\n            return this._mainRule;\n        }\n        const dotIndex = token.indexOf('.');\n        let head;\n        let tail;\n        if (dotIndex === -1) {\n            head = token;\n            tail = '';\n        }\n        else {\n            head = token.substring(0, dotIndex);\n            tail = token.substring(dotIndex + 1);\n        }\n        const child = this._children.get(head);\n        if (typeof child !== 'undefined') {\n            return child.match(tail);\n        }\n        return this._mainRule;\n    }\n    insert(token, fontStyle, foreground, background) {\n        if (token === '') {\n            // Merge into the main rule\n            this._mainRule.acceptOverwrite(fontStyle, foreground, background);\n            return;\n        }\n        const dotIndex = token.indexOf('.');\n        let head;\n        let tail;\n        if (dotIndex === -1) {\n            head = token;\n            tail = '';\n        }\n        else {\n            head = token.substring(0, dotIndex);\n            tail = token.substring(dotIndex + 1);\n        }\n        let child = this._children.get(head);\n        if (typeof child === 'undefined') {\n            child = new ThemeTrieElement(this._mainRule.clone());\n            this._children.set(head, child);\n        }\n        child.insert(tail, fontStyle, foreground, background);\n    }\n}\nexport function generateTokensCSSForColorMap(colorMap) {\n    const rules = [];\n    for (let i = 1, len = colorMap.length; i < len; i++) {\n        const color = colorMap[i];\n        rules[i] = `.mtk${i} { color: ${color}; }`;\n    }\n    rules.push('.mtki { font-style: italic; }');\n    rules.push('.mtkb { font-weight: bold; }');\n    rules.push('.mtku { text-decoration: underline; text-underline-position: under; }');\n    rules.push('.mtks { text-decoration: line-through; }');\n    rules.push('.mtks.mtku { text-decoration: underline line-through; text-underline-position: under; }');\n    return rules.join('\\n');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as strings from '../../../base/common/strings.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { NullState, nullTokenizeEncoded } from './nullTokenize.js';\nconst fallback = {\n    getInitialState: () => NullState,\n    tokenizeEncoded: (buffer, hasEOL, state) => nullTokenizeEncoded(0 /* LanguageId.Null */, state)\n};\nexport function tokenizeToString(languageService, text, languageId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!languageId) {\n            return _tokenizeToString(text, languageService.languageIdCodec, fallback);\n        }\n        const tokenizationSupport = yield TokenizationRegistry.getOrCreate(languageId);\n        return _tokenizeToString(text, languageService.languageIdCodec, tokenizationSupport || fallback);\n    });\n}\nexport function tokenizeLineToHTML(text, viewLineTokens, colorMap, startOffset, endOffset, tabSize, useNbsp) {\n    let result = `<div>`;\n    let charIndex = startOffset;\n    let tabsCharDelta = 0;\n    let prevIsSpace = true;\n    for (let tokenIndex = 0, tokenCount = viewLineTokens.getCount(); tokenIndex < tokenCount; tokenIndex++) {\n        const tokenEndIndex = viewLineTokens.getEndOffset(tokenIndex);\n        if (tokenEndIndex <= startOffset) {\n            continue;\n        }\n        let partContent = '';\n        for (; charIndex < tokenEndIndex && charIndex < endOffset; charIndex++) {\n            const charCode = text.charCodeAt(charIndex);\n            switch (charCode) {\n                case 9 /* CharCode.Tab */: {\n                    let insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n                    tabsCharDelta += insertSpacesCount - 1;\n                    while (insertSpacesCount > 0) {\n                        if (useNbsp && prevIsSpace) {\n                            partContent += '&#160;';\n                            prevIsSpace = false;\n                        }\n                        else {\n                            partContent += ' ';\n                            prevIsSpace = true;\n                        }\n                        insertSpacesCount--;\n                    }\n                    break;\n                }\n                case 60 /* CharCode.LessThan */:\n                    partContent += '&lt;';\n                    prevIsSpace = false;\n                    break;\n                case 62 /* CharCode.GreaterThan */:\n                    partContent += '&gt;';\n                    prevIsSpace = false;\n                    break;\n                case 38 /* CharCode.Ampersand */:\n                    partContent += '&amp;';\n                    prevIsSpace = false;\n                    break;\n                case 0 /* CharCode.Null */:\n                    partContent += '&#00;';\n                    prevIsSpace = false;\n                    break;\n                case 65279 /* CharCode.UTF8_BOM */:\n                case 8232 /* CharCode.LINE_SEPARATOR */:\n                case 8233 /* CharCode.PARAGRAPH_SEPARATOR */:\n                case 133 /* CharCode.NEXT_LINE */:\n                    partContent += '\\ufffd';\n                    prevIsSpace = false;\n                    break;\n                case 13 /* CharCode.CarriageReturn */:\n                    // zero width space, because carriage return would introduce a line break\n                    partContent += '&#8203';\n                    prevIsSpace = false;\n                    break;\n                case 32 /* CharCode.Space */:\n                    if (useNbsp && prevIsSpace) {\n                        partContent += '&#160;';\n                        prevIsSpace = false;\n                    }\n                    else {\n                        partContent += ' ';\n                        prevIsSpace = true;\n                    }\n                    break;\n                default:\n                    partContent += String.fromCharCode(charCode);\n                    prevIsSpace = false;\n            }\n        }\n        result += `<span style=\"${viewLineTokens.getInlineStyle(tokenIndex, colorMap)}\">${partContent}</span>`;\n        if (tokenEndIndex > endOffset || charIndex >= endOffset) {\n            break;\n        }\n    }\n    result += `</div>`;\n    return result;\n}\nexport function _tokenizeToString(text, languageIdCodec, tokenizationSupport) {\n    let result = `<div class=\"monaco-tokenized-source\">`;\n    const lines = strings.splitLines(text);\n    let currentState = tokenizationSupport.getInitialState();\n    for (let i = 0, len = lines.length; i < len; i++) {\n        const line = lines[i];\n        if (i > 0) {\n            result += `<br/>`;\n        }\n        const tokenizationResult = tokenizationSupport.tokenizeEncoded(line, true, currentState);\n        LineTokens.convertToEndOffset(tokenizationResult.tokens, line.length);\n        const lineTokens = new LineTokens(tokenizationResult.tokens, line, languageIdCodec);\n        const viewLineTokens = lineTokens.inflate();\n        let startOffset = 0;\n        for (let j = 0, lenJ = viewLineTokens.getCount(); j < lenJ; j++) {\n            const type = viewLineTokens.getClassName(j);\n            const endIndex = viewLineTokens.getEndOffset(j);\n            result += `<span class=\"${type}\">${strings.escape(line.substring(startOffset, endIndex))}</span>`;\n            startOffset = endIndex;\n        }\n        currentState = tokenizationResult.endState;\n    }\n    result += `</div>`;\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { equals } from '../../base/common/objects.js';\n/**\n * Vertical Lane in the overview ruler of the editor.\n */\nexport var OverviewRulerLane;\n(function (OverviewRulerLane) {\n    OverviewRulerLane[OverviewRulerLane[\"Left\"] = 1] = \"Left\";\n    OverviewRulerLane[OverviewRulerLane[\"Center\"] = 2] = \"Center\";\n    OverviewRulerLane[OverviewRulerLane[\"Right\"] = 4] = \"Right\";\n    OverviewRulerLane[OverviewRulerLane[\"Full\"] = 7] = \"Full\";\n})(OverviewRulerLane || (OverviewRulerLane = {}));\n/**\n * Vertical Lane in the glyph margin of the editor.\n */\nexport var GlyphMarginLane;\n(function (GlyphMarginLane) {\n    GlyphMarginLane[GlyphMarginLane[\"Left\"] = 1] = \"Left\";\n    GlyphMarginLane[GlyphMarginLane[\"Right\"] = 2] = \"Right\";\n})(GlyphMarginLane || (GlyphMarginLane = {}));\n/**\n * Position in the minimap to render the decoration.\n */\nexport var MinimapPosition;\n(function (MinimapPosition) {\n    MinimapPosition[MinimapPosition[\"Inline\"] = 1] = \"Inline\";\n    MinimapPosition[MinimapPosition[\"Gutter\"] = 2] = \"Gutter\";\n})(MinimapPosition || (MinimapPosition = {}));\nexport var InjectedTextCursorStops;\n(function (InjectedTextCursorStops) {\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Both\"] = 0] = \"Both\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Right\"] = 1] = \"Right\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Left\"] = 2] = \"Left\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"None\"] = 3] = \"None\";\n})(InjectedTextCursorStops || (InjectedTextCursorStops = {}));\nexport class TextModelResolvedOptions {\n    get originalIndentSize() {\n        return this._indentSizeIsTabSize ? 'tabSize' : this.indentSize;\n    }\n    /**\n     * @internal\n     */\n    constructor(src) {\n        this._textModelResolvedOptionsBrand = undefined;\n        this.tabSize = Math.max(1, src.tabSize | 0);\n        if (src.indentSize === 'tabSize') {\n            this.indentSize = this.tabSize;\n            this._indentSizeIsTabSize = true;\n        }\n        else {\n            this.indentSize = Math.max(1, src.indentSize | 0);\n            this._indentSizeIsTabSize = false;\n        }\n        this.insertSpaces = Boolean(src.insertSpaces);\n        this.defaultEOL = src.defaultEOL | 0;\n        this.trimAutoWhitespace = Boolean(src.trimAutoWhitespace);\n        this.bracketPairColorizationOptions = src.bracketPairColorizationOptions;\n    }\n    /**\n     * @internal\n     */\n    equals(other) {\n        return (this.tabSize === other.tabSize\n            && this._indentSizeIsTabSize === other._indentSizeIsTabSize\n            && this.indentSize === other.indentSize\n            && this.insertSpaces === other.insertSpaces\n            && this.defaultEOL === other.defaultEOL\n            && this.trimAutoWhitespace === other.trimAutoWhitespace\n            && equals(this.bracketPairColorizationOptions, other.bracketPairColorizationOptions));\n    }\n    /**\n     * @internal\n     */\n    createChangeEvent(newOpts) {\n        return {\n            tabSize: this.tabSize !== newOpts.tabSize,\n            indentSize: this.indentSize !== newOpts.indentSize,\n            insertSpaces: this.insertSpaces !== newOpts.insertSpaces,\n            trimAutoWhitespace: this.trimAutoWhitespace !== newOpts.trimAutoWhitespace,\n        };\n    }\n}\nexport class FindMatch {\n    /**\n     * @internal\n     */\n    constructor(range, matches) {\n        this._findMatchBrand = undefined;\n        this.range = range;\n        this.matches = matches;\n    }\n}\n/**\n * @internal\n */\nexport function isITextSnapshot(obj) {\n    return (obj && typeof obj.read === 'function');\n}\n/**\n * @internal\n */\nexport class ValidAnnotatedEditOperation {\n    constructor(identifier, range, text, forceMoveMarkers, isAutoWhitespaceEdit, _isTracked) {\n        this.identifier = identifier;\n        this.range = range;\n        this.text = text;\n        this.forceMoveMarkers = forceMoveMarkers;\n        this.isAutoWhitespaceEdit = isAutoWhitespaceEdit;\n        this._isTracked = _isTracked;\n    }\n}\n/**\n * @internal\n */\nexport class SearchData {\n    constructor(regex, wordSeparators, simpleSearch) {\n        this.regex = regex;\n        this.wordSeparators = wordSeparators;\n        this.simpleSearch = simpleSearch;\n    }\n}\n/**\n * @internal\n */\nexport class ApplyEditsResult {\n    constructor(reverseEdits, changes, trimAutoWhitespaceLineNumbers) {\n        this.reverseEdits = reverseEdits;\n        this.changes = changes;\n        this.trimAutoWhitespaceLineNumbers = trimAutoWhitespaceLineNumbers;\n    }\n}\n/**\n * @internal\n */\nexport function shouldSynchronizeModel(model) {\n    return (!model.isTooLargeForSyncing() && !model.isForSimpleWidget);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue } from '../../../../../base/common/arrays.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { lengthAdd, lengthDiffNonNegative, lengthEquals, lengthIsZero, lengthToObj, lengthZero, sumLengths } from './length.js';\nexport function combineTextEditInfos(textEditInfoFirst, textEditInfoSecond) {\n    if (textEditInfoFirst.length === 0) {\n        return textEditInfoSecond;\n    }\n    if (textEditInfoSecond.length === 0) {\n        return textEditInfoFirst;\n    }\n    // s0: State before any edits\n    const s0ToS1Map = new ArrayQueue(toLengthMapping(textEditInfoFirst));\n    // s1: State after first edit, but before second edit\n    const s1ToS2Map = toLengthMapping(textEditInfoSecond);\n    s1ToS2Map.push({ modified: false, lengthBefore: undefined, lengthAfter: undefined }); // Copy everything from old to new\n    // s2: State after both edits\n    let curItem = s0ToS1Map.dequeue();\n    /**\n     * @param s1Length Use undefined for length \"infinity\"\n     */\n    function nextS0ToS1MapWithS1LengthOf(s1Length) {\n        if (s1Length === undefined) {\n            const arr = s0ToS1Map.takeWhile(v => true) || [];\n            if (curItem) {\n                arr.unshift(curItem);\n            }\n            return arr;\n        }\n        const result = [];\n        while (curItem && !lengthIsZero(s1Length)) {\n            const [item, remainingItem] = curItem.splitAt(s1Length);\n            result.push(item);\n            s1Length = lengthDiffNonNegative(item.lengthAfter, s1Length);\n            curItem = remainingItem !== null && remainingItem !== void 0 ? remainingItem : s0ToS1Map.dequeue();\n        }\n        if (!lengthIsZero(s1Length)) {\n            result.push(new LengthMapping(false, s1Length, s1Length));\n        }\n        return result;\n    }\n    const result = [];\n    function pushEdit(startOffset, endOffset, newLength) {\n        if (result.length > 0 && lengthEquals(result[result.length - 1].endOffset, startOffset)) {\n            const lastResult = result[result.length - 1];\n            result[result.length - 1] = new TextEditInfo(lastResult.startOffset, endOffset, lengthAdd(lastResult.newLength, newLength));\n        }\n        else {\n            result.push({ startOffset, endOffset, newLength });\n        }\n    }\n    let s0offset = lengthZero;\n    for (const s1ToS2 of s1ToS2Map) {\n        const s0ToS1Map = nextS0ToS1MapWithS1LengthOf(s1ToS2.lengthBefore);\n        if (s1ToS2.modified) {\n            const s0Length = sumLengths(s0ToS1Map, s => s.lengthBefore);\n            const s0EndOffset = lengthAdd(s0offset, s0Length);\n            pushEdit(s0offset, s0EndOffset, s1ToS2.lengthAfter);\n            s0offset = s0EndOffset;\n        }\n        else {\n            for (const s1 of s0ToS1Map) {\n                const s0startOffset = s0offset;\n                s0offset = lengthAdd(s0offset, s1.lengthBefore);\n                if (s1.modified) {\n                    pushEdit(s0startOffset, s0offset, s1.lengthAfter);\n                }\n            }\n        }\n    }\n    return result;\n}\nclass LengthMapping {\n    constructor(\n    /**\n     * If false, length before and length after equal.\n     */\n    modified, lengthBefore, lengthAfter) {\n        this.modified = modified;\n        this.lengthBefore = lengthBefore;\n        this.lengthAfter = lengthAfter;\n    }\n    splitAt(lengthAfter) {\n        const remainingLengthAfter = lengthDiffNonNegative(lengthAfter, this.lengthAfter);\n        if (lengthEquals(remainingLengthAfter, lengthZero)) {\n            return [this, undefined];\n        }\n        else if (this.modified) {\n            return [\n                new LengthMapping(this.modified, this.lengthBefore, lengthAfter),\n                new LengthMapping(this.modified, lengthZero, remainingLengthAfter)\n            ];\n        }\n        else {\n            return [\n                new LengthMapping(this.modified, lengthAfter, lengthAfter),\n                new LengthMapping(this.modified, remainingLengthAfter, remainingLengthAfter)\n            ];\n        }\n    }\n    toString() {\n        return `${this.modified ? 'M' : 'U'}:${lengthToObj(this.lengthBefore)} -> ${lengthToObj(this.lengthAfter)}`;\n    }\n}\nfunction toLengthMapping(textEditInfos) {\n    const result = [];\n    let lastOffset = lengthZero;\n    for (const textEditInfo of textEditInfos) {\n        const spaceLength = lengthDiffNonNegative(lastOffset, textEditInfo.startOffset);\n        if (!lengthIsZero(spaceLength)) {\n            result.push(new LengthMapping(false, spaceLength, spaceLength));\n        }\n        const lengthBefore = lengthDiffNonNegative(textEditInfo.startOffset, textEditInfo.endOffset);\n        result.push(new LengthMapping(true, lengthBefore, textEditInfo.newLength));\n        lastOffset = textEditInfo.endOffset;\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { BracketInfo, BracketPairWithMinIndentationInfo } from '../../../textModelBracketPairs.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { LanguageAgnosticBracketTokens } from './brackets.js';\nimport { lengthAdd, lengthGreaterThanEqual, lengthLessThan, lengthLessThanEqual, lengthsToRange, lengthZero, positionToLength, toLength } from './length.js';\nimport { parseDocument } from './parser.js';\nimport { DenseKeyProvider } from './smallImmutableSet.js';\nimport { FastTokenizer, TextBufferTokenizer } from './tokenizer.js';\nimport { CallbackIterable } from '../../../../../base/common/arrays.js';\nimport { combineTextEditInfos } from './combineTextEditInfos.js';\nexport class BracketPairsTree extends Disposable {\n    didLanguageChange(languageId) {\n        return this.brackets.didLanguageChange(languageId);\n    }\n    constructor(textModel, getLanguageConfiguration) {\n        super();\n        this.textModel = textModel;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.didChangeEmitter = new Emitter();\n        this.denseKeyProvider = new DenseKeyProvider();\n        this.brackets = new LanguageAgnosticBracketTokens(this.denseKeyProvider, this.getLanguageConfiguration);\n        this.onDidChange = this.didChangeEmitter.event;\n        this.queuedTextEditsForInitialAstWithoutTokens = [];\n        this.queuedTextEdits = [];\n        if (!textModel.tokenization.hasTokens) {\n            const brackets = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId());\n            const tokenizer = new FastTokenizer(this.textModel.getValue(), brackets);\n            this.initialAstWithoutTokens = parseDocument(tokenizer, [], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n        else if (textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            // Skip the initial ast, as there is no flickering.\n            // Directly create the tree with token information.\n            this.initialAstWithoutTokens = undefined;\n            this.astWithTokens = this.parseDocumentFromTextBuffer([], undefined, false);\n        }\n        else {\n            // We missed some token changes already, so we cannot use the fast tokenizer + delta increments\n            this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n    }\n    //#region TextModel events\n    handleDidChangeBackgroundTokenizationState() {\n        if (this.textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            const wasUndefined = this.initialAstWithoutTokens === undefined;\n            // Clear the initial tree as we can use the tree with token information now.\n            this.initialAstWithoutTokens = undefined;\n            if (!wasUndefined) {\n                this.didChangeEmitter.fire();\n            }\n        }\n    }\n    handleDidChangeTokens({ ranges }) {\n        const edits = ranges.map(r => new TextEditInfo(toLength(r.fromLineNumber - 1, 0), toLength(r.toLineNumber, 0), toLength(r.toLineNumber - r.fromLineNumber + 1, 0)));\n        this.handleEdits(edits, true);\n        if (!this.initialAstWithoutTokens) {\n            this.didChangeEmitter.fire();\n        }\n    }\n    handleContentChanged(change) {\n        const edits = TextEditInfo.fromModelContentChanges(change.changes);\n        this.handleEdits(edits, false);\n    }\n    handleEdits(edits, tokenChange) {\n        // Lazily queue the edits and only apply them when the tree is accessed.\n        const result = combineTextEditInfos(this.queuedTextEdits, edits);\n        this.queuedTextEdits = result;\n        if (this.initialAstWithoutTokens && !tokenChange) {\n            this.queuedTextEditsForInitialAstWithoutTokens = combineTextEditInfos(this.queuedTextEditsForInitialAstWithoutTokens, edits);\n        }\n    }\n    //#endregion\n    flushQueue() {\n        if (this.queuedTextEdits.length > 0) {\n            this.astWithTokens = this.parseDocumentFromTextBuffer(this.queuedTextEdits, this.astWithTokens, false);\n            this.queuedTextEdits = [];\n        }\n        if (this.queuedTextEditsForInitialAstWithoutTokens.length > 0) {\n            if (this.initialAstWithoutTokens) {\n                this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(this.queuedTextEditsForInitialAstWithoutTokens, this.initialAstWithoutTokens, false);\n            }\n            this.queuedTextEditsForInitialAstWithoutTokens = [];\n        }\n    }\n    /**\n     * @pure (only if isPure = true)\n    */\n    parseDocumentFromTextBuffer(edits, previousAst, immutable) {\n        // Is much faster if `isPure = false`.\n        const isPure = false;\n        const previousAstClone = isPure ? previousAst === null || previousAst === void 0 ? void 0 : previousAst.deepClone() : previousAst;\n        const tokenizer = new TextBufferTokenizer(this.textModel, this.brackets);\n        const result = parseDocument(tokenizer, edits, previousAstClone, immutable);\n        return result;\n    }\n    getBracketsInRange(range, onlyColorizedBrackets) {\n        this.flushQueue();\n        const startOffset = toLength(range.startLineNumber - 1, range.startColumn - 1);\n        const endOffset = toLength(range.endLineNumber - 1, range.endColumn - 1);\n        return new CallbackIterable(cb => {\n            const node = this.initialAstWithoutTokens || this.astWithTokens;\n            collectBrackets(node, lengthZero, node.length, startOffset, endOffset, cb, 0, 0, new Map(), onlyColorizedBrackets);\n        });\n    }\n    getBracketPairsInRange(range, includeMinIndentation) {\n        this.flushQueue();\n        const startLength = positionToLength(range.getStartPosition());\n        const endLength = positionToLength(range.getEndPosition());\n        return new CallbackIterable(cb => {\n            const node = this.initialAstWithoutTokens || this.astWithTokens;\n            const context = new CollectBracketPairsContext(cb, includeMinIndentation, this.textModel);\n            collectBracketPairs(node, lengthZero, node.length, startLength, endLength, context, 0, new Map());\n        });\n    }\n    getFirstBracketAfter(position) {\n        this.flushQueue();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketAfter(node, lengthZero, node.length, positionToLength(position));\n    }\n    getFirstBracketBefore(position) {\n        this.flushQueue();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketBefore(node, lengthZero, node.length, positionToLength(position));\n    }\n}\nfunction getFirstBracketBefore(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        const lengths = [];\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            lengths.push({ nodeOffsetStart, nodeOffsetEnd });\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        for (let i = lengths.length - 1; i >= 0; i--) {\n            const { nodeOffsetStart, nodeOffsetEnd } = lengths[i];\n            if (lengthLessThan(nodeOffsetStart, position)) {\n                const result = getFirstBracketBefore(node.children[i], nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction getFirstBracketAfter(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThan(position, nodeOffsetEnd)) {\n                const result = getFirstBracketAfter(child, nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction collectBrackets(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, nestingLevelOfEqualBracketType, levelPerBracketType, onlyColorizedBrackets, parentPairIsIncomplete = false) {\n    if (level > 200) {\n        return true;\n    }\n    whileLoop: while (true) {\n        switch (node.kind) {\n            case 4 /* AstNodeKind.List */: {\n                const childCount = node.childrenLength;\n                for (let i = 0; i < childCount; i++) {\n                    const child = node.getChild(i);\n                    if (!child) {\n                        continue;\n                    }\n                    nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n                    if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                        lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                        const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n                        if (childEndsAfterEnd) {\n                            // No child after this child in the requested window, don't recurse\n                            node = child;\n                            continue whileLoop;\n                        }\n                        const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, 0, levelPerBracketType, onlyColorizedBrackets);\n                        if (!shouldContinue) {\n                            return false;\n                        }\n                    }\n                    nodeOffsetStart = nodeOffsetEnd;\n                }\n                return true;\n            }\n            case 2 /* AstNodeKind.Pair */: {\n                const colorize = !onlyColorizedBrackets || !node.closingBracket || node.closingBracket.bracketInfo.closesColorized(node.openingBracket.bracketInfo);\n                let levelPerBracket = 0;\n                if (levelPerBracketType) {\n                    let existing = levelPerBracketType.get(node.openingBracket.text);\n                    if (existing === undefined) {\n                        existing = 0;\n                    }\n                    levelPerBracket = existing;\n                    if (colorize) {\n                        existing++;\n                        levelPerBracketType.set(node.openingBracket.text, existing);\n                    }\n                }\n                const childCount = node.childrenLength;\n                for (let i = 0; i < childCount; i++) {\n                    const child = node.getChild(i);\n                    if (!child) {\n                        continue;\n                    }\n                    nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n                    if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                        lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                        const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n                        if (childEndsAfterEnd && child.kind !== 1 /* AstNodeKind.Bracket */) {\n                            // No child after this child in the requested window, don't recurse\n                            // Don't do this for brackets because of unclosed/unopened brackets\n                            node = child;\n                            if (colorize) {\n                                level++;\n                                nestingLevelOfEqualBracketType = levelPerBracket + 1;\n                            }\n                            else {\n                                nestingLevelOfEqualBracketType = levelPerBracket;\n                            }\n                            continue whileLoop;\n                        }\n                        if (colorize || child.kind !== 1 /* AstNodeKind.Bracket */ || !node.closingBracket) {\n                            const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, colorize ? level + 1 : level, colorize ? levelPerBracket + 1 : levelPerBracket, levelPerBracketType, onlyColorizedBrackets, !node.closingBracket);\n                            if (!shouldContinue) {\n                                return false;\n                            }\n                        }\n                    }\n                    nodeOffsetStart = nodeOffsetEnd;\n                }\n                levelPerBracketType === null || levelPerBracketType === void 0 ? void 0 : levelPerBracketType.set(node.openingBracket.text, levelPerBracket);\n                return true;\n            }\n            case 3 /* AstNodeKind.UnexpectedClosingBracket */: {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                return push(new BracketInfo(range, level - 1, 0, true));\n            }\n            case 1 /* AstNodeKind.Bracket */: {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                return push(new BracketInfo(range, level - 1, nestingLevelOfEqualBracketType - 1, parentPairIsIncomplete));\n            }\n            case 0 /* AstNodeKind.Text */:\n                return true;\n        }\n    }\n}\nclass CollectBracketPairsContext {\n    constructor(push, includeMinIndentation, textModel) {\n        this.push = push;\n        this.includeMinIndentation = includeMinIndentation;\n        this.textModel = textModel;\n    }\n}\nfunction collectBracketPairs(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level, levelPerBracketType) {\n    var _a;\n    if (level > 200) {\n        return true;\n    }\n    let shouldContinue = true;\n    if (node.kind === 2 /* AstNodeKind.Pair */) {\n        let levelPerBracket = 0;\n        if (levelPerBracketType) {\n            let existing = levelPerBracketType.get(node.openingBracket.text);\n            if (existing === undefined) {\n                existing = 0;\n            }\n            levelPerBracket = existing;\n            existing++;\n            levelPerBracketType.set(node.openingBracket.text, existing);\n        }\n        const openingBracketEnd = lengthAdd(nodeOffsetStart, node.openingBracket.length);\n        let minIndentation = -1;\n        if (context.includeMinIndentation) {\n            minIndentation = node.computeMinIndentation(nodeOffsetStart, context.textModel);\n        }\n        shouldContinue = context.push(new BracketPairWithMinIndentationInfo(lengthsToRange(nodeOffsetStart, nodeOffsetEnd), lengthsToRange(nodeOffsetStart, openingBracketEnd), node.closingBracket\n            ? lengthsToRange(lengthAdd(openingBracketEnd, ((_a = node.child) === null || _a === void 0 ? void 0 : _a.length) || lengthZero), nodeOffsetEnd)\n            : undefined, level, levelPerBracket, node, minIndentation));\n        nodeOffsetStart = openingBracketEnd;\n        if (shouldContinue && node.child) {\n            const child = node.child;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                shouldContinue = collectBracketPairs(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level + 1, levelPerBracketType);\n                if (!shouldContinue) {\n                    return false;\n                }\n            }\n        }\n        levelPerBracketType === null || levelPerBracketType === void 0 ? void 0 : levelPerBracketType.set(node.openingBracket.text, levelPerBracket);\n    }\n    else {\n        let curOffset = nodeOffsetStart;\n        for (const child of node.children) {\n            const childOffset = curOffset;\n            curOffset = lengthAdd(curOffset, child.length);\n            if (lengthLessThanEqual(childOffset, endOffset) &&\n                lengthLessThanEqual(startOffset, curOffset)) {\n                shouldContinue = collectBracketPairs(child, childOffset, curOffset, startOffset, endOffset, context, level, levelPerBracketType);\n                if (!shouldContinue) {\n                    return false;\n                }\n            }\n        }\n    }\n    return shouldContinue;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CallbackIterable, compareBy } from '../../../../base/common/arrays.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { ignoreBracketsInToken } from '../../languages/supports.js';\nimport { BracketsUtils } from '../../languages/supports/richEditBrackets.js';\nimport { BracketPairsTree } from './bracketPairsTree/bracketPairsTree.js';\nexport class BracketPairsTextModelPart extends Disposable {\n    get canBuildAST() {\n        const maxSupportedDocumentLength = /* max lines */ 50000 * /* average column count */ 100;\n        return this.textModel.getValueLength() <= maxSupportedDocumentLength;\n    }\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n        this.bracketPairsTree = this._register(new MutableDisposable());\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.bracketsRequested = false;\n        this._register(this.languageConfigurationService.onDidChange(e => {\n            var _a;\n            if (!e.languageId || ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.didLanguageChange(e.languageId))) {\n                this.bracketPairsTree.clear();\n                this.updateBracketPairsTree();\n            }\n        }));\n    }\n    //#region TextModel events\n    handleDidChangeOptions(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeLanguage(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeContent(change) {\n        var _a;\n        (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleContentChanged(change);\n    }\n    handleDidChangeBackgroundTokenizationState() {\n        var _a;\n        (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleDidChangeBackgroundTokenizationState();\n    }\n    handleDidChangeTokens(e) {\n        var _a;\n        (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleDidChangeTokens(e);\n    }\n    //#endregion\n    updateBracketPairsTree() {\n        if (this.bracketsRequested && this.canBuildAST) {\n            if (!this.bracketPairsTree.value) {\n                const store = new DisposableStore();\n                this.bracketPairsTree.value = createDisposableRef(store.add(new BracketPairsTree(this.textModel, (languageId) => {\n                    return this.languageConfigurationService.getLanguageConfiguration(languageId);\n                })), store);\n                store.add(this.bracketPairsTree.value.object.onDidChange(e => this.onDidChangeEmitter.fire(e)));\n                this.onDidChangeEmitter.fire();\n            }\n        }\n        else {\n            if (this.bracketPairsTree.value) {\n                this.bracketPairsTree.clear();\n                // Important: Don't call fire if there was no change!\n                this.onDidChangeEmitter.fire();\n            }\n        }\n    }\n    /**\n     * Returns all bracket pairs that intersect the given range.\n     * The result is sorted by the start position.\n    */\n    getBracketPairsInRange(range) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, false)) || CallbackIterable.empty;\n    }\n    getBracketPairsInRangeWithMinIndentation(range) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, true)) || CallbackIterable.empty;\n    }\n    getBracketsInRange(range, onlyColorizedBrackets = false) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketsInRange(range, onlyColorizedBrackets)) || CallbackIterable.empty;\n    }\n    findMatchingBracketUp(_bracket, _position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        const languageId = this.textModel.getLanguageIdAtPosition(position.lineNumber, position.column);\n        if (this.canBuildAST) {\n            const closingBracketInfo = this.languageConfigurationService\n                .getLanguageConfiguration(languageId)\n                .bracketsNew.getClosingBracketInfo(_bracket);\n            if (!closingBracketInfo) {\n                return null;\n            }\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(_position, _position)).findLast((b) => closingBracketInfo.closes(b.openingBracketInfo));\n            if (bracketPair) {\n                return bracketPair.openingBracketRange;\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const bracket = _bracket.toLowerCase();\n            const bracketsSupport = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n            if (!bracketsSupport) {\n                return null;\n            }\n            const data = bracketsSupport.textIsBracket[bracket];\n            if (!data) {\n                return null;\n            }\n            return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, createTimeBasedContinueBracketSearchPredicate(maxDuration)));\n        }\n    }\n    matchBracket(position, maxDuration) {\n        if (this.canBuildAST) {\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).filter((item) => item.closingBracketRange !== undefined &&\n                (item.openingBracketRange.containsPosition(position) ||\n                    item.closingBracketRange.containsPosition(position))).findLastMaxBy(compareBy((item) => item.openingBracketRange.containsPosition(position)\n                ? item.openingBracketRange\n                : item.closingBracketRange, Range.compareRangesUsingStarts));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n            return this._matchBracket(this.textModel.validatePosition(position), continueSearchPredicate);\n        }\n    }\n    _establishBracketSearchOffsets(position, lineTokens, modeBrackets, tokenIndex) {\n        const tokenCount = lineTokens.getCount();\n        const currentLanguageId = lineTokens.getLanguageId(tokenIndex);\n        // limit search to not go before `maxBracketLength`\n        let searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);\n        for (let i = tokenIndex - 1; i >= 0; i--) {\n            const tokenEndOffset = lineTokens.getEndOffset(i);\n            if (tokenEndOffset <= searchStartOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchStartOffset = tokenEndOffset;\n                break;\n            }\n        }\n        // limit search to not go after `maxBracketLength`\n        let searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);\n        for (let i = tokenIndex + 1; i < tokenCount; i++) {\n            const tokenStartOffset = lineTokens.getStartOffset(i);\n            if (tokenStartOffset >= searchEndOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchEndOffset = tokenStartOffset;\n                break;\n            }\n        }\n        return { searchStartOffset, searchEndOffset };\n    }\n    _matchBracket(position, continueSearchPredicate) {\n        const lineNumber = position.lineNumber;\n        const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n        const lineText = this.textModel.getLineContent(lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        if (tokenIndex < 0) {\n            return null;\n        }\n        const currentModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).brackets;\n        // check that the token is not to be ignored\n        if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n            let { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex);\n            // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n            // `bestResult` will contain the most right-side result\n            let bestResult = null;\n            while (true) {\n                const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!foundBracket) {\n                    // there are no more brackets in this text\n                    break;\n                }\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        bestResult = r;\n                    }\n                }\n                searchStartOffset = foundBracket.endColumn - 1;\n            }\n            if (bestResult) {\n                return bestResult;\n            }\n        }\n        // If position is in between two tokens, try also looking in the previous token\n        if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n            const prevTokenIndex = tokenIndex - 1;\n            const prevModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(prevTokenIndex)).brackets;\n            // check that previous token is not to be ignored\n            if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\n                const { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex);\n                const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        return r;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {\n        if (!data) {\n            return null;\n        }\n        const matched = (isOpen\n            ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate)\n            : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate));\n        if (!matched) {\n            return null;\n        }\n        if (matched instanceof BracketSearchCanceled) {\n            return matched;\n        }\n        return [foundBracket, matched];\n    }\n    _findMatchingBracketUp(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const reversedBracketRegex = bracket.reversedRegex;\n        let count = -1;\n        let totalCallCount = 0;\n        const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchEndOffset = r.startColumn - 1;\n            }\n            return null;\n        };\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    _findMatchingBracketDown(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const bracketRegex = bracket.forwardRegex;\n        let count = 1;\n        let totalCallCount = 0;\n        const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        const lineCount = this.textModel.getLineCount();\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    findPrevBracket(_position) {\n        var _a;\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getFirstBracketBefore(position)) || null;\n        }\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && bracketConfig && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findNextBracket(_position) {\n        var _a;\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getFirstBracketAfter(position)) || null;\n        }\n        const lineCount = this.textModel.getLineCount();\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findEnclosingBrackets(_position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            const range = Range.fromPositions(position);\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).findLast((item) => item.closingBracketRange !== undefined && item.range.strictContainsRange(range));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n        const lineCount = this.textModel.getLineCount();\n        const savedCounts = new Map();\n        let counts = [];\n        const resetCounts = (languageId, modeBrackets) => {\n            if (!savedCounts.has(languageId)) {\n                const tmp = [];\n                for (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\n                    tmp[i] = 0;\n                }\n                savedCounts.set(languageId, tmp);\n            }\n            counts = savedCounts.get(languageId);\n        };\n        let totalCallCount = 0;\n        const searchInRange = (modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                const bracket = modeBrackets.textIsBracket[hitText];\n                if (bracket) {\n                    if (bracket.isOpen(hitText)) {\n                        counts[bracket.index]++;\n                    }\n                    else if (bracket.isClose(hitText)) {\n                        counts[bracket.index]--;\n                    }\n                    if (counts[bracket.index] === -1) {\n                        return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);\n                    }\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        let languageId = null;\n        let modeBrackets = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return stripBracketSearchCanceled(r);\n                }\n            }\n        }\n        return null;\n    }\n    _toFoundBracket(bracketConfig, r) {\n        if (!r) {\n            return null;\n        }\n        let text = this.textModel.getValueInRange(r);\n        text = text.toLowerCase();\n        const bracketInfo = bracketConfig.getBracketInfo(text);\n        if (!bracketInfo) {\n            return null;\n        }\n        return {\n            range: r,\n            bracketInfo\n        };\n    }\n}\nfunction createDisposableRef(object, disposable) {\n    return {\n        object,\n        dispose: () => disposable === null || disposable === void 0 ? void 0 : disposable.dispose(),\n    };\n}\nfunction createTimeBasedContinueBracketSearchPredicate(maxDuration) {\n    if (typeof maxDuration === 'undefined') {\n        return () => true;\n    }\n    else {\n        const startTime = Date.now();\n        return () => {\n            return (Date.now() - startTime <= maxDuration);\n        };\n    }\n}\nclass BracketSearchCanceled {\n    constructor() {\n        this._searchCanceledBrand = undefined;\n    }\n}\nBracketSearchCanceled.INSTANCE = new BracketSearchCanceled();\nfunction stripBracketSearchCanceled(result) {\n    if (result instanceof BracketSearchCanceled) {\n        return null;\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { CursorColumns } from '../../../core/cursorColumns.js';\nimport { lengthAdd, lengthGetLineCount, lengthToObj, lengthZero } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\n/**\n * The base implementation for all AST nodes.\n*/\nclass BaseAstNode {\n    /**\n     * The length of the entire node, which should equal the sum of lengths of all children.\n    */\n    get length() {\n        return this._length;\n    }\n    constructor(length) {\n        this._length = length;\n    }\n}\n/**\n * Represents a bracket pair including its child (e.g. `{ ... }`).\n * Might be unclosed.\n * Immutable, if all children are immutable.\n*/\nexport class PairAstNode extends BaseAstNode {\n    static create(openingBracket, child, closingBracket) {\n        let length = openingBracket.length;\n        if (child) {\n            length = lengthAdd(length, child.length);\n        }\n        if (closingBracket) {\n            length = lengthAdd(length, closingBracket.length);\n        }\n        return new PairAstNode(length, openingBracket, child, closingBracket, child ? child.missingOpeningBracketIds : SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 2 /* AstNodeKind.Pair */;\n    }\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 3;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this.openingBracket;\n            case 1: return this.child;\n            case 2: return this.closingBracket;\n        }\n        throw new Error('Invalid child index');\n    }\n    /**\n     * Avoid using this property, it allocates an array!\n    */\n    get children() {\n        const result = [];\n        result.push(this.openingBracket);\n        if (this.child) {\n            result.push(this.child);\n        }\n        if (this.closingBracket) {\n            result.push(this.closingBracket);\n        }\n        return result;\n    }\n    constructor(length, openingBracket, child, closingBracket, missingOpeningBracketIds) {\n        super(length);\n        this.openingBracket = openingBracket;\n        this.child = child;\n        this.closingBracket = closingBracket;\n        this.missingOpeningBracketIds = missingOpeningBracketIds;\n    }\n    canBeReused(openBracketIds) {\n        if (this.closingBracket === null) {\n            // Unclosed pair ast nodes only\n            // end at the end of the document\n            // or when a parent node is closed.\n            // This could be improved:\n            // Only return false if some next token is neither \"undefined\" nor a bracket that closes a parent.\n            return false;\n        }\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        return true;\n    }\n    deepClone() {\n        return new PairAstNode(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return this.child ? this.child.computeMinIndentation(lengthAdd(offset, this.openingBracket.length), textModel) : Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class ListAstNode extends BaseAstNode {\n    /**\n     * This method uses more memory-efficient list nodes that can only store 2 or 3 children.\n    */\n    static create23(item1, item2, item3, immutable = false) {\n        let length = item1.length;\n        let missingBracketIds = item1.missingOpeningBracketIds;\n        if (item1.listHeight !== item2.listHeight) {\n            throw new Error('Invalid list heights');\n        }\n        length = lengthAdd(length, item2.length);\n        missingBracketIds = missingBracketIds.merge(item2.missingOpeningBracketIds);\n        if (item3) {\n            if (item1.listHeight !== item3.listHeight) {\n                throw new Error('Invalid list heights');\n            }\n            length = lengthAdd(length, item3.length);\n            missingBracketIds = missingBracketIds.merge(item3.missingOpeningBracketIds);\n        }\n        return immutable\n            ? new Immutable23ListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds)\n            : new TwoThreeListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds);\n    }\n    static getEmpty() {\n        return new ImmutableArrayListAstNode(lengthZero, 0, [], SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 4 /* AstNodeKind.List */;\n    }\n    get missingOpeningBracketIds() {\n        return this._missingOpeningBracketIds;\n    }\n    /**\n     * Use ListAstNode.create.\n    */\n    constructor(length, listHeight, _missingOpeningBracketIds) {\n        super(length);\n        this.listHeight = listHeight;\n        this._missingOpeningBracketIds = _missingOpeningBracketIds;\n        this.cachedMinIndentation = -1;\n    }\n    throwIfImmutable() {\n        // NOOP\n    }\n    makeLastElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const lastChild = this.getChild(childCount - 1);\n        const mutable = lastChild.kind === 4 /* AstNodeKind.List */ ? lastChild.toMutable() : lastChild;\n        if (lastChild !== mutable) {\n            this.setChild(childCount - 1, mutable);\n        }\n        return mutable;\n    }\n    makeFirstElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const firstChild = this.getChild(0);\n        const mutable = firstChild.kind === 4 /* AstNodeKind.List */ ? firstChild.toMutable() : firstChild;\n        if (firstChild !== mutable) {\n            this.setChild(0, mutable);\n        }\n        return mutable;\n    }\n    canBeReused(openBracketIds) {\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        if (this.childrenLength === 0) {\n            // Don't reuse empty lists.\n            return false;\n        }\n        let lastChild = this;\n        while (lastChild.kind === 4 /* AstNodeKind.List */) {\n            const lastLength = lastChild.childrenLength;\n            if (lastLength === 0) {\n                // Empty lists should never be contained in other lists.\n                throw new BugIndicatingError();\n            }\n            lastChild = lastChild.getChild(lastLength - 1);\n        }\n        return lastChild.canBeReused(openBracketIds);\n    }\n    handleChildrenChanged() {\n        this.throwIfImmutable();\n        const count = this.childrenLength;\n        let length = this.getChild(0).length;\n        let unopenedBrackets = this.getChild(0).missingOpeningBracketIds;\n        for (let i = 1; i < count; i++) {\n            const child = this.getChild(i);\n            length = lengthAdd(length, child.length);\n            unopenedBrackets = unopenedBrackets.merge(child.missingOpeningBracketIds);\n        }\n        this._length = length;\n        this._missingOpeningBracketIds = unopenedBrackets;\n        this.cachedMinIndentation = -1;\n    }\n    computeMinIndentation(offset, textModel) {\n        if (this.cachedMinIndentation !== -1) {\n            return this.cachedMinIndentation;\n        }\n        let minIndentation = Number.MAX_SAFE_INTEGER;\n        let childOffset = offset;\n        for (let i = 0; i < this.childrenLength; i++) {\n            const child = this.getChild(i);\n            if (child) {\n                minIndentation = Math.min(minIndentation, child.computeMinIndentation(childOffset, textModel));\n                childOffset = lengthAdd(childOffset, child.length);\n            }\n        }\n        this.cachedMinIndentation = minIndentation;\n        return minIndentation;\n    }\n}\nclass TwoThreeListAstNode extends ListAstNode {\n    get childrenLength() {\n        return this._item3 !== null ? 3 : 2;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this._item1;\n            case 1: return this._item2;\n            case 2: return this._item3;\n        }\n        throw new Error('Invalid child index');\n    }\n    setChild(idx, node) {\n        switch (idx) {\n            case 0:\n                this._item1 = node;\n                return;\n            case 1:\n                this._item2 = node;\n                return;\n            case 2:\n                this._item3 = node;\n                return;\n        }\n        throw new Error('Invalid child index');\n    }\n    get children() {\n        return this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];\n    }\n    get item1() {\n        return this._item1;\n    }\n    get item2() {\n        return this._item2;\n    }\n    get item3() {\n        return this._item3;\n    }\n    constructor(length, listHeight, _item1, _item2, _item3, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._item1 = _item1;\n        this._item2 = _item2;\n        this._item3 = _item3;\n    }\n    deepClone() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot append to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = node;\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    prependChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot prepend to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = this._item2;\n        this._item2 = this._item1;\n        this._item1 = node;\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item1;\n        this._item1 = this._item2;\n        this._item2 = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass Immutable23ListAstNode extends TwoThreeListAstNode {\n    toMutable() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\n/**\n * For debugging.\n*/\nclass ArrayListAstNode extends ListAstNode {\n    get childrenLength() {\n        return this._children.length;\n    }\n    getChild(idx) {\n        return this._children[idx];\n    }\n    setChild(idx, child) {\n        this._children[idx] = child;\n    }\n    get children() {\n        return this._children;\n    }\n    constructor(length, listHeight, _children, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._children = _children;\n    }\n    deepClone() {\n        const children = new Array(this._children.length);\n        for (let i = 0; i < this._children.length; i++) {\n            children[i] = this._children[i].deepClone();\n        }\n        return new ArrayListAstNode(this.length, this.listHeight, children, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.push(node);\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        this.throwIfImmutable();\n        const item = this._children.pop();\n        this.handleChildrenChanged();\n        return item;\n    }\n    prependChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.unshift(node);\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        this.throwIfImmutable();\n        const item = this._children.shift();\n        this.handleChildrenChanged();\n        return item;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass ImmutableArrayListAstNode extends ArrayListAstNode {\n    toMutable() {\n        return new ArrayListAstNode(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\nconst emptyArray = [];\nclass ImmutableLeafAstNode extends BaseAstNode {\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 0;\n    }\n    getChild(idx) {\n        return null;\n    }\n    get children() {\n        return emptyArray;\n    }\n    deepClone() {\n        return this;\n    }\n}\nexport class TextAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 0 /* AstNodeKind.Text */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    canBeReused(_openedBracketIds) {\n        return true;\n    }\n    computeMinIndentation(offset, textModel) {\n        const start = lengthToObj(offset);\n        // Text ast nodes don't have partial indentation (ensured by the tokenizer).\n        // Thus, if this text node does not start at column 0, the first line cannot have any indentation at all.\n        const startLineNumber = (start.columnCount === 0 ? start.lineCount : start.lineCount + 1) + 1;\n        const endLineNumber = lengthGetLineCount(lengthAdd(offset, this.length)) + 1;\n        let result = Number.MAX_SAFE_INTEGER;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const firstNonWsColumn = textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n            const lineContent = textModel.getLineContent(lineNumber);\n            if (firstNonWsColumn === 0) {\n                continue;\n            }\n            const visibleColumn = CursorColumns.visibleColumnFromColumn(lineContent, firstNonWsColumn, textModel.getOptions().tabSize);\n            result = Math.min(result, visibleColumn);\n        }\n        return result;\n    }\n}\nexport class BracketAstNode extends ImmutableLeafAstNode {\n    static create(length, bracketInfo, bracketIds) {\n        const node = new BracketAstNode(length, bracketInfo, bracketIds);\n        return node;\n    }\n    get kind() {\n        return 1 /* AstNodeKind.Bracket */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    constructor(length, bracketInfo, \n    /**\n     * In case of a opening bracket, this is the id of the opening bracket.\n     * In case of a closing bracket, this contains the ids of all opening brackets it can close.\n    */\n    bracketIds) {\n        super(length);\n        this.bracketInfo = bracketInfo;\n        this.bracketIds = bracketIds;\n    }\n    get text() {\n        return this.bracketInfo.bracketText;\n    }\n    get languageId() {\n        return this.bracketInfo.languageId;\n    }\n    canBeReused(_openedBracketIds) {\n        // These nodes could be reused,\n        // but not in a general way.\n        // Their parent may be reused.\n        return false;\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class InvalidBracketAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 3 /* AstNodeKind.UnexpectedClosingBracket */;\n    }\n    constructor(closingBrackets, length) {\n        super(length);\n        this.missingOpeningBracketIds = closingBrackets;\n    }\n    canBeReused(openedBracketIds) {\n        return !openedBracketIds.intersects(this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../../../core/range.js';\nimport { lengthAdd, lengthDiffNonNegative, lengthLessThanEqual, lengthOfString, lengthToObj, positionToLength, toLength } from './length.js';\nexport class TextEditInfo {\n    static fromModelContentChanges(changes) {\n        // Must be sorted in ascending order\n        const edits = changes.map(c => {\n            const range = Range.lift(c.range);\n            return new TextEditInfo(positionToLength(range.getStartPosition()), positionToLength(range.getEndPosition()), lengthOfString(c.text));\n        }).reverse();\n        return edits;\n    }\n    constructor(startOffset, endOffset, newLength) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.newLength = newLength;\n    }\n    toString() {\n        return `[${lengthToObj(this.startOffset)}...${lengthToObj(this.endOffset)}) -> ${lengthToObj(this.newLength)}`;\n    }\n}\nexport class BeforeEditPositionMapper {\n    /**\n     * @param edits Must be sorted by offset in ascending order.\n    */\n    constructor(edits) {\n        this.nextEditIdx = 0;\n        this.deltaOldToNewLineCount = 0;\n        this.deltaOldToNewColumnCount = 0;\n        this.deltaLineIdxInOld = -1;\n        this.edits = edits.map(edit => TextEditInfoCache.from(edit));\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n    */\n    getOffsetBeforeChange(offset) {\n        this.adjustNextEdit(offset);\n        return this.translateCurToOld(offset);\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n     * Returns null if there is no edit anymore.\n    */\n    getDistanceToNextChange(offset) {\n        this.adjustNextEdit(offset);\n        const nextEdit = this.edits[this.nextEditIdx];\n        const nextChangeOffset = nextEdit ? this.translateOldToCur(nextEdit.offsetObj) : null;\n        if (nextChangeOffset === null) {\n            return null;\n        }\n        return lengthDiffNonNegative(offset, nextChangeOffset);\n    }\n    translateOldToCur(oldOffsetObj) {\n        if (oldOffsetObj.lineCount === this.deltaLineIdxInOld) {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount + this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount);\n        }\n    }\n    translateCurToOld(newOffset) {\n        const offsetObj = lengthToObj(newOffset);\n        if (offsetObj.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld) {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount - this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount);\n        }\n    }\n    adjustNextEdit(offset) {\n        while (this.nextEditIdx < this.edits.length) {\n            const nextEdit = this.edits[this.nextEditIdx];\n            // After applying the edit, what is its end offset (considering all previous edits)?\n            const nextEditEndOffsetInCur = this.translateOldToCur(nextEdit.endOffsetAfterObj);\n            if (lengthLessThanEqual(nextEditEndOffsetInCur, offset)) {\n                // We are after the edit, skip it\n                this.nextEditIdx++;\n                const nextEditEndOffsetInCurObj = lengthToObj(nextEditEndOffsetInCur);\n                // Before applying the edit, what is its end offset (considering all previous edits)?\n                const nextEditEndOffsetBeforeInCurObj = lengthToObj(this.translateOldToCur(nextEdit.endOffsetBeforeObj));\n                const lineDelta = nextEditEndOffsetInCurObj.lineCount - nextEditEndOffsetBeforeInCurObj.lineCount;\n                this.deltaOldToNewLineCount += lineDelta;\n                const previousColumnDelta = this.deltaLineIdxInOld === nextEdit.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0;\n                const columnDelta = nextEditEndOffsetInCurObj.columnCount - nextEditEndOffsetBeforeInCurObj.columnCount;\n                this.deltaOldToNewColumnCount = previousColumnDelta + columnDelta;\n                this.deltaLineIdxInOld = nextEdit.endOffsetBeforeObj.lineCount;\n            }\n            else {\n                // We are in or before the edit.\n                break;\n            }\n        }\n    }\n}\nclass TextEditInfoCache {\n    static from(edit) {\n        return new TextEditInfoCache(edit.startOffset, edit.endOffset, edit.newLength);\n    }\n    constructor(startOffset, endOffset, textLength) {\n        this.endOffsetBeforeObj = lengthToObj(endOffset);\n        this.endOffsetAfterObj = lengthToObj(lengthAdd(startOffset, textLength));\n        this.offsetObj = lengthToObj(startOffset);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { escapeRegExpCharacters } from '../../../../../base/common/strings.js';\nimport { BracketAstNode } from './ast.js';\nimport { toLength } from './length.js';\nimport { identityKeyProvider, SmallImmutableSet } from './smallImmutableSet.js';\nimport { Token } from './tokenizer.js';\nexport class BracketTokens {\n    static createFromLanguage(configuration, denseKeyProvider) {\n        function getId(bracketInfo) {\n            return denseKeyProvider.getKey(`${bracketInfo.languageId}:::${bracketInfo.bracketText}`);\n        }\n        const map = new Map();\n        for (const openingBracket of configuration.bracketsNew.openingBrackets) {\n            const length = toLength(0, openingBracket.bracketText.length);\n            const openingTextId = getId(openingBracket);\n            const bracketIds = SmallImmutableSet.getEmpty().add(openingTextId, identityKeyProvider);\n            map.set(openingBracket.bracketText, new Token(length, 1 /* TokenKind.OpeningBracket */, openingTextId, bracketIds, BracketAstNode.create(length, openingBracket, bracketIds)));\n        }\n        for (const closingBracket of configuration.bracketsNew.closingBrackets) {\n            const length = toLength(0, closingBracket.bracketText.length);\n            let bracketIds = SmallImmutableSet.getEmpty();\n            const closingBrackets = closingBracket.getOpeningBrackets();\n            for (const bracket of closingBrackets) {\n                bracketIds = bracketIds.add(getId(bracket), identityKeyProvider);\n            }\n            map.set(closingBracket.bracketText, new Token(length, 2 /* TokenKind.ClosingBracket */, getId(closingBrackets[0]), bracketIds, BracketAstNode.create(length, closingBracket, bracketIds)));\n        }\n        return new BracketTokens(map);\n    }\n    constructor(map) {\n        this.map = map;\n        this.hasRegExp = false;\n        this._regExpGlobal = null;\n    }\n    getRegExpStr() {\n        if (this.isEmpty) {\n            return null;\n        }\n        else {\n            const keys = [...this.map.keys()];\n            keys.sort();\n            keys.reverse();\n            return keys.map(k => prepareBracketForRegExp(k)).join('|');\n        }\n    }\n    /**\n     * Returns null if there is no such regexp (because there are no brackets).\n    */\n    get regExpGlobal() {\n        if (!this.hasRegExp) {\n            const regExpStr = this.getRegExpStr();\n            this._regExpGlobal = regExpStr ? new RegExp(regExpStr, 'gi') : null;\n            this.hasRegExp = true;\n        }\n        return this._regExpGlobal;\n    }\n    getToken(value) {\n        return this.map.get(value.toLowerCase());\n    }\n    findClosingTokenText(openingBracketIds) {\n        for (const [closingText, info] of this.map) {\n            if (info.kind === 2 /* TokenKind.ClosingBracket */ && info.bracketIds.intersects(openingBracketIds)) {\n                return closingText;\n            }\n        }\n        return undefined;\n    }\n    get isEmpty() {\n        return this.map.size === 0;\n    }\n}\nfunction prepareBracketForRegExp(str) {\n    let escaped = escapeRegExpCharacters(str);\n    // These bracket pair delimiters start or end with letters\n    // see https://github.com/microsoft/vscode/issues/132162 https://github.com/microsoft/vscode/issues/150440\n    if (/^[\\w ]+/.test(str)) {\n        escaped = `\\\\b${escaped}`;\n    }\n    if (/[\\w ]+$/.test(str)) {\n        escaped = `${escaped}\\\\b`;\n    }\n    return escaped;\n}\nexport class LanguageAgnosticBracketTokens {\n    constructor(denseKeyProvider, getLanguageConfiguration) {\n        this.denseKeyProvider = denseKeyProvider;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.languageIdToBracketTokens = new Map();\n    }\n    didLanguageChange(languageId) {\n        // Report a change whenever the language configuration updates.\n        return this.languageIdToBracketTokens.has(languageId);\n    }\n    getSingleLanguageBracketTokens(languageId) {\n        let singleLanguageBracketTokens = this.languageIdToBracketTokens.get(languageId);\n        if (!singleLanguageBracketTokens) {\n            singleLanguageBracketTokens = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider);\n            this.languageIdToBracketTokens.set(languageId, singleLanguageBracketTokens);\n        }\n        return singleLanguageBracketTokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { splitLines } from '../../../../../base/common/strings.js';\nimport { Range } from '../../../core/range.js';\n/**\n * Represents a non-negative length in terms of line and column count.\n * Prefer using {@link Length} for performance reasons.\n*/\nexport class LengthObj {\n    constructor(lineCount, columnCount) {\n        this.lineCount = lineCount;\n        this.columnCount = columnCount;\n    }\n    toString() {\n        return `${this.lineCount},${this.columnCount}`;\n    }\n}\nLengthObj.zero = new LengthObj(0, 0);\n/**\n * The end must be greater than or equal to the start.\n*/\nexport function lengthDiff(startLineCount, startColumnCount, endLineCount, endColumnCount) {\n    return (startLineCount !== endLineCount)\n        ? toLength(endLineCount - startLineCount, endColumnCount)\n        : toLength(0, endColumnCount - startColumnCount);\n}\nexport const lengthZero = 0;\nexport function lengthIsZero(length) {\n    return length === 0;\n}\n/*\n * We have 52 bits available in a JS number.\n * We use the upper 26 bits to store the line and the lower 26 bits to store the column.\n */\n///*\nconst factor = Math.pow(2, 26);\n/*/\nconst factor = 1000000;\n// */\nexport function toLength(lineCount, columnCount) {\n    // llllllllllllllllllllllllllcccccccccccccccccccccccccc (52 bits)\n    //       line count (26 bits)    column count (26 bits)\n    // If there is no overflow (all values/sums below 2^26 = 67108864),\n    // we have `toLength(lns1, cols1) + toLength(lns2, cols2) = toLength(lns1 + lns2, cols1 + cols2)`.\n    return (lineCount * factor + columnCount);\n}\nexport function lengthToObj(length) {\n    const l = length;\n    const lineCount = Math.floor(l / factor);\n    const columnCount = l - lineCount * factor;\n    return new LengthObj(lineCount, columnCount);\n}\nexport function lengthGetLineCount(length) {\n    return Math.floor(length / factor);\n}\n/**\n * Returns the amount of columns of the given length, assuming that it does not span any line.\n*/\nexport function lengthGetColumnCountIfZeroLineCount(length) {\n    return length;\n}\nexport function lengthAdd(l1, l2) {\n    let r = l1 + l2;\n    if (l2 >= factor) {\n        r = r - (l1 % factor);\n    }\n    return r;\n}\nexport function sumLengths(items, lengthFn) {\n    return items.reduce((a, b) => lengthAdd(a, lengthFn(b)), lengthZero);\n}\nexport function lengthEquals(length1, length2) {\n    return length1 === length2;\n}\n/**\n * Returns a non negative length `result` such that `lengthAdd(length1, result) = length2`, or zero if such length does not exist.\n */\nexport function lengthDiffNonNegative(length1, length2) {\n    const l1 = length1;\n    const l2 = length2;\n    const diff = l2 - l1;\n    if (diff <= 0) {\n        // line-count of length1 is higher than line-count of length2\n        // or they are equal and column-count of length1 is higher than column-count of length2\n        return lengthZero;\n    }\n    const lineCount1 = Math.floor(l1 / factor);\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    if (lineCount1 === lineCount2) {\n        const colCount1 = l1 - lineCount1 * factor;\n        return toLength(0, colCount2 - colCount1);\n    }\n    else {\n        return toLength(lineCount2 - lineCount1, colCount2);\n    }\n}\nexport function lengthLessThan(length1, length2) {\n    // First, compare line counts, then column counts.\n    return length1 < length2;\n}\nexport function lengthLessThanEqual(length1, length2) {\n    return length1 <= length2;\n}\nexport function lengthGreaterThanEqual(length1, length2) {\n    return length1 >= length2;\n}\nexport function positionToLength(position) {\n    return toLength(position.lineNumber - 1, position.column - 1);\n}\nexport function lengthsToRange(lengthStart, lengthEnd) {\n    const l = lengthStart;\n    const lineCount = Math.floor(l / factor);\n    const colCount = l - lineCount * factor;\n    const l2 = lengthEnd;\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    return new Range(lineCount + 1, colCount + 1, lineCount2 + 1, colCount2 + 1);\n}\nexport function lengthOfString(str) {\n    const lines = splitLines(str);\n    return toLength(lines.length - 1, lines[lines.length - 1].length);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ListAstNode } from './ast.js';\n/**\n * Concatenates a list of (2,3) AstNode's into a single (2,3) AstNode.\n * This mutates the items of the input array!\n * If all items have the same height, this method has runtime O(items.length).\n * Otherwise, it has runtime O(items.length * max(log(items.length), items.max(i => i.height))).\n*/\nexport function concat23Trees(items) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let i = 0;\n    /**\n     * Reads nodes of same height and concatenates them to a single node.\n    */\n    function readNode() {\n        if (i >= items.length) {\n            return null;\n        }\n        const start = i;\n        const height = items[start].listHeight;\n        i++;\n        while (i < items.length && items[i].listHeight === height) {\n            i++;\n        }\n        if (i - start >= 2) {\n            return concat23TreesOfSameHeight(start === 0 && i === items.length ? items : items.slice(start, i), false);\n        }\n        else {\n            return items[start];\n        }\n    }\n    // The items might not have the same height.\n    // We merge all items by using a binary concat operator.\n    let first = readNode(); // There must be a first item\n    let second = readNode();\n    if (!second) {\n        return first;\n    }\n    for (let item = readNode(); item; item = readNode()) {\n        // Prefer concatenating smaller trees, as the runtime of concat depends on the tree height.\n        if (heightDiff(first, second) <= heightDiff(second, item)) {\n            first = concat(first, second);\n            second = item;\n        }\n        else {\n            second = concat(second, item);\n        }\n    }\n    const result = concat(first, second);\n    return result;\n}\nexport function concat23TreesOfSameHeight(items, createImmutableLists = false) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let length = items.length;\n    // All trees have same height, just create parent nodes.\n    while (length > 3) {\n        const newLength = length >> 1;\n        for (let i = 0; i < newLength; i++) {\n            const j = i << 1;\n            items[i] = ListAstNode.create23(items[j], items[j + 1], j + 3 === length ? items[j + 2] : null, createImmutableLists);\n        }\n        length = newLength;\n    }\n    return ListAstNode.create23(items[0], items[1], length >= 3 ? items[2] : null, createImmutableLists);\n}\nfunction heightDiff(node1, node2) {\n    return Math.abs(node1.listHeight - node2.listHeight);\n}\nfunction concat(node1, node2) {\n    if (node1.listHeight === node2.listHeight) {\n        return ListAstNode.create23(node1, node2, null, false);\n    }\n    else if (node1.listHeight > node2.listHeight) {\n        // node1 is the tree we want to insert into\n        return append(node1, node2);\n    }\n    else {\n        return prepend(node2, node1);\n    }\n}\n/**\n * Appends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction append(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = [];\n    let nodeToAppendOfCorrectHeight;\n    while (true) {\n        // assert nodeToInsert.listHeight <= curNode.listHeight\n        if (nodeToAppend.listHeight === curNode.listHeight) {\n            nodeToAppendOfCorrectHeight = nodeToAppend;\n            break;\n        }\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* AstNodeKind.List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenLength <= 3\n        curNode = curNode.makeLastElementMutable();\n    }\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToAppendOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToAppendOfCorrectHeight = ListAstNode.create23(parent.unappendChild(), nodeToAppendOfCorrectHeight, null, false);\n            }\n            else {\n                parent.appendChildOfSameHeight(nodeToAppendOfCorrectHeight);\n                nodeToAppendOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToAppendOfCorrectHeight) {\n        return ListAstNode.create23(list, nodeToAppendOfCorrectHeight, null, false);\n    }\n    else {\n        return list;\n    }\n}\n/**\n * Prepends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction prepend(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = [];\n    // assert nodeToInsert.listHeight <= curNode.listHeight\n    while (nodeToAppend.listHeight !== curNode.listHeight) {\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* AstNodeKind.List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenFast.length <= 3\n        curNode = curNode.makeFirstElementMutable();\n    }\n    let nodeToPrependOfCorrectHeight = nodeToAppend;\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToPrependOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToPrependOfCorrectHeight = ListAstNode.create23(nodeToPrependOfCorrectHeight, parent.unprependChild(), null, false);\n            }\n            else {\n                parent.prependChildOfSameHeight(nodeToPrependOfCorrectHeight);\n                nodeToPrependOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToPrependOfCorrectHeight) {\n        return ListAstNode.create23(nodeToPrependOfCorrectHeight, list, null, false);\n    }\n    else {\n        return list;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { lengthAdd, lengthZero, lengthLessThan } from './length.js';\n/**\n * Allows to efficiently find a longest child at a given offset in a fixed node.\n * The requested offsets must increase monotonously.\n*/\nexport class NodeReader {\n    constructor(node) {\n        this.lastOffset = lengthZero;\n        this.nextNodes = [node];\n        this.offsets = [lengthZero];\n        this.idxs = [];\n    }\n    /**\n     * Returns the longest node at `offset` that satisfies the predicate.\n     * @param offset must be greater than or equal to the last offset this method has been called with!\n    */\n    readLongestNodeAt(offset, predicate) {\n        if (lengthLessThan(offset, this.lastOffset)) {\n            throw new Error('Invalid offset');\n        }\n        this.lastOffset = offset;\n        // Find the longest node of all those that are closest to the current offset.\n        while (true) {\n            const curNode = lastOrUndefined(this.nextNodes);\n            if (!curNode) {\n                return undefined;\n            }\n            const curNodeOffset = lastOrUndefined(this.offsets);\n            if (lengthLessThan(offset, curNodeOffset)) {\n                // The next best node is not here yet.\n                // The reader must advance before a cached node is hit.\n                return undefined;\n            }\n            if (lengthLessThan(curNodeOffset, offset)) {\n                // The reader is ahead of the current node.\n                if (lengthAdd(curNodeOffset, curNode.length) <= offset) {\n                    // The reader is after the end of the current node.\n                    this.nextNodeAfterCurrent();\n                }\n                else {\n                    // The reader is somewhere in the current node.\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    if (nextChildIdx !== -1) {\n                        // Go to the first child and repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                    else {\n                        // We don't have children\n                        this.nextNodeAfterCurrent();\n                    }\n                }\n            }\n            else {\n                // readerOffsetBeforeChange === curNodeOffset\n                if (predicate(curNode)) {\n                    this.nextNodeAfterCurrent();\n                    return curNode;\n                }\n                else {\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    // look for shorter node\n                    if (nextChildIdx === -1) {\n                        // There is no shorter node.\n                        this.nextNodeAfterCurrent();\n                        return undefined;\n                    }\n                    else {\n                        // Descend into first child & repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                }\n            }\n        }\n    }\n    // Navigates to the longest node that continues after the current node.\n    nextNodeAfterCurrent() {\n        while (true) {\n            const currentOffset = lastOrUndefined(this.offsets);\n            const currentNode = lastOrUndefined(this.nextNodes);\n            this.nextNodes.pop();\n            this.offsets.pop();\n            if (this.idxs.length === 0) {\n                // We just popped the root node, there is no next node.\n                break;\n            }\n            // Parent is not undefined, because idxs is not empty\n            const parent = lastOrUndefined(this.nextNodes);\n            const nextChildIdx = getNextChildIdx(parent, this.idxs[this.idxs.length - 1]);\n            if (nextChildIdx !== -1) {\n                this.nextNodes.push(parent.getChild(nextChildIdx));\n                this.offsets.push(lengthAdd(currentOffset, currentNode.length));\n                this.idxs[this.idxs.length - 1] = nextChildIdx;\n                break;\n            }\n            else {\n                this.idxs.pop();\n            }\n            // We fully consumed the parent.\n            // Current node is now parent, so call nextNodeAfterCurrent again\n        }\n    }\n}\nfunction getNextChildIdx(node, curIdx = -1) {\n    while (true) {\n        curIdx++;\n        if (curIdx >= node.childrenLength) {\n            return -1;\n        }\n        if (node.getChild(curIdx)) {\n            return curIdx;\n        }\n    }\n}\nfunction lastOrUndefined(arr) {\n    return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { InvalidBracketAstNode, ListAstNode, PairAstNode, TextAstNode } from './ast.js';\nimport { BeforeEditPositionMapper } from './beforeEditPositionMapper.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nimport { lengthIsZero, lengthLessThan } from './length.js';\nimport { concat23Trees, concat23TreesOfSameHeight } from './concat23Trees.js';\nimport { NodeReader } from './nodeReader.js';\n/**\n * Non incrementally built ASTs are immutable.\n*/\nexport function parseDocument(tokenizer, edits, oldNode, createImmutableLists) {\n    const parser = new Parser(tokenizer, edits, oldNode, createImmutableLists);\n    return parser.parseDocument();\n}\n/**\n * Non incrementally built ASTs are immutable.\n*/\nclass Parser {\n    constructor(tokenizer, edits, oldNode, createImmutableLists) {\n        this.tokenizer = tokenizer;\n        this.createImmutableLists = createImmutableLists;\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        if (oldNode && createImmutableLists) {\n            throw new Error('Not supported');\n        }\n        this.oldNodeReader = oldNode ? new NodeReader(oldNode) : undefined;\n        this.positionMapper = new BeforeEditPositionMapper(edits);\n    }\n    parseDocument() {\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        let result = this.parseList(SmallImmutableSet.getEmpty(), 0);\n        if (!result) {\n            result = ListAstNode.getEmpty();\n        }\n        return result;\n    }\n    parseList(openedBracketIds, level) {\n        const items = [];\n        while (true) {\n            let child = this.tryReadChildFromCache(openedBracketIds);\n            if (!child) {\n                const token = this.tokenizer.peek();\n                if (!token ||\n                    (token.kind === 2 /* TokenKind.ClosingBracket */ &&\n                        token.bracketIds.intersects(openedBracketIds))) {\n                    break;\n                }\n                child = this.parseChild(openedBracketIds, level + 1);\n            }\n            if (child.kind === 4 /* AstNodeKind.List */ && child.childrenLength === 0) {\n                continue;\n            }\n            items.push(child);\n        }\n        // When there is no oldNodeReader, all items are created from scratch and must have the same height.\n        const result = this.oldNodeReader ? concat23Trees(items) : concat23TreesOfSameHeight(items, this.createImmutableLists);\n        return result;\n    }\n    tryReadChildFromCache(openedBracketIds) {\n        if (this.oldNodeReader) {\n            const maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);\n            if (maxCacheableLength === null || !lengthIsZero(maxCacheableLength)) {\n                const cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), curNode => {\n                    // The edit could extend the ending token, thus we cannot re-use nodes that touch the edit.\n                    // If there is no edit anymore, we can re-use the node in any case.\n                    if (maxCacheableLength !== null && !lengthLessThan(curNode.length, maxCacheableLength)) {\n                        // Either the node contains edited text or touches edited text.\n                        // In the latter case, brackets might have been extended (`end` -> `ending`), so even touching nodes cannot be reused.\n                        return false;\n                    }\n                    const canBeReused = curNode.canBeReused(openedBracketIds);\n                    return canBeReused;\n                });\n                if (cachedNode) {\n                    this._itemsFromCache++;\n                    this.tokenizer.skip(cachedNode.length);\n                    return cachedNode;\n                }\n            }\n        }\n        return undefined;\n    }\n    parseChild(openedBracketIds, level) {\n        this._itemsConstructed++;\n        const token = this.tokenizer.read();\n        switch (token.kind) {\n            case 2 /* TokenKind.ClosingBracket */:\n                return new InvalidBracketAstNode(token.bracketIds, token.length);\n            case 0 /* TokenKind.Text */:\n                return token.astNode;\n            case 1 /* TokenKind.OpeningBracket */: {\n                if (level > 300) {\n                    // To prevent stack overflows\n                    return new TextAstNode(token.length);\n                }\n                const set = openedBracketIds.merge(token.bracketIds);\n                const child = this.parseList(set, level + 1);\n                const nextToken = this.tokenizer.peek();\n                if (nextToken &&\n                    nextToken.kind === 2 /* TokenKind.ClosingBracket */ &&\n                    (nextToken.bracketId === token.bracketId || nextToken.bracketIds.intersects(token.bracketIds))) {\n                    this.tokenizer.read();\n                    return PairAstNode.create(token.astNode, child, nextToken.astNode);\n                }\n                else {\n                    return PairAstNode.create(token.astNode, child, null);\n                }\n            }\n            default:\n                throw new Error('unexpected');\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst emptyArr = [];\n/**\n * Represents an immutable set that works best for a small number of elements (less than 32).\n * It uses bits to encode element membership efficiently.\n*/\nexport class SmallImmutableSet {\n    static create(items, additionalItems) {\n        if (items <= 128 && additionalItems.length === 0) {\n            // We create a cache of 128=2^7 elements to cover all sets with up to 7 (dense) elements.\n            let cached = SmallImmutableSet.cache[items];\n            if (!cached) {\n                cached = new SmallImmutableSet(items, additionalItems);\n                SmallImmutableSet.cache[items] = cached;\n            }\n            return cached;\n        }\n        return new SmallImmutableSet(items, additionalItems);\n    }\n    static getEmpty() {\n        return this.empty;\n    }\n    constructor(items, additionalItems) {\n        this.items = items;\n        this.additionalItems = additionalItems;\n    }\n    add(value, keyProvider) {\n        const key = keyProvider.getKey(value);\n        let idx = key >> 5; // divided by 32\n        if (idx === 0) {\n            // fast path\n            const newItem = (1 << key) | this.items;\n            if (newItem === this.items) {\n                return this;\n            }\n            return SmallImmutableSet.create(newItem, this.additionalItems);\n        }\n        idx--;\n        const newItems = this.additionalItems.slice(0);\n        while (newItems.length < idx) {\n            newItems.push(0);\n        }\n        newItems[idx] |= 1 << (key & 31);\n        return SmallImmutableSet.create(this.items, newItems);\n    }\n    merge(other) {\n        const merged = this.items | other.items;\n        if (this.additionalItems === emptyArr && other.additionalItems === emptyArr) {\n            // fast path\n            if (merged === this.items) {\n                return this;\n            }\n            if (merged === other.items) {\n                return other;\n            }\n            return SmallImmutableSet.create(merged, emptyArr);\n        }\n        // This can be optimized, but it's not a common case\n        const newItems = [];\n        for (let i = 0; i < Math.max(this.additionalItems.length, other.additionalItems.length); i++) {\n            const item1 = this.additionalItems[i] || 0;\n            const item2 = other.additionalItems[i] || 0;\n            newItems.push(item1 | item2);\n        }\n        return SmallImmutableSet.create(merged, newItems);\n    }\n    intersects(other) {\n        if ((this.items & other.items) !== 0) {\n            return true;\n        }\n        for (let i = 0; i < Math.min(this.additionalItems.length, other.additionalItems.length); i++) {\n            if ((this.additionalItems[i] & other.additionalItems[i]) !== 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nSmallImmutableSet.cache = new Array(129);\nSmallImmutableSet.empty = SmallImmutableSet.create(0, emptyArr);\nexport const identityKeyProvider = {\n    getKey(value) {\n        return value;\n    }\n};\n/**\n * Assigns values a unique incrementing key.\n*/\nexport class DenseKeyProvider {\n    constructor() {\n        this.items = new Map();\n    }\n    getKey(value) {\n        let existing = this.items.get(value);\n        if (existing === undefined) {\n            existing = this.items.size;\n            this.items.set(value, existing);\n        }\n        return existing;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { NotSupportedError } from '../../../../../base/common/errors.js';\nimport { TokenMetadata } from '../../../encodedTokenAttributes.js';\nimport { TextAstNode } from './ast.js';\nimport { lengthAdd, lengthDiff, lengthGetColumnCountIfZeroLineCount, lengthToObj, lengthZero, toLength } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nexport class Token {\n    constructor(length, kind, \n    /**\n     * If this token is an opening bracket, this is the id of the opening bracket.\n     * If this token is a closing bracket, this is the id of the first opening bracket that is closed by this bracket.\n     * Otherwise, it is -1.\n     */\n    bracketId, \n    /**\n     * If this token is an opening bracket, this just contains `bracketId`.\n     * If this token is a closing bracket, this lists all opening bracket ids, that it closes.\n     * Otherwise, it is empty.\n     */\n    bracketIds, astNode) {\n        this.length = length;\n        this.kind = kind;\n        this.bracketId = bracketId;\n        this.bracketIds = bracketIds;\n        this.astNode = astNode;\n    }\n}\nexport class TextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);\n        this._offset = lengthZero;\n        this.didPeek = false;\n        this.peeked = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    get offset() {\n        return this._offset;\n    }\n    get length() {\n        return toLength(this.textBufferLineCount - 1, this.textBufferLastLineLength);\n    }\n    skip(length) {\n        this.didPeek = false;\n        this._offset = lengthAdd(this._offset, length);\n        const obj = lengthToObj(this._offset);\n        this.reader.setPosition(obj.lineCount, obj.columnCount);\n    }\n    read() {\n        let token;\n        if (this.peeked) {\n            this.didPeek = false;\n            token = this.peeked;\n        }\n        else {\n            token = this.reader.read();\n        }\n        if (token) {\n            this._offset = lengthAdd(this._offset, token.length);\n        }\n        return token;\n    }\n    peek() {\n        if (!this.didPeek) {\n            this.peeked = this.reader.read();\n            this.didPeek = true;\n        }\n        return this.peeked;\n    }\n}\n/**\n * Does not support peek.\n*/\nclass NonPeekableTextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.lineIdx = 0;\n        this.line = null;\n        this.lineCharOffset = 0;\n        this.lineTokens = null;\n        this.lineTokenOffset = 0;\n        /** Must be a zero line token. The end of the document cannot be peeked. */\n        this.peekedToken = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    setPosition(lineIdx, column) {\n        // We must not jump into a token!\n        if (lineIdx === this.lineIdx) {\n            this.lineCharOffset = column;\n            if (this.line !== null) {\n                this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n            }\n        }\n        else {\n            this.lineIdx = lineIdx;\n            this.lineCharOffset = column;\n            this.line = null;\n        }\n        this.peekedToken = null;\n    }\n    read() {\n        if (this.peekedToken) {\n            const token = this.peekedToken;\n            this.peekedToken = null;\n            this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(token.length);\n            return token;\n        }\n        if (this.lineIdx > this.textBufferLineCount - 1 || (this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)) {\n            // We are after the end\n            return null;\n        }\n        if (this.line === null) {\n            this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n            this.line = this.lineTokens.getLineContent();\n            this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n        }\n        const startLineIdx = this.lineIdx;\n        const startLineCharOffset = this.lineCharOffset;\n        // limits the length of text tokens.\n        // If text tokens get too long, incremental updates will be slow\n        let lengthHeuristic = 0;\n        while (true) {\n            const lineTokens = this.lineTokens;\n            const tokenCount = lineTokens.getCount();\n            let peekedBracketToken = null;\n            if (this.lineTokenOffset < tokenCount) {\n                const tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);\n                while (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {\n                    // Skip tokens that are identical.\n                    // Sometimes, (bracket) identifiers are split up into multiple tokens.\n                    this.lineTokenOffset++;\n                }\n                const isOther = TokenMetadata.getTokenType(tokenMetadata) === 0 /* StandardTokenType.Other */;\n                const containsBracketType = TokenMetadata.containsBalancedBrackets(tokenMetadata);\n                const endOffset = lineTokens.getEndOffset(this.lineTokenOffset);\n                // Is there a bracket token next? Only consume text.\n                if (containsBracketType && isOther && this.lineCharOffset < endOffset) {\n                    const languageId = lineTokens.getLanguageId(this.lineTokenOffset);\n                    const text = this.line.substring(this.lineCharOffset, endOffset);\n                    const brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);\n                    const regexp = brackets.regExpGlobal;\n                    if (regexp) {\n                        regexp.lastIndex = 0;\n                        const match = regexp.exec(text);\n                        if (match) {\n                            peekedBracketToken = brackets.getToken(match[0]);\n                            if (peekedBracketToken) {\n                                // Consume leading text of the token\n                                this.lineCharOffset += match.index;\n                            }\n                        }\n                    }\n                }\n                lengthHeuristic += endOffset - this.lineCharOffset;\n                if (peekedBracketToken) {\n                    // Don't skip the entire token, as a single token could contain multiple brackets.\n                    if (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {\n                        // There is text before the bracket\n                        this.peekedToken = peekedBracketToken;\n                        break;\n                    }\n                    else {\n                        // Consume the peeked token\n                        this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(peekedBracketToken.length);\n                        return peekedBracketToken;\n                    }\n                }\n                else {\n                    // Skip the entire token, as the token contains no brackets at all.\n                    this.lineTokenOffset++;\n                    this.lineCharOffset = endOffset;\n                }\n            }\n            else {\n                if (this.lineIdx === this.textBufferLineCount - 1) {\n                    break;\n                }\n                this.lineIdx++;\n                this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n                this.lineTokenOffset = 0;\n                this.line = this.lineTokens.getLineContent();\n                this.lineCharOffset = 0;\n                lengthHeuristic += 33; // max 1000/33 = 30 lines\n                // This limits the amount of work to recompute min-indentation\n                if (lengthHeuristic > 1000) {\n                    // only break (automatically) at the end of line.\n                    break;\n                }\n            }\n            if (lengthHeuristic > 1500) {\n                // Eventually break regardless of the line length so that\n                // very long lines do not cause bad performance.\n                // This effective limits max indentation to 500, as\n                // indentation is not computed across multiple text nodes.\n                break;\n            }\n        }\n        // If a token contains some proper indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION}),\n        // unless the line is too long.\n        // Thus, the min indentation of the document is the minimum min indentation of every text node.\n        const length = lengthDiff(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);\n        return new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n    }\n}\nexport class FastTokenizer {\n    constructor(text, brackets) {\n        this.text = text;\n        this._offset = lengthZero;\n        this.idx = 0;\n        const regExpStr = brackets.getRegExpStr();\n        const regexp = regExpStr ? new RegExp(regExpStr + '|\\n', 'gi') : null;\n        const tokens = [];\n        let match;\n        let curLineCount = 0;\n        let lastLineBreakOffset = 0;\n        let lastTokenEndOffset = 0;\n        let lastTokenEndLine = 0;\n        const smallTextTokens0Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens0Line.push(new Token(toLength(0, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(0, i))));\n        }\n        const smallTextTokens1Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens1Line.push(new Token(toLength(1, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(1, i))));\n        }\n        if (regexp) {\n            regexp.lastIndex = 0;\n            // If a token contains indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION})\n            while ((match = regexp.exec(text)) !== null) {\n                const curOffset = match.index;\n                const value = match[0];\n                if (value === '\\n') {\n                    curLineCount++;\n                    lastLineBreakOffset = curOffset + 1;\n                }\n                else {\n                    if (lastTokenEndOffset !== curOffset) {\n                        let token;\n                        if (lastTokenEndLine === curLineCount) {\n                            const colCount = curOffset - lastTokenEndOffset;\n                            if (colCount < smallTextTokens0Line.length) {\n                                token = smallTextTokens0Line[colCount];\n                            }\n                            else {\n                                const length = toLength(0, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        else {\n                            const lineCount = curLineCount - lastTokenEndLine;\n                            const colCount = curOffset - lastLineBreakOffset;\n                            if (lineCount === 1 && colCount < smallTextTokens1Line.length) {\n                                token = smallTextTokens1Line[colCount];\n                            }\n                            else {\n                                const length = toLength(lineCount, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        tokens.push(token);\n                    }\n                    // value is matched by regexp, so the token must exist\n                    tokens.push(brackets.getToken(value));\n                    lastTokenEndOffset = curOffset + value.length;\n                    lastTokenEndLine = curLineCount;\n                }\n            }\n        }\n        const offset = text.length;\n        if (lastTokenEndOffset !== offset) {\n            const length = (lastTokenEndLine === curLineCount)\n                ? toLength(0, offset - lastTokenEndOffset)\n                : toLength(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);\n            tokens.push(new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length)));\n        }\n        this.length = toLength(curLineCount, offset - lastLineBreakOffset);\n        this.tokens = tokens;\n    }\n    get offset() {\n        return this._offset;\n    }\n    read() {\n        return this.tokens[this.idx++] || null;\n    }\n    peek() {\n        return this.tokens[this.idx] || null;\n    }\n    skip(length) {\n        throw new NotSupportedError();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { editorBracketHighlightingForeground1, editorBracketHighlightingForeground2, editorBracketHighlightingForeground3, editorBracketHighlightingForeground4, editorBracketHighlightingForeground5, editorBracketHighlightingForeground6, editorBracketHighlightingUnexpectedBracketForeground } from '../../core/editorColorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nexport class ColorizedBracketPairsDecorationProvider extends Disposable {\n    constructor(textModel) {\n        super();\n        this.textModel = textModel;\n        this.colorProvider = new ColorProvider();\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.colorizationOptions = textModel.getOptions().bracketPairColorizationOptions;\n        this._register(textModel.bracketPairs.onDidChange(e => {\n            this.onDidChangeEmitter.fire();\n        }));\n    }\n    //#region TextModel events\n    handleDidChangeOptions(e) {\n        this.colorizationOptions = this.textModel.getOptions().bracketPairColorizationOptions;\n    }\n    //#endregion\n    getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations) {\n        if (onlyMinimapDecorations) {\n            // Bracket pair colorization decorations are not rendered in the minimap\n            return [];\n        }\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        const result = this.textModel.bracketPairs.getBracketsInRange(range, true).map(bracket => ({\n            id: `bracket${bracket.range.toString()}-${bracket.nestingLevel}`,\n            options: {\n                description: 'BracketPairColorization',\n                inlineClassName: this.colorProvider.getInlineClassName(bracket, this.colorizationOptions.independentColorPoolPerBracketType),\n            },\n            ownerId: 0,\n            range: bracket.range,\n        })).toArray();\n        return result;\n    }\n    getAllDecorations(ownerId, filterOutValidation) {\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        return this.getDecorationsInRange(new Range(1, 1, this.textModel.getLineCount(), 1), ownerId, filterOutValidation);\n    }\n}\nclass ColorProvider {\n    constructor() {\n        this.unexpectedClosingBracketClassName = 'unexpected-closing-bracket';\n    }\n    getInlineClassName(bracket, independentColorPoolPerBracketType) {\n        if (bracket.isInvalid) {\n            return this.unexpectedClosingBracketClassName;\n        }\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? bracket.nestingLevelOfEqualBracketType : bracket.nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-highlighting-${level % 30}`;\n    }\n}\nregisterThemingParticipant((theme, collector) => {\n    const colors = [\n        editorBracketHighlightingForeground1,\n        editorBracketHighlightingForeground2,\n        editorBracketHighlightingForeground3,\n        editorBracketHighlightingForeground4,\n        editorBracketHighlightingForeground5,\n        editorBracketHighlightingForeground6\n    ];\n    const colorProvider = new ColorProvider();\n    collector.addRule(`.monaco-editor .${colorProvider.unexpectedClosingBracketClassName} { color: ${theme.getColor(editorBracketHighlightingUnexpectedBracketForeground)}; }`);\n    const colorValues = colors\n        .map(c => theme.getColor(c))\n        .filter((c) => !!c)\n        .filter(c => !c.isTransparent());\n    for (let level = 0; level < 30; level++) {\n        const color = colorValues[level % colorValues.length];\n        collector.addRule(`.monaco-editor .${colorProvider.getInlineClassNameOfLevel(level)} { color: ${color}; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LanguageAgnosticBracketTokens } from './bracketPairsTree/brackets.js';\nimport { lengthAdd, lengthGetColumnCountIfZeroLineCount, lengthZero } from './bracketPairsTree/length.js';\nimport { parseDocument } from './bracketPairsTree/parser.js';\nimport { DenseKeyProvider } from './bracketPairsTree/smallImmutableSet.js';\nimport { TextBufferTokenizer } from './bracketPairsTree/tokenizer.js';\nexport function fixBracketsInLine(tokens, languageConfigurationService) {\n    const denseKeyProvider = new DenseKeyProvider();\n    const bracketTokens = new LanguageAgnosticBracketTokens(denseKeyProvider, (languageId) => languageConfigurationService.getLanguageConfiguration(languageId));\n    const tokenizer = new TextBufferTokenizer(new StaticTokenizerSource([tokens]), bracketTokens);\n    const node = parseDocument(tokenizer, [], undefined, true);\n    let str = '';\n    const line = tokens.getLineContent();\n    function processNode(node, offset) {\n        if (node.kind === 2 /* AstNodeKind.Pair */) {\n            processNode(node.openingBracket, offset);\n            offset = lengthAdd(offset, node.openingBracket.length);\n            if (node.child) {\n                processNode(node.child, offset);\n                offset = lengthAdd(offset, node.child.length);\n            }\n            if (node.closingBracket) {\n                processNode(node.closingBracket, offset);\n                offset = lengthAdd(offset, node.closingBracket.length);\n            }\n            else {\n                const singleLangBracketTokens = bracketTokens.getSingleLanguageBracketTokens(node.openingBracket.languageId);\n                const closingTokenText = singleLangBracketTokens.findClosingTokenText(node.openingBracket.bracketIds);\n                str += closingTokenText;\n            }\n        }\n        else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n            // remove the bracket\n        }\n        else if (node.kind === 0 /* AstNodeKind.Text */ || node.kind === 1 /* AstNodeKind.Bracket */) {\n            str += line.substring(lengthGetColumnCountIfZeroLineCount(offset), lengthGetColumnCountIfZeroLineCount(lengthAdd(offset, node.length)));\n        }\n        else if (node.kind === 4 /* AstNodeKind.List */) {\n            for (const child of node.children) {\n                processNode(child, offset);\n                offset = lengthAdd(offset, child.length);\n            }\n        }\n    }\n    processNode(node, lengthZero);\n    return str;\n}\nclass StaticTokenizerSource {\n    constructor(lines) {\n        this.lines = lines;\n        this.tokenization = {\n            getLineTokens: (lineNumber) => {\n                return this.lines[lineNumber - 1];\n            }\n        };\n    }\n    getLineCount() {\n        return this.lines.length;\n    }\n    getLineLength(lineNumber) {\n        return this.lines[lineNumber - 1].getLineContent().length;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Selection } from '../core/selection.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { TextChange, compressConsecutiveTextChanges } from '../core/textChange.js';\nimport * as buffer from '../../../base/common/buffer.js';\nimport { basename } from '../../../base/common/resources.js';\nfunction uriGetComparisonKey(resource) {\n    return resource.toString();\n}\nexport class SingleModelEditStackData {\n    static create(model, beforeCursorState) {\n        const alternativeVersionId = model.getAlternativeVersionId();\n        const eol = getModelEOL(model);\n        return new SingleModelEditStackData(alternativeVersionId, alternativeVersionId, eol, eol, beforeCursorState, beforeCursorState, []);\n    }\n    constructor(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes) {\n        this.beforeVersionId = beforeVersionId;\n        this.afterVersionId = afterVersionId;\n        this.beforeEOL = beforeEOL;\n        this.afterEOL = afterEOL;\n        this.beforeCursorState = beforeCursorState;\n        this.afterCursorState = afterCursorState;\n        this.changes = changes;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (textChanges.length > 0) {\n            this.changes = compressConsecutiveTextChanges(this.changes, textChanges);\n        }\n        this.afterEOL = afterEOL;\n        this.afterVersionId = afterVersionId;\n        this.afterCursorState = afterCursorState;\n    }\n    static _writeSelectionsSize(selections) {\n        return 4 + 4 * 4 * (selections ? selections.length : 0);\n    }\n    static _writeSelections(b, selections, offset) {\n        buffer.writeUInt32BE(b, (selections ? selections.length : 0), offset);\n        offset += 4;\n        if (selections) {\n            for (const selection of selections) {\n                buffer.writeUInt32BE(b, selection.selectionStartLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.selectionStartColumn, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionColumn, offset);\n                offset += 4;\n            }\n        }\n        return offset;\n    }\n    static _readSelections(b, offset, dest) {\n        const count = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        for (let i = 0; i < count; i++) {\n            const selectionStartLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const selectionStartColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            dest.push(new Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn));\n        }\n        return offset;\n    }\n    serialize() {\n        let necessarySize = (+4 // beforeVersionId\n            + 4 // afterVersionId\n            + 1 // beforeEOL\n            + 1 // afterEOL\n            + SingleModelEditStackData._writeSelectionsSize(this.beforeCursorState)\n            + SingleModelEditStackData._writeSelectionsSize(this.afterCursorState)\n            + 4 // change count\n        );\n        for (const change of this.changes) {\n            necessarySize += change.writeSize();\n        }\n        const b = new Uint8Array(necessarySize);\n        let offset = 0;\n        buffer.writeUInt32BE(b, this.beforeVersionId, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.afterVersionId, offset);\n        offset += 4;\n        buffer.writeUInt8(b, this.beforeEOL, offset);\n        offset += 1;\n        buffer.writeUInt8(b, this.afterEOL, offset);\n        offset += 1;\n        offset = SingleModelEditStackData._writeSelections(b, this.beforeCursorState, offset);\n        offset = SingleModelEditStackData._writeSelections(b, this.afterCursorState, offset);\n        buffer.writeUInt32BE(b, this.changes.length, offset);\n        offset += 4;\n        for (const change of this.changes) {\n            offset = change.write(b, offset);\n        }\n        return b.buffer;\n    }\n    static deserialize(source) {\n        const b = new Uint8Array(source);\n        let offset = 0;\n        const beforeVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const afterVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const beforeEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const afterEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const beforeCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, beforeCursorState);\n        const afterCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, afterCursorState);\n        const changeCount = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const changes = [];\n        for (let i = 0; i < changeCount; i++) {\n            offset = TextChange.read(b, offset, changes);\n        }\n        return new SingleModelEditStackData(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes);\n    }\n}\nexport class SingleModelEditStackElement {\n    get type() {\n        return 0 /* UndoRedoElementType.Resource */;\n    }\n    get resource() {\n        if (URI.isUri(this.model)) {\n            return this.model;\n        }\n        return this.model.uri;\n    }\n    constructor(label, code, model, beforeCursorState) {\n        this.label = label;\n        this.code = code;\n        this.model = model;\n        this._data = SingleModelEditStackData.create(model, beforeCursorState);\n    }\n    toString() {\n        const data = (this._data instanceof SingleModelEditStackData ? this._data : SingleModelEditStackData.deserialize(this._data));\n        return data.changes.map(change => change.toString()).join(', ');\n    }\n    matchesResource(resource) {\n        const uri = (URI.isUri(this.model) ? this.model : this.model.uri);\n        return (uri.toString() === resource.toString());\n    }\n    setModel(model) {\n        this.model = model;\n    }\n    canAppend(model) {\n        return (this.model === model && this._data instanceof SingleModelEditStackData);\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n        }\n    }\n    close() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n    }\n    open() {\n        if (!(this._data instanceof SingleModelEditStackData)) {\n            this._data = SingleModelEditStackData.deserialize(this._data);\n        }\n    }\n    undo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyUndo(data.changes, data.beforeEOL, data.beforeVersionId, data.beforeCursorState);\n    }\n    redo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyRedo(data.changes, data.afterEOL, data.afterVersionId, data.afterCursorState);\n    }\n    heapSize() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        return this._data.byteLength + 168 /*heap overhead*/;\n    }\n}\nexport class MultiModelEditStackElement {\n    get resources() {\n        return this._editStackElementsArr.map(editStackElement => editStackElement.resource);\n    }\n    constructor(label, code, editStackElements) {\n        this.label = label;\n        this.code = code;\n        this.type = 1 /* UndoRedoElementType.Workspace */;\n        this._isOpen = true;\n        this._editStackElementsArr = editStackElements.slice(0);\n        this._editStackElementsMap = new Map();\n        for (const editStackElement of this._editStackElementsArr) {\n            const key = uriGetComparisonKey(editStackElement.resource);\n            this._editStackElementsMap.set(key, editStackElement);\n        }\n        this._delegate = null;\n    }\n    prepareUndoRedo() {\n        if (this._delegate) {\n            return this._delegate.prepareUndoRedo(this);\n        }\n    }\n    matchesResource(resource) {\n        const key = uriGetComparisonKey(resource);\n        return (this._editStackElementsMap.has(key));\n    }\n    setModel(model) {\n        const key = uriGetComparisonKey(URI.isUri(model) ? model : model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            this._editStackElementsMap.get(key).setModel(model);\n        }\n    }\n    canAppend(model) {\n        if (!this._isOpen) {\n            return false;\n        }\n        const key = uriGetComparisonKey(model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.canAppend(model);\n        }\n        return false;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        const key = uriGetComparisonKey(model.uri);\n        const editStackElement = this._editStackElementsMap.get(key);\n        editStackElement.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n    }\n    close() {\n        this._isOpen = false;\n    }\n    open() {\n        // cannot reopen\n    }\n    undo() {\n        this._isOpen = false;\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.undo();\n        }\n    }\n    redo() {\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.redo();\n        }\n    }\n    heapSize(resource) {\n        const key = uriGetComparisonKey(resource);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.heapSize();\n        }\n        return 0;\n    }\n    split() {\n        return this._editStackElementsArr;\n    }\n    toString() {\n        const result = [];\n        for (const editStackElement of this._editStackElementsArr) {\n            result.push(`${basename(editStackElement.resource)}: ${editStackElement}`);\n        }\n        return `{${result.join(', ')}}`;\n    }\n}\nfunction getModelEOL(model) {\n    const eol = model.getEOL();\n    if (eol === '\\n') {\n        return 0 /* EndOfLineSequence.LF */;\n    }\n    else {\n        return 1 /* EndOfLineSequence.CRLF */;\n    }\n}\nexport function isEditStackElement(element) {\n    if (!element) {\n        return false;\n    }\n    return ((element instanceof SingleModelEditStackElement) || (element instanceof MultiModelEditStackElement));\n}\nexport class EditStack {\n    constructor(model, undoRedoService) {\n        this._model = model;\n        this._undoRedoService = undoRedoService;\n    }\n    pushStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.close();\n        }\n    }\n    popStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.open();\n        }\n    }\n    clear() {\n        this._undoRedoService.removeElements(this._model.uri);\n    }\n    _getOrCreateEditStackElement(beforeCursorState, group) {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement) && lastElement.canAppend(this._model)) {\n            return lastElement;\n        }\n        const newElement = new SingleModelEditStackElement(nls.localize('edit', \"Typing\"), 'undoredo.textBufferEdit', this._model, beforeCursorState);\n        this._undoRedoService.pushElement(newElement, group);\n        return newElement;\n    }\n    pushEOL(eol) {\n        const editStackElement = this._getOrCreateEditStackElement(null, undefined);\n        this._model.setEOL(eol);\n        editStackElement.append(this._model, [], getModelEOL(this._model), this._model.getAlternativeVersionId(), null);\n    }\n    pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group) {\n        const editStackElement = this._getOrCreateEditStackElement(beforeCursorState, group);\n        const inverseEditOperations = this._model.applyEdits(editOperations, true);\n        const afterCursorState = EditStack._computeCursorState(cursorStateComputer, inverseEditOperations);\n        const textChanges = inverseEditOperations.map((op, index) => ({ index: index, textChange: op.textChange }));\n        textChanges.sort((a, b) => {\n            if (a.textChange.oldPosition === b.textChange.oldPosition) {\n                return a.index - b.index;\n            }\n            return a.textChange.oldPosition - b.textChange.oldPosition;\n        });\n        editStackElement.append(this._model, textChanges.map(op => op.textChange), getModelEOL(this._model), this._model.getAlternativeVersionId(), afterCursorState);\n        return afterCursorState;\n    }\n    static _computeCursorState(cursorStateComputer, inverseEditOperations) {\n        try {\n            return cursorStateComputer ? cursorStateComputer(inverseEditOperations) : null;\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { arrayInsert } from '../../../base/common/arrays.js';\n/**\n * An array that avoids being sparse by always\n * filling up unused indices with a default value.\n */\nexport class FixedArray {\n    constructor(_default) {\n        this._default = _default;\n        this._store = [];\n    }\n    get(index) {\n        if (index < this._store.length) {\n            return this._store[index];\n        }\n        return this._default;\n    }\n    set(index, value) {\n        while (index >= this._store.length) {\n            this._store[this._store.length] = this._default;\n        }\n        this._store[index] = value;\n    }\n    replace(index, oldLength, newLength) {\n        if (index >= this._store.length) {\n            return;\n        }\n        if (oldLength === 0) {\n            this.insert(index, newLength);\n            return;\n        }\n        else if (newLength === 0) {\n            this.delete(index, oldLength);\n            return;\n        }\n        const before = this._store.slice(0, index);\n        const after = this._store.slice(index + oldLength);\n        const insertArr = arrayFill(newLength, this._default);\n        this._store = before.concat(insertArr, after);\n    }\n    delete(deleteIndex, deleteCount) {\n        if (deleteCount === 0 || deleteIndex >= this._store.length) {\n            return;\n        }\n        this._store.splice(deleteIndex, deleteCount);\n    }\n    insert(insertIndex, insertCount) {\n        if (insertCount === 0 || insertIndex >= this._store.length) {\n            return;\n        }\n        const arr = [];\n        for (let i = 0; i < insertCount; i++) {\n            arr[i] = this._default;\n        }\n        this._store = arrayInsert(this._store, insertIndex, arr);\n    }\n}\nfunction arrayFill(length, value) {\n    const arr = [];\n    for (let i = 0; i < length; i++) {\n        arr[i] = value;\n    }\n    return arr;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findLast } from '../../../base/common/arrays.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Range } from '../core/range.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { computeIndentLevel } from './utils.js';\nimport { HorizontalGuidesState, IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nexport class GuidesTextModelPart extends TextModelPart {\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n    }\n    getLanguageConfiguration(languageId) {\n        return this.languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    _computeIndentLevel(lineIndex) {\n        return computeIndentLevel(this.textModel.getLineContent(lineIndex + 1), this.textModel.getOptions().tabSize);\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (lineNumber < 1 || lineNumber > lineCount) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        let up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_aboveContentLineIndent = -1;\n        let up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_belowContentLineIndent = -1;\n        const up_resolveIndents = (lineNumber) => {\n            if (up_aboveContentLineIndex !== -1 &&\n                (up_aboveContentLineIndex === -2 ||\n                    up_aboveContentLineIndex > lineNumber - 1)) {\n                up_aboveContentLineIndex = -1;\n                up_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_aboveContentLineIndex = lineIndex;\n                        up_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (up_belowContentLineIndex === -2) {\n                up_belowContentLineIndex = -1;\n                up_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_belowContentLineIndex = lineIndex;\n                        up_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_aboveContentLineIndent = -1;\n        let down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_belowContentLineIndent = -1;\n        const down_resolveIndents = (lineNumber) => {\n            if (down_aboveContentLineIndex === -2) {\n                down_aboveContentLineIndex = -1;\n                down_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_aboveContentLineIndex = lineIndex;\n                        down_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (down_belowContentLineIndex !== -1 &&\n                (down_belowContentLineIndex === -2 ||\n                    down_belowContentLineIndex < lineNumber - 1)) {\n                down_belowContentLineIndex = -1;\n                down_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_belowContentLineIndex = lineIndex;\n                        down_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let startLineNumber = 0;\n        let goUp = true;\n        let endLineNumber = 0;\n        let goDown = true;\n        let indent = 0;\n        let initialIndent = 0;\n        for (let distance = 0; goUp || goDown; distance++) {\n            const upLineNumber = lineNumber - distance;\n            const downLineNumber = lineNumber + distance;\n            if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n                goUp = false;\n            }\n            if (distance > 1 &&\n                (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\n                goDown = false;\n            }\n            if (distance > 50000) {\n                // stop processing\n                goUp = false;\n                goDown = false;\n            }\n            let upLineIndentLevel = -1;\n            if (goUp && upLineNumber >= 1) {\n                // compute indent level going up\n                const currentIndent = this._computeIndentLevel(upLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    up_belowContentLineIndex = upLineNumber - 1;\n                    up_belowContentLineIndent = currentIndent;\n                    upLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    up_resolveIndents(upLineNumber);\n                    upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\n                }\n            }\n            let downLineIndentLevel = -1;\n            if (goDown && downLineNumber <= lineCount) {\n                // compute indent level going down\n                const currentIndent = this._computeIndentLevel(downLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    down_aboveContentLineIndex = downLineNumber - 1;\n                    down_aboveContentLineIndent = currentIndent;\n                    downLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    down_resolveIndents(downLineNumber);\n                    downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\n                }\n            }\n            if (distance === 0) {\n                initialIndent = upLineIndentLevel;\n                continue;\n            }\n            if (distance === 1) {\n                if (downLineNumber <= lineCount &&\n                    downLineIndentLevel >= 0 &&\n                    initialIndent + 1 === downLineIndentLevel) {\n                    // This is the beginning of a scope, we have special handling here, since we want the\n                    // child scope indent to be active, not the parent scope\n                    goUp = false;\n                    startLineNumber = downLineNumber;\n                    endLineNumber = downLineNumber;\n                    indent = downLineIndentLevel;\n                    continue;\n                }\n                if (upLineNumber >= 1 &&\n                    upLineIndentLevel >= 0 &&\n                    upLineIndentLevel - 1 === initialIndent) {\n                    // This is the end of a scope, just like above\n                    goDown = false;\n                    startLineNumber = upLineNumber;\n                    endLineNumber = upLineNumber;\n                    indent = upLineIndentLevel;\n                    continue;\n                }\n                startLineNumber = lineNumber;\n                endLineNumber = lineNumber;\n                indent = initialIndent;\n                if (indent === 0) {\n                    // No need to continue\n                    return { startLineNumber, endLineNumber, indent };\n                }\n            }\n            if (goUp) {\n                if (upLineIndentLevel >= indent) {\n                    startLineNumber = upLineNumber;\n                }\n                else {\n                    goUp = false;\n                }\n            }\n            if (goDown) {\n                if (downLineIndentLevel >= indent) {\n                    endLineNumber = downLineNumber;\n                }\n                else {\n                    goDown = false;\n                }\n            }\n        }\n        return { startLineNumber, endLineNumber, indent };\n    }\n    getLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options) {\n        var _a;\n        const result = [];\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            result.push([]);\n        }\n        // If requested, this could be made configurable.\n        const includeSingleLinePairs = true;\n        const bracketPairs = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new Range(startLineNumber, 1, endLineNumber, this.textModel.getLineMaxColumn(endLineNumber))).toArray();\n        let activeBracketPairRange = undefined;\n        if (activePosition && bracketPairs.length > 0) {\n            const bracketsContainingActivePosition = (startLineNumber <= activePosition.lineNumber &&\n                activePosition.lineNumber <= endLineNumber\n                // We don't need to query the brackets again if the cursor is in the viewport\n                ? bracketPairs\n                : this.textModel.bracketPairs.getBracketPairsInRange(Range.fromPositions(activePosition)).toArray()).filter((bp) => Range.strictContainsPosition(bp.range, activePosition));\n            activeBracketPairRange = (_a = findLast(bracketsContainingActivePosition, (i) => includeSingleLinePairs || i.range.startLineNumber !== i.range.endLineNumber)) === null || _a === void 0 ? void 0 : _a.range;\n        }\n        const independentColorPoolPerBracketType = this.textModel.getOptions().bracketPairColorizationOptions.independentColorPoolPerBracketType;\n        const colorProvider = new BracketPairGuidesClassNames();\n        for (const pair of bracketPairs) {\n            /*\n\n\n                    {\n                    |\n                    }\n\n                    {\n                    |\n                    ----}\n\n                ____{\n                |test\n                ----}\n\n                renderHorizontalEndLineAtTheBottom:\n                    {\n                    |\n                    |x}\n                    --\n                renderHorizontalEndLineAtTheBottom:\n                ____{\n                |test\n                | x }\n                ----\n            */\n            if (!pair.closingBracketRange) {\n                continue;\n            }\n            const isActive = activeBracketPairRange && pair.range.equalsRange(activeBracketPairRange);\n            if (!isActive && !options.includeInactive) {\n                continue;\n            }\n            const className = colorProvider.getInlineClassName(pair.nestingLevel, pair.nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) +\n                (options.highlightActive && isActive\n                    ? ' ' + colorProvider.activeClassName\n                    : '');\n            const start = pair.openingBracketRange.getStartPosition();\n            const end = pair.closingBracketRange.getStartPosition();\n            const horizontalGuides = options.horizontalGuides === HorizontalGuidesState.Enabled || (options.horizontalGuides === HorizontalGuidesState.EnabledForActive && isActive);\n            if (pair.range.startLineNumber === pair.range.endLineNumber) {\n                if (includeSingleLinePairs && horizontalGuides) {\n                    result[pair.range.startLineNumber - startLineNumber].push(new IndentGuide(-1, pair.openingBracketRange.getEndPosition().column, className, new IndentGuideHorizontalLine(false, end.column), -1, -1));\n                }\n                continue;\n            }\n            const endVisibleColumn = this.getVisibleColumnFromPosition(end);\n            const startVisibleColumn = this.getVisibleColumnFromPosition(pair.openingBracketRange.getStartPosition());\n            const guideVisibleColumn = Math.min(startVisibleColumn, endVisibleColumn, pair.minVisibleColumnIndentation + 1);\n            let renderHorizontalEndLineAtTheBottom = false;\n            const firstNonWsIndex = strings.firstNonWhitespaceIndex(this.textModel.getLineContent(pair.closingBracketRange.startLineNumber));\n            const hasTextBeforeClosingBracket = firstNonWsIndex < pair.closingBracketRange.startColumn - 1;\n            if (hasTextBeforeClosingBracket) {\n                renderHorizontalEndLineAtTheBottom = true;\n            }\n            const visibleGuideStartLineNumber = Math.max(start.lineNumber, startLineNumber);\n            const visibleGuideEndLineNumber = Math.min(end.lineNumber, endLineNumber);\n            const offset = renderHorizontalEndLineAtTheBottom ? 1 : 0;\n            for (let l = visibleGuideStartLineNumber; l < visibleGuideEndLineNumber + offset; l++) {\n                result[l - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, null, l === start.lineNumber ? start.column : -1, l === end.lineNumber ? end.column : -1));\n            }\n            if (horizontalGuides) {\n                if (start.lineNumber >= startLineNumber && startVisibleColumn > guideVisibleColumn) {\n                    result[start.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(false, start.column), -1, -1));\n                }\n                if (end.lineNumber <= endLineNumber && endVisibleColumn > guideVisibleColumn) {\n                    result[end.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(!renderHorizontalEndLineAtTheBottom, end.column), -1, -1));\n                }\n            }\n        }\n        for (const guides of result) {\n            guides.sort((a, b) => a.visibleColumn - b.visibleColumn);\n        }\n        return result;\n    }\n    getVisibleColumnFromPosition(position) {\n        return (CursorColumns.visibleColumnFromColumn(this.textModel.getLineContent(position.lineNumber), position.column, this.textModel.getOptions().tabSize) + 1);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (startLineNumber < 1 || startLineNumber > lineCount) {\n            throw new Error('Illegal value for startLineNumber');\n        }\n        if (endLineNumber < 1 || endLineNumber > lineCount) {\n            throw new Error('Illegal value for endLineNumber');\n        }\n        const options = this.textModel.getOptions();\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        const result = new Array(endLineNumber - startLineNumber + 1);\n        let aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let aboveContentLineIndent = -1;\n        let belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let belowContentLineIndent = -1;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const resultIndex = lineNumber - startLineNumber;\n            const currentIndent = this._computeIndentLevel(lineNumber - 1);\n            if (currentIndent >= 0) {\n                // This line has content (besides whitespace)\n                // Use the line's indent\n                aboveContentLineIndex = lineNumber - 1;\n                aboveContentLineIndent = currentIndent;\n                result[resultIndex] = Math.ceil(currentIndent / options.indentSize);\n                continue;\n            }\n            if (aboveContentLineIndex === -2) {\n                aboveContentLineIndex = -1;\n                aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        aboveContentLineIndex = lineIndex;\n                        aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (belowContentLineIndex !== -1 &&\n                (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\n                belowContentLineIndex = -1;\n                belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        belowContentLineIndex = lineIndex;\n                        belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\n        }\n        return result;\n    }\n    _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {\n        const options = this.textModel.getOptions();\n        if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n            // At the top or bottom of the file\n            return 0;\n        }\n        else if (aboveContentLineIndent < belowContentLineIndent) {\n            // we are inside the region above\n            return 1 + Math.floor(aboveContentLineIndent / options.indentSize);\n        }\n        else if (aboveContentLineIndent === belowContentLineIndent) {\n            // we are in between two regions\n            return Math.ceil(belowContentLineIndent / options.indentSize);\n        }\n        else {\n            if (offSide) {\n                // same level as region below\n                return Math.ceil(belowContentLineIndent / options.indentSize);\n            }\n            else {\n                // we are inside the region that ends below\n                return 1 + Math.floor(belowContentLineIndent / options.indentSize);\n            }\n        }\n    }\n}\nexport class BracketPairGuidesClassNames {\n    constructor() {\n        this.activeClassName = 'indent-active';\n    }\n    getInlineClassName(nestingLevel, nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) {\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? nestingLevelOfEqualBracketType : nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-indent-guide lvl-${level % 30}`;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass SpacesDiffResult {\n    constructor() {\n        this.spacesDiff = 0;\n        this.looksLikeAlignment = false;\n    }\n}\n/**\n * Compute the diff in spaces between two line's indentation.\n */\nfunction spacesDiff(a, aLength, b, bLength, result) {\n    result.spacesDiff = 0;\n    result.looksLikeAlignment = false;\n    // This can go both ways (e.g.):\n    //  - a: \"\\t\"\n    //  - b: \"\\t    \"\n    //  => This should count 1 tab and 4 spaces\n    let i;\n    for (i = 0; i < aLength && i < bLength; i++) {\n        const aCharCode = a.charCodeAt(i);\n        const bCharCode = b.charCodeAt(i);\n        if (aCharCode !== bCharCode) {\n            break;\n        }\n    }\n    let aSpacesCnt = 0, aTabsCount = 0;\n    for (let j = i; j < aLength; j++) {\n        const aCharCode = a.charCodeAt(j);\n        if (aCharCode === 32 /* CharCode.Space */) {\n            aSpacesCnt++;\n        }\n        else {\n            aTabsCount++;\n        }\n    }\n    let bSpacesCnt = 0, bTabsCount = 0;\n    for (let j = i; j < bLength; j++) {\n        const bCharCode = b.charCodeAt(j);\n        if (bCharCode === 32 /* CharCode.Space */) {\n            bSpacesCnt++;\n        }\n        else {\n            bTabsCount++;\n        }\n    }\n    if (aSpacesCnt > 0 && aTabsCount > 0) {\n        return;\n    }\n    if (bSpacesCnt > 0 && bTabsCount > 0) {\n        return;\n    }\n    const tabsDiff = Math.abs(aTabsCount - bTabsCount);\n    const spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);\n    if (tabsDiff === 0) {\n        // check if the indentation difference might be caused by alignment reasons\n        // sometime folks like to align their code, but this should not be used as a hint\n        result.spacesDiff = spacesDiff;\n        if (spacesDiff > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {\n            if (b.charCodeAt(bSpacesCnt) !== 32 /* CharCode.Space */ && a.charCodeAt(bSpacesCnt - 1) === 32 /* CharCode.Space */) {\n                if (a.charCodeAt(a.length - 1) === 44 /* CharCode.Comma */) {\n                    // This looks like an alignment desire: e.g.\n                    // const a = b + c,\n                    //       d = b - c;\n                    result.looksLikeAlignment = true;\n                }\n            }\n        }\n        return;\n    }\n    if (spacesDiff % tabsDiff === 0) {\n        result.spacesDiff = spacesDiff / tabsDiff;\n        return;\n    }\n}\nexport function guessIndentation(source, defaultTabSize, defaultInsertSpaces) {\n    // Look at most at the first 10k lines\n    const linesCount = Math.min(source.getLineCount(), 10000);\n    let linesIndentedWithTabsCount = 0; // number of lines that contain at least one tab in indentation\n    let linesIndentedWithSpacesCount = 0; // number of lines that contain only spaces in indentation\n    let previousLineText = ''; // content of latest line that contained non-whitespace chars\n    let previousLineIndentation = 0; // index at which latest line contained the first non-whitespace char\n    const ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7]; // prefer even guesses for `tabSize`, limit to [2, 8].\n    const MAX_ALLOWED_TAB_SIZE_GUESS = 8; // max(ALLOWED_TAB_SIZE_GUESSES) = 8\n    const spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // `tabSize` scores\n    const tmp = new SpacesDiffResult();\n    for (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {\n        const currentLineLength = source.getLineLength(lineNumber);\n        const currentLineText = source.getLineContent(lineNumber);\n        // if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.\n        // checking charCode on chunks directly is cheaper.\n        const useCurrentLineText = (currentLineLength <= 65536);\n        let currentLineHasContent = false; // does `currentLineText` contain non-whitespace chars\n        let currentLineIndentation = 0; // index at which `currentLineText` contains the first non-whitespace char\n        let currentLineSpacesCount = 0; // count of spaces found in `currentLineText` indentation\n        let currentLineTabsCount = 0; // count of tabs found in `currentLineText` indentation\n        for (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {\n            const charCode = (useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j));\n            if (charCode === 9 /* CharCode.Tab */) {\n                currentLineTabsCount++;\n            }\n            else if (charCode === 32 /* CharCode.Space */) {\n                currentLineSpacesCount++;\n            }\n            else {\n                // Hit non whitespace character on this line\n                currentLineHasContent = true;\n                currentLineIndentation = j;\n                break;\n            }\n        }\n        // Ignore empty or only whitespace lines\n        if (!currentLineHasContent) {\n            continue;\n        }\n        if (currentLineTabsCount > 0) {\n            linesIndentedWithTabsCount++;\n        }\n        else if (currentLineSpacesCount > 1) {\n            linesIndentedWithSpacesCount++;\n        }\n        spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);\n        if (tmp.looksLikeAlignment) {\n            // if defaultInsertSpaces === true && the spaces count == tabSize, we may want to count it as valid indentation\n            //\n            // - item1\n            //   - item2\n            //\n            // otherwise skip this line entirely\n            //\n            // const a = 1,\n            //       b = 2;\n            if (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {\n                continue;\n            }\n        }\n        const currentSpacesDiff = tmp.spacesDiff;\n        if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {\n            spacesDiffCount[currentSpacesDiff]++;\n        }\n        previousLineText = currentLineText;\n        previousLineIndentation = currentLineIndentation;\n    }\n    let insertSpaces = defaultInsertSpaces;\n    if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {\n        insertSpaces = (linesIndentedWithTabsCount < linesIndentedWithSpacesCount);\n    }\n    let tabSize = defaultTabSize;\n    // Guess tabSize only if inserting spaces...\n    if (insertSpaces) {\n        let tabSizeScore = (insertSpaces ? 0 : 0.1 * linesCount);\n        // console.log(\"score threshold: \" + tabSizeScore);\n        ALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {\n            const possibleTabSizeScore = spacesDiffCount[possibleTabSize];\n            if (possibleTabSizeScore > tabSizeScore) {\n                tabSizeScore = possibleTabSizeScore;\n                tabSize = possibleTabSize;\n            }\n        });\n        // Let a tabSize of 2 win even if it is not the maximum\n        // (only in case 4 was guessed)\n        if (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {\n            tabSize = 2;\n        }\n    }\n    // console.log('--------------------------');\n    // console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);\n    // console.log('spacesDiffCount: ' + spacesDiffCount);\n    // console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);\n    return {\n        insertSpaces: insertSpaces,\n        tabSize: tabSize\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function getNodeColor(node) {\n    return ((node.metadata & 1 /* Constants.ColorMask */) >>> 0 /* Constants.ColorOffset */);\n}\nfunction setNodeColor(node, color) {\n    node.metadata = ((node.metadata & 254 /* Constants.ColorMaskInverse */) | (color << 0 /* Constants.ColorOffset */));\n}\nfunction getNodeIsVisited(node) {\n    return ((node.metadata & 2 /* Constants.IsVisitedMask */) >>> 1 /* Constants.IsVisitedOffset */) === 1;\n}\nfunction setNodeIsVisited(node, value) {\n    node.metadata = ((node.metadata & 253 /* Constants.IsVisitedMaskInverse */) | ((value ? 1 : 0) << 1 /* Constants.IsVisitedOffset */));\n}\nfunction getNodeIsForValidation(node) {\n    return ((node.metadata & 4 /* Constants.IsForValidationMask */) >>> 2 /* Constants.IsForValidationOffset */) === 1;\n}\nfunction setNodeIsForValidation(node, value) {\n    node.metadata = ((node.metadata & 251 /* Constants.IsForValidationMaskInverse */) | ((value ? 1 : 0) << 2 /* Constants.IsForValidationOffset */));\n}\nfunction getNodeIsInGlyphMargin(node) {\n    return ((node.metadata & 64 /* Constants.IsMarginMask */) >>> 6 /* Constants.IsMarginOffset */) === 1;\n}\nfunction setNodeIsInGlyphMargin(node, value) {\n    node.metadata = ((node.metadata & 191 /* Constants.IsMarginMaskInverse */) | ((value ? 1 : 0) << 6 /* Constants.IsMarginOffset */));\n}\nfunction getNodeStickiness(node) {\n    return ((node.metadata & 24 /* Constants.StickinessMask */) >>> 3 /* Constants.StickinessOffset */);\n}\nfunction _setNodeStickiness(node, stickiness) {\n    node.metadata = ((node.metadata & 231 /* Constants.StickinessMaskInverse */) | (stickiness << 3 /* Constants.StickinessOffset */));\n}\nfunction getCollapseOnReplaceEdit(node) {\n    return ((node.metadata & 32 /* Constants.CollapseOnReplaceEditMask */) >>> 5 /* Constants.CollapseOnReplaceEditOffset */) === 1;\n}\nfunction setCollapseOnReplaceEdit(node, value) {\n    node.metadata = ((node.metadata & 223 /* Constants.CollapseOnReplaceEditMaskInverse */) | ((value ? 1 : 0) << 5 /* Constants.CollapseOnReplaceEditOffset */));\n}\nexport class IntervalNode {\n    constructor(id, start, end) {\n        this.metadata = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n        setNodeColor(this, 1 /* NodeColor.Red */);\n        this.start = start;\n        this.end = end;\n        // FORCE_OVERFLOWING_TEST: this.delta = start;\n        this.delta = 0;\n        this.maxEnd = end;\n        this.id = id;\n        this.ownerId = 0;\n        this.options = null;\n        setNodeIsForValidation(this, false);\n        setNodeIsInGlyphMargin(this, false);\n        _setNodeStickiness(this, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        setCollapseOnReplaceEdit(this, false);\n        this.cachedVersionId = 0;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = null;\n        setNodeIsVisited(this, false);\n    }\n    reset(versionId, start, end, range) {\n        this.start = start;\n        this.end = end;\n        this.maxEnd = end;\n        this.cachedVersionId = versionId;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = range;\n    }\n    setOptions(options) {\n        this.options = options;\n        const className = this.options.className;\n        setNodeIsForValidation(this, (className === \"squiggly-error\" /* ClassName.EditorErrorDecoration */\n            || className === \"squiggly-warning\" /* ClassName.EditorWarningDecoration */\n            || className === \"squiggly-info\" /* ClassName.EditorInfoDecoration */));\n        setNodeIsInGlyphMargin(this, this.options.glyphMarginClassName !== null);\n        _setNodeStickiness(this, this.options.stickiness);\n        setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n    }\n    setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {\n        if (this.cachedVersionId !== cachedVersionId) {\n            this.range = null;\n        }\n        this.cachedVersionId = cachedVersionId;\n        this.cachedAbsoluteStart = absoluteStart;\n        this.cachedAbsoluteEnd = absoluteEnd;\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new IntervalNode(null, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, 0 /* NodeColor.Black */);\nexport class IntervalTree {\n    constructor() {\n        this.root = SENTINEL;\n        this.requestNormalizeDelta = false;\n    }\n    intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    }\n    search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return search(this, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesFromOwner(ownerId) {\n        return collectNodesFromOwner(this, ownerId);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesPostOrder() {\n        return collectNodesPostOrder(this);\n    }\n    insert(node) {\n        rbTreeInsert(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    delete(node) {\n        rbTreeDelete(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    resolveNode(node, cachedVersionId) {\n        const initialNode = node;\n        let delta = 0;\n        while (node !== this.root) {\n            if (node === node.parent.right) {\n                delta += node.parent.delta;\n            }\n            node = node.parent;\n        }\n        const nodeStart = initialNode.start + delta;\n        const nodeEnd = initialNode.end + delta;\n        initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n        // (1) collect all nodes that are intersecting this edit as nodes of interest\n        const nodesOfInterest = searchForEditing(this, offset, offset + length);\n        // (2) remove all nodes that are intersecting this edit\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            rbTreeDelete(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n        // (3) edit all tree nodes except the nodes of interest\n        noOverlapReplace(this, offset, offset + length, textLength);\n        this._normalizeDeltaIfNecessary();\n        // (4) edit the nodes of interest and insert them back in the tree\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            node.start = node.cachedAbsoluteStart;\n            node.end = node.cachedAbsoluteEnd;\n            nodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\n            node.maxEnd = node.end;\n            rbTreeInsert(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n    }\n    _normalizeDeltaIfNecessary() {\n        if (!this.requestNormalizeDelta) {\n            return;\n        }\n        this.requestNormalizeDelta = false;\n        normalizeDelta(this);\n    }\n}\n//#region Delta Normalization\nfunction normalizeDelta(T) {\n    let node = T.root;\n    let delta = 0;\n    while (node !== SENTINEL) {\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        node.start = delta + node.start;\n        node.end = delta + node.end;\n        node.delta = 0;\n        recomputeMaxEnd(node);\n        setNodeIsVisited(node, true);\n        // going up from this node\n        setNodeIsVisited(node.left, false);\n        setNodeIsVisited(node.right, false);\n        if (node === node.parent.right) {\n            delta -= node.parent.delta;\n        }\n        node = node.parent;\n    }\n    setNodeIsVisited(T.root, false);\n}\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n    if (markerOffset < checkOffset) {\n        return true;\n    }\n    if (markerOffset > checkOffset) {\n        return false;\n    }\n    if (moveSemantics === 1 /* MarkerMoveSemantics.ForceMove */) {\n        return false;\n    }\n    if (moveSemantics === 2 /* MarkerMoveSemantics.ForceStay */) {\n        return true;\n    }\n    return markerStickToPreviousCharacter;\n}\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n    const nodeStickiness = getNodeStickiness(node);\n    const startStickToPreviousCharacter = (nodeStickiness === 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const endStickToPreviousCharacter = (nodeStickiness === 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const deletingCnt = (end - start);\n    const insertingCnt = textLength;\n    const commonLength = Math.min(deletingCnt, insertingCnt);\n    const nodeStart = node.start;\n    let startDone = false;\n    const nodeEnd = node.end;\n    let endDone = false;\n    if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n        // This edit encompasses the entire decoration range\n        // and the decoration has asked to become collapsed\n        node.start = start;\n        startDone = true;\n        node.end = start;\n        endDone = true;\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : (deletingCnt > 0 ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    if (commonLength > 0 && !forceMoveMarkers) {\n        const moveSemantics = (deletingCnt > insertingCnt ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : 0 /* MarkerMoveSemantics.MarkerDefined */;\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n            node.start = start + insertingCnt;\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n            node.end = start + insertingCnt;\n            endDone = true;\n        }\n    }\n    // Finish\n    const deltaColumn = (insertingCnt - deletingCnt);\n    if (!startDone) {\n        node.start = Math.max(0, nodeStart + deltaColumn);\n    }\n    if (!endDone) {\n        node.end = Math.max(0, nodeEnd + deltaColumn);\n    }\n    if (node.start > node.end) {\n        node.end = node.start;\n    }\n}\nfunction searchForEditing(T, start, end) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= start) {\n            node.setCachedOffsets(nodeStart, nodeEnd, 0);\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction noOverlapReplace(T, start, end, textLength) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    const editDelta = (textLength - (end - start));\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            recomputeMaxEnd(node);\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            node.start += editDelta;\n            node.end += editDelta;\n            node.delta += editDelta;\n            if (node.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || node.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n                T.requestNormalizeDelta = true;\n            }\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n}\n//#endregion\n//#region Searching\nfunction collectNodesFromOwner(T, ownerId) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        if (node.ownerId === ownerId) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction collectNodesPostOrder(T) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        result[resultLen++] = node;\n        setNodeIsVisited(node, true);\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    let node = T.root;\n    let delta = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        nodeEnd = delta + node.end;\n        node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n        let include = true;\n        if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n            include = false;\n        }\n        if (filterOutValidation && getNodeIsForValidation(node)) {\n            include = false;\n        }\n        if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n            include = false;\n        }\n        if (include) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < intervalStart) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > intervalEnd) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= intervalStart) {\n            // There is overlap\n            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n            let include = true;\n            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n                include = false;\n            }\n            if (filterOutValidation && getNodeIsForValidation(node)) {\n                include = false;\n            }\n            if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n                include = false;\n            }\n            if (include) {\n                result[resultLen++] = node;\n            }\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\n//#endregion\n//#region Insertion\nfunction rbTreeInsert(T, newNode) {\n    if (T.root === SENTINEL) {\n        newNode.parent = SENTINEL;\n        newNode.left = SENTINEL;\n        newNode.right = SENTINEL;\n        setNodeColor(newNode, 0 /* NodeColor.Black */);\n        T.root = newNode;\n        return T.root;\n    }\n    treeInsert(T, newNode);\n    recomputeMaxEndWalkToRoot(newNode.parent);\n    // repair tree\n    let x = newNode;\n    while (x !== T.root && getNodeColor(x.parent) === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent.parent);\n            }\n        }\n    }\n    setNodeColor(T.root, 0 /* NodeColor.Black */);\n    return newNode;\n}\nfunction treeInsert(T, z) {\n    let delta = 0;\n    let x = T.root;\n    const zAbsoluteStart = z.start;\n    const zAbsoluteEnd = z.end;\n    while (true) {\n        const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n        if (cmp < 0) {\n            // this node should be inserted to the left\n            // => it is not affected by the node's delta\n            if (x.left === SENTINEL) {\n                z.start -= delta;\n                z.end -= delta;\n                z.maxEnd -= delta;\n                x.left = z;\n                break;\n            }\n            else {\n                x = x.left;\n            }\n        }\n        else {\n            // this node should be inserted to the right\n            // => it is not affected by the node's delta\n            if (x.right === SENTINEL) {\n                z.start -= (delta + x.delta);\n                z.end -= (delta + x.delta);\n                z.maxEnd -= (delta + x.delta);\n                x.right = z;\n                break;\n            }\n            else {\n                delta += x.delta;\n                x = x.right;\n            }\n        }\n    }\n    z.parent = x;\n    z.left = SENTINEL;\n    z.right = SENTINEL;\n    setNodeColor(z, 1 /* NodeColor.Red */);\n}\n//#endregion\n//#region Deletion\nfunction rbTreeDelete(T, z) {\n    let x;\n    let y;\n    // RB-DELETE except we don't swap z and y in case c)\n    // i.e. we always delete what's pointed at by z.\n    if (z.left === SENTINEL) {\n        x = z.right;\n        y = z;\n        // x's delta is no longer influenced by z's delta\n        x.delta += z.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        x.start += z.delta;\n        x.end += z.delta;\n    }\n    else if (z.right === SENTINEL) {\n        x = z.left;\n        y = z;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n        // y's delta is no longer influenced by z's delta,\n        // but we don't want to walk the entire right-hand-side subtree of x.\n        // we therefore maintain z's delta in y, and adjust only x\n        x.start += y.delta;\n        x.end += y.delta;\n        x.delta += y.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        y.start += z.delta;\n        y.end += z.delta;\n        y.delta = z.delta;\n        if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n    }\n    if (y === T.root) {\n        T.root = x;\n        setNodeColor(x, 0 /* NodeColor.Black */);\n        z.detach();\n        resetSentinel();\n        recomputeMaxEnd(x);\n        T.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (getNodeColor(y) === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        setNodeColor(y, getNodeColor(z));\n        if (z === T.root) {\n            T.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n    }\n    z.detach();\n    if (yWasRed) {\n        recomputeMaxEndWalkToRoot(x.parent);\n        if (y !== z) {\n            recomputeMaxEndWalkToRoot(y);\n            recomputeMaxEndWalkToRoot(y.parent);\n        }\n        resetSentinel();\n        return;\n    }\n    recomputeMaxEndWalkToRoot(x);\n    recomputeMaxEndWalkToRoot(x.parent);\n    if (y !== z) {\n        recomputeMaxEndWalkToRoot(y);\n        recomputeMaxEndWalkToRoot(y.parent);\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== T.root && getNodeColor(x) === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent);\n                w = x.parent.right;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.left, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    rightRotate(T, w);\n                    w = x.parent.right;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.right, 0 /* NodeColor.Black */);\n                leftRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent);\n                w = x.parent.left;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.left) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.right, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    leftRotate(T, w);\n                    w = x.parent.left;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.left, 0 /* NodeColor.Black */);\n                rightRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n    }\n    setNodeColor(x, 0 /* NodeColor.Black */);\n    resetSentinel();\n}\nfunction leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n    SENTINEL.delta = 0; // optional\n    SENTINEL.start = 0; // optional\n    SENTINEL.end = 0; // optional\n}\n//#endregion\n//#region Rotations\nfunction leftRotate(T, x) {\n    const y = x.right; // set y.\n    y.delta += x.delta; // y's delta is no longer influenced by x's delta\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start += x.delta;\n    y.end += x.delta;\n    x.right = y.left; // turn y's left subtree into x's right subtree.\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent; // link x's parent to y.\n    if (x.parent === SENTINEL) {\n        T.root = y;\n    }\n    else if (x === x.parent.left) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x; // put x on y's left.\n    x.parent = y;\n    recomputeMaxEnd(x);\n    recomputeMaxEnd(y);\n}\nfunction rightRotate(T, y) {\n    const x = y.left;\n    y.delta -= x.delta;\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start -= x.delta;\n    y.end -= x.delta;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    if (y.parent === SENTINEL) {\n        T.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n    recomputeMaxEnd(y);\n    recomputeMaxEnd(x);\n}\n//#endregion\n//#region max end computation\nfunction computeMaxEnd(node) {\n    let maxEnd = node.end;\n    if (node.left !== SENTINEL) {\n        const leftMaxEnd = node.left.maxEnd;\n        if (leftMaxEnd > maxEnd) {\n            maxEnd = leftMaxEnd;\n        }\n    }\n    if (node.right !== SENTINEL) {\n        const rightMaxEnd = node.right.maxEnd + node.delta;\n        if (rightMaxEnd > maxEnd) {\n            maxEnd = rightMaxEnd;\n        }\n    }\n    return maxEnd;\n}\nexport function recomputeMaxEnd(node) {\n    node.maxEnd = computeMaxEnd(node);\n}\nfunction recomputeMaxEndWalkToRoot(node) {\n    while (node !== SENTINEL) {\n        const maxEnd = computeMaxEnd(node);\n        if (node.maxEnd === maxEnd) {\n            // no need to go further\n            return;\n        }\n        node.maxEnd = maxEnd;\n        node = node.parent;\n    }\n}\n//#endregion\n//#region utils\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\n    if (aStart === bStart) {\n        return aEnd - bEnd;\n    }\n    return aStart - bStart;\n}\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertNever } from '../../base/common/assert.js';\nimport { Position } from './core/position.js';\nimport { InjectedTextCursorStops } from './model.js';\n/**\n * *input*:\n * ```\n * xxxxxxxxxxxxxxxxxxxxxxxxxxx\n * ```\n *\n * -> Applying injections `[i...i]`, *inputWithInjections*:\n * ```\n * xxxxxx[iiiiiiiiii]xxxxxxxxxxxxxxxxx[ii]xxxx\n * ```\n *\n * -> breaking at offsets `|` in `xxxxxx[iiiiiii|iii]xxxxxxxxxxx|xxxxxx[ii]xxxx|`:\n * ```\n * xxxxxx[iiiiiii\n * iii]xxxxxxxxxxx\n * xxxxxx[ii]xxxx\n * ```\n *\n * -> applying wrappedTextIndentLength, *output*:\n * ```\n * xxxxxx[iiiiiii\n *    iii]xxxxxxxxxxx\n *    xxxxxx[ii]xxxx\n * ```\n */\nexport class ModelLineProjectionData {\n    constructor(injectionOffsets, \n    /**\n     * `injectionOptions.length` must equal `injectionOffsets.length`\n     */\n    injectionOptions, \n    /**\n     * Refers to offsets after applying injections to the source.\n     * The last break offset indicates the length of the source after applying injections.\n     */\n    breakOffsets, \n    /**\n     * Refers to offsets after applying injections\n     */\n    breakOffsetsVisibleColumn, wrappedTextIndentLength) {\n        this.injectionOffsets = injectionOffsets;\n        this.injectionOptions = injectionOptions;\n        this.breakOffsets = breakOffsets;\n        this.breakOffsetsVisibleColumn = breakOffsetsVisibleColumn;\n        this.wrappedTextIndentLength = wrappedTextIndentLength;\n    }\n    getOutputLineCount() {\n        return this.breakOffsets.length;\n    }\n    getMinOutputOffset(outputLineIndex) {\n        if (outputLineIndex > 0) {\n            return this.wrappedTextIndentLength;\n        }\n        return 0;\n    }\n    getLineLength(outputLineIndex) {\n        // These offsets refer to model text with injected text.\n        const startOffset = outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0;\n        const endOffset = this.breakOffsets[outputLineIndex];\n        let lineLength = endOffset - startOffset;\n        if (outputLineIndex > 0) {\n            lineLength += this.wrappedTextIndentLength;\n        }\n        return lineLength;\n    }\n    getMaxOutputOffset(outputLineIndex) {\n        return this.getLineLength(outputLineIndex);\n    }\n    translateToInputOffset(outputLineIndex, outputOffset) {\n        if (outputLineIndex > 0) {\n            outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n        }\n        const offsetInInputWithInjection = outputLineIndex === 0 ? outputOffset : this.breakOffsets[outputLineIndex - 1] + outputOffset;\n        let offsetInInput = offsetInInputWithInjection;\n        if (this.injectionOffsets !== null) {\n            for (let i = 0; i < this.injectionOffsets.length; i++) {\n                if (offsetInInput > this.injectionOffsets[i]) {\n                    if (offsetInInput < this.injectionOffsets[i] + this.injectionOptions[i].content.length) {\n                        // `inputOffset` is within injected text\n                        offsetInInput = this.injectionOffsets[i];\n                    }\n                    else {\n                        offsetInInput -= this.injectionOptions[i].content.length;\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        return offsetInInput;\n    }\n    translateToOutputPosition(inputOffset, affinity = 2 /* PositionAffinity.None */) {\n        let inputOffsetInInputWithInjection = inputOffset;\n        if (this.injectionOffsets !== null) {\n            for (let i = 0; i < this.injectionOffsets.length; i++) {\n                if (inputOffset < this.injectionOffsets[i]) {\n                    break;\n                }\n                if (affinity !== 1 /* PositionAffinity.Right */ && inputOffset === this.injectionOffsets[i]) {\n                    break;\n                }\n                inputOffsetInInputWithInjection += this.injectionOptions[i].content.length;\n            }\n        }\n        return this.offsetInInputWithInjectionsToOutputPosition(inputOffsetInInputWithInjection, affinity);\n    }\n    offsetInInputWithInjectionsToOutputPosition(offsetInInputWithInjections, affinity = 2 /* PositionAffinity.None */) {\n        let low = 0;\n        let high = this.breakOffsets.length - 1;\n        let mid = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            const midStop = this.breakOffsets[mid];\n            midStart = mid > 0 ? this.breakOffsets[mid - 1] : 0;\n            if (affinity === 0 /* PositionAffinity.Left */) {\n                if (offsetInInputWithInjections <= midStart) {\n                    high = mid - 1;\n                }\n                else if (offsetInInputWithInjections > midStop) {\n                    low = mid + 1;\n                }\n                else {\n                    break;\n                }\n            }\n            else {\n                if (offsetInInputWithInjections < midStart) {\n                    high = mid - 1;\n                }\n                else if (offsetInInputWithInjections >= midStop) {\n                    low = mid + 1;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        let outputOffset = offsetInInputWithInjections - midStart;\n        if (mid > 0) {\n            outputOffset += this.wrappedTextIndentLength;\n        }\n        return new OutputPosition(mid, outputOffset);\n    }\n    normalizeOutputPosition(outputLineIndex, outputOffset, affinity) {\n        if (this.injectionOffsets !== null) {\n            const offsetInInputWithInjections = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n            const normalizedOffsetInUnwrappedLine = this.normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity);\n            if (normalizedOffsetInUnwrappedLine !== offsetInInputWithInjections) {\n                // injected text caused a change\n                return this.offsetInInputWithInjectionsToOutputPosition(normalizedOffsetInUnwrappedLine, affinity);\n            }\n        }\n        if (affinity === 0 /* PositionAffinity.Left */) {\n            if (outputLineIndex > 0 && outputOffset === this.getMinOutputOffset(outputLineIndex)) {\n                return new OutputPosition(outputLineIndex - 1, this.getMaxOutputOffset(outputLineIndex - 1));\n            }\n        }\n        else if (affinity === 1 /* PositionAffinity.Right */) {\n            const maxOutputLineIndex = this.getOutputLineCount() - 1;\n            if (outputLineIndex < maxOutputLineIndex && outputOffset === this.getMaxOutputOffset(outputLineIndex)) {\n                return new OutputPosition(outputLineIndex + 1, this.getMinOutputOffset(outputLineIndex + 1));\n            }\n        }\n        return new OutputPosition(outputLineIndex, outputOffset);\n    }\n    outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset) {\n        if (outputLineIndex > 0) {\n            outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n        }\n        const result = (outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0) + outputOffset;\n        return result;\n    }\n    normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity) {\n        const injectedText = this.getInjectedTextAtOffset(offsetInInputWithInjections);\n        if (!injectedText) {\n            return offsetInInputWithInjections;\n        }\n        if (affinity === 2 /* PositionAffinity.None */) {\n            if (offsetInInputWithInjections === injectedText.offsetInInputWithInjections + injectedText.length\n                && hasRightCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {\n                return injectedText.offsetInInputWithInjections + injectedText.length;\n            }\n            else {\n                let result = injectedText.offsetInInputWithInjections;\n                if (hasLeftCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {\n                    return result;\n                }\n                let index = injectedText.injectedTextIndex - 1;\n                while (index >= 0 && this.injectionOffsets[index] === this.injectionOffsets[injectedText.injectedTextIndex]) {\n                    if (hasRightCursorStop(this.injectionOptions[index].cursorStops)) {\n                        break;\n                    }\n                    result -= this.injectionOptions[index].content.length;\n                    if (hasLeftCursorStop(this.injectionOptions[index].cursorStops)) {\n                        break;\n                    }\n                    index--;\n                }\n                return result;\n            }\n        }\n        else if (affinity === 1 /* PositionAffinity.Right */ || affinity === 4 /* PositionAffinity.RightOfInjectedText */) {\n            let result = injectedText.offsetInInputWithInjections + injectedText.length;\n            let index = injectedText.injectedTextIndex;\n            // traverse all injected text that touch each other\n            while (index + 1 < this.injectionOffsets.length && this.injectionOffsets[index + 1] === this.injectionOffsets[index]) {\n                result += this.injectionOptions[index + 1].content.length;\n                index++;\n            }\n            return result;\n        }\n        else if (affinity === 0 /* PositionAffinity.Left */ || affinity === 3 /* PositionAffinity.LeftOfInjectedText */) {\n            // affinity is left\n            let result = injectedText.offsetInInputWithInjections;\n            let index = injectedText.injectedTextIndex;\n            // traverse all injected text that touch each other\n            while (index - 1 >= 0 && this.injectionOffsets[index - 1] === this.injectionOffsets[index]) {\n                result -= this.injectionOptions[index - 1].content.length;\n                index--;\n            }\n            return result;\n        }\n        assertNever(affinity);\n    }\n    getInjectedText(outputLineIndex, outputOffset) {\n        const offset = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n        const injectedText = this.getInjectedTextAtOffset(offset);\n        if (!injectedText) {\n            return null;\n        }\n        return {\n            options: this.injectionOptions[injectedText.injectedTextIndex]\n        };\n    }\n    getInjectedTextAtOffset(offsetInInputWithInjections) {\n        const injectionOffsets = this.injectionOffsets;\n        const injectionOptions = this.injectionOptions;\n        if (injectionOffsets !== null) {\n            let totalInjectedTextLengthBefore = 0;\n            for (let i = 0; i < injectionOffsets.length; i++) {\n                const length = injectionOptions[i].content.length;\n                const injectedTextStartOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore;\n                const injectedTextEndOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore + length;\n                if (injectedTextStartOffsetInInputWithInjections > offsetInInputWithInjections) {\n                    // Injected text starts later.\n                    break; // All later injected texts have an even larger offset.\n                }\n                if (offsetInInputWithInjections <= injectedTextEndOffsetInInputWithInjections) {\n                    // Injected text ends after or with the given position (but also starts with or before it).\n                    return {\n                        injectedTextIndex: i,\n                        offsetInInputWithInjections: injectedTextStartOffsetInInputWithInjections,\n                        length\n                    };\n                }\n                totalInjectedTextLengthBefore += length;\n            }\n        }\n        return undefined;\n    }\n}\nfunction hasRightCursorStop(cursorStop) {\n    if (cursorStop === null || cursorStop === undefined) {\n        return true;\n    }\n    return cursorStop === InjectedTextCursorStops.Right || cursorStop === InjectedTextCursorStops.Both;\n}\nfunction hasLeftCursorStop(cursorStop) {\n    if (cursorStop === null || cursorStop === undefined) {\n        return true;\n    }\n    return cursorStop === InjectedTextCursorStops.Left || cursorStop === InjectedTextCursorStops.Both;\n}\nexport class InjectedText {\n    constructor(options) {\n        this.options = options;\n    }\n}\nexport class OutputPosition {\n    constructor(outputLineIndex, outputOffset) {\n        this.outputLineIndex = outputLineIndex;\n        this.outputOffset = outputOffset;\n    }\n    toString() {\n        return `${this.outputLineIndex}:${this.outputOffset}`;\n    }\n    toPosition(baseLineNumber) {\n        return new Position(baseLineNumber + this.outputLineIndex, this.outputOffset + 1);\n    }\n}\n"],"names":["LinesDiff","constructor","changes","hitTimeout","this","LineRangeMapping","inverse","mapping","originalLineCount","modifiedLineCount","result","lastOriginalEndLineNumber","lastModifiedEndLineNumber","m","r","LineRange","originalRange","startLineNumber","modifiedRange","undefined","isEmpty","push","endLineNumberExclusive","innerChanges","toString","concat","changedLineCount","Math","max","length","RangeMapping","computeDiff","originalSequence","modifiedSequence","continueProcessingPredicate","pretty","LcsDiff","ComputeDiff","LineSequence","lines","startColumns","endColumns","i","getFirstNonBlankColumn","getLastNonBlankColumn","_startColumns","_endColumns","getElements","elements","len","substring","getStrictElement","index","getStartLineNumber","getEndLineNumber","createCharSequence","shouldIgnoreTrimWhitespace","startIndex","endIndex","charCodes","lineNumbers","columns","lineContent","startColumn","endColumn","col","charCodeAt","CharSequence","_charCodes","_lineNumbers","_columns","map","s","idx","String","fromCharCode","join","_assertIndex","arr","Error","getStartColumn","getEndColumn","CharChange","originalStartLineNumber","originalStartColumn","originalEndLineNumber","originalEndColumn","modifiedStartLineNumber","modifiedStartColumn","modifiedEndLineNumber","modifiedEndColumn","createFromDiffChange","diffChange","originalCharSequence","modifiedCharSequence","originalStart","originalLength","modifiedStart","modifiedLength","LineChange","charChanges","createFromDiffResult","originalLineSequence","modifiedLineSequence","continueCharDiff","shouldComputeCharChanges","shouldPostProcessCharChanges","rawChanges","prevChange","currChange","originalMatchingLength","modifiedMatchingLength","min","postProcessCharChanges","DiffComputer","originalLines","modifiedLines","opts","shouldMakePrettyDiff","original","modified","continueLineDiff","createContinueProcessingPredicate","maxComputationTime","quitEarly","diffResult","lineChanges","originalLineIndex","modifiedLineIndex","nextChange","originalStop","modifiedStop","originalLine","modifiedLine","_pushTrimWhitespaceCharChange","originalMaxColumn","modifiedMaxColumn","originalLineNumber","modifiedLineNumber","_mergeTrimWhitespaceCharChange","txt","defaultValue","strings","maximumRuntime","startTime","Date","now","DiffAlgorithmResult","trivial","seq1","seq2","SequenceDiff","OffsetRange","trivialTimedOut","diffs","seq1Range","seq2Range","reverse","other","InfiniteTimeout","isValid","instance","DateTimeout","timeout","valid","BugIndicatingError","Array2D","width","height","array","Array","get","x","y","set","value","DynamicProgrammingDiffing","compute","sequence1","sequence2","arguments","equalityScore","lcsLengths","directions","lengths","s1","s2","horizontalLen","verticalLen","extendedSeqScore","getElement","newValue","prevLen","lastAligningPosS1","lastAligningPosS2","reportDecreasingAligningPositions","optimizeSequenceDiffs","sequenceDiffs","lastResult","cur","all","start","endExclusive","joinSequenceDiffs","getBoundaryScore","diff","seq2PrevEndExclusive","seq2NextStart","shiftDiffToBetterPosition","seq1PrevEndExclusive","seq1NextStart","shiftSequenceDiffs","deltaBefore","deltaAfter","bestDelta","bestScore","delta","seq2OffsetStart","seq2OffsetEndExclusive","seq1Offset","score","MyersDiffAlgorithm","getXAfterSnake","d","V","FastInt32Array","paths","FastArrayNegativeIndices","SnakePath","k","loop","maxXofDLineTop","maxXofDLineLeft","newMaxX","lastPath","path","endX","endY","prev","positiveArr","Int32Array","negativeArr","trimmedHash","offset","getIndentation","str","Slice","lineRange","considerWhitespaceChanges","firstCharOffsetByLineMinusOne","offsetByLine","trimFirstLineFully","line","trimmedStartLine","trimStart","trimEnd","text","e","prevCategory","getCategory","nextCategory","getCategoryBoundaryScore","translateOffset","Position","j","floor","offsetOfPrevLineBreak","translateRange","range","Range","fromPositions","findWordContaining","isWordChar","end","charCode","category","isSpace","linesDiffComputers","legacy","options","_a","maxComputationTimeMs","ignoreTrimWhitespace","lastChange","c","change","pop","assertFn","checkAdjacentItems","m1","m2","advanced","dynamicProgrammingDiffing","myersDiffingAlgorithm","perfectHashes","Map","getOrCreateHash","hash","size","srcDocLines","l","trim","tgtDocLines","lineAlignmentResult","offset1","offset2","log","lineAlignments","alignments","scanForWhitespaceChanges","equalLinesCount","seq1LastStart","seq2Offset","seq2LastStart","characterDiffs","refineDiff","a","mappings","g","items","shouldBeGrouped","currentGroup","last","item","group","rangeMapping","lineStartDelta","lineEndDelta","endLineNumber","originalLineRange","modifiedLineRange","getLineRangeMapping","a1","a2","overlapOrTouch","first","lineRangeMappingFromRangeMappings","sourceSlice","targetSlice","additional","lastModifiedWord","maybePushWordToAdditional","originalLength1","s1Range","deleted","s2Range","added","count","processWord","_b","_c","_d","containsRange","s1Added","tryCreate","s2Added","changedS1","intersect","changedS2","w1Before","w2Before","w1After","w2After","equals","sequenceDiffs1","sequenceDiffs2","sd1","sd2","next","shift","mergeSequenceDiffs","coverFullWords","smoothenSequenceDiffs","InternalEditorAction","id","label","alias","precondition","run","contextKeyService","_precondition","_run","_contextKeyService","isSupported","contextMatchesRules","args","Promise","resolve","EditorType","ICodeEditor","IDiffEditor","EditorContextKeys","editorSimpleInput","RawContextKey","editorTextFocus","nls","focus","textInputFocus","readOnly","inDiffEditor","isEmbeddedDiffEditor","columnSelection","writable","toNegated","hasNonEmptySelection","hasOnlyEmptySelection","hasMultipleSelections","hasSingleSelection","tabMovesFocus","tabDoesNotMoveFocus","isInWalkThroughSnippet","canUndo","canRedo","hoverVisible","hoverFocused","stickyScrollFocused","stickyScrollVisible","standaloneColorPickerVisible","standaloneColorPickerFocused","inCompositeEditor","notInCompositeEditor","languageId","hasCompletionItemProvider","hasCodeActionsProvider","hasCodeLensProvider","hasDefinitionProvider","hasDeclarationProvider","hasImplementationProvider","hasTypeDefinitionProvider","hasHoverProvider","hasDocumentHighlightProvider","hasDocumentSymbolProvider","hasReferenceProvider","hasRenameProvider","hasSignatureHelpProvider","hasInlayHintsProvider","hasDocumentFormattingProvider","hasDocumentSelectionFormattingProvider","hasMultipleDocumentFormattingProvider","hasMultipleDocumentSelectionFormattingProvider","editorFeatures","registerEditorFeature","ctor","getEditorFeatures","slice","EditorTheme","type","_theme","theme","update","getColor","color","TokenMetadata","getLanguageId","metadata","getTokenType","containsBalancedBrackets","getFontStyle","getForeground","getBackground","getClassNameFromMetadata","className","fontStyle","getInlineStyleFromMetadata","colorMap","foreground","textDecoration","getPresentationFromMetadata","italic","Boolean","bold","underline","strikethrough","selector","candidateUri","candidateLanguage","candidateIsSynchronized","candidateNotebookUri","candidateNotebookType","isArray","ret","filter","language","pattern","scheme","hasAccessToAllModels","notebookType","normalizedPattern","Object","assign","base","normalize","fsPath","matchGlobPattern","isExclusive","every","exclusive","MatchCandidate","uri","notebookUri","LanguageFeatureRegistry","_notebookInfoResolver","_clock","_entries","_onDidChange","Emitter","onDidChange","event","register","provider","entry","_score","_time","_lastCandidate","fire","toDisposable","indexOf","splice","has","model","_updateScores","ordered","_orderedForEach","orderedGroups","lastBucket","lastBucketScore","callback","notebookInfo","call","candidate","shouldSynchronizeModel","sort","_compareByScoreAndTime","b","isBuiltinSelector","some","isBuiltin","CompletionItemKinds","InlineCompletionTriggerKind","SignatureHelpTriggerKind","DocumentHighlightKind","SymbolKinds","Command","InlayHintKind","Token","_tokenBrand","TokenizationResult","tokens","endState","_tokenizationResultBrand","EncodedTokenizationResult","_encodedTokenizationResultBrand","byKind","Codicon","symbolMethod","symbolFunction","symbolConstructor","symbolField","symbolVariable","symbolClass","symbolStruct","symbolInterface","symbolModule","symbolProperty","symbolEvent","symbolOperator","symbolUnit","symbolValue","symbolEnum","symbolConstant","symbolEnumMember","symbolKeyword","symbolSnippet","symbolText","symbolColor","symbolFile","symbolReference","symbolCustomColor","symbolFolder","symbolTypeParameter","account","issues","toIcon","kind","codicon","console","info","data","fromString","strict","res","SelectedSuggestionInfo","completionKind","isSnippetText","lift","equalsRange","isLocationLink","thing","URI","isUri","isIRange","originSelectionRange","targetSelectionRange","symbolNamespace","symbolPackage","symbolString","symbolNumber","symbolBoolean","symbolArray","symbolObject","symbolKey","symbolNull","icon","FoldingRangeKind","fromValue","Comment","Imports","Region","is","obj","title","LazyTokenizationSupport","createSupport","_tokenizationSupport","dispose","then","support","tokenizationSupport","TokenizationRegistry","TokenizationRegistryImpl","getInheritIndentForLine","autoIndent","lineNumber","honorIntentialIndent","indentRulesSupport","getLanguageConfiguration","tokenization","indentation","action","priorLineNumber","getLineContent","precedingUnIgnoredLine","getLanguageIdAtPosition","lastLineNumber","resultLineNumber","shouldIgnore","test","getPrecedingValidLine","precedingUnIgnoredLineContent","shouldIncrease","shouldIndentNextLine","IndentAction","Indent","shouldDecrease","previousLine","previousLineIndentMetadata","getIndentMetadata","stopLine","getGoodIndentForLine","virtualModel","indentConverter","languageConfigurationService","richEditSupport","indent","inheritLine","shouldApplyEnterRules","inBetweenLine","enterResult","onEnter","removeText","indentAction","IndentOutdent","shiftIndent","Outdent","unshiftIndent","appendText","getIndentForEnter","forceTokenization","lineTokens","getLineTokens","scopedLineTokens","createScopedLineTokens","scopedLineText","beforeEnterText","afterEnterText","embeddedLanguage","firstCharOffset","substr","getScopedLineTokens","beforeEnterResult","beforeEnterIndent","column","currentLineIndent","afterEnterAction","beforeEnter","afterEnter","afterEnterIndent","getIndentActionForType","ch","beforeTypeText","afterTypeText","getLineCount","_parseCaptureGroups","captureGroups","values","captureGroup","parsedNumber","Number","replace","_toIColor","red","blue","green","alpha","_findRange","match","startPosition","positionAt","_findHexColorInformation","hexValue","parsedHexColor","Color","Format","CSS","parseHex","rgba","_findRGBColorInformation","matches","isAlpha","parsedRegex","_findHSLColorInformation","colorEquivalent","HSLA","_findMatches","regex","matchAll","findMatches","computeDefaultDocumentColors","getValue","initialValidationMatches","initialMatch","initialCaptureGroups","colorScheme","colorParameters","colorInformation","regexParameters","computeColors","getEnterAction","previousLineText","oneLineAboveScopedLineTokens","getIndentationAtPosition","ILanguageService","createDecorator","StandardAutoClosingPairConditional","source","_neutralCharacter","_neutralCharacterSearched","open","close","_inString","_inComment","_inRegEx","notIn","isOK","standardToken","shouldAutoClose","context","getTokenCount","tokenIndex","findTokenIndexAtOffset","standardTokenType","getStandardTokenType","_findNeutralCharacterInRange","toCharCode","character","includes","findNeutralCharacter","AutoClosingPairs","autoClosingPairs","autoClosingPairsOpenByStart","autoClosingPairsOpenByEnd","autoClosingPairsCloseByStart","autoClosingPairsCloseByEnd","autoClosingPairsCloseSingleChar","pair","appendEntry","charAt","target","key","CharacterPairSupport","config","_autoClosingPairs","el","brackets","__electricCharacterSupport","docComment","_autoCloseBeforeForQuotes","autoCloseBefore","DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES","_autoCloseBeforeForBrackets","DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS","_surroundingPairs","surroundingPairs","getAutoClosingPairs","getAutoCloseBeforeSet","forQuotes","getSurroundingPairs","BracketElectricCharacterSupport","richEditBrackets","_richEditBrackets","getElectricCharacters","bracket","lastChar","distinct","onElectricCharacter","ignoreBracketsInToken","reversedBracketRegex","reversedRegex","BracketsUtils","findPrevBracketInRange","bracketText","toLowerCase","textIsOpenBracket","textBeforeBracket","getActualLineContentBefore","matchOpenBracket","resetGlobalRegex","reg","global","lastIndex","IndentRulesSupport","indentationRules","_indentationRules","increaseIndentPattern","decreaseIndentPattern","indentNextLinePattern","unIndentedLinePattern","OnEnterSupport","_brackets","forEach","openRegExp","_createOpenBracketRegExp","closeRegExp","_createCloseBracketRegExp","_regExpRules","onEnterRules","rule","beforeText","afterText","_safeRegExp","def","RegExp","err","onUnexpectedError","LanguageBracketsConfiguration","bracketPairs","filterValidBrackets","openingBracketInfos","CachedFunction","closing","Set","OpeningBracketKind","closingBracketInfos","opening","openingColorized","ClosingBracketKind","add","colorizedBracketPairs","p","_openingBrackets","cachedValues","_ref","v","_closingBrackets","_ref2","openingBrackets","closingBrackets","getOpeningBracketInfo","getClosingBracketInfo","getBracketInfo","_ref3","BracketKindBase","openedBrackets","super","isOpeningBracket","openingColorizedBrackets","closes","closesColorized","getOpeningBrackets","__decorate","decorators","desc","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__param","paramIndex","decorator","LanguageConfigurationServiceChangeEvent","affects","ILanguageConfigurationService","LanguageConfigurationService","Disposable","configurationService","languageService","_registry","_register","LanguageConfigurationRegistry","onDidChangeEmitter","configurations","languageConfigKeys","customizedLanguageConfigKeys","onDidChangeConfiguration","globalConfigChanged","keys","localConfigChanged","overrides","overrideLangName","clear","isRegisteredLanguageId","delete","configuration","priority","registry","languageConfig","ResolvedLanguageConfiguration","customizedConfig","overrideIdentifier","validateBracketPairs","getCustomizedLanguageConfig","combineLanguageConfigurations","underlyingConfig","computeConfig","IConfigurationService","lineText","columnNumber","getLineMaxColumn","ComposedLanguageConfiguration","_resolved","_order","LanguageConfigurationContribution","getResolvedConfiguration","_resolve","cmp","configs","comments","wordPattern","folding","order","LanguageConfigurationChangeEvent","PLAINTEXT_LANGUAGE_ID","offSide","entries","disposable","_electricCharacter","_onEnterSupport","_handleComments","characterPair","wordDefinition","DEFAULT_WORD_REGEXP","foldingRules","bracketsNew","getWordDefinition","ensureValidWordDefinition","RichEditBrackets","electricCharacter","conf","commentRule","lineComment","lineCommentToken","blockComment","blockStart","blockEnd","blockCommentStartToken","blockCommentEndToken","registerSingleton","Uint8Matrix","rows","cols","Uint8Array","_data","row","StateMachine","edges","maxCharCode","maxState","from","chCode","to","states","_states","_maxCharCode","nextState","currentState","_stateMachine","_classifier","LinkComputer","_createLink","classifier","linkBeginIndex","linkEndIndex","lastIncludedCharIndex","charCodeBeforeLink","lastCharCodeInLink","url","computeLinks","stateMachine","CharacterClassifier","FORCE_TERMINATION_CHARACTERS","CANNOT_END_WITH_CHARACTERS","getClassifier","lineCount","linkBeginChCode","state","hasOpenParens","hasOpenSquareBracket","inSquareBrackets","hasOpenCurlyBracket","resetStateMachine","chClass","ModesRegistry","_onDidChangeLanguages","onDidChangeLanguages","_languages","registerLanguage","getLanguages","Registry","extensions","aliases","mimetypes","Mimes","as","ConfigurationExtensions","Configuration","registerDefaultConfigurations","NullState","clone","nullTokenize","nullTokenizeEncoded","Uint32Array","tokenCount","getCount","desiredLanguageId","lastTokenIndex","firstTokenIndex","ScopedLineTokens","getStartOffset","getEndOffset","actual","lastCharOffset","_scopedLineTokensBrand","_actual","_firstTokenIndex","_lastTokenIndex","_lastCharOffset","BasicInplaceReplace","_defaultValueSet","navigateValueSet","range1","text1","range2","text2","up","doNavigateValueSet","numberResult","numberReplace","textReplace","precision","pow","lastIndexOf","n1","n2","parseFloat","isNaN","valueSetsReplace","valueSets","valueSetReplace","valueSet","INSTANCE","RichEditBracket","forwardRegex","_richEditBracketBrand","_openSet","_toSet","_closeSet","isOpen","isClose","element","_richEditBracketsBrand","N","areOverlapping","aOpen","aClose","bOpen","bClose","mergeGroups","g1","g2","newG","oldG","currentOpen","currentClose","groupFuzzyBrackets","currentIndex","pieces","collectSuperstrings","unique","lengthcmp","createBracketOrRegExp","getRegexForBracketPair","toReversedString","getReversedRegexForBracketPair","getRegexForBrackets","getReversedRegexForBrackets","textIsBracket","maxBracketLength","dest","seen","prepareBracketForRegExp","insertWordBoundaries","regexStr","lastInput","lastOutput","Uint16Array","stringBuilder","decode","_findPrevBracketInText","reversedText","matchOffset","matchLength","absoluteMatchOffset","startOffset","endOffset","reversedSubstr","findNextBracketInText","bracketRegex","findNextBracketInRange","ParsedTokenThemeRule","token","background","_parsedThemeRuleBrand","colorRegExp","ColorMap","_lastColorId","_id2color","_color2id","getId","toUpperCase","fromHex","getColorMap","TokenTheme","createFromRawTokenTheme","customTokenColors","createFromParsedTokenTheme","resultLen","segments","split","lenJ","parseTokenTheme","parsedThemeRules","strcmp","defaultFontStyle","defaultForeground","defaultBackground","incomingDefaults","foregroundColorId","backgroundColorId","defaults","ThemeTrieElementRule","root","ThemeTrieElement","insert","resolveParsedTokenThemeRules","_colorMap","_root","_cache","_match","tokenType","STANDARD_TOKEN_TYPE_REGEXP","toStandardTokenType","_themeTrieElementRuleBrand","_fontStyle","_foreground","_background","acceptOverwrite","mainRule","_themeTrieElementBrand","_mainRule","_children","dotIndex","head","tail","child","generateTokensCSSForColorMap","rules","__awaiter","thisArg","_arguments","P","generator","reject","fulfilled","step","rejected","done","apply","fallback","getInitialState","tokenizeEncoded","buffer","hasEOL","tokenizeToString","_tokenizeToString","languageIdCodec","getOrCreate","tokenizeLineToHTML","viewLineTokens","tabSize","useNbsp","charIndex","tabsCharDelta","prevIsSpace","tokenEndIndex","partContent","insertSpacesCount","getInlineStyle","tokenizationResult","LineTokens","convertToEndOffset","inflate","getClassName","OverviewRulerLane","GlyphMarginLane","MinimapPosition","InjectedTextCursorStops","TextModelResolvedOptions","originalIndentSize","_indentSizeIsTabSize","indentSize","src","_textModelResolvedOptionsBrand","insertSpaces","defaultEOL","trimAutoWhitespace","bracketPairColorizationOptions","createChangeEvent","newOpts","FindMatch","_findMatchBrand","isITextSnapshot","read","ValidAnnotatedEditOperation","identifier","forceMoveMarkers","isAutoWhitespaceEdit","_isTracked","SearchData","wordSeparators","simpleSearch","ApplyEditsResult","reverseEdits","trimAutoWhitespaceLineNumbers","isTooLargeForSyncing","isForSimpleWidget","combineTextEditInfos","textEditInfoFirst","textEditInfoSecond","s0ToS1Map","ArrayQueue","toLengthMapping","s1ToS2Map","lengthBefore","lengthAfter","curItem","dequeue","nextS0ToS1MapWithS1LengthOf","s1Length","takeWhile","unshift","lengthIsZero","remainingItem","splitAt","lengthDiffNonNegative","LengthMapping","pushEdit","newLength","lengthEquals","TextEditInfo","lengthAdd","s0offset","lengthZero","s1ToS2","s0Length","sumLengths","s0EndOffset","s0startOffset","remainingLengthAfter","lengthToObj","textEditInfos","lastOffset","textEditInfo","spaceLength","BracketPairsTree","didLanguageChange","textModel","didChangeEmitter","denseKeyProvider","DenseKeyProvider","LanguageAgnosticBracketTokens","queuedTextEditsForInitialAstWithoutTokens","queuedTextEdits","hasTokens","backgroundTokenizationState","initialAstWithoutTokens","astWithTokens","parseDocumentFromTextBuffer","getSingleLanguageBracketTokens","tokenizer","FastTokenizer","parseDocument","handleDidChangeBackgroundTokenizationState","wasUndefined","handleDidChangeTokens","ranges","edits","toLength","fromLineNumber","toLineNumber","handleEdits","handleContentChanged","fromModelContentChanges","tokenChange","flushQueue","previousAst","immutable","previousAstClone","TextBufferTokenizer","getBracketsInRange","onlyColorizedBrackets","CallbackIterable","cb","node","collectBrackets","getBracketPairsInRange","includeMinIndentation","startLength","positionToLength","getStartPosition","endLength","getEndPosition","CollectBracketPairsContext","collectBracketPairs","getFirstBracketAfter","position","getFirstBracketBefore","nodeOffsetStart","nodeOffsetEnd","children","lengthLessThan","lengthsToRange","bracketInfo","level","nestingLevelOfEqualBracketType","levelPerBracketType","parentPairIsIncomplete","whileLoop","childCount","childrenLength","getChild","lengthLessThanEqual","lengthGreaterThanEqual","colorize","closingBracket","openingBracket","levelPerBracket","existing","BracketInfo","shouldContinue","openingBracketEnd","minIndentation","computeMinIndentation","BracketPairWithMinIndentationInfo","curOffset","childOffset","BracketPairsTextModelPart","canBuildAST","getValueLength","bracketPairsTree","MutableDisposable","bracketsRequested","object","updateBracketPairsTree","handleDidChangeOptions","handleDidChangeLanguage","handleDidChangeContent","store","DisposableStore","empty","getBracketPairsInRangeWithMinIndentation","findMatchingBracketUp","_bracket","_position","maxDuration","validatePosition","closingBracketInfo","bracketPair","findLast","openingBracketInfo","openingBracketRange","bracketsSupport","stripBracketSearchCanceled","_findMatchingBracketUp","createTimeBasedContinueBracketSearchPredicate","matchBracket","closingBracketRange","containsPosition","findLastMaxBy","compareBy","compareRangesUsingStarts","continueSearchPredicate","_matchBracket","_establishBracketSearchOffsets","modeBrackets","currentLanguageId","searchStartOffset","tokenEndOffset","searchEndOffset","tokenStartOffset","currentModeBrackets","bestResult","foundBracket","foundBracketText","_matchFoundBracket","BracketSearchCanceled","prevTokenIndex","prevModeBrackets","matched","_findMatchingBracketDown","totalCallCount","searchPrevMatchingBracketInRange","hitText","prevSearchInToken","searchInToken","searchNextMatchingBracketInRange","findPrevBracket","bracketConfig","tokenLanguageId","_toFoundBracket","findNextBracket","findEnclosingBrackets","strictContainsRange","savedCounts","counts","resetCounts","tmp","searchInRange","getValueInRange","_searchCanceledBrand","BaseAstNode","_length","PairAstNode","create","missingOpeningBracketIds","SmallImmutableSet","getEmpty","listHeight","canBeReused","openBracketIds","intersects","deepClone","MAX_SAFE_INTEGER","ListAstNode","create23","item1","item2","item3","missingBracketIds","merge","Immutable23ListAstNode","TwoThreeListAstNode","ImmutableArrayListAstNode","_missingOpeningBracketIds","cachedMinIndentation","throwIfImmutable","makeLastElementMutable","lastChild","mutable","toMutable","setChild","makeFirstElementMutable","firstChild","lastLength","handleChildrenChanged","unopenedBrackets","_item3","_item1","_item2","appendChildOfSameHeight","unappendChild","prependChildOfSameHeight","unprependChild","ArrayListAstNode","emptyArray","ImmutableLeafAstNode","TextAstNode","_openedBracketIds","columnCount","lengthGetLineCount","firstNonWsColumn","getLineFirstNonWhitespaceColumn","visibleColumn","CursorColumns","visibleColumnFromColumn","getOptions","BracketAstNode","bracketIds","InvalidBracketAstNode","openedBracketIds","lengthOfString","BeforeEditPositionMapper","nextEditIdx","deltaOldToNewLineCount","deltaOldToNewColumnCount","deltaLineIdxInOld","edit","TextEditInfoCache","getOffsetBeforeChange","adjustNextEdit","translateCurToOld","getDistanceToNextChange","nextEdit","nextChangeOffset","translateOldToCur","offsetObj","oldOffsetObj","newOffset","nextEditEndOffsetInCur","endOffsetAfterObj","nextEditEndOffsetInCurObj","nextEditEndOffsetBeforeInCurObj","endOffsetBeforeObj","lineDelta","previousColumnDelta","columnDelta","textLength","BracketTokens","createFromLanguage","getKey","openingTextId","identityKeyProvider","hasRegExp","_regExpGlobal","getRegExpStr","escaped","escapeRegExpCharacters","regExpGlobal","regExpStr","getToken","findClosingTokenText","openingBracketIds","closingText","languageIdToBracketTokens","singleLanguageBracketTokens","LengthObj","lengthDiff","startLineCount","startColumnCount","endLineCount","endColumnCount","zero","factor","lengthGetColumnCountIfZeroLineCount","l1","l2","lengthFn","reduce","length1","length2","lineCount1","lineCount2","colCount2","lengthStart","lengthEnd","colCount","splitLines","concat23TreesOfSameHeight","createImmutableLists","heightDiff","node1","node2","abs","list","nodeToAppend","curNode","parents","nodeToAppendOfCorrectHeight","parent","append","nodeToPrependOfCorrectHeight","prepend","NodeReader","nextNodes","offsets","idxs","readLongestNodeAt","predicate","lastOrUndefined","curNodeOffset","nextNodeAfterCurrent","nextChildIdx","getNextChildIdx","currentOffset","currentNode","curIdx","oldNode","Parser","_itemsConstructed","_itemsFromCache","oldNodeReader","positionMapper","parseList","tryReadChildFromCache","peek","parseChild","readNode","second","concat23Trees","maxCacheableLength","cachedNode","skip","astNode","nextToken","bracketId","emptyArr","additionalItems","cached","cache","keyProvider","newItem","newItems","merged","bracketTokens","reader","NonPeekableTextBufferTokenizer","_offset","didPeek","peeked","textBufferLineCount","textBufferLastLineLength","getLineLength","setPosition","lineIdx","lineCharOffset","lineTokenOffset","peekedToken","startLineIdx","startLineCharOffset","lengthHeuristic","peekedBracketToken","tokenMetadata","getMetadata","isOther","containsBracketType","regexp","exec","curLineCount","lastLineBreakOffset","lastTokenEndOffset","lastTokenEndLine","smallTextTokens0Line","smallTextTokens1Line","NotSupportedError","ColorizedBracketPairsDecorationProvider","colorProvider","ColorProvider","colorizationOptions","getDecorationsInRange","ownerId","filterOutValidation","onlyMinimapDecorations","enabled","nestingLevel","description","inlineClassName","getInlineClassName","independentColorPoolPerBracketType","toArray","getAllDecorations","unexpectedClosingBracketClassName","isInvalid","getInlineClassNameOfLevel","registerThemingParticipant","collector","colors","editorBracketHighlightingForeground1","editorBracketHighlightingForeground2","editorBracketHighlightingForeground3","editorBracketHighlightingForeground4","editorBracketHighlightingForeground5","editorBracketHighlightingForeground6","addRule","editorBracketHighlightingUnexpectedBracketForeground","colorValues","isTransparent","fixBracketsInLine","StaticTokenizerSource","processNode","closingTokenText","uriGetComparisonKey","resource","SingleModelEditStackData","beforeCursorState","alternativeVersionId","getAlternativeVersionId","eol","getModelEOL","beforeVersionId","afterVersionId","beforeEOL","afterEOL","afterCursorState","textChanges","compressConsecutiveTextChanges","_writeSelectionsSize","selections","_writeSelections","selection","selectionStartLineNumber","selectionStartColumn","positionLineNumber","positionColumn","_readSelections","Selection","serialize","necessarySize","writeSize","write","deserialize","changeCount","TextChange","SingleModelEditStackElement","code","matchesResource","setModel","canAppend","undo","_applyUndo","redo","_applyRedo","heapSize","byteLength","MultiModelEditStackElement","resources","_editStackElementsArr","editStackElement","editStackElements","_isOpen","_editStackElementsMap","_delegate","prepareUndoRedo","basename","getEOL","isEditStackElement","EditStack","undoRedoService","_model","_undoRedoService","pushStackElement","lastElement","getLastElement","popStackElement","removeElements","_getOrCreateEditStackElement","newElement","pushElement","pushEOL","setEOL","pushEditOperation","editOperations","cursorStateComputer","inverseEditOperations","applyEdits","_computeCursorState","op","textChange","oldPosition","FixedArray","_default","_store","oldLength","before","after","insertArr","arrayFill","deleteIndex","deleteCount","insertIndex","insertCount","arrayInsert","GuidesTextModelPart","TextModelPart","_computeIndentLevel","lineIndex","computeIndentLevel","getActiveIndentGuide","minLineNumber","maxLineNumber","assertNotDisposed","up_aboveContentLineIndex","up_aboveContentLineIndent","up_belowContentLineIndex","up_belowContentLineIndent","up_resolveIndents","down_aboveContentLineIndex","down_aboveContentLineIndent","down_belowContentLineIndex","down_belowContentLineIndent","down_resolveIndents","goUp","goDown","initialIndent","distance","upLineNumber","downLineNumber","upLineIndentLevel","currentIndent","ceil","_getIndentLevelForWhitespaceLine","downLineIndentLevel","getLinesBracketGuides","activePosition","activeBracketPairRange","bracketsContainingActivePosition","bp","strictContainsPosition","BracketPairGuidesClassNames","isActive","includeInactive","highlightActive","activeClassName","horizontalGuides","HorizontalGuidesState","Enabled","EnabledForActive","IndentGuide","IndentGuideHorizontalLine","endVisibleColumn","getVisibleColumnFromPosition","startVisibleColumn","guideVisibleColumn","minVisibleColumnIndentation","renderHorizontalEndLineAtTheBottom","visibleGuideStartLineNumber","visibleGuideEndLineNumber","guides","getLinesIndentGuides","aboveContentLineIndex","aboveContentLineIndent","belowContentLineIndex","belowContentLineIndent","resultIndex","SpacesDiffResult","spacesDiff","looksLikeAlignment","aLength","bLength","aSpacesCnt","aTabsCount","bSpacesCnt","bTabsCount","tabsDiff","guessIndentation","defaultTabSize","defaultInsertSpaces","linesCount","linesIndentedWithTabsCount","linesIndentedWithSpacesCount","previousLineIndentation","ALLOWED_TAB_SIZE_GUESSES","spacesDiffCount","currentLineLength","currentLineText","useCurrentLineText","currentLineHasContent","currentLineIndentation","currentLineSpacesCount","currentLineTabsCount","getLineCharCode","currentSpacesDiff","tabSizeScore","possibleTabSize","possibleTabSizeScore","getNodeColor","setNodeColor","getNodeIsVisited","setNodeIsVisited","getNodeIsForValidation","setNodeIsForValidation","getNodeIsInGlyphMargin","setNodeIsInGlyphMargin","_setNodeStickiness","stickiness","setCollapseOnReplaceEdit","IntervalNode","left","right","maxEnd","cachedVersionId","cachedAbsoluteStart","cachedAbsoluteEnd","reset","versionId","setOptions","glyphMarginClassName","collapseOnReplaceEdit","setCachedOffsets","absoluteStart","absoluteEnd","detach","SENTINEL","IntervalTree","requestNormalizeDelta","intervalSearch","filterOwnerId","onlyMarginDecorations","T","intervalStart","intervalEnd","nodeMaxEnd","nodeStart","nodeEnd","include","search","collectNodesFromOwner","collectNodesPostOrder","rbTreeInsert","_normalizeDeltaIfNecessary","rbTreeDelete","resolveNode","initialNode","acceptReplace","nodesOfInterest","searchForEditing","editDelta","recomputeMaxEnd","noOverlapReplace","nodeAcceptEdit","normalizeDelta","adjustMarkerBeforeColumn","markerOffset","markerStickToPreviousCharacter","checkOffset","moveSemantics","nodeStickiness","getNodeStickiness","startStickToPreviousCharacter","endStickToPreviousCharacter","deletingCnt","insertingCnt","commonLength","startDone","endDone","getCollapseOnReplaceEdit","deltaColumn","newNode","z","zAbsoluteStart","zAbsoluteEnd","intervalCompare","treeInsert","recomputeMaxEndWalkToRoot","leftRotate","rightRotate","leftest","resetSentinel","yWasRed","w","computeMaxEnd","leftMaxEnd","rightMaxEnd","aStart","aEnd","bStart","bEnd","ModelLineProjectionData","injectionOffsets","injectionOptions","breakOffsets","breakOffsetsVisibleColumn","wrappedTextIndentLength","getOutputLineCount","getMinOutputOffset","outputLineIndex","lineLength","getMaxOutputOffset","translateToInputOffset","outputOffset","offsetInInput","content","translateToOutputPosition","inputOffset","affinity","inputOffsetInInputWithInjection","offsetInInputWithInjectionsToOutputPosition","offsetInInputWithInjections","low","high","mid","midStart","midStop","OutputPosition","normalizeOutputPosition","outputPositionToOffsetInInputWithInjections","normalizedOffsetInUnwrappedLine","normalizeOffsetInInputWithInjectionsAroundInjections","injectedText","getInjectedTextAtOffset","hasRightCursorStop","injectedTextIndex","cursorStops","hasLeftCursorStop","assertNever","getInjectedText","totalInjectedTextLengthBefore","injectedTextStartOffsetInInputWithInjections","injectedTextEndOffsetInInputWithInjections","cursorStop","Right","Both","Left","toPosition","baseLineNumber"],"sourceRoot":""}