{"version":3,"file":"static/js/monaco-editor-vendor.df546ea5.d58b970f.js","mappings":"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","sources":["../node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js","../node_modules/monaco-editor/esm/vs/editor/common/core/cursorColumns.js","../node_modules/monaco-editor/esm/vs/editor/common/core/editOperation.js","../node_modules/monaco-editor/esm/vs/editor/common/core/editorColorRegistry.js","../node_modules/monaco-editor/esm/vs/editor/common/core/eolCounter.js","../node_modules/monaco-editor/esm/vs/editor/common/core/indentation.js","../node_modules/monaco-editor/esm/vs/editor/common/core/position.js","../node_modules/monaco-editor/esm/vs/editor/common/core/range.js","../node_modules/monaco-editor/esm/vs/editor/common/core/rgba.js","../node_modules/monaco-editor/esm/vs/editor/common/core/selection.js","../node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js","../node_modules/monaco-editor/esm/vs/editor/common/core/textChange.js","../node_modules/monaco-editor/esm/vs/editor/common/core/textModelDefaults.js","../node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js","../node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/oneCursor.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorCollection.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorContext.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursor.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorAtomicMoveOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorColumnSelection.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorDeleteOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorMoveCommands.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorMoveOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorTypeOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorWordOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursorCommon.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/smartLinesDiffComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/diffAlgorithm.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/utils.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/dynamicProgrammingDiffing.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/joinSequenceDiffs.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/myersDiffAlgorithm.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/standardLinesDiffComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js","../node_modules/monaco-editor/esm/vs/editor/common/editorAction.js","../node_modules/monaco-editor/esm/vs/editor/common/editorCommon.js","../node_modules/monaco-editor/esm/vs/editor/common/editorContextKeys.js","../node_modules/monaco-editor/esm/vs/editor/common/editorFeatures.js","../node_modules/monaco-editor/esm/vs/editor/common/editorTheme.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { toUint8 } from '../../../base/common/uint.js';\n/**\n * A fast character classifier that uses a compact array for ASCII values.\n */\nexport class CharacterClassifier {\n    constructor(_defaultValue) {\n        const defaultValue = toUint8(_defaultValue);\n        this._defaultValue = defaultValue;\n        this._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);\n        this._map = new Map();\n    }\n    static _createAsciiMap(defaultValue) {\n        const asciiMap = new Uint8Array(256);\n        asciiMap.fill(defaultValue);\n        return asciiMap;\n    }\n    set(charCode, _value) {\n        const value = toUint8(_value);\n        if (charCode >= 0 && charCode < 256) {\n            this._asciiMap[charCode] = value;\n        }\n        else {\n            this._map.set(charCode, value);\n        }\n    }\n    get(charCode) {\n        if (charCode >= 0 && charCode < 256) {\n            return this._asciiMap[charCode];\n        }\n        else {\n            return (this._map.get(charCode) || this._defaultValue);\n        }\n    }\n    clear() {\n        this._asciiMap.fill(this._defaultValue);\n        this._map.clear();\n    }\n}\nexport class CharacterSet {\n    constructor() {\n        this._actual = new CharacterClassifier(0 /* Boolean.False */);\n    }\n    add(charCode) {\n        this._actual.set(charCode, 1 /* Boolean.True */);\n    }\n    has(charCode) {\n        return (this._actual.get(charCode) === 1 /* Boolean.True */);\n    }\n    clear() {\n        return this._actual.clear();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\n/**\n * A column in a position is the gap between two adjacent characters. The methods here\n * work with a concept called \"visible column\". A visible column is a very rough approximation\n * of the horizontal screen position of a column. For example, using a tab size of 4:\n * ```txt\n * |<TAB>|<TAB>|T|ext\n * |     |     | \\---- column = 4, visible column = 9\n * |     |     \\------ column = 3, visible column = 8\n * |     \\------------ column = 2, visible column = 4\n * \\------------------ column = 1, visible column = 0\n * ```\n *\n * **NOTE**: Visual columns do not work well for RTL text or variable-width fonts or characters.\n *\n * **NOTE**: These methods work and make sense both on the model and on the view model.\n */\nexport class CursorColumns {\n    static _nextVisibleColumn(codePoint, visibleColumn, tabSize) {\n        if (codePoint === 9 /* CharCode.Tab */) {\n            return CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        }\n        if (strings.isFullWidthCharacter(codePoint) || strings.isEmojiImprecise(codePoint)) {\n            return visibleColumn + 2;\n        }\n        return visibleColumn + 1;\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    static visibleColumnFromColumn(lineContent, column, tabSize) {\n        const textLen = Math.min(column - 1, lineContent.length);\n        const text = lineContent.substring(0, textLen);\n        const iterator = new strings.GraphemeIterator(text);\n        let result = 0;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(text, textLen, iterator.offset);\n            iterator.nextGraphemeLength();\n            result = this._nextVisibleColumn(codePoint, result, tabSize);\n        }\n        return result;\n    }\n    /**\n     * Returns a column from a visible column.\n     * @see {@link CursorColumns}\n     */\n    static columnFromVisibleColumn(lineContent, visibleColumn, tabSize) {\n        if (visibleColumn <= 0) {\n            return 1;\n        }\n        const lineContentLength = lineContent.length;\n        const iterator = new strings.GraphemeIterator(lineContent);\n        let beforeVisibleColumn = 0;\n        let beforeColumn = 1;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(lineContent, lineContentLength, iterator.offset);\n            iterator.nextGraphemeLength();\n            const afterVisibleColumn = this._nextVisibleColumn(codePoint, beforeVisibleColumn, tabSize);\n            const afterColumn = iterator.offset + 1;\n            if (afterVisibleColumn >= visibleColumn) {\n                const beforeDelta = visibleColumn - beforeVisibleColumn;\n                const afterDelta = afterVisibleColumn - visibleColumn;\n                if (afterDelta < beforeDelta) {\n                    return afterColumn;\n                }\n                else {\n                    return beforeColumn;\n                }\n            }\n            beforeVisibleColumn = afterVisibleColumn;\n            beforeColumn = afterColumn;\n        }\n        // walked the entire string\n        return lineContentLength + 1;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextRenderTabStop(visibleColumn, tabSize) {\n        return visibleColumn + tabSize - visibleColumn % tabSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextIndentTabStop(visibleColumn, indentSize) {\n        return visibleColumn + indentSize - visibleColumn % indentSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevRenderTabStop(column, tabSize) {\n        return Math.max(0, column - 1 - (column - 1) % tabSize);\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevIndentTabStop(column, indentSize) {\n        return Math.max(0, column - 1 - (column - 1) % indentSize);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from './range.js';\nexport class EditOperation {\n    static insert(position, text) {\n        return {\n            range: new Range(position.lineNumber, position.column, position.lineNumber, position.column),\n            text: text,\n            forceMoveMarkers: true\n        };\n    }\n    static delete(range) {\n        return {\n            range: range,\n            text: null\n        };\n    }\n    static replace(range, text) {\n        return {\n            range: range,\n            text: text\n        };\n    }\n    static replaceMove(range, text) {\n        return {\n            range: range,\n            text: text,\n            forceMoveMarkers: true\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { Color, RGBA } from '../../../base/common/color.js';\nimport { activeContrastBorder, editorBackground, registerColor, editorWarningForeground, editorInfoForeground, editorWarningBorder, editorInfoBorder, contrastBorder, editorFindMatchHighlight } from '../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../platform/theme/common/themeService.js';\n/**\n * Definition of the editor colors\n */\nexport const editorLineHighlight = registerColor('editor.lineHighlightBackground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('lineHighlight', 'Background color for the highlight of line at the cursor position.'));\nexport const editorLineHighlightBorder = registerColor('editor.lineHighlightBorder', { dark: '#282828', light: '#eeeeee', hcDark: '#f38518', hcLight: contrastBorder }, nls.localize('lineHighlightBorderBox', 'Background color for the border around the line at the cursor position.'));\nexport const editorRangeHighlight = registerColor('editor.rangeHighlightBackground', { dark: '#ffffff0b', light: '#fdff0033', hcDark: null, hcLight: null }, nls.localize('rangeHighlight', 'Background color of highlighted ranges, like by quick open and find features. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorRangeHighlightBorder = registerColor('editor.rangeHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('rangeHighlightBorder', 'Background color of the border around highlighted ranges.'), true);\nexport const editorSymbolHighlight = registerColor('editor.symbolHighlightBackground', { dark: editorFindMatchHighlight, light: editorFindMatchHighlight, hcDark: null, hcLight: null }, nls.localize('symbolHighlight', 'Background color of highlighted symbol, like for go to definition or go next/previous symbol. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorSymbolHighlightBorder = registerColor('editor.symbolHighlightBorder', { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('symbolHighlightBorder', 'Background color of the border around highlighted symbols.'), true);\nexport const editorCursorForeground = registerColor('editorCursor.foreground', { dark: '#AEAFAD', light: Color.black, hcDark: Color.white, hcLight: '#0F4A85' }, nls.localize('caret', 'Color of the editor cursor.'));\nexport const editorCursorBackground = registerColor('editorCursor.background', null, nls.localize('editorCursorBackground', 'The background color of the editor cursor. Allows customizing the color of a character overlapped by a block cursor.'));\nexport const editorWhitespaces = registerColor('editorWhitespace.foreground', { dark: '#e3e4e229', light: '#33333333', hcDark: '#e3e4e229', hcLight: '#CCCCCC' }, nls.localize('editorWhitespaces', 'Color of whitespace characters in the editor.'));\nexport const editorIndentGuides = registerColor('editorIndentGuide.background', { dark: editorWhitespaces, light: editorWhitespaces, hcDark: editorWhitespaces, hcLight: editorWhitespaces }, nls.localize('editorIndentGuides', 'Color of the editor indentation guides.'));\nexport const editorActiveIndentGuides = registerColor('editorIndentGuide.activeBackground', { dark: editorWhitespaces, light: editorWhitespaces, hcDark: editorWhitespaces, hcLight: editorWhitespaces }, nls.localize('editorActiveIndentGuide', 'Color of the active editor indentation guides.'));\nexport const editorLineNumbers = registerColor('editorLineNumber.foreground', { dark: '#858585', light: '#237893', hcDark: Color.white, hcLight: '#292929' }, nls.localize('editorLineNumbers', 'Color of editor line numbers.'));\nconst deprecatedEditorActiveLineNumber = registerColor('editorActiveLineNumber.foreground', { dark: '#c6c6c6', light: '#0B216F', hcDark: activeContrastBorder, hcLight: activeContrastBorder }, nls.localize('editorActiveLineNumber', 'Color of editor active line number'), false, nls.localize('deprecatedEditorActiveLineNumber', 'Id is deprecated. Use \\'editorLineNumber.activeForeground\\' instead.'));\nexport const editorActiveLineNumber = registerColor('editorLineNumber.activeForeground', { dark: deprecatedEditorActiveLineNumber, light: deprecatedEditorActiveLineNumber, hcDark: deprecatedEditorActiveLineNumber, hcLight: deprecatedEditorActiveLineNumber }, nls.localize('editorActiveLineNumber', 'Color of editor active line number'));\nexport const editorDimmedLineNumber = registerColor('editorLineNumber.dimmedForeground', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('editorDimmedLineNumber', 'Color of the final editor line when editor.renderFinalNewline is set to dimmed.'));\nexport const editorRuler = registerColor('editorRuler.foreground', { dark: '#5A5A5A', light: Color.lightgrey, hcDark: Color.white, hcLight: '#292929' }, nls.localize('editorRuler', 'Color of the editor rulers.'));\nexport const editorCodeLensForeground = registerColor('editorCodeLens.foreground', { dark: '#999999', light: '#919191', hcDark: '#999999', hcLight: '#292929' }, nls.localize('editorCodeLensForeground', 'Foreground color of editor CodeLens'));\nexport const editorBracketMatchBackground = registerColor('editorBracketMatch.background', { dark: '#0064001a', light: '#0064001a', hcDark: '#0064001a', hcLight: '#0000' }, nls.localize('editorBracketMatchBackground', 'Background color behind matching brackets'));\nexport const editorBracketMatchBorder = registerColor('editorBracketMatch.border', { dark: '#888', light: '#B9B9B9', hcDark: contrastBorder, hcLight: contrastBorder }, nls.localize('editorBracketMatchBorder', 'Color for matching brackets boxes'));\nexport const editorOverviewRulerBorder = registerColor('editorOverviewRuler.border', { dark: '#7f7f7f4d', light: '#7f7f7f4d', hcDark: '#7f7f7f4d', hcLight: '#666666' }, nls.localize('editorOverviewRulerBorder', 'Color of the overview ruler border.'));\nexport const editorOverviewRulerBackground = registerColor('editorOverviewRuler.background', null, nls.localize('editorOverviewRulerBackground', 'Background color of the editor overview ruler.'));\nexport const editorGutter = registerColor('editorGutter.background', { dark: editorBackground, light: editorBackground, hcDark: editorBackground, hcLight: editorBackground }, nls.localize('editorGutter', 'Background color of the editor gutter. The gutter contains the glyph margins and the line numbers.'));\nexport const editorUnnecessaryCodeBorder = registerColor('editorUnnecessaryCode.border', { dark: null, light: null, hcDark: Color.fromHex('#fff').transparent(0.8), hcLight: contrastBorder }, nls.localize('unnecessaryCodeBorder', 'Border color of unnecessary (unused) source code in the editor.'));\nexport const editorUnnecessaryCodeOpacity = registerColor('editorUnnecessaryCode.opacity', { dark: Color.fromHex('#000a'), light: Color.fromHex('#0007'), hcDark: null, hcLight: null }, nls.localize('unnecessaryCodeOpacity', 'Opacity of unnecessary (unused) source code in the editor. For example, \"#000000c0\" will render the code with 75% opacity. For high contrast themes, use the  \\'editorUnnecessaryCode.border\\' theme color to underline unnecessary code instead of fading it out.'));\nexport const ghostTextBorder = registerColor('editorGhostText.border', { dark: null, light: null, hcDark: Color.fromHex('#fff').transparent(0.8), hcLight: Color.fromHex('#292929').transparent(0.8) }, nls.localize('editorGhostTextBorder', 'Border color of ghost text in the editor.'));\nexport const ghostTextForeground = registerColor('editorGhostText.foreground', { dark: Color.fromHex('#ffffff56'), light: Color.fromHex('#0007'), hcDark: null, hcLight: null }, nls.localize('editorGhostTextForeground', 'Foreground color of the ghost text in the editor.'));\nexport const ghostTextBackground = registerColor('editorGhostText.background', { dark: null, light: null, hcDark: null, hcLight: null }, nls.localize('editorGhostTextBackground', 'Background color of the ghost text in the editor.'));\nconst rulerRangeDefault = new Color(new RGBA(0, 122, 204, 0.6));\nexport const overviewRulerRangeHighlight = registerColor('editorOverviewRuler.rangeHighlightForeground', { dark: rulerRangeDefault, light: rulerRangeDefault, hcDark: rulerRangeDefault, hcLight: rulerRangeDefault }, nls.localize('overviewRulerRangeHighlight', 'Overview ruler marker color for range highlights. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const overviewRulerError = registerColor('editorOverviewRuler.errorForeground', { dark: new Color(new RGBA(255, 18, 18, 0.7)), light: new Color(new RGBA(255, 18, 18, 0.7)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: '#B5200D' }, nls.localize('overviewRuleError', 'Overview ruler marker color for errors.'));\nexport const overviewRulerWarning = registerColor('editorOverviewRuler.warningForeground', { dark: editorWarningForeground, light: editorWarningForeground, hcDark: editorWarningBorder, hcLight: editorWarningBorder }, nls.localize('overviewRuleWarning', 'Overview ruler marker color for warnings.'));\nexport const overviewRulerInfo = registerColor('editorOverviewRuler.infoForeground', { dark: editorInfoForeground, light: editorInfoForeground, hcDark: editorInfoBorder, hcLight: editorInfoBorder }, nls.localize('overviewRuleInfo', 'Overview ruler marker color for infos.'));\nexport const editorBracketHighlightingForeground1 = registerColor('editorBracketHighlight.foreground1', { dark: '#FFD700', light: '#0431FAFF', hcDark: '#FFD700', hcLight: '#0431FAFF' }, nls.localize('editorBracketHighlightForeground1', 'Foreground color of brackets (1). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground2 = registerColor('editorBracketHighlight.foreground2', { dark: '#DA70D6', light: '#319331FF', hcDark: '#DA70D6', hcLight: '#319331FF' }, nls.localize('editorBracketHighlightForeground2', 'Foreground color of brackets (2). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground3 = registerColor('editorBracketHighlight.foreground3', { dark: '#179FFF', light: '#7B3814FF', hcDark: '#87CEFA', hcLight: '#7B3814FF' }, nls.localize('editorBracketHighlightForeground3', 'Foreground color of brackets (3). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground4 = registerColor('editorBracketHighlight.foreground4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketHighlightForeground4', 'Foreground color of brackets (4). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground5 = registerColor('editorBracketHighlight.foreground5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketHighlightForeground5', 'Foreground color of brackets (5). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground6 = registerColor('editorBracketHighlight.foreground6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketHighlightForeground6', 'Foreground color of brackets (6). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingUnexpectedBracketForeground = registerColor('editorBracketHighlight.unexpectedBracket.foreground', { dark: new Color(new RGBA(255, 18, 18, 0.8)), light: new Color(new RGBA(255, 18, 18, 0.8)), hcDark: new Color(new RGBA(255, 50, 50, 1)), hcLight: '' }, nls.localize('editorBracketHighlightUnexpectedBracketForeground', 'Foreground color of unexpected brackets.'));\nexport const editorBracketPairGuideBackground1 = registerColor('editorBracketPairGuide.background1', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background1', 'Background color of inactive bracket pair guides (1). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground2 = registerColor('editorBracketPairGuide.background2', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background2', 'Background color of inactive bracket pair guides (2). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground3 = registerColor('editorBracketPairGuide.background3', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background3', 'Background color of inactive bracket pair guides (3). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground4 = registerColor('editorBracketPairGuide.background4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background4', 'Background color of inactive bracket pair guides (4). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground5 = registerColor('editorBracketPairGuide.background5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background5', 'Background color of inactive bracket pair guides (5). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground6 = registerColor('editorBracketPairGuide.background6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.background6', 'Background color of inactive bracket pair guides (6). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground1 = registerColor('editorBracketPairGuide.activeBackground1', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground1', 'Background color of active bracket pair guides (1). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground2 = registerColor('editorBracketPairGuide.activeBackground2', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground2', 'Background color of active bracket pair guides (2). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground3 = registerColor('editorBracketPairGuide.activeBackground3', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground3', 'Background color of active bracket pair guides (3). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground4 = registerColor('editorBracketPairGuide.activeBackground4', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground4', 'Background color of active bracket pair guides (4). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground5 = registerColor('editorBracketPairGuide.activeBackground5', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground5', 'Background color of active bracket pair guides (5). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground6 = registerColor('editorBracketPairGuide.activeBackground6', { dark: '#00000000', light: '#00000000', hcDark: '#00000000', hcLight: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground6', 'Background color of active bracket pair guides (6). Requires enabling bracket pair guides.'));\nexport const editorUnicodeHighlightBorder = registerColor('editorUnicodeHighlight.border', { dark: '#BD9B03', light: '#CEA33D', hcDark: '#ff0000', hcLight: '#CEA33D' }, nls.localize('editorUnicodeHighlight.border', 'Border color used to highlight unicode characters.'));\nexport const editorUnicodeHighlightBackground = registerColor('editorUnicodeHighlight.background', { dark: '#bd9b0326', light: '#cea33d14', hcDark: '#00000000', hcLight: '#cea33d14' }, nls.localize('editorUnicodeHighlight.background', 'Background color used to highlight unicode characters.'));\n// contains all color rules that used to defined in editor/browser/widget/editor.css\nregisterThemingParticipant((theme, collector) => {\n    const background = theme.getColor(editorBackground);\n    const lineHighlight = theme.getColor(editorLineHighlight);\n    const imeBackground = (lineHighlight && !lineHighlight.isTransparent() ? lineHighlight : background);\n    if (imeBackground) {\n        collector.addRule(`.monaco-editor .inputarea.ime-input { background-color: ${imeBackground}; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function countEOL(text) {\n    let eolCount = 0;\n    let firstLineLength = 0;\n    let lastLineStart = 0;\n    let eol = 0 /* StringEOL.Unknown */;\n    for (let i = 0, len = text.length; i < len; i++) {\n        const chr = text.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            if (i + 1 < len && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                eol |= 2 /* StringEOL.CRLF */;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                eol |= 3 /* StringEOL.Invalid */;\n            }\n            lastLineStart = i + 1;\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            // \\n... case\n            eol |= 1 /* StringEOL.LF */;\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            lastLineStart = i + 1;\n        }\n    }\n    if (eolCount === 0) {\n        firstLineLength = text.length;\n    }\n    return [eolCount, firstLineLength, text.length - lastLineStart, eol];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from './cursorColumns.js';\nfunction _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {\n    let spacesCnt = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str.charAt(i) === '\\t') {\n            spacesCnt = CursorColumns.nextIndentTabStop(spacesCnt, indentSize);\n        }\n        else {\n            spacesCnt++;\n        }\n    }\n    let result = '';\n    if (!insertSpaces) {\n        const tabsCnt = Math.floor(spacesCnt / indentSize);\n        spacesCnt = spacesCnt % indentSize;\n        for (let i = 0; i < tabsCnt; i++) {\n            result += '\\t';\n        }\n    }\n    for (let i = 0; i < spacesCnt; i++) {\n        result += ' ';\n    }\n    return result;\n}\nexport function normalizeIndentation(str, indentSize, insertSpaces) {\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\n    if (firstNonWhitespaceIndex === -1) {\n        firstNonWhitespaceIndex = str.length;\n    }\n    return _normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A position in the editor.\n */\nexport class Position {\n    constructor(lineNumber, column) {\n        this.lineNumber = lineNumber;\n        this.column = column;\n    }\n    /**\n     * Create a new position from this position.\n     *\n     * @param newLineNumber new line number\n     * @param newColumn new column\n     */\n    with(newLineNumber = this.lineNumber, newColumn = this.column) {\n        if (newLineNumber === this.lineNumber && newColumn === this.column) {\n            return this;\n        }\n        else {\n            return new Position(newLineNumber, newColumn);\n        }\n    }\n    /**\n     * Derive a new position from this position.\n     *\n     * @param deltaLineNumber line number delta\n     * @param deltaColumn column delta\n     */\n    delta(deltaLineNumber = 0, deltaColumn = 0) {\n        return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);\n    }\n    /**\n     * Test if this position equals other position\n     */\n    equals(other) {\n        return Position.equals(this, other);\n    }\n    /**\n     * Test if position `a` equals position `b`\n     */\n    static equals(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        return (!!a &&\n            !!b &&\n            a.lineNumber === b.lineNumber &&\n            a.column === b.column);\n    }\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be false.\n     */\n    isBefore(other) {\n        return Position.isBefore(this, other);\n    }\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be false.\n     */\n    static isBefore(a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column < b.column;\n    }\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be true.\n     */\n    isBeforeOrEqual(other) {\n        return Position.isBeforeOrEqual(this, other);\n    }\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be true.\n     */\n    static isBeforeOrEqual(a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column <= b.column;\n    }\n    /**\n     * A function that compares positions, useful for sorting\n     */\n    static compare(a, b) {\n        const aLineNumber = a.lineNumber | 0;\n        const bLineNumber = b.lineNumber | 0;\n        if (aLineNumber === bLineNumber) {\n            const aColumn = a.column | 0;\n            const bColumn = b.column | 0;\n            return aColumn - bColumn;\n        }\n        return aLineNumber - bLineNumber;\n    }\n    /**\n     * Clone this position.\n     */\n    clone() {\n        return new Position(this.lineNumber, this.column);\n    }\n    /**\n     * Convert to a human-readable representation.\n     */\n    toString() {\n        return '(' + this.lineNumber + ',' + this.column + ')';\n    }\n    // ---\n    /**\n     * Create a `Position` from an `IPosition`.\n     */\n    static lift(pos) {\n        return new Position(pos.lineNumber, pos.column);\n    }\n    /**\n     * Test if `obj` is an `IPosition`.\n     */\n    static isIPosition(obj) {\n        return (obj\n            && (typeof obj.lineNumber === 'number')\n            && (typeof obj.column === 'number'));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\n/**\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\n */\nexport class Range {\n    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {\n        if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\n            this.startLineNumber = endLineNumber;\n            this.startColumn = endColumn;\n            this.endLineNumber = startLineNumber;\n            this.endColumn = startColumn;\n        }\n        else {\n            this.startLineNumber = startLineNumber;\n            this.startColumn = startColumn;\n            this.endLineNumber = endLineNumber;\n            this.endColumn = endColumn;\n        }\n    }\n    /**\n     * Test if this range is empty.\n     */\n    isEmpty() {\n        return Range.isEmpty(this);\n    }\n    /**\n     * Test if `range` is empty.\n     */\n    static isEmpty(range) {\n        return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\n    }\n    /**\n     * Test if position is in this range. If the position is at the edges, will return true.\n     */\n    containsPosition(position) {\n        return Range.containsPosition(this, position);\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return true.\n     */\n    static containsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return false.\n     * @internal\n     */\n    static strictContainsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if range is in this range. If the range is equal to this range, will return true.\n     */\n    containsRange(range) {\n        return Range.containsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\n     */\n    static containsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\n     */\n    strictContainsRange(range) {\n        return Range.strictContainsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.\n     */\n    static strictContainsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    plusRange(range) {\n        return Range.plusRange(this, range);\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    static plusRange(a, b) {\n        let startLineNumber;\n        let startColumn;\n        let endLineNumber;\n        let endColumn;\n        if (b.startLineNumber < a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = b.startColumn;\n        }\n        else if (b.startLineNumber === a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = Math.min(b.startColumn, a.startColumn);\n        }\n        else {\n            startLineNumber = a.startLineNumber;\n            startColumn = a.startColumn;\n        }\n        if (b.endLineNumber > a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = b.endColumn;\n        }\n        else if (b.endLineNumber === a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = Math.max(b.endColumn, a.endColumn);\n        }\n        else {\n            endLineNumber = a.endLineNumber;\n            endColumn = a.endColumn;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    intersectRanges(range) {\n        return Range.intersectRanges(this, range);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    static intersectRanges(a, b) {\n        let resultStartLineNumber = a.startLineNumber;\n        let resultStartColumn = a.startColumn;\n        let resultEndLineNumber = a.endLineNumber;\n        let resultEndColumn = a.endColumn;\n        const otherStartLineNumber = b.startLineNumber;\n        const otherStartColumn = b.startColumn;\n        const otherEndLineNumber = b.endLineNumber;\n        const otherEndColumn = b.endColumn;\n        if (resultStartLineNumber < otherStartLineNumber) {\n            resultStartLineNumber = otherStartLineNumber;\n            resultStartColumn = otherStartColumn;\n        }\n        else if (resultStartLineNumber === otherStartLineNumber) {\n            resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n        }\n        if (resultEndLineNumber > otherEndLineNumber) {\n            resultEndLineNumber = otherEndLineNumber;\n            resultEndColumn = otherEndColumn;\n        }\n        else if (resultEndLineNumber === otherEndLineNumber) {\n            resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n        }\n        // Check if selection is now empty\n        if (resultStartLineNumber > resultEndLineNumber) {\n            return null;\n        }\n        if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n            return null;\n        }\n        return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n    }\n    /**\n     * Test if this range equals other.\n     */\n    equalsRange(other) {\n        return Range.equalsRange(this, other);\n    }\n    /**\n     * Test if range `a` equals `b`.\n     */\n    static equalsRange(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        return (!!a &&\n            !!b &&\n            a.startLineNumber === b.startLineNumber &&\n            a.startColumn === b.startColumn &&\n            a.endLineNumber === b.endLineNumber &&\n            a.endColumn === b.endColumn);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    getEndPosition() {\n        return Range.getEndPosition(this);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    static getEndPosition(range) {\n        return new Position(range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    getStartPosition() {\n        return Range.getStartPosition(this);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    static getStartPosition(range) {\n        return new Position(range.startLineNumber, range.startColumn);\n    }\n    /**\n     * Transform to a user presentable string representation.\n     */\n    toString() {\n        return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\n    }\n    /**\n     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    collapseToStart() {\n        return Range.collapseToStart(this);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    static collapseToStart(range) {\n        return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n    }\n    /**\n     * Create a new empty range using this range's end position.\n     */\n    collapseToEnd() {\n        return Range.collapseToEnd(this);\n    }\n    /**\n     * Create a new empty range using this range's end position.\n     */\n    static collapseToEnd(range) {\n        return new Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Moves the range by the given amount of lines.\n     */\n    delta(lineCount) {\n        return new Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);\n    }\n    // ---\n    static fromPositions(start, end = start) {\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    static lift(range) {\n        if (!range) {\n            return null;\n        }\n        return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Test if `obj` is an `IRange`.\n     */\n    static isIRange(obj) {\n        return (obj\n            && (typeof obj.startLineNumber === 'number')\n            && (typeof obj.startColumn === 'number')\n            && (typeof obj.endLineNumber === 'number')\n            && (typeof obj.endColumn === 'number'));\n    }\n    /**\n     * Test if the two ranges are touching in any way.\n     */\n    static areIntersectingOrTouching(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * Test if the two ranges are intersecting. If the ranges are touching it returns true.\n     */\n    static areIntersecting(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the startPosition and then on the endPosition\n     */\n    static compareRangesUsingStarts(a, b) {\n        if (a && b) {\n            const aStartLineNumber = a.startLineNumber | 0;\n            const bStartLineNumber = b.startLineNumber | 0;\n            if (aStartLineNumber === bStartLineNumber) {\n                const aStartColumn = a.startColumn | 0;\n                const bStartColumn = b.startColumn | 0;\n                if (aStartColumn === bStartColumn) {\n                    const aEndLineNumber = a.endLineNumber | 0;\n                    const bEndLineNumber = b.endLineNumber | 0;\n                    if (aEndLineNumber === bEndLineNumber) {\n                        const aEndColumn = a.endColumn | 0;\n                        const bEndColumn = b.endColumn | 0;\n                        return aEndColumn - bEndColumn;\n                    }\n                    return aEndLineNumber - bEndLineNumber;\n                }\n                return aStartColumn - bStartColumn;\n            }\n            return aStartLineNumber - bStartLineNumber;\n        }\n        const aExists = (a ? 1 : 0);\n        const bExists = (b ? 1 : 0);\n        return aExists - bExists;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the endPosition and then on the startPosition\n     */\n    static compareRangesUsingEnds(a, b) {\n        if (a.endLineNumber === b.endLineNumber) {\n            if (a.endColumn === b.endColumn) {\n                if (a.startLineNumber === b.startLineNumber) {\n                    return a.startColumn - b.startColumn;\n                }\n                return a.startLineNumber - b.startLineNumber;\n            }\n            return a.endColumn - b.endColumn;\n        }\n        return a.endLineNumber - b.endLineNumber;\n    }\n    /**\n     * Test if the range spans multiple lines.\n     */\n    static spansMultipleLines(range) {\n        return range.endLineNumber > range.startLineNumber;\n    }\n    toJSON() {\n        return this;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A very VM friendly rgba datastructure.\n * Please don't touch unless you take a look at the IR.\n */\nclass RGBA8 {\n    constructor(r, g, b, a) {\n        this._rgba8Brand = undefined;\n        this.r = RGBA8._clamp(r);\n        this.g = RGBA8._clamp(g);\n        this.b = RGBA8._clamp(b);\n        this.a = RGBA8._clamp(a);\n    }\n    equals(other) {\n        return (this.r === other.r\n            && this.g === other.g\n            && this.b === other.b\n            && this.a === other.a);\n    }\n    static _clamp(c) {\n        if (c < 0) {\n            return 0;\n        }\n        if (c > 255) {\n            return 255;\n        }\n        return c | 0;\n    }\n}\nRGBA8.Empty = new RGBA8(0, 0, 0, 0);\nexport { RGBA8 };\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\nimport { Range } from './range.js';\n/**\n * A selection in the editor.\n * The selection is a range that has an orientation.\n */\nexport class Selection extends Range {\n    constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {\n        super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);\n        this.selectionStartLineNumber = selectionStartLineNumber;\n        this.selectionStartColumn = selectionStartColumn;\n        this.positionLineNumber = positionLineNumber;\n        this.positionColumn = positionColumn;\n    }\n    /**\n     * Transform to a human-readable representation.\n     */\n    toString() {\n        return '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';\n    }\n    /**\n     * Test if equals other selection.\n     */\n    equalsSelection(other) {\n        return (Selection.selectionsEqual(this, other));\n    }\n    /**\n     * Test if the two selections are equal.\n     */\n    static selectionsEqual(a, b) {\n        return (a.selectionStartLineNumber === b.selectionStartLineNumber &&\n            a.selectionStartColumn === b.selectionStartColumn &&\n            a.positionLineNumber === b.positionLineNumber &&\n            a.positionColumn === b.positionColumn);\n    }\n    /**\n     * Get directions (LTR or RTL).\n     */\n    getDirection() {\n        if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {\n            return 0 /* SelectionDirection.LTR */;\n        }\n        return 1 /* SelectionDirection.RTL */;\n    }\n    /**\n     * Create a new selection with a different `positionLineNumber` and `positionColumn`.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        if (this.getDirection() === 0 /* SelectionDirection.LTR */) {\n            return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);\n    }\n    /**\n     * Get the position at `positionLineNumber` and `positionColumn`.\n     */\n    getPosition() {\n        return new Position(this.positionLineNumber, this.positionColumn);\n    }\n    /**\n     * Get the position at the start of the selection.\n    */\n    getSelectionStart() {\n        return new Position(this.selectionStartLineNumber, this.selectionStartColumn);\n    }\n    /**\n     * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        if (this.getDirection() === 0 /* SelectionDirection.LTR */) {\n            return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n        }\n        return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);\n    }\n    // ----\n    /**\n     * Create a `Selection` from one or two positions\n     */\n    static fromPositions(start, end = start) {\n        return new Selection(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    /**\n     * Creates a `Selection` from a range, given a direction.\n     */\n    static fromRange(range, direction) {\n        if (direction === 0 /* SelectionDirection.LTR */) {\n            return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n        }\n        else {\n            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n        }\n    }\n    /**\n     * Create a `Selection` from an `ISelection`.\n     */\n    static liftSelection(sel) {\n        return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);\n    }\n    /**\n     * `a` equals `b`.\n     */\n    static selectionsArrEqual(a, b) {\n        if (a && !b || !a && b) {\n            return false;\n        }\n        if (!a && !b) {\n            return true;\n        }\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (!this.selectionsEqual(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Test if `obj` is an `ISelection`.\n     */\n    static isISelection(obj) {\n        return (obj\n            && (typeof obj.selectionStartLineNumber === 'number')\n            && (typeof obj.selectionStartColumn === 'number')\n            && (typeof obj.positionLineNumber === 'number')\n            && (typeof obj.positionColumn === 'number'));\n    }\n    /**\n     * Create with a direction.\n     */\n    static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {\n        if (direction === 0 /* SelectionDirection.LTR */) {\n            return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as buffer from '../../../base/common/buffer.js';\nlet _utf16LE_TextDecoder;\nfunction getUTF16LE_TextDecoder() {\n    if (!_utf16LE_TextDecoder) {\n        _utf16LE_TextDecoder = new TextDecoder('UTF-16LE');\n    }\n    return _utf16LE_TextDecoder;\n}\nlet _utf16BE_TextDecoder;\nfunction getUTF16BE_TextDecoder() {\n    if (!_utf16BE_TextDecoder) {\n        _utf16BE_TextDecoder = new TextDecoder('UTF-16BE');\n    }\n    return _utf16BE_TextDecoder;\n}\nlet _platformTextDecoder;\nexport function getPlatformTextDecoder() {\n    if (!_platformTextDecoder) {\n        _platformTextDecoder = platform.isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n    }\n    return _platformTextDecoder;\n}\nexport function decodeUTF16LE(source, offset, len) {\n    const view = new Uint16Array(source.buffer, offset, len);\n    if (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n        // UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n        // It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n        // We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n        // So we use the manual decoder\n        return compatDecodeUTF16LE(source, offset, len);\n    }\n    return getUTF16LE_TextDecoder().decode(view);\n}\nfunction compatDecodeUTF16LE(source, offset, len) {\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0; i < len; i++) {\n        const charCode = buffer.readUInt16LE(source, offset);\n        offset += 2;\n        result[resultLen++] = String.fromCharCode(charCode);\n    }\n    return result.join('');\n}\nexport class StringBuilder {\n    constructor(capacity) {\n        this._capacity = capacity | 0;\n        this._buffer = new Uint16Array(this._capacity);\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    reset() {\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    build() {\n        if (this._completedStrings !== null) {\n            this._flushBuffer();\n            return this._completedStrings.join('');\n        }\n        return this._buildBuffer();\n    }\n    _buildBuffer() {\n        if (this._bufferLength === 0) {\n            return '';\n        }\n        const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);\n        return getPlatformTextDecoder().decode(view);\n    }\n    _flushBuffer() {\n        const bufferString = this._buildBuffer();\n        this._bufferLength = 0;\n        if (this._completedStrings === null) {\n            this._completedStrings = [bufferString];\n        }\n        else {\n            this._completedStrings[this._completedStrings.length] = bufferString;\n        }\n    }\n    /**\n     * Append a char code (<2^16)\n     */\n    appendCharCode(charCode) {\n        const remainingSpace = this._capacity - this._bufferLength;\n        if (remainingSpace <= 1) {\n            if (remainingSpace === 0 || strings.isHighSurrogate(charCode)) {\n                this._flushBuffer();\n            }\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    /**\n     * Append an ASCII char code (<2^8)\n     */\n    appendASCIICharCode(charCode) {\n        if (this._bufferLength === this._capacity) {\n            // buffer is full\n            this._flushBuffer();\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendString(str) {\n        const strLen = str.length;\n        if (this._bufferLength + strLen >= this._capacity) {\n            // This string does not fit in the remaining buffer space\n            this._flushBuffer();\n            this._completedStrings[this._completedStrings.length] = str;\n            return;\n        }\n        for (let i = 0; i < strLen; i++) {\n            this._buffer[this._bufferLength++] = str.charCodeAt(i);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as buffer from '../../../base/common/buffer.js';\nimport { decodeUTF16LE } from './stringBuilder.js';\nfunction escapeNewLine(str) {\n    return (str\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r'));\n}\nexport class TextChange {\n    get oldLength() {\n        return this.oldText.length;\n    }\n    get oldEnd() {\n        return this.oldPosition + this.oldText.length;\n    }\n    get newLength() {\n        return this.newText.length;\n    }\n    get newEnd() {\n        return this.newPosition + this.newText.length;\n    }\n    constructor(oldPosition, oldText, newPosition, newText) {\n        this.oldPosition = oldPosition;\n        this.oldText = oldText;\n        this.newPosition = newPosition;\n        this.newText = newText;\n    }\n    toString() {\n        if (this.oldText.length === 0) {\n            return `(insert@${this.oldPosition} \"${escapeNewLine(this.newText)}\")`;\n        }\n        if (this.newText.length === 0) {\n            return `(delete@${this.oldPosition} \"${escapeNewLine(this.oldText)}\")`;\n        }\n        return `(replace@${this.oldPosition} \"${escapeNewLine(this.oldText)}\" with \"${escapeNewLine(this.newText)}\")`;\n    }\n    static _writeStringSize(str) {\n        return (4 + 2 * str.length);\n    }\n    static _writeString(b, str, offset) {\n        const len = str.length;\n        buffer.writeUInt32BE(b, len, offset);\n        offset += 4;\n        for (let i = 0; i < len; i++) {\n            buffer.writeUInt16LE(b, str.charCodeAt(i), offset);\n            offset += 2;\n        }\n        return offset;\n    }\n    static _readString(b, offset) {\n        const len = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        return decodeUTF16LE(b, offset, len);\n    }\n    writeSize() {\n        return (+4 // oldPosition\n            + 4 // newPosition\n            + TextChange._writeStringSize(this.oldText)\n            + TextChange._writeStringSize(this.newText));\n    }\n    write(b, offset) {\n        buffer.writeUInt32BE(b, this.oldPosition, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.newPosition, offset);\n        offset += 4;\n        offset = TextChange._writeString(b, this.oldText, offset);\n        offset = TextChange._writeString(b, this.newText, offset);\n        return offset;\n    }\n    static read(b, offset, dest) {\n        const oldPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const newPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const oldText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(oldText);\n        const newText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(newText);\n        dest.push(new TextChange(oldPosition, oldText, newPosition, newText));\n        return offset;\n    }\n}\nexport function compressConsecutiveTextChanges(prevEdits, currEdits) {\n    if (prevEdits === null || prevEdits.length === 0) {\n        return currEdits;\n    }\n    const compressor = new TextChangeCompressor(prevEdits, currEdits);\n    return compressor.compress();\n}\nclass TextChangeCompressor {\n    constructor(prevEdits, currEdits) {\n        this._prevEdits = prevEdits;\n        this._currEdits = currEdits;\n        this._result = [];\n        this._resultLen = 0;\n        this._prevLen = this._prevEdits.length;\n        this._prevDeltaOffset = 0;\n        this._currLen = this._currEdits.length;\n        this._currDeltaOffset = 0;\n    }\n    compress() {\n        let prevIndex = 0;\n        let currIndex = 0;\n        let prevEdit = this._getPrev(prevIndex);\n        let currEdit = this._getCurr(currIndex);\n        while (prevIndex < this._prevLen || currIndex < this._currLen) {\n            if (prevEdit === null) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (currEdit === null) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldEnd <= prevEdit.newPosition) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (prevEdit.newEnd <= currEdit.oldPosition) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldPosition < prevEdit.newPosition) {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newPosition - currEdit.oldPosition);\n                this._acceptCurr(e1);\n                currEdit = e2;\n                continue;\n            }\n            if (prevEdit.newPosition < currEdit.oldPosition) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldPosition - prevEdit.newPosition);\n                this._acceptPrev(e1);\n                prevEdit = e2;\n                continue;\n            }\n            // At this point, currEdit.oldPosition === prevEdit.newPosition\n            let mergePrev;\n            let mergeCurr;\n            if (currEdit.oldEnd === prevEdit.newEnd) {\n                mergePrev = prevEdit;\n                mergeCurr = currEdit;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = this._getCurr(++currIndex);\n            }\n            else if (currEdit.oldEnd < prevEdit.newEnd) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldLength);\n                mergePrev = e1;\n                mergeCurr = currEdit;\n                prevEdit = e2;\n                currEdit = this._getCurr(++currIndex);\n            }\n            else {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newLength);\n                mergePrev = prevEdit;\n                mergeCurr = e1;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = e2;\n            }\n            this._result[this._resultLen++] = new TextChange(mergePrev.oldPosition, mergePrev.oldText, mergeCurr.newPosition, mergeCurr.newText);\n            this._prevDeltaOffset += mergePrev.newLength - mergePrev.oldLength;\n            this._currDeltaOffset += mergeCurr.newLength - mergeCurr.oldLength;\n        }\n        const merged = TextChangeCompressor._merge(this._result);\n        const cleaned = TextChangeCompressor._removeNoOps(merged);\n        return cleaned;\n    }\n    _acceptCurr(currEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebaseCurr(this._prevDeltaOffset, currEdit);\n        this._currDeltaOffset += currEdit.newLength - currEdit.oldLength;\n    }\n    _getCurr(currIndex) {\n        return (currIndex < this._currLen ? this._currEdits[currIndex] : null);\n    }\n    _acceptPrev(prevEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebasePrev(this._currDeltaOffset, prevEdit);\n        this._prevDeltaOffset += prevEdit.newLength - prevEdit.oldLength;\n    }\n    _getPrev(prevIndex) {\n        return (prevIndex < this._prevLen ? this._prevEdits[prevIndex] : null);\n    }\n    static _rebaseCurr(prevDeltaOffset, currEdit) {\n        return new TextChange(currEdit.oldPosition - prevDeltaOffset, currEdit.oldText, currEdit.newPosition, currEdit.newText);\n    }\n    static _rebasePrev(currDeltaOffset, prevEdit) {\n        return new TextChange(prevEdit.oldPosition, prevEdit.oldText, prevEdit.newPosition + currDeltaOffset, prevEdit.newText);\n    }\n    static _splitPrev(edit, offset) {\n        const preText = edit.newText.substr(0, offset);\n        const postText = edit.newText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, edit.oldText, edit.newPosition, preText),\n            new TextChange(edit.oldEnd, '', edit.newPosition + offset, postText)\n        ];\n    }\n    static _splitCurr(edit, offset) {\n        const preText = edit.oldText.substr(0, offset);\n        const postText = edit.oldText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, preText, edit.newPosition, edit.newText),\n            new TextChange(edit.oldPosition + offset, postText, edit.newEnd, '')\n        ];\n    }\n    static _merge(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        let prev = edits[0];\n        for (let i = 1; i < edits.length; i++) {\n            const curr = edits[i];\n            if (prev.oldEnd === curr.oldPosition) {\n                // Merge into `prev`\n                prev = new TextChange(prev.oldPosition, prev.oldText + curr.oldText, prev.newPosition, prev.newText + curr.newText);\n            }\n            else {\n                result[resultLen++] = prev;\n                prev = curr;\n            }\n        }\n        result[resultLen++] = prev;\n        return result;\n    }\n    static _removeNoOps(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0; i < edits.length; i++) {\n            const edit = edits[i];\n            if (edit.oldText === edit.newText) {\n                continue;\n            }\n            result[resultLen++] = edit;\n        }\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const EDITOR_MODEL_DEFAULTS = {\n    tabSize: 4,\n    indentSize: 4,\n    insertSpaces: true,\n    detectIndentation: true,\n    trimAutoWhitespace: true,\n    largeFileOptimizations: true,\n    bracketPairColorizationOptions: {\n        enabled: true,\n        independentColorPoolPerBracketType: false,\n    },\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CharacterClassifier } from './characterClassifier.js';\nexport class WordCharacterClassifier extends CharacterClassifier {\n    constructor(wordSeparators) {\n        super(0 /* WordCharacterClass.Regular */);\n        for (let i = 0, len = wordSeparators.length; i < len; i++) {\n            this.set(wordSeparators.charCodeAt(i), 2 /* WordCharacterClass.WordSeparator */);\n        }\n        this.set(32 /* CharCode.Space */, 1 /* WordCharacterClass.Whitespace */);\n        this.set(9 /* CharCode.Tab */, 1 /* WordCharacterClass.Whitespace */);\n    }\n}\nfunction once(computeFn) {\n    const cache = {}; // TODO@Alex unbounded cache\n    return (input) => {\n        if (!cache.hasOwnProperty(input)) {\n            cache[input] = computeFn(input);\n        }\n        return cache[input];\n    };\n}\nexport const getMapForWordSeparators = once((input) => new WordCharacterClassifier(input));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Iterable } from '../../../base/common/iterator.js';\nimport { LinkedList } from '../../../base/common/linkedList.js';\nexport const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n/**\n * Create a word definition regular expression based on default word separators.\n * Optionally provide allowed separators that should be included in words.\n *\n * The default would look like this:\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n */\nfunction createWordRegExp(allowInWords = '') {\n    let source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n    for (const sep of USUAL_WORD_SEPARATORS) {\n        if (allowInWords.indexOf(sep) >= 0) {\n            continue;\n        }\n        source += '\\\\' + sep;\n    }\n    source += '\\\\s]+)';\n    return new RegExp(source, 'g');\n}\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\nexport const DEFAULT_WORD_REGEXP = createWordRegExp();\nexport function ensureValidWordDefinition(wordDefinition) {\n    let result = DEFAULT_WORD_REGEXP;\n    if (wordDefinition && (wordDefinition instanceof RegExp)) {\n        if (!wordDefinition.global) {\n            let flags = 'g';\n            if (wordDefinition.ignoreCase) {\n                flags += 'i';\n            }\n            if (wordDefinition.multiline) {\n                flags += 'm';\n            }\n            if (wordDefinition.unicode) {\n                flags += 'u';\n            }\n            result = new RegExp(wordDefinition.source, flags);\n        }\n        else {\n            result = wordDefinition;\n        }\n    }\n    result.lastIndex = 0;\n    return result;\n}\nconst _defaultConfig = new LinkedList();\n_defaultConfig.unshift({\n    maxLen: 1000,\n    windowSize: 15,\n    timeBudget: 150\n});\nexport function getWordAtText(column, wordDefinition, text, textOffset, config) {\n    if (!config) {\n        config = Iterable.first(_defaultConfig);\n    }\n    if (text.length > config.maxLen) {\n        // don't throw strings that long at the regexp\n        // but use a sub-string in which a word must occur\n        let start = column - config.maxLen / 2;\n        if (start < 0) {\n            start = 0;\n        }\n        else {\n            textOffset += start;\n        }\n        text = text.substring(start, column + config.maxLen / 2);\n        return getWordAtText(column, wordDefinition, text, textOffset, config);\n    }\n    const t1 = Date.now();\n    const pos = column - 1 - textOffset;\n    let prevRegexIndex = -1;\n    let match = null;\n    for (let i = 1;; i++) {\n        // check time budget\n        if (Date.now() - t1 >= config.timeBudget) {\n            break;\n        }\n        // reset the index at which the regexp should start matching, also know where it\n        // should stop so that subsequent search don't repeat previous searches\n        const regexIndex = pos - config.windowSize * i;\n        wordDefinition.lastIndex = Math.max(0, regexIndex);\n        const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\n        if (!thisMatch && match) {\n            // stop: we have something\n            break;\n        }\n        match = thisMatch;\n        // stop: searched at start\n        if (regexIndex <= 0) {\n            break;\n        }\n        prevRegexIndex = regexIndex;\n    }\n    if (match) {\n        const result = {\n            word: match[0],\n            startColumn: textOffset + 1 + match.index,\n            endColumn: textOffset + 1 + match.index + match[0].length\n        };\n        wordDefinition.lastIndex = 0;\n        return result;\n    }\n    return null;\n}\nfunction _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {\n    let match;\n    while (match = wordDefinition.exec(text)) {\n        const matchIndex = match.index || 0;\n        if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n            return match;\n        }\n        else if (stopPos > 0 && matchIndex > stopPos) {\n            return null;\n        }\n    }\n    return null;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorState, SingleCursorState } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\n/**\n * Represents a single cursor.\n*/\nexport class Cursor {\n    constructor(context) {\n        this._selTrackedRange = null;\n        this._trackSelection = true;\n        this._setState(context, new SingleCursorState(new Range(1, 1, 1, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(1, 1), 0), new SingleCursorState(new Range(1, 1, 1, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(1, 1), 0));\n    }\n    dispose(context) {\n        this._removeTrackedRange(context);\n    }\n    startTrackingSelection(context) {\n        this._trackSelection = true;\n        this._updateTrackedRange(context);\n    }\n    stopTrackingSelection(context) {\n        this._trackSelection = false;\n        this._removeTrackedRange(context);\n    }\n    _updateTrackedRange(context) {\n        if (!this._trackSelection) {\n            // don't track the selection\n            return;\n        }\n        this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, this.modelState.selection, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n    }\n    _removeTrackedRange(context) {\n        this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, null, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n    }\n    asCursorState() {\n        return new CursorState(this.modelState, this.viewState);\n    }\n    readSelectionFromMarkers(context) {\n        const range = context.model._getTrackedRange(this._selTrackedRange);\n        if (this.modelState.selection.isEmpty() && !range.isEmpty()) {\n            // Avoid selecting text when recovering from markers\n            return Selection.fromRange(range.collapseToEnd(), this.modelState.selection.getDirection());\n        }\n        return Selection.fromRange(range, this.modelState.selection.getDirection());\n    }\n    ensureValidState(context) {\n        this._setState(context, this.modelState, this.viewState);\n    }\n    setState(context, modelState, viewState) {\n        this._setState(context, modelState, viewState);\n    }\n    static _validatePositionWithCache(viewModel, position, cacheInput, cacheOutput) {\n        if (position.equals(cacheInput)) {\n            return cacheOutput;\n        }\n        return viewModel.normalizePosition(position, 2 /* PositionAffinity.None */);\n    }\n    static _validateViewState(viewModel, viewState) {\n        const position = viewState.position;\n        const sStartPosition = viewState.selectionStart.getStartPosition();\n        const sEndPosition = viewState.selectionStart.getEndPosition();\n        const validPosition = viewModel.normalizePosition(position, 2 /* PositionAffinity.None */);\n        const validSStartPosition = this._validatePositionWithCache(viewModel, sStartPosition, position, validPosition);\n        const validSEndPosition = this._validatePositionWithCache(viewModel, sEndPosition, sStartPosition, validSStartPosition);\n        if (position.equals(validPosition) && sStartPosition.equals(validSStartPosition) && sEndPosition.equals(validSEndPosition)) {\n            // fast path: the state is valid\n            return viewState;\n        }\n        return new SingleCursorState(Range.fromPositions(validSStartPosition, validSEndPosition), viewState.selectionStartKind, viewState.selectionStartLeftoverVisibleColumns + sStartPosition.column - validSStartPosition.column, validPosition, viewState.leftoverVisibleColumns + position.column - validPosition.column);\n    }\n    _setState(context, modelState, viewState) {\n        if (viewState) {\n            viewState = Cursor._validateViewState(context.viewModel, viewState);\n        }\n        if (!modelState) {\n            if (!viewState) {\n                return;\n            }\n            // We only have the view state => compute the model state\n            const selectionStart = context.model.validateRange(context.coordinatesConverter.convertViewRangeToModelRange(viewState.selectionStart));\n            const position = context.model.validatePosition(context.coordinatesConverter.convertViewPositionToModelPosition(viewState.position));\n            modelState = new SingleCursorState(selectionStart, viewState.selectionStartKind, viewState.selectionStartLeftoverVisibleColumns, position, viewState.leftoverVisibleColumns);\n        }\n        else {\n            // Validate new model state\n            const selectionStart = context.model.validateRange(modelState.selectionStart);\n            const selectionStartLeftoverVisibleColumns = modelState.selectionStart.equalsRange(selectionStart) ? modelState.selectionStartLeftoverVisibleColumns : 0;\n            const position = context.model.validatePosition(modelState.position);\n            const leftoverVisibleColumns = modelState.position.equals(position) ? modelState.leftoverVisibleColumns : 0;\n            modelState = new SingleCursorState(selectionStart, modelState.selectionStartKind, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns);\n        }\n        if (!viewState) {\n            // We only have the model state => compute the view state\n            const viewSelectionStart1 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.startLineNumber, modelState.selectionStart.startColumn));\n            const viewSelectionStart2 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.endLineNumber, modelState.selectionStart.endColumn));\n            const viewSelectionStart = new Range(viewSelectionStart1.lineNumber, viewSelectionStart1.column, viewSelectionStart2.lineNumber, viewSelectionStart2.column);\n            const viewPosition = context.coordinatesConverter.convertModelPositionToViewPosition(modelState.position);\n            viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartKind, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n        }\n        else {\n            // Validate new view state\n            const viewSelectionStart = context.coordinatesConverter.validateViewRange(viewState.selectionStart, modelState.selectionStart);\n            const viewPosition = context.coordinatesConverter.validateViewPosition(viewState.position, modelState.position);\n            viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartKind, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n        }\n        this.modelState = modelState;\n        this.viewState = viewState;\n        this._updateTrackedRange(context);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { compareBy, findLastMaxBy, findMinBy } from '../../../base/common/arrays.js';\nimport { CursorState } from '../cursorCommon.js';\nimport { Cursor } from './oneCursor.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nexport class CursorCollection {\n    constructor(context) {\n        this.context = context;\n        this.cursors = [new Cursor(context)];\n        this.lastAddedCursorIndex = 0;\n    }\n    dispose() {\n        for (const cursor of this.cursors) {\n            cursor.dispose(this.context);\n        }\n    }\n    startTrackingSelections() {\n        for (const cursor of this.cursors) {\n            cursor.startTrackingSelection(this.context);\n        }\n    }\n    stopTrackingSelections() {\n        for (const cursor of this.cursors) {\n            cursor.stopTrackingSelection(this.context);\n        }\n    }\n    updateContext(context) {\n        this.context = context;\n    }\n    ensureValidState() {\n        for (const cursor of this.cursors) {\n            cursor.ensureValidState(this.context);\n        }\n    }\n    readSelectionFromMarkers() {\n        return this.cursors.map(c => c.readSelectionFromMarkers(this.context));\n    }\n    getAll() {\n        return this.cursors.map(c => c.asCursorState());\n    }\n    getViewPositions() {\n        return this.cursors.map(c => c.viewState.position);\n    }\n    getTopMostViewPosition() {\n        return findMinBy(this.cursors, compareBy(c => c.viewState.position, Position.compare)).viewState.position;\n    }\n    getBottomMostViewPosition() {\n        return findLastMaxBy(this.cursors, compareBy(c => c.viewState.position, Position.compare)).viewState.position;\n    }\n    getSelections() {\n        return this.cursors.map(c => c.modelState.selection);\n    }\n    getViewSelections() {\n        return this.cursors.map(c => c.viewState.selection);\n    }\n    setSelections(selections) {\n        this.setStates(CursorState.fromModelSelections(selections));\n    }\n    getPrimaryCursor() {\n        return this.cursors[0].asCursorState();\n    }\n    setStates(states) {\n        if (states === null) {\n            return;\n        }\n        this.cursors[0].setState(this.context, states[0].modelState, states[0].viewState);\n        this._setSecondaryStates(states.slice(1));\n    }\n    /**\n     * Creates or disposes secondary cursors as necessary to match the number of `secondarySelections`.\n     */\n    _setSecondaryStates(secondaryStates) {\n        const secondaryCursorsLength = this.cursors.length - 1;\n        const secondaryStatesLength = secondaryStates.length;\n        if (secondaryCursorsLength < secondaryStatesLength) {\n            const createCnt = secondaryStatesLength - secondaryCursorsLength;\n            for (let i = 0; i < createCnt; i++) {\n                this._addSecondaryCursor();\n            }\n        }\n        else if (secondaryCursorsLength > secondaryStatesLength) {\n            const removeCnt = secondaryCursorsLength - secondaryStatesLength;\n            for (let i = 0; i < removeCnt; i++) {\n                this._removeSecondaryCursor(this.cursors.length - 2);\n            }\n        }\n        for (let i = 0; i < secondaryStatesLength; i++) {\n            this.cursors[i + 1].setState(this.context, secondaryStates[i].modelState, secondaryStates[i].viewState);\n        }\n    }\n    killSecondaryCursors() {\n        this._setSecondaryStates([]);\n    }\n    _addSecondaryCursor() {\n        this.cursors.push(new Cursor(this.context));\n        this.lastAddedCursorIndex = this.cursors.length - 1;\n    }\n    getLastAddedCursorIndex() {\n        if (this.cursors.length === 1 || this.lastAddedCursorIndex === 0) {\n            return 0;\n        }\n        return this.lastAddedCursorIndex;\n    }\n    _removeSecondaryCursor(removeIndex) {\n        if (this.lastAddedCursorIndex >= removeIndex + 1) {\n            this.lastAddedCursorIndex--;\n        }\n        this.cursors[removeIndex + 1].dispose(this.context);\n        this.cursors.splice(removeIndex + 1, 1);\n    }\n    normalize() {\n        if (this.cursors.length === 1) {\n            return;\n        }\n        const cursors = this.cursors.slice(0);\n        const sortedCursors = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            sortedCursors.push({\n                index: i,\n                selection: cursors[i].modelState.selection,\n            });\n        }\n        sortedCursors.sort(compareBy(s => s.selection, Range.compareRangesUsingStarts));\n        for (let sortedCursorIndex = 0; sortedCursorIndex < sortedCursors.length - 1; sortedCursorIndex++) {\n            const current = sortedCursors[sortedCursorIndex];\n            const next = sortedCursors[sortedCursorIndex + 1];\n            const currentSelection = current.selection;\n            const nextSelection = next.selection;\n            if (!this.context.cursorConfig.multiCursorMergeOverlapping) {\n                continue;\n            }\n            let shouldMergeCursors;\n            if (nextSelection.isEmpty() || currentSelection.isEmpty()) {\n                // Merge touching cursors if one of them is collapsed\n                shouldMergeCursors = nextSelection.getStartPosition().isBeforeOrEqual(currentSelection.getEndPosition());\n            }\n            else {\n                // Merge only overlapping cursors (i.e. allow touching ranges)\n                shouldMergeCursors = nextSelection.getStartPosition().isBefore(currentSelection.getEndPosition());\n            }\n            if (shouldMergeCursors) {\n                const winnerSortedCursorIndex = current.index < next.index ? sortedCursorIndex : sortedCursorIndex + 1;\n                const looserSortedCursorIndex = current.index < next.index ? sortedCursorIndex + 1 : sortedCursorIndex;\n                const looserIndex = sortedCursors[looserSortedCursorIndex].index;\n                const winnerIndex = sortedCursors[winnerSortedCursorIndex].index;\n                const looserSelection = sortedCursors[looserSortedCursorIndex].selection;\n                const winnerSelection = sortedCursors[winnerSortedCursorIndex].selection;\n                if (!looserSelection.equalsSelection(winnerSelection)) {\n                    const resultingRange = looserSelection.plusRange(winnerSelection);\n                    const looserSelectionIsLTR = (looserSelection.selectionStartLineNumber === looserSelection.startLineNumber && looserSelection.selectionStartColumn === looserSelection.startColumn);\n                    const winnerSelectionIsLTR = (winnerSelection.selectionStartLineNumber === winnerSelection.startLineNumber && winnerSelection.selectionStartColumn === winnerSelection.startColumn);\n                    // Give more importance to the last added cursor (think Ctrl-dragging + hitting another cursor)\n                    let resultingSelectionIsLTR;\n                    if (looserIndex === this.lastAddedCursorIndex) {\n                        resultingSelectionIsLTR = looserSelectionIsLTR;\n                        this.lastAddedCursorIndex = winnerIndex;\n                    }\n                    else {\n                        // Winner takes it all\n                        resultingSelectionIsLTR = winnerSelectionIsLTR;\n                    }\n                    let resultingSelection;\n                    if (resultingSelectionIsLTR) {\n                        resultingSelection = new Selection(resultingRange.startLineNumber, resultingRange.startColumn, resultingRange.endLineNumber, resultingRange.endColumn);\n                    }\n                    else {\n                        resultingSelection = new Selection(resultingRange.endLineNumber, resultingRange.endColumn, resultingRange.startLineNumber, resultingRange.startColumn);\n                    }\n                    sortedCursors[winnerSortedCursorIndex].selection = resultingSelection;\n                    const resultingState = CursorState.fromModelSelection(resultingSelection);\n                    cursors[winnerIndex].setState(this.context, resultingState.modelState, resultingState.viewState);\n                }\n                for (const sortedCursor of sortedCursors) {\n                    if (sortedCursor.index > looserIndex) {\n                        sortedCursor.index--;\n                    }\n                }\n                cursors.splice(looserIndex, 1);\n                sortedCursors.splice(looserSortedCursorIndex, 1);\n                this._removeSecondaryCursor(looserIndex - 1);\n                sortedCursorIndex--;\n            }\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class CursorContext {\n    constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n        this._cursorContextBrand = undefined;\n        this.model = model;\n        this.viewModel = viewModel;\n        this.coordinatesConverter = coordinatesConverter;\n        this.cursorConfig = cursorConfig;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorCollection } from './cursorCollection.js';\nimport { CursorState, EditOperationResult } from '../cursorCommon.js';\nimport { CursorContext } from './cursorContext.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { CompositionOutcome, TypeOperations, TypeWithAutoClosingCommand } from './cursorTypeOperations.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ModelInjectedTextChangedEvent } from '../textModelEvents.js';\nimport { ViewCursorStateChangedEvent, ViewRevealRangeRequestEvent } from '../viewEvents.js';\nimport { dispose, Disposable } from '../../../base/common/lifecycle.js';\nimport { CursorStateChangedEvent } from '../viewModelEventDispatcher.js';\nexport class CursorsController extends Disposable {\n    constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n        super();\n        this._model = model;\n        this._knownModelVersionId = this._model.getVersionId();\n        this._viewModel = viewModel;\n        this._coordinatesConverter = coordinatesConverter;\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors = new CursorCollection(this.context);\n        this._hasFocus = false;\n        this._isHandling = false;\n        this._compositionState = null;\n        this._columnSelectData = null;\n        this._autoClosedActions = [];\n        this._prevEditOperationType = 0 /* EditOperationType.Other */;\n    }\n    dispose() {\n        this._cursors.dispose();\n        this._autoClosedActions = dispose(this._autoClosedActions);\n        super.dispose();\n    }\n    updateConfiguration(cursorConfig) {\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors.updateContext(this.context);\n    }\n    onLineMappingChanged(eventsCollector) {\n        if (this._knownModelVersionId !== this._model.getVersionId()) {\n            // There are model change events that I didn't yet receive.\n            //\n            // This can happen when editing the model, and the view model receives the change events first,\n            // and the view model emits line mapping changed events, all before the cursor gets a chance to\n            // recover from markers.\n            //\n            // The model change listener above will be called soon and we'll ensure a valid cursor state there.\n            return;\n        }\n        // Ensure valid state\n        this.setStates(eventsCollector, 'viewModel', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n    }\n    _validateAutoClosedActions() {\n        if (this._autoClosedActions.length > 0) {\n            const selections = this._cursors.getSelections();\n            for (let i = 0; i < this._autoClosedActions.length; i++) {\n                const autoClosedAction = this._autoClosedActions[i];\n                if (!autoClosedAction.isValid(selections)) {\n                    autoClosedAction.dispose();\n                    this._autoClosedActions.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n    }\n    // ------ some getters/setters\n    getPrimaryCursorState() {\n        return this._cursors.getPrimaryCursor();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursors.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursors.getAll();\n    }\n    setStates(eventsCollector, source, reason, states) {\n        let reachedMaxCursorCount = false;\n        const multiCursorLimit = this.context.cursorConfig.multiCursorLimit;\n        if (states !== null && states.length > multiCursorLimit) {\n            states = states.slice(0, multiCursorLimit);\n            reachedMaxCursorCount = true;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.setStates(states);\n        this._cursors.normalize();\n        this._columnSelectData = null;\n        this._validateAutoClosedActions();\n        return this._emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount);\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._columnSelectData = columnSelectData;\n    }\n    revealPrimary(eventsCollector, source, minimalReveal, verticalType, revealHorizontal, scrollType) {\n        const viewPositions = this._cursors.getViewPositions();\n        let revealViewRange = null;\n        let revealViewSelections = null;\n        if (viewPositions.length > 1) {\n            revealViewSelections = this._cursors.getViewSelections();\n        }\n        else {\n            revealViewRange = Range.fromPositions(viewPositions[0], viewPositions[0]);\n        }\n        eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, revealViewRange, revealViewSelections, verticalType, revealHorizontal, scrollType));\n    }\n    saveState() {\n        const result = [];\n        const selections = this._cursors.getSelections();\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            result.push({\n                inSelectionMode: !selection.isEmpty(),\n                selectionStart: {\n                    lineNumber: selection.selectionStartLineNumber,\n                    column: selection.selectionStartColumn,\n                },\n                position: {\n                    lineNumber: selection.positionLineNumber,\n                    column: selection.positionColumn,\n                }\n            });\n        }\n        return result;\n    }\n    restoreState(eventsCollector, states) {\n        const desiredSelections = [];\n        for (let i = 0, len = states.length; i < len; i++) {\n            const state = states[i];\n            let positionLineNumber = 1;\n            let positionColumn = 1;\n            // Avoid missing properties on the literal\n            if (state.position && state.position.lineNumber) {\n                positionLineNumber = state.position.lineNumber;\n            }\n            if (state.position && state.position.column) {\n                positionColumn = state.position.column;\n            }\n            let selectionStartLineNumber = positionLineNumber;\n            let selectionStartColumn = positionColumn;\n            // Avoid missing properties on the literal\n            if (state.selectionStart && state.selectionStart.lineNumber) {\n                selectionStartLineNumber = state.selectionStart.lineNumber;\n            }\n            if (state.selectionStart && state.selectionStart.column) {\n                selectionStartColumn = state.selectionStart.column;\n            }\n            desiredSelections.push({\n                selectionStartLineNumber: selectionStartLineNumber,\n                selectionStartColumn: selectionStartColumn,\n                positionLineNumber: positionLineNumber,\n                positionColumn: positionColumn\n            });\n        }\n        this.setStates(eventsCollector, 'restoreState', 0 /* CursorChangeReason.NotSet */, CursorState.fromModelSelections(desiredSelections));\n        this.revealPrimary(eventsCollector, 'restoreState', false, 0 /* VerticalRevealType.Simple */, true, 1 /* editorCommon.ScrollType.Immediate */);\n    }\n    onModelContentChanged(eventsCollector, event) {\n        if (event instanceof ModelInjectedTextChangedEvent) {\n            // If injected texts change, the view positions of all cursors need to be updated.\n            if (this._isHandling) {\n                // The view positions will be updated when handling finishes\n                return;\n            }\n            // setStates might remove markers, which could trigger a decoration change.\n            // If there are injected text decorations for that line, `onModelContentChanged` is emitted again\n            // and an endless recursion happens.\n            // _isHandling prevents that.\n            this._isHandling = true;\n            try {\n                this.setStates(eventsCollector, 'modelChange', 0 /* CursorChangeReason.NotSet */, this.getCursorStates());\n            }\n            finally {\n                this._isHandling = false;\n            }\n        }\n        else {\n            const e = event.rawContentChangedEvent;\n            this._knownModelVersionId = e.versionId;\n            if (this._isHandling) {\n                return;\n            }\n            const hadFlushEvent = e.containsEvent(1 /* RawContentChangedType.Flush */);\n            this._prevEditOperationType = 0 /* EditOperationType.Other */;\n            if (hadFlushEvent) {\n                // a model.setValue() was called\n                this._cursors.dispose();\n                this._cursors = new CursorCollection(this.context);\n                this._validateAutoClosedActions();\n                this._emitStateChangedIfNecessary(eventsCollector, 'model', 1 /* CursorChangeReason.ContentFlush */, null, false);\n            }\n            else {\n                if (this._hasFocus && e.resultingSelection && e.resultingSelection.length > 0) {\n                    const cursorState = CursorState.fromModelSelections(e.resultingSelection);\n                    if (this.setStates(eventsCollector, 'modelChange', e.isUndoing ? 5 /* CursorChangeReason.Undo */ : e.isRedoing ? 6 /* CursorChangeReason.Redo */ : 2 /* CursorChangeReason.RecoverFromMarkers */, cursorState)) {\n                        this.revealPrimary(eventsCollector, 'modelChange', false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n                    }\n                }\n                else {\n                    const selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\n                    this.setStates(eventsCollector, 'modelChange', 2 /* CursorChangeReason.RecoverFromMarkers */, CursorState.fromModelSelections(selectionsFromMarkers));\n                }\n            }\n        }\n    }\n    getSelection() {\n        return this._cursors.getPrimaryCursor().modelState.selection;\n    }\n    getTopMostViewPosition() {\n        return this._cursors.getTopMostViewPosition();\n    }\n    getBottomMostViewPosition() {\n        return this._cursors.getBottomMostViewPosition();\n    }\n    getCursorColumnSelectData() {\n        if (this._columnSelectData) {\n            return this._columnSelectData;\n        }\n        const primaryCursor = this._cursors.getPrimaryCursor();\n        const viewSelectionStart = primaryCursor.viewState.selectionStart.getStartPosition();\n        const viewPosition = primaryCursor.viewState.position;\n        return {\n            isReal: false,\n            fromViewLineNumber: viewSelectionStart.lineNumber,\n            fromViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewSelectionStart),\n            toViewLineNumber: viewPosition.lineNumber,\n            toViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewPosition),\n        };\n    }\n    getSelections() {\n        return this._cursors.getSelections();\n    }\n    setSelections(eventsCollector, source, selections, reason) {\n        this.setStates(eventsCollector, source, reason, CursorState.fromModelSelections(selections));\n    }\n    getPrevEditOperationType() {\n        return this._prevEditOperationType;\n    }\n    setPrevEditOperationType(type) {\n        this._prevEditOperationType = type;\n    }\n    // ------ auxiliary handling logic\n    _pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges) {\n        const autoClosedCharactersDeltaDecorations = [];\n        const autoClosedEnclosingDeltaDecorations = [];\n        for (let i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {\n            autoClosedCharactersDeltaDecorations.push({\n                range: autoClosedCharactersRanges[i],\n                options: {\n                    description: 'auto-closed-character',\n                    inlineClassName: 'auto-closed-character',\n                    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n                }\n            });\n            autoClosedEnclosingDeltaDecorations.push({\n                range: autoClosedEnclosingRanges[i],\n                options: {\n                    description: 'auto-closed-enclosing',\n                    stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n                }\n            });\n        }\n        const autoClosedCharactersDecorations = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);\n        const autoClosedEnclosingDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);\n        this._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations));\n    }\n    _executeEditOperation(opResult) {\n        if (!opResult) {\n            // Nothing to execute\n            return;\n        }\n        if (opResult.shouldPushStackElementBefore) {\n            this._model.pushStackElement();\n        }\n        const result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);\n        if (result) {\n            // The commands were applied correctly\n            this._interpretCommandResult(result);\n            // Check for auto-closing closed characters\n            const autoClosedCharactersRanges = [];\n            const autoClosedEnclosingRanges = [];\n            for (let i = 0; i < opResult.commands.length; i++) {\n                const command = opResult.commands[i];\n                if (command instanceof TypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange) {\n                    autoClosedCharactersRanges.push(command.closeCharacterRange);\n                    autoClosedEnclosingRanges.push(command.enclosingRange);\n                }\n            }\n            if (autoClosedCharactersRanges.length > 0) {\n                this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n            }\n            this._prevEditOperationType = opResult.type;\n        }\n        if (opResult.shouldPushStackElementAfter) {\n            this._model.pushStackElement();\n        }\n    }\n    _interpretCommandResult(cursorState) {\n        if (!cursorState || cursorState.length === 0) {\n            cursorState = this._cursors.readSelectionFromMarkers();\n        }\n        this._columnSelectData = null;\n        this._cursors.setSelections(cursorState);\n        this._cursors.normalize();\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- emitting events\n    _emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount) {\n        const newState = CursorModelState.from(this._model, this);\n        if (newState.equals(oldState)) {\n            return false;\n        }\n        const selections = this._cursors.getSelections();\n        const viewSelections = this._cursors.getViewSelections();\n        // Let the view get the event first.\n        eventsCollector.emitViewEvent(new ViewCursorStateChangedEvent(viewSelections, selections, reason));\n        // Only after the view has been notified, let the rest of the world know...\n        if (!oldState\n            || oldState.cursorState.length !== newState.cursorState.length\n            || newState.cursorState.some((newCursorState, i) => !newCursorState.modelState.equals(oldState.cursorState[i].modelState))) {\n            const oldSelections = oldState ? oldState.cursorState.map(s => s.modelState.selection) : null;\n            const oldModelVersionId = oldState ? oldState.modelVersionId : 0;\n            eventsCollector.emitOutgoingEvent(new CursorStateChangedEvent(oldSelections, selections, oldModelVersionId, newState.modelVersionId, source || 'keyboard', reason, reachedMaxCursorCount));\n        }\n        return true;\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- handlers beyond this point\n    _findAutoClosingPairs(edits) {\n        if (!edits.length) {\n            return null;\n        }\n        const indices = [];\n        for (let i = 0, len = edits.length; i < len; i++) {\n            const edit = edits[i];\n            if (!edit.text || edit.text.indexOf('\\n') >= 0) {\n                return null;\n            }\n            const m = edit.text.match(/([)\\]}>'\"`])([^)\\]}>'\"`]*)$/);\n            if (!m) {\n                return null;\n            }\n            const closeChar = m[1];\n            const autoClosingPairsCandidates = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(closeChar);\n            if (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {\n                return null;\n            }\n            const openChar = autoClosingPairsCandidates[0].open;\n            const closeCharIndex = edit.text.length - m[2].length - 1;\n            const openCharIndex = edit.text.lastIndexOf(openChar, closeCharIndex - 1);\n            if (openCharIndex === -1) {\n                return null;\n            }\n            indices.push([openCharIndex, closeCharIndex]);\n        }\n        return indices;\n    }\n    executeEdits(eventsCollector, source, edits, cursorStateComputer) {\n        let autoClosingIndices = null;\n        if (source === 'snippet') {\n            autoClosingIndices = this._findAutoClosingPairs(edits);\n        }\n        if (autoClosingIndices) {\n            edits[0]._isTracked = true;\n        }\n        const autoClosedCharactersRanges = [];\n        const autoClosedEnclosingRanges = [];\n        const selections = this._model.pushEditOperations(this.getSelections(), edits, (undoEdits) => {\n            if (autoClosingIndices) {\n                for (let i = 0, len = autoClosingIndices.length; i < len; i++) {\n                    const [openCharInnerIndex, closeCharInnerIndex] = autoClosingIndices[i];\n                    const undoEdit = undoEdits[i];\n                    const lineNumber = undoEdit.range.startLineNumber;\n                    const openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;\n                    const closeCharIndex = undoEdit.range.startColumn - 1 + closeCharInnerIndex;\n                    autoClosedCharactersRanges.push(new Range(lineNumber, closeCharIndex + 1, lineNumber, closeCharIndex + 2));\n                    autoClosedEnclosingRanges.push(new Range(lineNumber, openCharIndex + 1, lineNumber, closeCharIndex + 2));\n                }\n            }\n            const selections = cursorStateComputer(undoEdits);\n            if (selections) {\n                // Don't recover the selection from markers because\n                // we know what it should be.\n                this._isHandling = true;\n            }\n            return selections;\n        });\n        if (selections) {\n            this._isHandling = false;\n            this.setSelections(eventsCollector, source, selections, 0 /* CursorChangeReason.NotSet */);\n        }\n        if (autoClosedCharactersRanges.length > 0) {\n            this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n        }\n    }\n    _executeEdit(callback, eventsCollector, source, cursorChangeReason = 0 /* CursorChangeReason.NotSet */) {\n        if (this.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            return;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.stopTrackingSelections();\n        this._isHandling = true;\n        try {\n            this._cursors.ensureValidState();\n            callback();\n        }\n        catch (err) {\n            onUnexpectedError(err);\n        }\n        this._isHandling = false;\n        this._cursors.startTrackingSelections();\n        this._validateAutoClosedActions();\n        if (this._emitStateChangedIfNecessary(eventsCollector, source, cursorChangeReason, oldState, false)) {\n            this.revealPrimary(eventsCollector, source, false, 0 /* VerticalRevealType.Simple */, true, 0 /* editorCommon.ScrollType.Smooth */);\n        }\n    }\n    getAutoClosedCharacters() {\n        return AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\n    }\n    startComposition(eventsCollector) {\n        this._compositionState = new CompositionState(this._model, this.getSelections());\n    }\n    endComposition(eventsCollector, source) {\n        const compositionOutcome = this._compositionState ? this._compositionState.deduceOutcome(this._model, this.getSelections()) : null;\n        this._compositionState = null;\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // composition finishes, let's check if we need to auto complete if necessary.\n                this._executeEditOperation(TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, compositionOutcome, this.getSelections(), this.getAutoClosedCharacters()));\n            }\n        }, eventsCollector, source);\n    }\n    type(eventsCollector, text, source) {\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // If this event is coming straight from the keyboard, look for electric characters and enter\n                const len = text.length;\n                let offset = 0;\n                while (offset < len) {\n                    const charLength = strings.nextCharLength(text, offset);\n                    const chr = text.substr(offset, charLength);\n                    // Here we must interpret each typed character individually\n                    this._executeEditOperation(TypeOperations.typeWithInterceptors(!!this._compositionState, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), chr));\n                    offset += charLength;\n                }\n            }\n            else {\n                this._executeEditOperation(TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text));\n            }\n        }, eventsCollector, source);\n    }\n    compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        if (text.length === 0 && replacePrevCharCnt === 0 && replaceNextCharCnt === 0) {\n            // this edit is a no-op\n            if (positionDelta !== 0) {\n                // but it still wants to move the cursor\n                const newSelections = this.getSelections().map(selection => {\n                    const position = selection.getPosition();\n                    return new Selection(position.lineNumber, position.column + positionDelta, position.lineNumber, position.column + positionDelta);\n                });\n                this.setSelections(eventsCollector, source, newSelections, 0 /* CursorChangeReason.NotSet */);\n            }\n            return;\n        }\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        }, eventsCollector, source);\n    }\n    paste(eventsCollector, text, pasteOnNewLine, multicursorText, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.paste(this.context.cursorConfig, this._model, this.getSelections(), text, pasteOnNewLine, multicursorText || []));\n        }, eventsCollector, source, 4 /* CursorChangeReason.Paste */);\n    }\n    cut(eventsCollector, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(DeleteOperations.cut(this.context.cursorConfig, this._model, this.getSelections()));\n        }, eventsCollector, source);\n    }\n    executeCommand(eventsCollector, command, source) {\n        this._executeEdit(() => {\n            this._cursors.killSecondaryCursors();\n            this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, [command], {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n    executeCommands(eventsCollector, commands, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n}\n/**\n * A snapshot of the cursor and the model state\n */\nclass CursorModelState {\n    static from(model, cursor) {\n        return new CursorModelState(model.getVersionId(), cursor.getCursorStates());\n    }\n    constructor(modelVersionId, cursorState) {\n        this.modelVersionId = modelVersionId;\n        this.cursorState = cursorState;\n    }\n    equals(other) {\n        if (!other) {\n            return false;\n        }\n        if (this.modelVersionId !== other.modelVersionId) {\n            return false;\n        }\n        if (this.cursorState.length !== other.cursorState.length) {\n            return false;\n        }\n        for (let i = 0, len = this.cursorState.length; i < len; i++) {\n            if (!this.cursorState[i].equals(other.cursorState[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass AutoClosedAction {\n    static getAllAutoClosedCharacters(autoClosedActions) {\n        let autoClosedCharacters = [];\n        for (const autoClosedAction of autoClosedActions) {\n            autoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());\n        }\n        return autoClosedCharacters;\n    }\n    constructor(model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations) {\n        this._model = model;\n        this._autoClosedCharactersDecorations = autoClosedCharactersDecorations;\n        this._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;\n    }\n    dispose() {\n        this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);\n        this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);\n    }\n    getAutoClosedCharactersRanges() {\n        const result = [];\n        for (let i = 0; i < this._autoClosedCharactersDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);\n            if (decorationRange) {\n                result.push(decorationRange);\n            }\n        }\n        return result;\n    }\n    isValid(selections) {\n        const enclosingRanges = [];\n        for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);\n            if (decorationRange) {\n                enclosingRanges.push(decorationRange);\n                if (decorationRange.startLineNumber !== decorationRange.endLineNumber) {\n                    // Stop tracking if the range becomes multiline...\n                    return false;\n                }\n            }\n        }\n        enclosingRanges.sort(Range.compareRangesUsingStarts);\n        selections.sort(Range.compareRangesUsingStarts);\n        for (let i = 0; i < selections.length; i++) {\n            if (i >= enclosingRanges.length) {\n                return false;\n            }\n            if (!enclosingRanges[i].strictContainsRange(selections[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass CommandExecutor {\n    static executeCommands(model, selectionsBefore, commands) {\n        const ctx = {\n            model: model,\n            selectionsBefore: selectionsBefore,\n            trackedRanges: [],\n            trackedRangesDirection: []\n        };\n        const result = this._innerExecuteCommands(ctx, commands);\n        for (let i = 0, len = ctx.trackedRanges.length; i < len; i++) {\n            ctx.model._setTrackedRange(ctx.trackedRanges[i], null, 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */);\n        }\n        return result;\n    }\n    static _innerExecuteCommands(ctx, commands) {\n        if (this._arrayIsEmpty(commands)) {\n            return null;\n        }\n        const commandsData = this._getEditOperations(ctx, commands);\n        if (commandsData.operations.length === 0) {\n            return null;\n        }\n        const rawOperations = commandsData.operations;\n        const loserCursorsMap = this._getLoserCursorMap(rawOperations);\n        if (loserCursorsMap.hasOwnProperty('0')) {\n            // These commands are very messed up\n            console.warn('Ignoring commands');\n            return null;\n        }\n        // Remove operations belonging to losing cursors\n        const filteredOperations = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {\n                filteredOperations.push(rawOperations[i]);\n            }\n        }\n        // TODO@Alex: find a better way to do this.\n        // give the hint that edit operations are tracked to the model\n        if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\n            filteredOperations[0]._isTracked = true;\n        }\n        let selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, (inverseEditOperations) => {\n            const groupedInverseEditOperations = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                groupedInverseEditOperations[i] = [];\n            }\n            for (const op of inverseEditOperations) {\n                if (!op.identifier) {\n                    // perhaps auto whitespace trim edits\n                    continue;\n                }\n                groupedInverseEditOperations[op.identifier.major].push(op);\n            }\n            const minorBasedSorter = (a, b) => {\n                return a.identifier.minor - b.identifier.minor;\n            };\n            const cursorSelections = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                if (groupedInverseEditOperations[i].length > 0) {\n                    groupedInverseEditOperations[i].sort(minorBasedSorter);\n                    cursorSelections[i] = commands[i].computeCursorState(ctx.model, {\n                        getInverseEditOperations: () => {\n                            return groupedInverseEditOperations[i];\n                        },\n                        getTrackedSelection: (id) => {\n                            const idx = parseInt(id, 10);\n                            const range = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);\n                            if (ctx.trackedRangesDirection[idx] === 0 /* SelectionDirection.LTR */) {\n                                return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n                            }\n                            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n                        }\n                    });\n                }\n                else {\n                    cursorSelections[i] = ctx.selectionsBefore[i];\n                }\n            }\n            return cursorSelections;\n        });\n        if (!selectionsAfter) {\n            selectionsAfter = ctx.selectionsBefore;\n        }\n        // Extract losing cursors\n        const losingCursors = [];\n        for (const losingCursorIndex in loserCursorsMap) {\n            if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\n                losingCursors.push(parseInt(losingCursorIndex, 10));\n            }\n        }\n        // Sort losing cursors descending\n        losingCursors.sort((a, b) => {\n            return b - a;\n        });\n        // Remove losing cursors\n        for (const losingCursor of losingCursors) {\n            selectionsAfter.splice(losingCursor, 1);\n        }\n        return selectionsAfter;\n    }\n    static _arrayIsEmpty(commands) {\n        for (let i = 0, len = commands.length; i < len; i++) {\n            if (commands[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _getEditOperations(ctx, commands) {\n        let operations = [];\n        let hadTrackedEditOperation = false;\n        for (let i = 0, len = commands.length; i < len; i++) {\n            const command = commands[i];\n            if (command) {\n                const r = this._getEditOperationsFromCommand(ctx, i, command);\n                operations = operations.concat(r.operations);\n                hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\n            }\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getEditOperationsFromCommand(ctx, majorIdentifier, command) {\n        // This method acts as a transaction, if the command fails\n        // everything it has done is ignored\n        const operations = [];\n        let operationMinor = 0;\n        const addEditOperation = (range, text, forceMoveMarkers = false) => {\n            if (Range.isEmpty(range) && text === '') {\n                // This command wants to add a no-op => no thank you\n                return;\n            }\n            operations.push({\n                identifier: {\n                    major: majorIdentifier,\n                    minor: operationMinor++\n                },\n                range: range,\n                text: text,\n                forceMoveMarkers: forceMoveMarkers,\n                isAutoWhitespaceEdit: command.insertsAutoWhitespace\n            });\n        };\n        let hadTrackedEditOperation = false;\n        const addTrackedEditOperation = (selection, text, forceMoveMarkers) => {\n            hadTrackedEditOperation = true;\n            addEditOperation(selection, text, forceMoveMarkers);\n        };\n        const trackSelection = (_selection, trackPreviousOnEmpty) => {\n            const selection = Selection.liftSelection(_selection);\n            let stickiness;\n            if (selection.isEmpty()) {\n                if (typeof trackPreviousOnEmpty === 'boolean') {\n                    if (trackPreviousOnEmpty) {\n                        stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n                else {\n                    // Try to lock it with surrounding text\n                    const maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn === maxLineColumn) {\n                        stickiness = 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n            }\n            else {\n                stickiness = 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */;\n            }\n            const l = ctx.trackedRanges.length;\n            const id = ctx.model._setTrackedRange(null, selection, stickiness);\n            ctx.trackedRanges[l] = id;\n            ctx.trackedRangesDirection[l] = selection.getDirection();\n            return l.toString();\n        };\n        const editOperationBuilder = {\n            addEditOperation: addEditOperation,\n            addTrackedEditOperation: addTrackedEditOperation,\n            trackSelection: trackSelection\n        };\n        try {\n            command.getEditOperations(ctx.model, editOperationBuilder);\n        }\n        catch (e) {\n            // TODO@Alex use notification service if this should be user facing\n            // e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\n            onUnexpectedError(e);\n            return {\n                operations: [],\n                hadTrackedEditOperation: false\n            };\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getLoserCursorMap(operations) {\n        // This is destructive on the array\n        operations = operations.slice(0);\n        // Sort operations with last one first\n        operations.sort((a, b) => {\n            // Note the minus!\n            return -(Range.compareRangesUsingEnds(a.range, b.range));\n        });\n        // Operations can not overlap!\n        const loserCursorsMap = {};\n        for (let i = 1; i < operations.length; i++) {\n            const previousOp = operations[i - 1];\n            const currentOp = operations[i];\n            if (Range.getStartPosition(previousOp.range).isBefore(Range.getEndPosition(currentOp.range))) {\n                let loserMajor;\n                if (previousOp.identifier.major > currentOp.identifier.major) {\n                    // previousOp loses the battle\n                    loserMajor = previousOp.identifier.major;\n                }\n                else {\n                    loserMajor = currentOp.identifier.major;\n                }\n                loserCursorsMap[loserMajor.toString()] = true;\n                for (let j = 0; j < operations.length; j++) {\n                    if (operations[j].identifier.major === loserMajor) {\n                        operations.splice(j, 1);\n                        if (j < i) {\n                            i--;\n                        }\n                        j--;\n                    }\n                }\n                if (i > 0) {\n                    i--;\n                }\n            }\n        }\n        return loserCursorsMap;\n    }\n}\nclass CompositionLineState {\n    constructor(text, startSelection, endSelection) {\n        this.text = text;\n        this.startSelection = startSelection;\n        this.endSelection = endSelection;\n    }\n}\nclass CompositionState {\n    static _capture(textModel, selections) {\n        const result = [];\n        for (const selection of selections) {\n            if (selection.startLineNumber !== selection.endLineNumber) {\n                return null;\n            }\n            result.push(new CompositionLineState(textModel.getLineContent(selection.startLineNumber), selection.startColumn - 1, selection.endColumn - 1));\n        }\n        return result;\n    }\n    constructor(textModel, selections) {\n        this._original = CompositionState._capture(textModel, selections);\n    }\n    /**\n     * Returns the inserted text during this composition.\n     * If the composition resulted in existing text being changed (i.e. not a pure insertion) it returns null.\n     */\n    deduceOutcome(textModel, selections) {\n        if (!this._original) {\n            return null;\n        }\n        const current = CompositionState._capture(textModel, selections);\n        if (!current) {\n            return null;\n        }\n        if (this._original.length !== current.length) {\n            return null;\n        }\n        const result = [];\n        for (let i = 0, len = this._original.length; i < len; i++) {\n            result.push(CompositionState._deduceOutcome(this._original[i], current[i]));\n        }\n        return result;\n    }\n    static _deduceOutcome(original, current) {\n        const commonPrefix = Math.min(original.startSelection, current.startSelection, strings.commonPrefixLength(original.text, current.text));\n        const commonSuffix = Math.min(original.text.length - original.endSelection, current.text.length - current.endSelection, strings.commonSuffixLength(original.text, current.text));\n        const deletedText = original.text.substring(commonPrefix, original.text.length - commonSuffix);\n        const insertedText = current.text.substring(commonPrefix, current.text.length - commonSuffix);\n        return new CompositionOutcome(deletedText, original.startSelection - commonPrefix, original.endSelection - commonPrefix, insertedText, current.startSelection - commonPrefix, current.endSelection - commonPrefix);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorColumns } from '../core/cursorColumns.js';\nexport class AtomicTabMoveOperations {\n    /**\n     * Get the visible column at the position. If we get to a non-whitespace character first\n     * or past the end of string then return -1.\n     *\n     * **Note** `position` and the return value are 0-based.\n     */\n    static whitespaceVisibleColumn(lineContent, position, tabSize) {\n        const lineLength = lineContent.length;\n        let visibleColumn = 0;\n        let prevTabStopPosition = -1;\n        let prevTabStopVisibleColumn = -1;\n        for (let i = 0; i < lineLength; i++) {\n            if (i === position) {\n                return [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn];\n            }\n            if (visibleColumn % tabSize === 0) {\n                prevTabStopPosition = i;\n                prevTabStopVisibleColumn = visibleColumn;\n            }\n            const chCode = lineContent.charCodeAt(i);\n            switch (chCode) {\n                case 32 /* CharCode.Space */:\n                    visibleColumn += 1;\n                    break;\n                case 9 /* CharCode.Tab */:\n                    // Skip to the next multiple of tabSize.\n                    visibleColumn = CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n                    break;\n                default:\n                    return [-1, -1, -1];\n            }\n        }\n        if (position === lineLength) {\n            return [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn];\n        }\n        return [-1, -1, -1];\n    }\n    /**\n     * Return the position that should result from a move left, right or to the\n     * nearest tab, if atomic tabs are enabled. Left and right are used for the\n     * arrow key movements, nearest is used for mouse selection. It returns\n     * -1 if atomic tabs are not relevant and you should fall back to normal\n     * behaviour.\n     *\n     * **Note**: `position` and the return value are 0-based.\n     */\n    static atomicPosition(lineContent, position, tabSize, direction) {\n        const lineLength = lineContent.length;\n        // Get the 0-based visible column corresponding to the position, or return\n        // -1 if it is not in the initial whitespace.\n        const [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn] = AtomicTabMoveOperations.whitespaceVisibleColumn(lineContent, position, tabSize);\n        if (visibleColumn === -1) {\n            return -1;\n        }\n        // Is the output left or right of the current position. The case for nearest\n        // where it is the same as the current position is handled in the switch.\n        let left;\n        switch (direction) {\n            case 0 /* Direction.Left */:\n                left = true;\n                break;\n            case 1 /* Direction.Right */:\n                left = false;\n                break;\n            case 2 /* Direction.Nearest */:\n                // The code below assumes the output position is either left or right\n                // of the input position. If it is the same, return immediately.\n                if (visibleColumn % tabSize === 0) {\n                    return position;\n                }\n                // Go to the nearest indentation.\n                left = visibleColumn % tabSize <= (tabSize / 2);\n                break;\n        }\n        // If going left, we can just use the info about the last tab stop position and\n        // last tab stop visible column that we computed in the first walk over the whitespace.\n        if (left) {\n            if (prevTabStopPosition === -1) {\n                return -1;\n            }\n            // If the direction is left, we need to keep scanning right to ensure\n            // that targetVisibleColumn + tabSize is before non-whitespace.\n            // This is so that when we press left at the end of a partial\n            // indentation it only goes one character. For example '      foo' with\n            // tabSize 4, should jump from position 6 to position 5, not 4.\n            let currentVisibleColumn = prevTabStopVisibleColumn;\n            for (let i = prevTabStopPosition; i < lineLength; ++i) {\n                if (currentVisibleColumn === prevTabStopVisibleColumn + tabSize) {\n                    // It is a full indentation.\n                    return prevTabStopPosition;\n                }\n                const chCode = lineContent.charCodeAt(i);\n                switch (chCode) {\n                    case 32 /* CharCode.Space */:\n                        currentVisibleColumn += 1;\n                        break;\n                    case 9 /* CharCode.Tab */:\n                        currentVisibleColumn = CursorColumns.nextRenderTabStop(currentVisibleColumn, tabSize);\n                        break;\n                    default:\n                        return -1;\n                }\n            }\n            if (currentVisibleColumn === prevTabStopVisibleColumn + tabSize) {\n                return prevTabStopPosition;\n            }\n            // It must have been a partial indentation.\n            return -1;\n        }\n        // We are going right.\n        const targetVisibleColumn = CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        // We can just continue from where whitespaceVisibleColumn got to.\n        let currentVisibleColumn = visibleColumn;\n        for (let i = position; i < lineLength; i++) {\n            if (currentVisibleColumn === targetVisibleColumn) {\n                return i;\n            }\n            const chCode = lineContent.charCodeAt(i);\n            switch (chCode) {\n                case 32 /* CharCode.Space */:\n                    currentVisibleColumn += 1;\n                    break;\n                case 9 /* CharCode.Tab */:\n                    currentVisibleColumn = CursorColumns.nextRenderTabStop(currentVisibleColumn, tabSize);\n                    break;\n                default:\n                    return -1;\n            }\n        }\n        // This condition handles when the target column is at the end of the line.\n        if (currentVisibleColumn === targetVisibleColumn) {\n            return lineLength;\n        }\n        return -1;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class ColumnSelection {\n    static columnSelect(config, model, fromLineNumber, fromVisibleColumn, toLineNumber, toVisibleColumn) {\n        const lineCount = Math.abs(toLineNumber - fromLineNumber) + 1;\n        const reversed = (fromLineNumber > toLineNumber);\n        const isRTL = (fromVisibleColumn > toVisibleColumn);\n        const isLTR = (fromVisibleColumn < toVisibleColumn);\n        const result = [];\n        // console.log(`fromVisibleColumn: ${fromVisibleColumn}, toVisibleColumn: ${toVisibleColumn}`);\n        for (let i = 0; i < lineCount; i++) {\n            const lineNumber = fromLineNumber + (reversed ? -i : i);\n            const startColumn = config.columnFromVisibleColumn(model, lineNumber, fromVisibleColumn);\n            const endColumn = config.columnFromVisibleColumn(model, lineNumber, toVisibleColumn);\n            const visibleStartColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, startColumn));\n            const visibleEndColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, endColumn));\n            // console.log(`lineNumber: ${lineNumber}: visibleStartColumn: ${visibleStartColumn}, visibleEndColumn: ${visibleEndColumn}`);\n            if (isLTR) {\n                if (visibleStartColumn > toVisibleColumn) {\n                    continue;\n                }\n                if (visibleEndColumn < fromVisibleColumn) {\n                    continue;\n                }\n            }\n            if (isRTL) {\n                if (visibleEndColumn > fromVisibleColumn) {\n                    continue;\n                }\n                if (visibleStartColumn < toVisibleColumn) {\n                    continue;\n                }\n            }\n            result.push(new SingleCursorState(new Range(lineNumber, startColumn, lineNumber, startColumn), 0 /* SelectionStartKind.Simple */, 0, new Position(lineNumber, endColumn), 0));\n        }\n        if (result.length === 0) {\n            // We are after all the lines, so add cursor at the end of each line\n            for (let i = 0; i < lineCount; i++) {\n                const lineNumber = fromLineNumber + (reversed ? -i : i);\n                const maxColumn = model.getLineMaxColumn(lineNumber);\n                result.push(new SingleCursorState(new Range(lineNumber, maxColumn, lineNumber, maxColumn), 0 /* SelectionStartKind.Simple */, 0, new Position(lineNumber, maxColumn), 0));\n            }\n        }\n        return {\n            viewStates: result,\n            reversed: reversed,\n            fromLineNumber: fromLineNumber,\n            fromVisualColumn: fromVisibleColumn,\n            toLineNumber: toLineNumber,\n            toVisualColumn: toVisibleColumn\n        };\n    }\n    static columnSelectLeft(config, model, prevColumnSelectData) {\n        let toViewVisualColumn = prevColumnSelectData.toViewVisualColumn;\n        if (toViewVisualColumn > 0) {\n            toViewVisualColumn--;\n        }\n        return ColumnSelection.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, prevColumnSelectData.toViewLineNumber, toViewVisualColumn);\n    }\n    static columnSelectRight(config, model, prevColumnSelectData) {\n        let maxVisualViewColumn = 0;\n        const minViewLineNumber = Math.min(prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.toViewLineNumber);\n        const maxViewLineNumber = Math.max(prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.toViewLineNumber);\n        for (let lineNumber = minViewLineNumber; lineNumber <= maxViewLineNumber; lineNumber++) {\n            const lineMaxViewColumn = model.getLineMaxColumn(lineNumber);\n            const lineMaxVisualViewColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, lineMaxViewColumn));\n            maxVisualViewColumn = Math.max(maxVisualViewColumn, lineMaxVisualViewColumn);\n        }\n        let toViewVisualColumn = prevColumnSelectData.toViewVisualColumn;\n        if (toViewVisualColumn < maxVisualViewColumn) {\n            toViewVisualColumn++;\n        }\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, prevColumnSelectData.toViewLineNumber, toViewVisualColumn);\n    }\n    static columnSelectUp(config, model, prevColumnSelectData, isPaged) {\n        const linesCount = isPaged ? config.pageSize : 1;\n        const toViewLineNumber = Math.max(1, prevColumnSelectData.toViewLineNumber - linesCount);\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, toViewLineNumber, prevColumnSelectData.toViewVisualColumn);\n    }\n    static columnSelectDown(config, model, prevColumnSelectData, isPaged) {\n        const linesCount = isPaged ? config.pageSize : 1;\n        const toViewLineNumber = Math.min(model.getLineCount(), prevColumnSelectData.toViewLineNumber + linesCount);\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, toViewLineNumber, prevColumnSelectData.toViewVisualColumn);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand } from '../commands/replaceCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nexport class DeleteOperations {\n    static deleteRight(prevEditOperationType, config, model, selections) {\n        const commands = [];\n        let shouldPushStackElementBefore = (prevEditOperationType !== 3 /* EditOperationType.DeletingRight */);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            let deleteSelection = selection;\n            if (deleteSelection.isEmpty()) {\n                const position = selection.getPosition();\n                const rightOfPosition = MoveOperations.right(config, model, position);\n                deleteSelection = new Range(rightOfPosition.lineNumber, rightOfPosition.column, position.lineNumber, position.column);\n            }\n            if (deleteSelection.isEmpty()) {\n                // Probably at end of file => ignore\n                commands[i] = null;\n                continue;\n            }\n            if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {\n                shouldPushStackElementBefore = true;\n            }\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n        }\n        return [shouldPushStackElementBefore, commands];\n    }\n    static isAutoClosingPairDelete(autoClosingDelete, autoClosingBrackets, autoClosingQuotes, autoClosingPairsOpen, model, selections, autoClosedCharacters) {\n        if (autoClosingBrackets === 'never' && autoClosingQuotes === 'never') {\n            return false;\n        }\n        if (autoClosingDelete === 'never') {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            if (!selection.isEmpty()) {\n                return false;\n            }\n            const lineText = model.getLineContent(position.lineNumber);\n            if (position.column < 2 || position.column >= lineText.length + 1) {\n                return false;\n            }\n            const character = lineText.charAt(position.column - 2);\n            const autoClosingPairCandidates = autoClosingPairsOpen.get(character);\n            if (!autoClosingPairCandidates) {\n                return false;\n            }\n            if (isQuote(character)) {\n                if (autoClosingQuotes === 'never') {\n                    return false;\n                }\n            }\n            else {\n                if (autoClosingBrackets === 'never') {\n                    return false;\n                }\n            }\n            const afterCharacter = lineText.charAt(position.column - 1);\n            let foundAutoClosingPair = false;\n            for (const autoClosingPairCandidate of autoClosingPairCandidates) {\n                if (autoClosingPairCandidate.open === character && autoClosingPairCandidate.close === afterCharacter) {\n                    foundAutoClosingPair = true;\n                }\n            }\n            if (!foundAutoClosingPair) {\n                return false;\n            }\n            // Must delete the pair only if it was automatically inserted by the editor\n            if (autoClosingDelete === 'auto') {\n                let found = false;\n                for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                    const autoClosedCharacter = autoClosedCharacters[j];\n                    if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runAutoClosingPairDelete(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const position = selections[i].getPosition();\n            const deleteSelection = new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n        }\n        return [true, commands];\n    }\n    static deleteLeft(prevEditOperationType, config, model, selections, autoClosedCharacters) {\n        if (this.isAutoClosingPairDelete(config.autoClosingDelete, config.autoClosingBrackets, config.autoClosingQuotes, config.autoClosingPairs.autoClosingPairsOpenByEnd, model, selections, autoClosedCharacters)) {\n            return this._runAutoClosingPairDelete(config, model, selections);\n        }\n        const commands = [];\n        let shouldPushStackElementBefore = (prevEditOperationType !== 2 /* EditOperationType.DeletingLeft */);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const deleteRange = DeleteOperations.getDeleteRange(selections[i], model, config);\n            // Ignore empty delete ranges, as they have no effect\n            // They happen if the cursor is at the beginning of the file.\n            if (deleteRange.isEmpty()) {\n                commands[i] = null;\n                continue;\n            }\n            if (deleteRange.startLineNumber !== deleteRange.endLineNumber) {\n                shouldPushStackElementBefore = true;\n            }\n            commands[i] = new ReplaceCommand(deleteRange, '');\n        }\n        return [shouldPushStackElementBefore, commands];\n    }\n    static getDeleteRange(selection, model, config) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = selection.getPosition();\n        // Unintend when using tab stops and cursor is within indentation\n        if (config.useTabStops && position.column > 1) {\n            const lineContent = model.getLineContent(position.lineNumber);\n            const firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n            const lastIndentationColumn = (firstNonWhitespaceIndex === -1\n                ? /* entire string is whitespace */ lineContent.length + 1\n                : firstNonWhitespaceIndex + 1);\n            if (position.column <= lastIndentationColumn) {\n                const fromVisibleColumn = config.visibleColumnFromColumn(model, position);\n                const toVisibleColumn = CursorColumns.prevIndentTabStop(fromVisibleColumn, config.indentSize);\n                const toColumn = config.columnFromVisibleColumn(model, position.lineNumber, toVisibleColumn);\n                return new Range(position.lineNumber, toColumn, position.lineNumber, position.column);\n            }\n        }\n        return Range.fromPositions(DeleteOperations.getPositionAfterDeleteLeft(position, model), position);\n    }\n    static getPositionAfterDeleteLeft(position, model) {\n        if (position.column > 1) {\n            // Convert 1-based columns to 0-based offsets and back.\n            const idx = strings.getLeftDeleteOffset(position.column - 1, model.getLineContent(position.lineNumber));\n            return position.with(undefined, idx + 1);\n        }\n        else if (position.lineNumber > 1) {\n            const newLine = position.lineNumber - 1;\n            return new Position(newLine, model.getLineMaxColumn(newLine));\n        }\n        else {\n            return position;\n        }\n    }\n    static cut(config, model, selections) {\n        const commands = [];\n        let lastCutRange = null;\n        selections.sort((a, b) => Position.compare(a.getStartPosition(), b.getEndPosition()));\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                if (config.emptySelectionClipboard) {\n                    // This is a full line cut\n                    const position = selection.getPosition();\n                    let startLineNumber, startColumn, endLineNumber, endColumn;\n                    if (position.lineNumber < model.getLineCount()) {\n                        // Cutting a line in the middle of the model\n                        startLineNumber = position.lineNumber;\n                        startColumn = 1;\n                        endLineNumber = position.lineNumber + 1;\n                        endColumn = 1;\n                    }\n                    else if (position.lineNumber > 1 && (lastCutRange === null || lastCutRange === void 0 ? void 0 : lastCutRange.endLineNumber) !== position.lineNumber) {\n                        // Cutting the last line & there are more than 1 lines in the model & a previous cut operation does not touch the current cut operation\n                        startLineNumber = position.lineNumber - 1;\n                        startColumn = model.getLineMaxColumn(position.lineNumber - 1);\n                        endLineNumber = position.lineNumber;\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\n                    }\n                    else {\n                        // Cutting the single line that the model contains\n                        startLineNumber = position.lineNumber;\n                        startColumn = 1;\n                        endLineNumber = position.lineNumber;\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\n                    }\n                    const deleteSelection = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n                    lastCutRange = deleteSelection;\n                    if (!deleteSelection.isEmpty()) {\n                        commands[i] = new ReplaceCommand(deleteSelection, '');\n                    }\n                    else {\n                        commands[i] = null;\n                    }\n                }\n                else {\n                    // Cannot cut empty selection\n                    commands[i] = null;\n                }\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, '');\n            }\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as types from '../../../base/common/types.js';\nimport { CursorState, SingleCursorState } from '../cursorCommon.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { WordOperations } from './cursorWordOperations.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class CursorMoveCommands {\n    static addCursorDown(viewModel, cursors, useLogicalLine) {\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n            if (useLogicalLine) {\n                result[resultLen++] = CursorState.fromModelState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n            }\n            else {\n                result[resultLen++] = CursorState.fromViewState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel, cursor.viewState));\n            }\n        }\n        return result;\n    }\n    static addCursorUp(viewModel, cursors, useLogicalLine) {\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n            if (useLogicalLine) {\n                result[resultLen++] = CursorState.fromModelState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n            }\n            else {\n                result[resultLen++] = CursorState.fromViewState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel, cursor.viewState));\n            }\n        }\n        return result;\n    }\n    static moveToBeginningOfLine(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = this._moveToLineStart(viewModel, cursor, inSelectionMode);\n        }\n        return result;\n    }\n    static _moveToLineStart(viewModel, cursor, inSelectionMode) {\n        const currentViewStateColumn = cursor.viewState.position.column;\n        const currentModelStateColumn = cursor.modelState.position.column;\n        const isFirstLineOfWrappedLine = currentViewStateColumn === currentModelStateColumn;\n        const currentViewStatelineNumber = cursor.viewState.position.lineNumber;\n        const firstNonBlankColumn = viewModel.getLineFirstNonWhitespaceColumn(currentViewStatelineNumber);\n        const isBeginningOfViewLine = currentViewStateColumn === firstNonBlankColumn;\n        if (!isFirstLineOfWrappedLine && !isBeginningOfViewLine) {\n            return this._moveToLineStartByView(viewModel, cursor, inSelectionMode);\n        }\n        else {\n            return this._moveToLineStartByModel(viewModel, cursor, inSelectionMode);\n        }\n    }\n    static _moveToLineStartByView(viewModel, cursor, inSelectionMode) {\n        return CursorState.fromViewState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode));\n    }\n    static _moveToLineStartByModel(viewModel, cursor, inSelectionMode) {\n        return CursorState.fromModelState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n    }\n    static moveToEndOfLine(viewModel, cursors, inSelectionMode, sticky) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = this._moveToLineEnd(viewModel, cursor, inSelectionMode, sticky);\n        }\n        return result;\n    }\n    static _moveToLineEnd(viewModel, cursor, inSelectionMode, sticky) {\n        const viewStatePosition = cursor.viewState.position;\n        const viewModelMaxColumn = viewModel.getLineMaxColumn(viewStatePosition.lineNumber);\n        const isEndOfViewLine = viewStatePosition.column === viewModelMaxColumn;\n        const modelStatePosition = cursor.modelState.position;\n        const modelMaxColumn = viewModel.model.getLineMaxColumn(modelStatePosition.lineNumber);\n        const isEndLineOfWrappedLine = viewModelMaxColumn - viewStatePosition.column === modelMaxColumn - modelStatePosition.column;\n        if (isEndOfViewLine || isEndLineOfWrappedLine) {\n            return this._moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky);\n        }\n        else {\n            return this._moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky);\n        }\n    }\n    static _moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky) {\n        return CursorState.fromViewState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, sticky));\n    }\n    static _moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky) {\n        return CursorState.fromModelState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, sticky));\n    }\n    static expandLineSelection(viewModel, cursors) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const startLineNumber = cursor.modelState.selection.startLineNumber;\n            const lineCount = viewModel.model.getLineCount();\n            let endLineNumber = cursor.modelState.selection.endLineNumber;\n            let endColumn;\n            if (endLineNumber === lineCount) {\n                endColumn = viewModel.model.getLineMaxColumn(lineCount);\n            }\n            else {\n                endLineNumber++;\n                endColumn = 1;\n            }\n            result[i] = CursorState.fromModelState(new SingleCursorState(new Range(startLineNumber, 1, startLineNumber, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(endLineNumber, endColumn), 0));\n        }\n        return result;\n    }\n    static moveToBeginningOfBuffer(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveToBeginningOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n        }\n        return result;\n    }\n    static moveToEndOfBuffer(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveToEndOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n        }\n        return result;\n    }\n    static selectAll(viewModel, cursor) {\n        const lineCount = viewModel.model.getLineCount();\n        const maxColumn = viewModel.model.getLineMaxColumn(lineCount);\n        return CursorState.fromModelState(new SingleCursorState(new Range(1, 1, 1, 1), 0 /* SelectionStartKind.Simple */, 0, new Position(lineCount, maxColumn), 0));\n    }\n    static line(viewModel, cursor, inSelectionMode, _position, _viewPosition) {\n        const position = viewModel.model.validatePosition(_position);\n        const viewPosition = (_viewPosition\n            ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\n            : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position));\n        if (!inSelectionMode) {\n            // Entering line selection for the first time\n            const lineCount = viewModel.model.getLineCount();\n            let selectToLineNumber = position.lineNumber + 1;\n            let selectToColumn = 1;\n            if (selectToLineNumber > lineCount) {\n                selectToLineNumber = lineCount;\n                selectToColumn = viewModel.model.getLineMaxColumn(selectToLineNumber);\n            }\n            return CursorState.fromModelState(new SingleCursorState(new Range(position.lineNumber, 1, selectToLineNumber, selectToColumn), 2 /* SelectionStartKind.Line */, 0, new Position(selectToLineNumber, selectToColumn), 0));\n        }\n        // Continuing line selection\n        const enteringLineNumber = cursor.modelState.selectionStart.getStartPosition().lineNumber;\n        if (position.lineNumber < enteringLineNumber) {\n            return CursorState.fromViewState(cursor.viewState.move(true, viewPosition.lineNumber, 1, 0));\n        }\n        else if (position.lineNumber > enteringLineNumber) {\n            const lineCount = viewModel.getLineCount();\n            let selectToViewLineNumber = viewPosition.lineNumber + 1;\n            let selectToViewColumn = 1;\n            if (selectToViewLineNumber > lineCount) {\n                selectToViewLineNumber = lineCount;\n                selectToViewColumn = viewModel.getLineMaxColumn(selectToViewLineNumber);\n            }\n            return CursorState.fromViewState(cursor.viewState.move(true, selectToViewLineNumber, selectToViewColumn, 0));\n        }\n        else {\n            const endPositionOfSelectionStart = cursor.modelState.selectionStart.getEndPosition();\n            return CursorState.fromModelState(cursor.modelState.move(true, endPositionOfSelectionStart.lineNumber, endPositionOfSelectionStart.column, 0));\n        }\n    }\n    static word(viewModel, cursor, inSelectionMode, _position) {\n        const position = viewModel.model.validatePosition(_position);\n        return CursorState.fromModelState(WordOperations.word(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, position));\n    }\n    static cancelSelection(viewModel, cursor) {\n        if (!cursor.modelState.hasSelection()) {\n            return new CursorState(cursor.modelState, cursor.viewState);\n        }\n        const lineNumber = cursor.viewState.position.lineNumber;\n        const column = cursor.viewState.position.column;\n        return CursorState.fromViewState(new SingleCursorState(new Range(lineNumber, column, lineNumber, column), 0 /* SelectionStartKind.Simple */, 0, new Position(lineNumber, column), 0));\n    }\n    static moveTo(viewModel, cursor, inSelectionMode, _position, _viewPosition) {\n        if (inSelectionMode) {\n            if (cursor.modelState.selectionStartKind === 1 /* SelectionStartKind.Word */) {\n                return this.word(viewModel, cursor, inSelectionMode, _position);\n            }\n            if (cursor.modelState.selectionStartKind === 2 /* SelectionStartKind.Line */) {\n                return this.line(viewModel, cursor, inSelectionMode, _position, _viewPosition);\n            }\n        }\n        const position = viewModel.model.validatePosition(_position);\n        const viewPosition = (_viewPosition\n            ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\n            : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position));\n        return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, viewPosition.lineNumber, viewPosition.column, 0));\n    }\n    static simpleMove(viewModel, cursors, direction, inSelectionMode, value, unit) {\n        switch (direction) {\n            case 0 /* CursorMove.Direction.Left */: {\n                if (unit === 4 /* CursorMove.Unit.HalfLine */) {\n                    // Move left by half the current line length\n                    return this._moveHalfLineLeft(viewModel, cursors, inSelectionMode);\n                }\n                else {\n                    // Move left by `moveParams.value` columns\n                    return this._moveLeft(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 1 /* CursorMove.Direction.Right */: {\n                if (unit === 4 /* CursorMove.Unit.HalfLine */) {\n                    // Move right by half the current line length\n                    return this._moveHalfLineRight(viewModel, cursors, inSelectionMode);\n                }\n                else {\n                    // Move right by `moveParams.value` columns\n                    return this._moveRight(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 2 /* CursorMove.Direction.Up */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    // Move up by view lines\n                    return this._moveUpByViewLines(viewModel, cursors, inSelectionMode, value);\n                }\n                else {\n                    // Move up by model lines\n                    return this._moveUpByModelLines(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 3 /* CursorMove.Direction.Down */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    // Move down by view lines\n                    return this._moveDownByViewLines(viewModel, cursors, inSelectionMode, value);\n                }\n                else {\n                    // Move down by model lines\n                    return this._moveDownByModelLines(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 4 /* CursorMove.Direction.PrevBlankLine */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)));\n                }\n                else {\n                    return cursors.map(cursor => CursorState.fromModelState(MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)));\n                }\n            }\n            case 5 /* CursorMove.Direction.NextBlankLine */: {\n                if (unit === 2 /* CursorMove.Unit.WrappedLine */) {\n                    return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)));\n                }\n                else {\n                    return cursors.map(cursor => CursorState.fromModelState(MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)));\n                }\n            }\n            case 6 /* CursorMove.Direction.WrappedLineStart */: {\n                // Move to the beginning of the current view line\n                return this._moveToViewMinColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 7 /* CursorMove.Direction.WrappedLineFirstNonWhitespaceCharacter */: {\n                // Move to the first non-whitespace column of the current view line\n                return this._moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 8 /* CursorMove.Direction.WrappedLineColumnCenter */: {\n                // Move to the \"center\" of the current view line\n                return this._moveToViewCenterColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 9 /* CursorMove.Direction.WrappedLineEnd */: {\n                // Move to the end of the current view line\n                return this._moveToViewMaxColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 10 /* CursorMove.Direction.WrappedLineLastNonWhitespaceCharacter */: {\n                // Move to the last non-whitespace column of the current view line\n                return this._moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n            }\n            default:\n                return null;\n        }\n    }\n    static viewportMove(viewModel, cursors, direction, inSelectionMode, value) {\n        const visibleViewRange = viewModel.getCompletelyVisibleViewRange();\n        const visibleModelRange = viewModel.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n        switch (direction) {\n            case 11 /* CursorMove.Direction.ViewPortTop */: {\n                // Move to the nth line start in the viewport (from the top)\n                const modelLineNumber = this._firstLineNumberInRange(viewModel.model, visibleModelRange, value);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 13 /* CursorMove.Direction.ViewPortBottom */: {\n                // Move to the nth line start in the viewport (from the bottom)\n                const modelLineNumber = this._lastLineNumberInRange(viewModel.model, visibleModelRange, value);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 12 /* CursorMove.Direction.ViewPortCenter */: {\n                // Move to the line start in the viewport center\n                const modelLineNumber = Math.round((visibleModelRange.startLineNumber + visibleModelRange.endLineNumber) / 2);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 14 /* CursorMove.Direction.ViewPortIfOutside */: {\n                // Move to a position inside the viewport\n                const result = [];\n                for (let i = 0, len = cursors.length; i < len; i++) {\n                    const cursor = cursors[i];\n                    result[i] = this.findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode);\n                }\n                return result;\n            }\n            default:\n                return null;\n        }\n    }\n    static findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode) {\n        const viewLineNumber = cursor.viewState.position.lineNumber;\n        if (visibleViewRange.startLineNumber <= viewLineNumber && viewLineNumber <= visibleViewRange.endLineNumber - 1) {\n            // Nothing to do, cursor is in viewport\n            return new CursorState(cursor.modelState, cursor.viewState);\n        }\n        else {\n            let newViewLineNumber;\n            if (viewLineNumber > visibleViewRange.endLineNumber - 1) {\n                newViewLineNumber = visibleViewRange.endLineNumber - 1;\n            }\n            else if (viewLineNumber < visibleViewRange.startLineNumber) {\n                newViewLineNumber = visibleViewRange.startLineNumber;\n            }\n            else {\n                newViewLineNumber = viewLineNumber;\n            }\n            const position = MoveOperations.vertical(viewModel.cursorConfig, viewModel, viewLineNumber, cursor.viewState.position.column, cursor.viewState.leftoverVisibleColumns, newViewLineNumber, false);\n            return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, position.lineNumber, position.column, position.leftoverVisibleColumns));\n        }\n    }\n    /**\n     * Find the nth line start included in the range (from the start).\n     */\n    static _firstLineNumberInRange(model, range, count) {\n        let startLineNumber = range.startLineNumber;\n        if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n            // Move on to the second line if the first line start is not included in the range\n            startLineNumber++;\n        }\n        return Math.min(range.endLineNumber, startLineNumber + count - 1);\n    }\n    /**\n     * Find the nth line start included in the range (from the end).\n     */\n    static _lastLineNumberInRange(model, range, count) {\n        let startLineNumber = range.startLineNumber;\n        if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n            // Move on to the second line if the first line start is not included in the range\n            startLineNumber++;\n        }\n        return Math.max(startLineNumber, range.endLineNumber - count + 1);\n    }\n    static _moveLeft(viewModel, cursors, inSelectionMode, noOfColumns) {\n        return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)));\n    }\n    static _moveHalfLineLeft(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const halfLine = Math.round(viewModel.getLineContent(viewLineNumber).length / 2);\n            result[i] = CursorState.fromViewState(MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n        }\n        return result;\n    }\n    static _moveRight(viewModel, cursors, inSelectionMode, noOfColumns) {\n        return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)));\n    }\n    static _moveHalfLineRight(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const halfLine = Math.round(viewModel.getLineContent(viewLineNumber).length / 2);\n            result[i] = CursorState.fromViewState(MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n        }\n        return result;\n    }\n    static _moveDownByViewLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromViewState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveDownByModelLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveUpByViewLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromViewState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveUpByModelLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveToViewPosition(viewModel, cursor, inSelectionMode, toViewLineNumber, toViewColumn) {\n        return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, toViewLineNumber, toViewColumn, 0));\n    }\n    static _moveToModelPosition(viewModel, cursor, inSelectionMode, toModelLineNumber, toModelColumn) {\n        return CursorState.fromModelState(cursor.modelState.move(inSelectionMode, toModelLineNumber, toModelColumn, 0));\n    }\n    static _moveToViewMinColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineMinColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineFirstNonWhitespaceColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewCenterColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = Math.round((viewModel.getLineMaxColumn(viewLineNumber) + viewModel.getLineMinColumn(viewLineNumber)) / 2);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewMaxColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineMaxColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineLastNonWhitespaceColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n}\nexport var CursorMove;\n(function (CursorMove) {\n    const isCursorMoveArgs = function (arg) {\n        if (!types.isObject(arg)) {\n            return false;\n        }\n        const cursorMoveArg = arg;\n        if (!types.isString(cursorMoveArg.to)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.select) && !types.isBoolean(cursorMoveArg.select)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.by) && !types.isString(cursorMoveArg.by)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.value) && !types.isNumber(cursorMoveArg.value)) {\n            return false;\n        }\n        return true;\n    };\n    CursorMove.description = {\n        description: 'Move cursor to a logical position in the view',\n        args: [\n            {\n                name: 'Cursor move argument object',\n                description: `Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'to': A mandatory logical position value providing where to move the cursor.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine',\n\t\t\t\t\t\t'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'\n\t\t\t\t\t\t'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'\n\t\t\t\t\t\t'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'by': Unit to move. Default is computed based on 'to' value.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'line', 'wrappedLine', 'character', 'halfLine'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'value': Number of units to move. Default is '1'.\n\t\t\t\t\t* 'select': If 'true' makes the selection. Default is 'false'.\n\t\t\t\t`,\n                constraint: isCursorMoveArgs,\n                schema: {\n                    'type': 'object',\n                    'required': ['to'],\n                    'properties': {\n                        'to': {\n                            'type': 'string',\n                            'enum': ['left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine', 'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter', 'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter', 'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside']\n                        },\n                        'by': {\n                            'type': 'string',\n                            'enum': ['line', 'wrappedLine', 'character', 'halfLine']\n                        },\n                        'value': {\n                            'type': 'number',\n                            'default': 1\n                        },\n                        'select': {\n                            'type': 'boolean',\n                            'default': false\n                        }\n                    }\n                }\n            }\n        ]\n    };\n    /**\n     * Positions in the view for cursor move command.\n     */\n    CursorMove.RawDirection = {\n        Left: 'left',\n        Right: 'right',\n        Up: 'up',\n        Down: 'down',\n        PrevBlankLine: 'prevBlankLine',\n        NextBlankLine: 'nextBlankLine',\n        WrappedLineStart: 'wrappedLineStart',\n        WrappedLineFirstNonWhitespaceCharacter: 'wrappedLineFirstNonWhitespaceCharacter',\n        WrappedLineColumnCenter: 'wrappedLineColumnCenter',\n        WrappedLineEnd: 'wrappedLineEnd',\n        WrappedLineLastNonWhitespaceCharacter: 'wrappedLineLastNonWhitespaceCharacter',\n        ViewPortTop: 'viewPortTop',\n        ViewPortCenter: 'viewPortCenter',\n        ViewPortBottom: 'viewPortBottom',\n        ViewPortIfOutside: 'viewPortIfOutside'\n    };\n    /**\n     * Units for Cursor move 'by' argument\n     */\n    CursorMove.RawUnit = {\n        Line: 'line',\n        WrappedLine: 'wrappedLine',\n        Character: 'character',\n        HalfLine: 'halfLine'\n    };\n    function parse(args) {\n        if (!args.to) {\n            // illegal arguments\n            return null;\n        }\n        let direction;\n        switch (args.to) {\n            case CursorMove.RawDirection.Left:\n                direction = 0 /* Direction.Left */;\n                break;\n            case CursorMove.RawDirection.Right:\n                direction = 1 /* Direction.Right */;\n                break;\n            case CursorMove.RawDirection.Up:\n                direction = 2 /* Direction.Up */;\n                break;\n            case CursorMove.RawDirection.Down:\n                direction = 3 /* Direction.Down */;\n                break;\n            case CursorMove.RawDirection.PrevBlankLine:\n                direction = 4 /* Direction.PrevBlankLine */;\n                break;\n            case CursorMove.RawDirection.NextBlankLine:\n                direction = 5 /* Direction.NextBlankLine */;\n                break;\n            case CursorMove.RawDirection.WrappedLineStart:\n                direction = 6 /* Direction.WrappedLineStart */;\n                break;\n            case CursorMove.RawDirection.WrappedLineFirstNonWhitespaceCharacter:\n                direction = 7 /* Direction.WrappedLineFirstNonWhitespaceCharacter */;\n                break;\n            case CursorMove.RawDirection.WrappedLineColumnCenter:\n                direction = 8 /* Direction.WrappedLineColumnCenter */;\n                break;\n            case CursorMove.RawDirection.WrappedLineEnd:\n                direction = 9 /* Direction.WrappedLineEnd */;\n                break;\n            case CursorMove.RawDirection.WrappedLineLastNonWhitespaceCharacter:\n                direction = 10 /* Direction.WrappedLineLastNonWhitespaceCharacter */;\n                break;\n            case CursorMove.RawDirection.ViewPortTop:\n                direction = 11 /* Direction.ViewPortTop */;\n                break;\n            case CursorMove.RawDirection.ViewPortBottom:\n                direction = 13 /* Direction.ViewPortBottom */;\n                break;\n            case CursorMove.RawDirection.ViewPortCenter:\n                direction = 12 /* Direction.ViewPortCenter */;\n                break;\n            case CursorMove.RawDirection.ViewPortIfOutside:\n                direction = 14 /* Direction.ViewPortIfOutside */;\n                break;\n            default:\n                // illegal arguments\n                return null;\n        }\n        let unit = 0 /* Unit.None */;\n        switch (args.by) {\n            case CursorMove.RawUnit.Line:\n                unit = 1 /* Unit.Line */;\n                break;\n            case CursorMove.RawUnit.WrappedLine:\n                unit = 2 /* Unit.WrappedLine */;\n                break;\n            case CursorMove.RawUnit.Character:\n                unit = 3 /* Unit.Character */;\n                break;\n            case CursorMove.RawUnit.HalfLine:\n                unit = 4 /* Unit.HalfLine */;\n                break;\n        }\n        return {\n            direction: direction,\n            unit: unit,\n            select: (!!args.select),\n            value: (args.value || 1)\n        };\n    }\n    CursorMove.parse = parse;\n})(CursorMove || (CursorMove = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { AtomicTabMoveOperations } from './cursorAtomicMoveOperations.js';\nexport class CursorPosition {\n    constructor(lineNumber, column, leftoverVisibleColumns) {\n        this._cursorPositionBrand = undefined;\n        this.lineNumber = lineNumber;\n        this.column = column;\n        this.leftoverVisibleColumns = leftoverVisibleColumns;\n    }\n}\nexport class MoveOperations {\n    static leftPosition(model, position) {\n        if (position.column > model.getLineMinColumn(position.lineNumber)) {\n            return position.delta(undefined, -strings.prevCharLength(model.getLineContent(position.lineNumber), position.column - 1));\n        }\n        else if (position.lineNumber > 1) {\n            const newLineNumber = position.lineNumber - 1;\n            return new Position(newLineNumber, model.getLineMaxColumn(newLineNumber));\n        }\n        else {\n            return position;\n        }\n    }\n    static leftPositionAtomicSoftTabs(model, position, tabSize) {\n        if (position.column <= model.getLineIndentColumn(position.lineNumber)) {\n            const minColumn = model.getLineMinColumn(position.lineNumber);\n            const lineContent = model.getLineContent(position.lineNumber);\n            const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, 0 /* Direction.Left */);\n            if (newPosition !== -1 && newPosition + 1 >= minColumn) {\n                return new Position(position.lineNumber, newPosition + 1);\n            }\n        }\n        return this.leftPosition(model, position);\n    }\n    static left(config, model, position) {\n        const pos = config.stickyTabStops\n            ? MoveOperations.leftPositionAtomicSoftTabs(model, position, config.tabSize)\n            : MoveOperations.leftPosition(model, position);\n        return new CursorPosition(pos.lineNumber, pos.column, 0);\n    }\n    /**\n     * @param noOfColumns Must be either `1`\n     * or `Math.round(viewModel.getLineContent(viewLineNumber).length / 2)` (for half lines).\n    */\n    static moveLeft(config, model, cursor, inSelectionMode, noOfColumns) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If the user has a selection and does not want to extend it,\n            // put the cursor at the beginning of the selection.\n            lineNumber = cursor.selection.startLineNumber;\n            column = cursor.selection.startColumn;\n        }\n        else {\n            // This has no effect if noOfColumns === 1.\n            // It is ok to do so in the half-line scenario.\n            const pos = cursor.position.delta(undefined, -(noOfColumns - 1));\n            // We clip the position before normalization, as normalization is not defined\n            // for possibly negative columns.\n            const normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 0 /* PositionAffinity.Left */);\n            const p = MoveOperations.left(config, model, normalizedPos);\n            lineNumber = p.lineNumber;\n            column = p.column;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    /**\n     * Adjusts the column so that it is within min/max of the line.\n    */\n    static clipPositionColumn(position, model) {\n        return new Position(position.lineNumber, MoveOperations.clipRange(position.column, model.getLineMinColumn(position.lineNumber), model.getLineMaxColumn(position.lineNumber)));\n    }\n    static clipRange(value, min, max) {\n        if (value < min) {\n            return min;\n        }\n        if (value > max) {\n            return max;\n        }\n        return value;\n    }\n    static rightPosition(model, lineNumber, column) {\n        if (column < model.getLineMaxColumn(lineNumber)) {\n            column = column + strings.nextCharLength(model.getLineContent(lineNumber), column - 1);\n        }\n        else if (lineNumber < model.getLineCount()) {\n            lineNumber = lineNumber + 1;\n            column = model.getLineMinColumn(lineNumber);\n        }\n        return new Position(lineNumber, column);\n    }\n    static rightPositionAtomicSoftTabs(model, lineNumber, column, tabSize, indentSize) {\n        if (column < model.getLineIndentColumn(lineNumber)) {\n            const lineContent = model.getLineContent(lineNumber);\n            const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, column - 1, tabSize, 1 /* Direction.Right */);\n            if (newPosition !== -1) {\n                return new Position(lineNumber, newPosition + 1);\n            }\n        }\n        return this.rightPosition(model, lineNumber, column);\n    }\n    static right(config, model, position) {\n        const pos = config.stickyTabStops\n            ? MoveOperations.rightPositionAtomicSoftTabs(model, position.lineNumber, position.column, config.tabSize, config.indentSize)\n            : MoveOperations.rightPosition(model, position.lineNumber, position.column);\n        return new CursorPosition(pos.lineNumber, pos.column, 0);\n    }\n    static moveRight(config, model, cursor, inSelectionMode, noOfColumns) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move right without selection cancels selection and puts cursor at the end of the selection\n            lineNumber = cursor.selection.endLineNumber;\n            column = cursor.selection.endColumn;\n        }\n        else {\n            const pos = cursor.position.delta(undefined, noOfColumns - 1);\n            const normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 1 /* PositionAffinity.Right */);\n            const r = MoveOperations.right(config, model, normalizedPos);\n            lineNumber = r.lineNumber;\n            column = r.column;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    static vertical(config, model, lineNumber, column, leftoverVisibleColumns, newLineNumber, allowMoveOnEdgeLine, normalizationAffinity) {\n        const currentVisibleColumn = CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize) + leftoverVisibleColumns;\n        const lineCount = model.getLineCount();\n        const wasOnFirstPosition = (lineNumber === 1 && column === 1);\n        const wasOnLastPosition = (lineNumber === lineCount && column === model.getLineMaxColumn(lineNumber));\n        const wasAtEdgePosition = (newLineNumber < lineNumber ? wasOnFirstPosition : wasOnLastPosition);\n        lineNumber = newLineNumber;\n        if (lineNumber < 1) {\n            lineNumber = 1;\n            if (allowMoveOnEdgeLine) {\n                column = model.getLineMinColumn(lineNumber);\n            }\n            else {\n                column = Math.min(model.getLineMaxColumn(lineNumber), column);\n            }\n        }\n        else if (lineNumber > lineCount) {\n            lineNumber = lineCount;\n            if (allowMoveOnEdgeLine) {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n            else {\n                column = Math.min(model.getLineMaxColumn(lineNumber), column);\n            }\n        }\n        else {\n            column = config.columnFromVisibleColumn(model, lineNumber, currentVisibleColumn);\n        }\n        if (wasAtEdgePosition) {\n            leftoverVisibleColumns = 0;\n        }\n        else {\n            leftoverVisibleColumns = currentVisibleColumn - CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize);\n        }\n        if (normalizationAffinity !== undefined) {\n            const position = new Position(lineNumber, column);\n            const newPosition = model.normalizePosition(position, normalizationAffinity);\n            leftoverVisibleColumns = leftoverVisibleColumns + (column - newPosition.column);\n            lineNumber = newPosition.lineNumber;\n            column = newPosition.column;\n        }\n        return new CursorPosition(lineNumber, column, leftoverVisibleColumns);\n    }\n    static down(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnLastLine) {\n        return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber + count, allowMoveOnLastLine, 4 /* PositionAffinity.RightOfInjectedText */);\n    }\n    static moveDown(config, model, cursor, inSelectionMode, linesCount) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move down acts relative to the end of selection\n            lineNumber = cursor.selection.endLineNumber;\n            column = cursor.selection.endColumn;\n        }\n        else {\n            lineNumber = cursor.position.lineNumber;\n            column = cursor.position.column;\n        }\n        const r = MoveOperations.down(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);\n        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n    }\n    static translateDown(config, model, cursor) {\n        const selection = cursor.selection;\n        const selectionStart = MoveOperations.down(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n        const position = MoveOperations.down(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), 0 /* SelectionStartKind.Simple */, selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n    }\n    static up(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnFirstLine) {\n        return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber - count, allowMoveOnFirstLine, 3 /* PositionAffinity.LeftOfInjectedText */);\n    }\n    static moveUp(config, model, cursor, inSelectionMode, linesCount) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move up acts relative to the beginning of selection\n            lineNumber = cursor.selection.startLineNumber;\n            column = cursor.selection.startColumn;\n        }\n        else {\n            lineNumber = cursor.position.lineNumber;\n            column = cursor.position.column;\n        }\n        const r = MoveOperations.up(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);\n        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n    }\n    static translateUp(config, model, cursor) {\n        const selection = cursor.selection;\n        const selectionStart = MoveOperations.up(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n        const position = MoveOperations.up(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), 0 /* SelectionStartKind.Simple */, selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n    }\n    static _isBlankLine(model, lineNumber) {\n        if (model.getLineFirstNonWhitespaceColumn(lineNumber) === 0) {\n            // empty or contains only whitespace\n            return true;\n        }\n        return false;\n    }\n    static moveToPrevBlankLine(config, model, cursor, inSelectionMode) {\n        let lineNumber = cursor.position.lineNumber;\n        // If our current line is blank, move to the previous non-blank line\n        while (lineNumber > 1 && this._isBlankLine(model, lineNumber)) {\n            lineNumber--;\n        }\n        // Find the previous blank line\n        while (lineNumber > 1 && !this._isBlankLine(model, lineNumber)) {\n            lineNumber--;\n        }\n        return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n    }\n    static moveToNextBlankLine(config, model, cursor, inSelectionMode) {\n        const lineCount = model.getLineCount();\n        let lineNumber = cursor.position.lineNumber;\n        // If our current line is blank, move to the next non-blank line\n        while (lineNumber < lineCount && this._isBlankLine(model, lineNumber)) {\n            lineNumber++;\n        }\n        // Find the next blank line\n        while (lineNumber < lineCount && !this._isBlankLine(model, lineNumber)) {\n            lineNumber++;\n        }\n        return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n    }\n    static moveToBeginningOfLine(config, model, cursor, inSelectionMode) {\n        const lineNumber = cursor.position.lineNumber;\n        const minColumn = model.getLineMinColumn(lineNumber);\n        const firstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(lineNumber) || minColumn;\n        let column;\n        const relevantColumnNumber = cursor.position.column;\n        if (relevantColumnNumber === firstNonBlankColumn) {\n            column = minColumn;\n        }\n        else {\n            column = firstNonBlankColumn;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    static moveToEndOfLine(config, model, cursor, inSelectionMode, sticky) {\n        const lineNumber = cursor.position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        return cursor.move(inSelectionMode, lineNumber, maxColumn, sticky ? 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */ - maxColumn : 0);\n    }\n    static moveToBeginningOfBuffer(config, model, cursor, inSelectionMode) {\n        return cursor.move(inSelectionMode, 1, 1, 0);\n    }\n    static moveToEndOfBuffer(config, model, cursor, inSelectionMode) {\n        const lastLineNumber = model.getLineCount();\n        const lastColumn = model.getLineMaxColumn(lastLineNumber);\n        return cursor.move(inSelectionMode, lastLineNumber, lastColumn, 0);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition, ReplaceCommandThatPreservesSelection } from '../commands/replaceCommand.js';\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { CompositionSurroundSelectionCommand, SurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nimport { IndentAction } from '../languages/languageConfiguration.js';\nimport { getIndentationAtPosition } from '../languages/languageConfigurationRegistry.js';\nimport { createScopedLineTokens } from '../languages/supports.js';\nimport { getIndentActionForType, getIndentForEnter, getInheritIndentForLine } from '../languages/autoIndent.js';\nimport { getEnterAction } from '../languages/enterAction.js';\nexport class TypeOperations {\n    static indent(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: false,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            }, config.languageConfigurationService);\n        }\n        return commands;\n    }\n    static outdent(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: true,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            }, config.languageConfigurationService);\n        }\n        return commands;\n    }\n    static shiftIndent(config, indentation, count) {\n        count = count || 1;\n        return ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n    static unshiftIndent(config, indentation, count) {\n        count = count || 1;\n        return ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n    static _distributedPaste(config, model, selections, text) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], text[i]);\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _simplePaste(config, model, selections, text, pasteOnNewLine) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            if (pasteOnNewLine && !selection.isEmpty()) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine) {\n                // Paste entire line at the beginning of line\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\n                commands[i] = new ReplaceCommandThatPreservesSelection(typeSelection, text, selection, true);\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, text);\n            }\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText) {\n        if (pasteOnNewLine) {\n            return null;\n        }\n        if (selections.length === 1) {\n            return null;\n        }\n        if (multicursorText && multicursorText.length === selections.length) {\n            return multicursorText;\n        }\n        if (config.multiCursorPaste === 'spread') {\n            // Try to spread the pasted text in case the line count matches the cursor count\n            // Remove trailing \\n if present\n            if (text.charCodeAt(text.length - 1) === 10 /* CharCode.LineFeed */) {\n                text = text.substr(0, text.length - 1);\n            }\n            // Remove trailing \\r if present\n            if (text.charCodeAt(text.length - 1) === 13 /* CharCode.CarriageReturn */) {\n                text = text.substr(0, text.length - 1);\n            }\n            const lines = strings.splitLines(text);\n            if (lines.length === selections.length) {\n                return lines;\n            }\n        }\n        return null;\n    }\n    static paste(config, model, selections, text, pasteOnNewLine, multicursorText) {\n        const distributedPaste = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText);\n        if (distributedPaste) {\n            selections = selections.sort(Range.compareRangesUsingStarts);\n            return this._distributedPaste(config, model, selections, distributedPaste);\n        }\n        else {\n            return this._simplePaste(config, model, selections, text, pasteOnNewLine);\n        }\n    }\n    static _goodIndentForLine(config, model, lineNumber) {\n        let action = null;\n        let indentation = '';\n        const expectedIndentAction = getInheritIndentForLine(config.autoIndent, model, lineNumber, false, config.languageConfigurationService);\n        if (expectedIndentAction) {\n            action = expectedIndentAction.action;\n            indentation = expectedIndentAction.indentation;\n        }\n        else if (lineNumber > 1) {\n            let lastLineNumber;\n            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n                const lineText = model.getLineContent(lastLineNumber);\n                const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n                if (nonWhitespaceIdx >= 0) {\n                    break;\n                }\n            }\n            if (lastLineNumber < 1) {\n                // No previous line with content found\n                return null;\n            }\n            const maxColumn = model.getLineMaxColumn(lastLineNumber);\n            const expectedEnterAction = getEnterAction(config.autoIndent, model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn), config.languageConfigurationService);\n            if (expectedEnterAction) {\n                indentation = expectedEnterAction.indentation + expectedEnterAction.appendText;\n            }\n        }\n        if (action) {\n            if (action === IndentAction.Indent) {\n                indentation = TypeOperations.shiftIndent(config, indentation);\n            }\n            if (action === IndentAction.Outdent) {\n                indentation = TypeOperations.unshiftIndent(config, indentation);\n            }\n            indentation = config.normalizeIndentation(indentation);\n        }\n        if (!indentation) {\n            return null;\n        }\n        return indentation;\n    }\n    static _replaceJumpToNextIndent(config, model, selection, insertsAutoWhitespace) {\n        let typeText = '';\n        const position = selection.getStartPosition();\n        if (config.insertSpaces) {\n            const visibleColumnFromColumn = config.visibleColumnFromColumn(model, position);\n            const indentSize = config.indentSize;\n            const spacesCnt = indentSize - (visibleColumnFromColumn % indentSize);\n            for (let i = 0; i < spacesCnt; i++) {\n                typeText += ' ';\n            }\n        }\n        else {\n            typeText = '\\t';\n        }\n        return new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n    }\n    static tab(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                const lineText = model.getLineContent(selection.startLineNumber);\n                if (/^\\s*$/.test(lineText) && model.tokenization.isCheapToTokenize(selection.startLineNumber)) {\n                    let goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n                    goodIndent = goodIndent || '\\t';\n                    const possibleTypeText = config.normalizeIndentation(goodIndent);\n                    if (!lineText.startsWith(possibleTypeText)) {\n                        commands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n                        continue;\n                    }\n                }\n                commands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n            }\n            else {\n                if (selection.startLineNumber === selection.endLineNumber) {\n                    const lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n                        // This is a single line selection that is not the entire line\n                        commands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n                        continue;\n                    }\n                }\n                commands[i] = new ShiftCommand(selection, {\n                    isUnshift: false,\n                    tabSize: config.tabSize,\n                    indentSize: config.indentSize,\n                    insertSpaces: config.insertSpaces,\n                    useTabStops: config.useTabStops,\n                    autoIndent: config.autoIndent\n                }, config.languageConfigurationService);\n            }\n        }\n        return commands;\n    }\n    static compositionType(prevEditOperationType, config, model, selections, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        const commands = selections.map(selection => this._compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        if (!selection.isEmpty()) {\n            // looks like https://github.com/microsoft/vscode/issues/2773\n            // where a cursor operation occurred before a canceled composition\n            // => ignore composition\n            return null;\n        }\n        const pos = selection.getPosition();\n        const startColumn = Math.max(1, pos.column - replacePrevCharCnt);\n        const endColumn = Math.min(model.getLineMaxColumn(pos.lineNumber), pos.column + replaceNextCharCnt);\n        const range = new Range(pos.lineNumber, startColumn, pos.lineNumber, endColumn);\n        const oldText = model.getValueInRange(range);\n        if (oldText === text && positionDelta === 0) {\n            // => ignore composition that doesn't do anything\n            return null;\n        }\n        return new ReplaceCommandWithOffsetCursorState(range, text, 0, positionDelta);\n    }\n    static _typeCommand(range, text, keepPosition) {\n        if (keepPosition) {\n            return new ReplaceCommandWithoutChangingPosition(range, text, true);\n        }\n        else {\n            return new ReplaceCommand(range, text, true);\n        }\n    }\n    static _enter(config, model, keepPosition, range) {\n        if (config.autoIndent === 0 /* EditorAutoIndentStrategy.None */) {\n            return TypeOperations._typeCommand(range, '\\n', keepPosition);\n        }\n        if (!model.tokenization.isCheapToTokenize(range.getStartPosition().lineNumber) || config.autoIndent === 1 /* EditorAutoIndentStrategy.Keep */) {\n            const lineText = model.getLineContent(range.startLineNumber);\n            const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n            return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n        }\n        const r = getEnterAction(config.autoIndent, model, range, config.languageConfigurationService);\n        if (r) {\n            if (r.indentAction === IndentAction.None) {\n                // Nothing special\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.Indent) {\n                // Indent once\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.IndentOutdent) {\n                // Ultra special\n                const normalIndent = config.normalizeIndentation(r.indentation);\n                const increasedIndent = config.normalizeIndentation(r.indentation + r.appendText);\n                const typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, typeText, true);\n                }\n                else {\n                    return new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n                }\n            }\n            else if (r.indentAction === IndentAction.Outdent) {\n                const actualIndentation = TypeOperations.unshiftIndent(config, r.indentation);\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + r.appendText), keepPosition);\n            }\n        }\n        const lineText = model.getLineContent(range.startLineNumber);\n        const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n        if (config.autoIndent >= 4 /* EditorAutoIndentStrategy.Full */) {\n            const ir = getIndentForEnter(config.autoIndent, model, range, {\n                unshiftIndent: (indent) => {\n                    return TypeOperations.unshiftIndent(config, indent);\n                },\n                shiftIndent: (indent) => {\n                    return TypeOperations.shiftIndent(config, indent);\n                },\n                normalizeIndentation: (indent) => {\n                    return config.normalizeIndentation(indent);\n                }\n            }, config.languageConfigurationService);\n            if (ir) {\n                let oldEndViewColumn = config.visibleColumnFromColumn(model, range.getEndPosition());\n                const oldEndColumn = range.endColumn;\n                const newLineContent = model.getLineContent(range.endLineNumber);\n                const firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n                if (firstNonWhitespace >= 0) {\n                    range = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n                }\n                else {\n                    range = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n                }\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, '\\n' + config.normalizeIndentation(ir.afterEnter), true);\n                }\n                else {\n                    let offset = 0;\n                    if (oldEndColumn <= firstNonWhitespace + 1) {\n                        if (!config.insertSpaces) {\n                            oldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n                        }\n                        offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n                    }\n                    return new ReplaceCommandWithOffsetCursorState(range, '\\n' + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n                }\n            }\n        }\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n    }\n    static _isAutoIndentType(config, model, selections) {\n        if (config.autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            if (!model.tokenization.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _runAutoIndentType(config, model, range, ch) {\n        const currentIndentation = getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n        const actualIndentation = getIndentActionForType(config.autoIndent, model, range, ch, {\n            shiftIndent: (indentation) => {\n                return TypeOperations.shiftIndent(config, indentation);\n            },\n            unshiftIndent: (indentation) => {\n                return TypeOperations.unshiftIndent(config, indentation);\n            },\n        }, config.languageConfigurationService);\n        if (actualIndentation === null) {\n            return null;\n        }\n        if (actualIndentation !== config.normalizeIndentation(currentIndentation)) {\n            const firstNonWhitespace = model.getLineFirstNonWhitespaceColumn(range.startLineNumber);\n            if (firstNonWhitespace === 0) {\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + ch, false);\n            }\n            else {\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) +\n                    model.getLineContent(range.startLineNumber).substring(firstNonWhitespace - 1, range.startColumn - 1) + ch, false);\n            }\n        }\n        return null;\n    }\n    static _isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch) {\n        if (config.autoClosingOvertype === 'never') {\n            return false;\n        }\n        if (!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (!selection.isEmpty()) {\n                return false;\n            }\n            const position = selection.getPosition();\n            const lineText = model.getLineContent(position.lineNumber);\n            const afterCharacter = lineText.charAt(position.column - 1);\n            if (afterCharacter !== ch) {\n                return false;\n            }\n            // Do not over-type quotes after a backslash\n            const chIsQuote = isQuote(ch);\n            const beforeCharacter = position.column > 2 ? lineText.charCodeAt(position.column - 2) : 0 /* CharCode.Null */;\n            if (beforeCharacter === 92 /* CharCode.Backslash */ && chIsQuote) {\n                return false;\n            }\n            // Must over-type a closing character typed by the editor\n            if (config.autoClosingOvertype === 'auto') {\n                let found = false;\n                for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                    const autoClosedCharacter = autoClosedCharacters[j];\n                    if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            const typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(typeSelection, ch);\n        }\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* EditOperationType.TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _isBeforeClosingBrace(config, lineAfter) {\n        // If the start of lineAfter can be interpretted as both a starting or ending brace, default to returning false\n        const nextChar = lineAfter.charAt(0);\n        const potentialStartingBraces = config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) || [];\n        const potentialClosingBraces = config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar) || [];\n        const isBeforeStartingBrace = potentialStartingBraces.some(x => lineAfter.startsWith(x.open));\n        const isBeforeClosingBrace = potentialClosingBraces.some(x => lineAfter.startsWith(x.close));\n        return !isBeforeStartingBrace && isBeforeClosingBrace;\n    }\n    /**\n     * Determine if typing `ch` at all `positions` in the `model` results in an\n     * auto closing open sequence being typed.\n     *\n     * Auto closing open sequences can consist of multiple characters, which\n     * can lead to ambiguities. In such a case, the longest auto-closing open\n     * sequence is returned.\n     */\n    static _findAutoClosingPairOpen(config, model, positions, ch) {\n        const candidates = config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n        if (!candidates) {\n            return null;\n        }\n        // Determine which auto-closing pair it is\n        let result = null;\n        for (const candidate of candidates) {\n            if (result === null || candidate.open.length > result.open.length) {\n                let candidateIsMatch = true;\n                for (const position of positions) {\n                    const relevantText = model.getValueInRange(new Range(position.lineNumber, position.column - candidate.open.length + 1, position.lineNumber, position.column));\n                    if (relevantText + ch !== candidate.open) {\n                        candidateIsMatch = false;\n                        break;\n                    }\n                }\n                if (candidateIsMatch) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Find another auto-closing pair that is contained by the one passed in.\n     *\n     * e.g. when having [(,)] and [(*,*)] as auto-closing pairs\n     * this method will find [(,)] as a containment pair for [(*,*)]\n     */\n    static _findContainedAutoClosingPair(config, pair) {\n        if (pair.open.length <= 1) {\n            return null;\n        }\n        const lastChar = pair.close.charAt(pair.close.length - 1);\n        // get candidates with the same last character as close\n        const candidates = config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) || [];\n        let result = null;\n        for (const candidate of candidates) {\n            if (candidate.open !== pair.open && pair.open.includes(candidate.open) && pair.close.endsWith(candidate.close)) {\n                if (!result || candidate.open.length > result.open.length) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    static _getAutoClosingPairClose(config, model, selections, ch, chIsAlreadyTyped) {\n        const chIsQuote = isQuote(ch);\n        const autoCloseConfig = (chIsQuote ? config.autoClosingQuotes : config.autoClosingBrackets);\n        const shouldAutoCloseBefore = (chIsQuote ? config.shouldAutoCloseBefore.quote : config.shouldAutoCloseBefore.bracket);\n        if (autoCloseConfig === 'never') {\n            return null;\n        }\n        for (const selection of selections) {\n            if (!selection.isEmpty()) {\n                return null;\n            }\n        }\n        // This method is called both when typing (regularly) and when composition ends\n        // This means that we need to work with a text buffer where sometimes `ch` is not\n        // there (it is being typed right now) or with a text buffer where `ch` has already been typed\n        //\n        // In order to avoid adding checks for `chIsAlreadyTyped` in all places, we will work\n        // with two conceptual positions, the position before `ch` and the position after `ch`\n        //\n        const positions = selections.map((s) => {\n            const position = s.getPosition();\n            if (chIsAlreadyTyped) {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column - ch.length, afterColumn: position.column };\n            }\n            else {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column, afterColumn: position.column };\n            }\n        });\n        // Find the longest auto-closing open pair in case of multiple ending in `ch`\n        // e.g. when having [f\",\"] and [\",\"], it picks [f\",\"] if the character before is f\n        const pair = this._findAutoClosingPairOpen(config, model, positions.map(p => new Position(p.lineNumber, p.beforeColumn)), ch);\n        if (!pair) {\n            return null;\n        }\n        // Sometimes, it is possible to have two auto-closing pairs that have a containment relationship\n        // e.g. when having [(,)] and [(*,*)]\n        // - when typing (, the resulting state is (|)\n        // - when typing *, the desired resulting state is (*|*), not (*|*))\n        const containedPair = this._findContainedAutoClosingPair(config, pair);\n        const containedPairClose = containedPair ? containedPair.close : '';\n        let isContainedPairPresent = true;\n        for (const position of positions) {\n            const { lineNumber, beforeColumn, afterColumn } = position;\n            const lineText = model.getLineContent(lineNumber);\n            const lineBefore = lineText.substring(0, beforeColumn - 1);\n            const lineAfter = lineText.substring(afterColumn - 1);\n            if (!lineAfter.startsWith(containedPairClose)) {\n                isContainedPairPresent = false;\n            }\n            // Only consider auto closing the pair if an allowed character follows or if another autoclosed pair closing brace follows\n            if (lineAfter.length > 0) {\n                const characterAfter = lineAfter.charAt(0);\n                const isBeforeCloseBrace = TypeOperations._isBeforeClosingBrace(config, lineAfter);\n                if (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n                    return null;\n                }\n            }\n            // Do not auto-close ' or \" after a word character\n            if (pair.open.length === 1 && (ch === '\\'' || ch === '\"') && autoCloseConfig !== 'always') {\n                const wordSeparators = getMapForWordSeparators(config.wordSeparators);\n                if (lineBefore.length > 0) {\n                    const characterBefore = lineBefore.charCodeAt(lineBefore.length - 1);\n                    if (wordSeparators.get(characterBefore) === 0 /* WordCharacterClass.Regular */) {\n                        return null;\n                    }\n                }\n            }\n            if (!model.tokenization.isCheapToTokenize(lineNumber)) {\n                // Do not force tokenization\n                return null;\n            }\n            model.tokenization.forceTokenization(lineNumber);\n            const lineTokens = model.tokenization.getLineTokens(lineNumber);\n            const scopedLineTokens = createScopedLineTokens(lineTokens, beforeColumn - 1);\n            if (!pair.shouldAutoClose(scopedLineTokens, beforeColumn - scopedLineTokens.firstCharOffset)) {\n                return null;\n            }\n            // Typing for example a quote could either start a new string, in which case auto-closing is desirable\n            // or it could end a previously started string, in which case auto-closing is not desirable\n            //\n            // In certain cases, it is really not possible to look at the previous token to determine\n            // what would happen. That's why we do something really unusual, we pretend to type a different\n            // character and ask the tokenizer what the outcome of doing that is: after typing a neutral\n            // character, are we in a string (i.e. the quote would most likely end a string) or not?\n            //\n            const neutralCharacter = pair.findNeutralCharacter();\n            if (neutralCharacter) {\n                const tokenType = model.tokenization.getTokenTypeIfInsertingCharacter(lineNumber, beforeColumn, neutralCharacter);\n                if (!pair.isOK(tokenType)) {\n                    return null;\n                }\n            }\n        }\n        if (isContainedPairPresent) {\n            return pair.close.substring(0, pair.close.length - containedPairClose.length);\n        }\n        else {\n            return pair.close;\n        }\n    }\n    static _runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, chIsAlreadyTyped, autoClosingPairClose) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            commands[i] = new TypeWithAutoClosingCommand(selection, ch, !chIsAlreadyTyped, autoClosingPairClose);\n        }\n        return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _shouldSurroundChar(config, ch) {\n        if (isQuote(ch)) {\n            return (config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined');\n        }\n        else {\n            // Character is a bracket\n            return (config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined');\n        }\n    }\n    static _isSurroundSelectionType(config, model, selections, ch) {\n        if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n            return false;\n        }\n        const isTypingAQuoteCharacter = isQuote(ch);\n        for (const selection of selections) {\n            if (selection.isEmpty()) {\n                return false;\n            }\n            let selectionContainsOnlyWhitespace = true;\n            for (let lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n                const lineText = model.getLineContent(lineNumber);\n                const startIndex = (lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0);\n                const endIndex = (lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length);\n                const selectedText = lineText.substring(startIndex, endIndex);\n                if (/[^ \\t]/.test(selectedText)) {\n                    // this selected text contains something other than whitespace\n                    selectionContainsOnlyWhitespace = false;\n                    break;\n                }\n            }\n            if (selectionContainsOnlyWhitespace) {\n                return false;\n            }\n            if (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n                const selectionText = model.getValueInRange(selection);\n                if (isQuote(selectionText)) {\n                    // Typing a quote character on top of another quote character\n                    // => disable surround selection type\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runSurroundSelectionType(prevEditOperationType, config, model, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const closeCharacter = config.surroundingPairs[ch];\n            commands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\n        }\n        return new EditOperationResult(0 /* EditOperationType.Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _isTypeInterceptorElectricChar(config, model, selections) {\n        if (selections.length === 1 && model.tokenization.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n            return true;\n        }\n        return false;\n    }\n    static _typeInterceptorElectricChar(prevEditOperationType, config, model, selection, ch) {\n        if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n            return null;\n        }\n        const position = selection.getPosition();\n        model.tokenization.forceTokenization(position.lineNumber);\n        const lineTokens = model.tokenization.getLineTokens(position.lineNumber);\n        let electricAction;\n        try {\n            electricAction = config.onElectricCharacter(ch, lineTokens, position.column);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n        if (!electricAction) {\n            return null;\n        }\n        if (electricAction.matchOpenBracket) {\n            const endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n            const match = model.bracketPairs.findMatchingBracketUp(electricAction.matchOpenBracket, {\n                lineNumber: position.lineNumber,\n                column: endColumn\n            }, 500 /* give at most 500ms to compute */);\n            if (match) {\n                if (match.startLineNumber === position.lineNumber) {\n                    // matched something on the same line => no change in indentation\n                    return null;\n                }\n                const matchLine = model.getLineContent(match.startLineNumber);\n                const matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n                const newIndentation = config.normalizeIndentation(matchLineIndentation);\n                const lineText = model.getLineContent(position.lineNumber);\n                const lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n                const prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n                const typeText = newIndentation + prefix + ch;\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\n                const command = new ReplaceCommand(typeSelection, typeText);\n                return new EditOperationResult(getTypingOperation(typeText, prevEditOperationType), [command], {\n                    shouldPushStackElementBefore: false,\n                    shouldPushStackElementAfter: true\n                });\n            }\n        }\n        return null;\n    }\n    /**\n     * This is very similar with typing, but the character is already in the text buffer!\n     */\n    static compositionEndWithInterceptors(prevEditOperationType, config, model, compositions, selections, autoClosedCharacters) {\n        if (!compositions) {\n            // could not deduce what the composition did\n            return null;\n        }\n        let insertedText = null;\n        for (const composition of compositions) {\n            if (insertedText === null) {\n                insertedText = composition.insertedText;\n            }\n            else if (insertedText !== composition.insertedText) {\n                // not all selections agree on what was typed\n                return null;\n            }\n        }\n        if (!insertedText || insertedText.length !== 1) {\n            // we're only interested in the case where a single character was inserted\n            return null;\n        }\n        const ch = insertedText;\n        let hasDeletion = false;\n        for (const composition of compositions) {\n            if (composition.deletedText.length !== 0) {\n                hasDeletion = true;\n                break;\n            }\n        }\n        if (hasDeletion) {\n            // Check if this could have been a surround selection\n            if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n                return null;\n            }\n            const isTypingAQuoteCharacter = isQuote(ch);\n            for (const composition of compositions) {\n                if (composition.deletedSelectionStart !== 0 || composition.deletedSelectionEnd !== composition.deletedText.length) {\n                    // more text was deleted than was selected, so this could not have been a surround selection\n                    return null;\n                }\n                if (/^[ \\t]+$/.test(composition.deletedText)) {\n                    // deleted text was only whitespace\n                    return null;\n                }\n                if (isTypingAQuoteCharacter && isQuote(composition.deletedText)) {\n                    // deleted text was a quote\n                    return null;\n                }\n            }\n            const positions = [];\n            for (const selection of selections) {\n                if (!selection.isEmpty()) {\n                    return null;\n                }\n                positions.push(selection.getPosition());\n            }\n            if (positions.length !== compositions.length) {\n                return null;\n            }\n            const commands = [];\n            for (let i = 0, len = positions.length; i < len; i++) {\n                commands.push(new CompositionSurroundSelectionCommand(positions[i], compositions[i].deletedText, config.surroundingPairs[ch]));\n            }\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            // Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\n            const commands = selections.map(s => new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), '', false));\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, true);\n        if (autoClosingPairClose !== null) {\n            return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, true, autoClosingPairClose);\n        }\n        return null;\n    }\n    static typeWithInterceptors(isDoingComposition, prevEditOperationType, config, model, selections, autoClosedCharacters, ch) {\n        if (!isDoingComposition && ch === '\\n') {\n            const commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = TypeOperations._enter(config, model, false, selections[i]);\n            }\n            return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false,\n            });\n        }\n        if (!isDoingComposition && this._isAutoIndentType(config, model, selections)) {\n            const commands = [];\n            let autoIndentFails = false;\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = this._runAutoIndentType(config, model, selections[i], ch);\n                if (!commands[i]) {\n                    autoIndentFails = true;\n                    break;\n                }\n            }\n            if (!autoIndentFails) {\n                return new EditOperationResult(4 /* EditOperationType.TypingOther */, commands, {\n                    shouldPushStackElementBefore: true,\n                    shouldPushStackElementAfter: false,\n                });\n            }\n        }\n        if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            return this._runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch);\n        }\n        if (!isDoingComposition) {\n            const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, false);\n            if (autoClosingPairClose) {\n                return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, false, autoClosingPairClose);\n            }\n        }\n        if (!isDoingComposition && this._isSurroundSelectionType(config, model, selections, ch)) {\n            return this._runSurroundSelectionType(prevEditOperationType, config, model, selections, ch);\n        }\n        // Electric characters make sense only when dealing with a single cursor,\n        // as multiple cursors typing brackets for example would interfer with bracket matching\n        if (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model, selections)) {\n            const r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n            if (r) {\n                return r;\n            }\n        }\n        // A simple character type\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], ch);\n        }\n        const opType = getTypingOperation(ch, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static typeWithoutInterceptors(prevEditOperationType, config, model, selections, str) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], str);\n        }\n        const opType = getTypingOperation(str, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static lineInsertBefore(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            let lineNumber = selections[i].positionLineNumber;\n            if (lineNumber === 1) {\n                commands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\n            }\n            else {\n                lineNumber--;\n                const column = model.getLineMaxColumn(lineNumber);\n                commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n            }\n        }\n        return commands;\n    }\n    static lineInsertAfter(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const lineNumber = selections[i].positionLineNumber;\n            const column = model.getLineMaxColumn(lineNumber);\n            commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n        }\n        return commands;\n    }\n    static lineBreakInsert(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = this._enter(config, model, true, selections[i]);\n        }\n        return commands;\n    }\n}\nexport class TypeWithAutoClosingCommand extends ReplaceCommandWithOffsetCursorState {\n    constructor(selection, openCharacter, insertOpenCharacter, closeCharacter) {\n        super(selection, (insertOpenCharacter ? openCharacter : '') + closeCharacter, 0, -closeCharacter.length);\n        this._openCharacter = openCharacter;\n        this._closeCharacter = closeCharacter;\n        this.closeCharacterRange = null;\n        this.enclosingRange = null;\n    }\n    computeCursorState(model, helper) {\n        const inverseEditOperations = helper.getInverseEditOperations();\n        const range = inverseEditOperations[0].range;\n        this.closeCharacterRange = new Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        this.enclosingRange = new Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        return super.computeCursorState(model, helper);\n    }\n}\nexport class CompositionOutcome {\n    constructor(deletedText, deletedSelectionStart, deletedSelectionEnd, insertedText, insertedSelectionStart, insertedSelectionEnd) {\n        this.deletedText = deletedText;\n        this.deletedSelectionStart = deletedSelectionStart;\n        this.deletedSelectionEnd = deletedSelectionEnd;\n        this.insertedText = insertedText;\n        this.insertedSelectionStart = insertedSelectionStart;\n        this.insertedSelectionEnd = insertedSelectionEnd;\n    }\n}\nfunction getTypingOperation(typedText, previousTypingOperation) {\n    if (typedText === ' ') {\n        return previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */\n            || previousTypingOperation === 6 /* EditOperationType.TypingConsecutiveSpace */\n            ? 6 /* EditOperationType.TypingConsecutiveSpace */\n            : 5 /* EditOperationType.TypingFirstSpace */;\n    }\n    return 4 /* EditOperationType.TypingOther */;\n}\nfunction shouldPushStackElementBetween(previousTypingOperation, typingOperation) {\n    if (isTypingOperation(previousTypingOperation) && !isTypingOperation(typingOperation)) {\n        // Always set an undo stop before non-type operations\n        return true;\n    }\n    if (previousTypingOperation === 5 /* EditOperationType.TypingFirstSpace */) {\n        // `abc |d`: No undo stop\n        // `abc  |d`: Undo stop\n        return false;\n    }\n    // Insert undo stop between different operation types\n    return normalizeOperationType(previousTypingOperation) !== normalizeOperationType(typingOperation);\n}\nfunction normalizeOperationType(type) {\n    return (type === 6 /* EditOperationType.TypingConsecutiveSpace */ || type === 5 /* EditOperationType.TypingFirstSpace */)\n        ? 'space'\n        : type;\n}\nfunction isTypingOperation(type) {\n    return type === 4 /* EditOperationType.TypingOther */\n        || type === 5 /* EditOperationType.TypingFirstSpace */\n        || type === 6 /* EditOperationType.TypingConsecutiveSpace */;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class WordOperations {\n    static _createWord(lineContent, wordType, nextCharClass, start, end) {\n        // console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\n        return { start: start, end: end, wordType: wordType, nextCharClass: nextCharClass };\n    }\n    static _findPreviousWordOnLine(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\n    }\n    static _doFindPreviousWordOnLine(lineContent, wordSeparators, position) {\n        let wordType = 0 /* WordType.None */;\n        for (let chIndex = position.column - 2; chIndex >= 0; chIndex--) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 0 /* WordCharacterClass.Regular */) {\n                if (wordType === 2 /* WordType.Separator */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = 1 /* WordType.Regular */;\n            }\n            else if (chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                if (wordType === 1 /* WordType.Regular */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = 2 /* WordType.Separator */;\n            }\n            else if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                if (wordType !== 0 /* WordType.None */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n            }\n        }\n        if (wordType !== 0 /* WordType.None */) {\n            return this._createWord(lineContent, wordType, 1 /* WordCharacterClass.Whitespace */, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\n        }\n        return null;\n    }\n    static _findEndOfWord(lineContent, wordSeparators, wordType, startIndex) {\n        const len = lineContent.length;\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                return chIndex;\n            }\n            if (wordType === 1 /* WordType.Regular */ && chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                return chIndex;\n            }\n            if (wordType === 2 /* WordType.Separator */ && chClass === 0 /* WordCharacterClass.Regular */) {\n                return chIndex;\n            }\n        }\n        return len;\n    }\n    static _findNextWordOnLine(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindNextWordOnLine(lineContent, wordSeparators, position);\n    }\n    static _doFindNextWordOnLine(lineContent, wordSeparators, position) {\n        let wordType = 0 /* WordType.None */;\n        const len = lineContent.length;\n        for (let chIndex = position.column - 1; chIndex < len; chIndex++) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 0 /* WordCharacterClass.Regular */) {\n                if (wordType === 2 /* WordType.Separator */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = 1 /* WordType.Regular */;\n            }\n            else if (chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                if (wordType === 1 /* WordType.Regular */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = 2 /* WordType.Separator */;\n            }\n            else if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                if (wordType !== 0 /* WordType.None */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n            }\n        }\n        if (wordType !== 0 /* WordType.None */) {\n            return this._createWord(lineContent, wordType, 1 /* WordCharacterClass.Whitespace */, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\n        }\n        return null;\n    }\n    static _findStartOfWord(lineContent, wordSeparators, wordType, startIndex) {\n        for (let chIndex = startIndex; chIndex >= 0; chIndex--) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 1 /* WordCharacterClass.Whitespace */) {\n                return chIndex + 1;\n            }\n            if (wordType === 1 /* WordType.Regular */ && chClass === 2 /* WordCharacterClass.WordSeparator */) {\n                return chIndex + 1;\n            }\n            if (wordType === 2 /* WordType.Separator */ && chClass === 0 /* WordCharacterClass.Regular */) {\n                return chIndex + 1;\n            }\n        }\n        return 0;\n    }\n    static moveWordLeft(wordSeparators, model, position, wordNavigationType) {\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        if (column === 1) {\n            if (lineNumber > 1) {\n                lineNumber = lineNumber - 1;\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n        if (wordNavigationType === 0 /* WordNavigationType.WordStart */) {\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        if (wordNavigationType === 1 /* WordNavigationType.WordStartFast */) {\n            if (prevWordOnLine\n                && prevWordOnLine.wordType === 2 /* WordType.Separator */\n                && prevWordOnLine.end - prevWordOnLine.start === 1\n                && prevWordOnLine.nextCharClass === 0 /* WordCharacterClass.Regular */) {\n                // Skip over a word made up of one single separator and followed by a regular character\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        if (wordNavigationType === 3 /* WordNavigationType.WordAccessibility */) {\n            while (prevWordOnLine\n                && prevWordOnLine.wordType === 2 /* WordType.Separator */) {\n                // Skip over words made up of only separators\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        // We are stopping at the ending of words\n        if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n            prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n        }\n        return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\n    }\n    static _moveWordPartLeft(model, position) {\n        const lineNumber = position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === 1) {\n            return (lineNumber > 1 ? new Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position);\n        }\n        const lineContent = model.getLineContent(lineNumber);\n        for (let column = position.column - 1; column > 1; column--) {\n            const left = lineContent.charCodeAt(column - 2);\n            const right = lineContent.charCodeAt(column - 1);\n            if (left === 95 /* CharCode.Underline */ && right !== 95 /* CharCode.Underline */) {\n                // snake_case_variables\n                return new Position(lineNumber, column);\n            }\n            if (left === 45 /* CharCode.Dash */ && right !== 45 /* CharCode.Dash */) {\n                // kebab-case-variables\n                return new Position(lineNumber, column);\n            }\n            if ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    const rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n                        return new Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new Position(lineNumber, 1);\n    }\n    static moveWordRight(wordSeparators, model, position, wordNavigationType) {\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        let movedDown = false;\n        if (column === model.getLineMaxColumn(lineNumber)) {\n            if (lineNumber < model.getLineCount()) {\n                movedDown = true;\n                lineNumber = lineNumber + 1;\n                column = 1;\n            }\n        }\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n        if (wordNavigationType === 2 /* WordNavigationType.WordEnd */) {\n            if (nextWordOnLine && nextWordOnLine.wordType === 2 /* WordType.Separator */) {\n                if (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === 0 /* WordCharacterClass.Regular */) {\n                    // Skip over a word made up of one single separator and followed by a regular character\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n                }\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        else if (wordNavigationType === 3 /* WordNavigationType.WordAccessibility */) {\n            if (movedDown) {\n                // If we move to the next line, pretend that the cursor is right before the first character.\n                // This is needed when the first word starts right at the first character - and in order not to miss it,\n                // we need to start before.\n                column = 0;\n            }\n            while (nextWordOnLine\n                && (nextWordOnLine.wordType === 2 /* WordType.Separator */\n                    || nextWordOnLine.start + 1 <= column)) {\n                // Skip over a word made up of one single separator\n                // Also skip over word if it begins before current cursor position to ascertain we're moving forward at least 1 character.\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        else {\n            if (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    static _moveWordPartRight(model, position) {\n        const lineNumber = position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === maxColumn) {\n            return (lineNumber < model.getLineCount() ? new Position(lineNumber + 1, 1) : position);\n        }\n        const lineContent = model.getLineContent(lineNumber);\n        for (let column = position.column + 1; column < maxColumn; column++) {\n            const left = lineContent.charCodeAt(column - 2);\n            const right = lineContent.charCodeAt(column - 1);\n            if (left !== 95 /* CharCode.Underline */ && right === 95 /* CharCode.Underline */) {\n                // snake_case_variables\n                return new Position(lineNumber, column);\n            }\n            if (left !== 45 /* CharCode.Dash */ && right === 45 /* CharCode.Dash */) {\n                // kebab-case-variables\n                return new Position(lineNumber, column);\n            }\n            if ((strings.isLowerAsciiLetter(left) || strings.isAsciiDigit(left)) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    const rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight) || strings.isAsciiDigit(rightRight)) {\n                        return new Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new Position(lineNumber, maxColumn);\n    }\n    static _deleteWordLeftWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const startIndex = position.column - 2;\n        const lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\n        if (lastNonWhitespace + 1 < startIndex) {\n            return new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\n        }\n        return null;\n    }\n    static deleteWordLeft(ctx, wordNavigationType) {\n        const wordSeparators = ctx.wordSeparators;\n        const model = ctx.model;\n        const selection = ctx.selection;\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        if (DeleteOperations.isAutoClosingPairDelete(ctx.autoClosingDelete, ctx.autoClosingBrackets, ctx.autoClosingQuotes, ctx.autoClosingPairs.autoClosingPairsOpenByEnd, ctx.model, [ctx.selection], ctx.autoClosedCharacters)) {\n            const position = ctx.selection.getPosition();\n            return new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        if (lineNumber === 1 && column === 1) {\n            // Ignore deleting at beginning of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            const r = this._deleteWordLeftWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === 0 /* WordNavigationType.WordStart */) {\n            if (prevWordOnLine) {\n                column = prevWordOnLine.start + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        else {\n            if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            if (prevWordOnLine) {\n                column = prevWordOnLine.end + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n    static deleteInsideWord(wordSeparators, model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        const r = this._deleteInsideWordWhitespace(model, position);\n        if (r) {\n            return r;\n        }\n        return this._deleteInsideWordDetermineDeleteRange(wordSeparators, model, position);\n    }\n    static _charAtIsWhitespace(str, index) {\n        const charCode = str.charCodeAt(index);\n        return (charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */);\n    }\n    static _deleteInsideWordWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const lineContentLength = lineContent.length;\n        if (lineContentLength === 0) {\n            // empty line\n            return null;\n        }\n        let leftIndex = Math.max(position.column - 2, 0);\n        if (!this._charAtIsWhitespace(lineContent, leftIndex)) {\n            // touches a non-whitespace character to the left\n            return null;\n        }\n        let rightIndex = Math.min(position.column - 1, lineContentLength - 1);\n        if (!this._charAtIsWhitespace(lineContent, rightIndex)) {\n            // touches a non-whitespace character to the right\n            return null;\n        }\n        // walk over whitespace to the left\n        while (leftIndex > 0 && this._charAtIsWhitespace(lineContent, leftIndex - 1)) {\n            leftIndex--;\n        }\n        // walk over whitespace to the right\n        while (rightIndex + 1 < lineContentLength && this._charAtIsWhitespace(lineContent, rightIndex + 1)) {\n            rightIndex++;\n        }\n        return new Range(position.lineNumber, leftIndex + 1, position.lineNumber, rightIndex + 2);\n    }\n    static _deleteInsideWordDetermineDeleteRange(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const lineLength = lineContent.length;\n        if (lineLength === 0) {\n            // empty line\n            if (position.lineNumber > 1) {\n                return new Range(position.lineNumber - 1, model.getLineMaxColumn(position.lineNumber - 1), position.lineNumber, 1);\n            }\n            else {\n                if (position.lineNumber < model.getLineCount()) {\n                    return new Range(position.lineNumber, 1, position.lineNumber + 1, 1);\n                }\n                else {\n                    // empty model\n                    return new Range(position.lineNumber, 1, position.lineNumber, 1);\n                }\n            }\n        }\n        const touchesWord = (word) => {\n            return (word.start + 1 <= position.column && position.column <= word.end + 1);\n        };\n        const createRangeWithPosition = (startColumn, endColumn) => {\n            startColumn = Math.min(startColumn, position.column);\n            endColumn = Math.max(endColumn, position.column);\n            return new Range(position.lineNumber, startColumn, position.lineNumber, endColumn);\n        };\n        const deleteWordAndAdjacentWhitespace = (word) => {\n            let startColumn = word.start + 1;\n            let endColumn = word.end + 1;\n            let expandedToTheRight = false;\n            while (endColumn - 1 < lineLength && this._charAtIsWhitespace(lineContent, endColumn - 1)) {\n                expandedToTheRight = true;\n                endColumn++;\n            }\n            if (!expandedToTheRight) {\n                while (startColumn > 1 && this._charAtIsWhitespace(lineContent, startColumn - 2)) {\n                    startColumn--;\n                }\n            }\n            return createRangeWithPosition(startColumn, endColumn);\n        };\n        const prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (prevWordOnLine && touchesWord(prevWordOnLine)) {\n            return deleteWordAndAdjacentWhitespace(prevWordOnLine);\n        }\n        const nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (nextWordOnLine && touchesWord(nextWordOnLine)) {\n            return deleteWordAndAdjacentWhitespace(nextWordOnLine);\n        }\n        if (prevWordOnLine && nextWordOnLine) {\n            return createRangeWithPosition(prevWordOnLine.end + 1, nextWordOnLine.start + 1);\n        }\n        if (prevWordOnLine) {\n            return createRangeWithPosition(prevWordOnLine.start + 1, prevWordOnLine.end + 1);\n        }\n        if (nextWordOnLine) {\n            return createRangeWithPosition(nextWordOnLine.start + 1, nextWordOnLine.end + 1);\n        }\n        return createRangeWithPosition(1, lineLength + 1);\n    }\n    static _deleteWordPartLeft(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const pos = selection.getPosition();\n        const toPosition = WordOperations._moveWordPartLeft(model, pos);\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n    static _findFirstNonWhitespaceChar(str, startIndex) {\n        const len = str.length;\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\n            const ch = str.charAt(chIndex);\n            if (ch !== ' ' && ch !== '\\t') {\n                return chIndex;\n            }\n        }\n        return len;\n    }\n    static _deleteWordRightWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const startIndex = position.column - 1;\n        const firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\n        if (startIndex + 1 < firstNonWhitespace) {\n            // bingo\n            return new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\n        }\n        return null;\n    }\n    static deleteWordRight(ctx, wordNavigationType) {\n        const wordSeparators = ctx.wordSeparators;\n        const model = ctx.model;\n        const selection = ctx.selection;\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        const lineCount = model.getLineCount();\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (lineNumber === lineCount && column === maxColumn) {\n            // Ignore deleting at end of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            const r = this._deleteWordRightWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === 2 /* WordNavigationType.WordEnd */) {\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        else {\n            if (nextWordOnLine && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n    static _deleteWordPartRight(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const pos = selection.getPosition();\n        const toPosition = WordOperations._moveWordPartRight(model, pos);\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n    static _createWordAtPosition(model, lineNumber, word) {\n        const range = new Range(lineNumber, word.start + 1, lineNumber, word.end + 1);\n        return {\n            word: model.getValueInRange(range),\n            startColumn: range.startColumn,\n            endColumn: range.endColumn\n        };\n    }\n    static getWordAtPosition(model, _wordSeparators, position) {\n        const wordSeparators = getMapForWordSeparators(_wordSeparators);\n        const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n            return WordOperations._createWordAtPosition(model, position.lineNumber, prevWord);\n        }\n        const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n            return WordOperations._createWordAtPosition(model, position.lineNumber, nextWord);\n        }\n        return null;\n    }\n    static word(config, model, cursor, inSelectionMode, position) {\n        const wordSeparators = getMapForWordSeparators(config.wordSeparators);\n        const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (!inSelectionMode) {\n            // Entering word selection for the first time\n            let startColumn;\n            let endColumn;\n            if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n                // isTouchingPrevWord\n                startColumn = prevWord.start + 1;\n                endColumn = prevWord.end + 1;\n            }\n            else if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n                // isTouchingNextWord\n                startColumn = nextWord.start + 1;\n                endColumn = nextWord.end + 1;\n            }\n            else {\n                if (prevWord) {\n                    startColumn = prevWord.end + 1;\n                }\n                else {\n                    startColumn = 1;\n                }\n                if (nextWord) {\n                    endColumn = nextWord.start + 1;\n                }\n                else {\n                    endColumn = model.getLineMaxColumn(position.lineNumber);\n                }\n            }\n            return new SingleCursorState(new Range(position.lineNumber, startColumn, position.lineNumber, endColumn), 1 /* SelectionStartKind.Word */, 0, new Position(position.lineNumber, endColumn), 0);\n        }\n        let startColumn;\n        let endColumn;\n        if (prevWord && prevWord.wordType === 1 /* WordType.Regular */ && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\n            // isInsidePrevWord\n            startColumn = prevWord.start + 1;\n            endColumn = prevWord.end + 1;\n        }\n        else if (nextWord && nextWord.wordType === 1 /* WordType.Regular */ && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\n            // isInsideNextWord\n            startColumn = nextWord.start + 1;\n            endColumn = nextWord.end + 1;\n        }\n        else {\n            startColumn = position.column;\n            endColumn = position.column;\n        }\n        const lineNumber = position.lineNumber;\n        let column;\n        if (cursor.selectionStart.containsPosition(position)) {\n            column = cursor.selectionStart.endColumn;\n        }\n        else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\n            column = startColumn;\n            const possiblePosition = new Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.endColumn;\n            }\n        }\n        else {\n            column = endColumn;\n            const possiblePosition = new Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.startColumn;\n            }\n        }\n        return cursor.move(true, lineNumber, column, 0);\n    }\n}\nexport class WordPartOperations extends WordOperations {\n    static deleteWordPartLeft(ctx) {\n        const candidates = enforceDefined([\n            WordOperations.deleteWordLeft(ctx, 0 /* WordNavigationType.WordStart */),\n            WordOperations.deleteWordLeft(ctx, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._deleteWordPartLeft(ctx.model, ctx.selection)\n        ]);\n        candidates.sort(Range.compareRangesUsingEnds);\n        return candidates[2];\n    }\n    static deleteWordPartRight(ctx) {\n        const candidates = enforceDefined([\n            WordOperations.deleteWordRight(ctx, 0 /* WordNavigationType.WordStart */),\n            WordOperations.deleteWordRight(ctx, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._deleteWordPartRight(ctx.model, ctx.selection)\n        ]);\n        candidates.sort(Range.compareRangesUsingStarts);\n        return candidates[0];\n    }\n    static moveWordPartLeft(wordSeparators, model, position) {\n        const candidates = enforceDefined([\n            WordOperations.moveWordLeft(wordSeparators, model, position, 0 /* WordNavigationType.WordStart */),\n            WordOperations.moveWordLeft(wordSeparators, model, position, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._moveWordPartLeft(model, position)\n        ]);\n        candidates.sort(Position.compare);\n        return candidates[2];\n    }\n    static moveWordPartRight(wordSeparators, model, position) {\n        const candidates = enforceDefined([\n            WordOperations.moveWordRight(wordSeparators, model, position, 0 /* WordNavigationType.WordStart */),\n            WordOperations.moveWordRight(wordSeparators, model, position, 2 /* WordNavigationType.WordEnd */),\n            WordOperations._moveWordPartRight(model, position)\n        ]);\n        candidates.sort(Position.compare);\n        return candidates[0];\n    }\n}\nfunction enforceDefined(arr) {\n    return arr.filter(el => Boolean(el));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './core/position.js';\nimport { Range } from './core/range.js';\nimport { Selection } from './core/selection.js';\nimport { createScopedLineTokens } from './languages/supports.js';\nimport { CursorColumns } from './core/cursorColumns.js';\nimport { normalizeIndentation } from './core/indentation.js';\nconst autoCloseAlways = () => true;\nconst autoCloseNever = () => false;\nconst autoCloseBeforeWhitespace = (chr) => (chr === ' ' || chr === '\\t');\nexport class CursorConfiguration {\n    static shouldRecreate(e) {\n        return (e.hasChanged(138 /* EditorOption.layoutInfo */)\n            || e.hasChanged(124 /* EditorOption.wordSeparators */)\n            || e.hasChanged(34 /* EditorOption.emptySelectionClipboard */)\n            || e.hasChanged(73 /* EditorOption.multiCursorMergeOverlapping */)\n            || e.hasChanged(75 /* EditorOption.multiCursorPaste */)\n            || e.hasChanged(76 /* EditorOption.multiCursorLimit */)\n            || e.hasChanged(5 /* EditorOption.autoClosingBrackets */)\n            || e.hasChanged(8 /* EditorOption.autoClosingQuotes */)\n            || e.hasChanged(6 /* EditorOption.autoClosingDelete */)\n            || e.hasChanged(7 /* EditorOption.autoClosingOvertype */)\n            || e.hasChanged(11 /* EditorOption.autoSurround */)\n            || e.hasChanged(122 /* EditorOption.useTabStops */)\n            || e.hasChanged(47 /* EditorOption.fontInfo */)\n            || e.hasChanged(86 /* EditorOption.readOnly */));\n    }\n    constructor(languageId, modelOptions, configuration, languageConfigurationService) {\n        this.languageConfigurationService = languageConfigurationService;\n        this._cursorMoveConfigurationBrand = undefined;\n        this._languageId = languageId;\n        const options = configuration.options;\n        const layoutInfo = options.get(138 /* EditorOption.layoutInfo */);\n        const fontInfo = options.get(47 /* EditorOption.fontInfo */);\n        this.readOnly = options.get(86 /* EditorOption.readOnly */);\n        this.tabSize = modelOptions.tabSize;\n        this.indentSize = modelOptions.indentSize;\n        this.insertSpaces = modelOptions.insertSpaces;\n        this.stickyTabStops = options.get(110 /* EditorOption.stickyTabStops */);\n        this.lineHeight = fontInfo.lineHeight;\n        this.typicalHalfwidthCharacterWidth = fontInfo.typicalHalfwidthCharacterWidth;\n        this.pageSize = Math.max(1, Math.floor(layoutInfo.height / this.lineHeight) - 2);\n        this.useTabStops = options.get(122 /* EditorOption.useTabStops */);\n        this.wordSeparators = options.get(124 /* EditorOption.wordSeparators */);\n        this.emptySelectionClipboard = options.get(34 /* EditorOption.emptySelectionClipboard */);\n        this.copyWithSyntaxHighlighting = options.get(22 /* EditorOption.copyWithSyntaxHighlighting */);\n        this.multiCursorMergeOverlapping = options.get(73 /* EditorOption.multiCursorMergeOverlapping */);\n        this.multiCursorPaste = options.get(75 /* EditorOption.multiCursorPaste */);\n        this.multiCursorLimit = options.get(76 /* EditorOption.multiCursorLimit */);\n        this.autoClosingBrackets = options.get(5 /* EditorOption.autoClosingBrackets */);\n        this.autoClosingQuotes = options.get(8 /* EditorOption.autoClosingQuotes */);\n        this.autoClosingDelete = options.get(6 /* EditorOption.autoClosingDelete */);\n        this.autoClosingOvertype = options.get(7 /* EditorOption.autoClosingOvertype */);\n        this.autoSurround = options.get(11 /* EditorOption.autoSurround */);\n        this.autoIndent = options.get(9 /* EditorOption.autoIndent */);\n        this.surroundingPairs = {};\n        this._electricChars = null;\n        this.shouldAutoCloseBefore = {\n            quote: this._getShouldAutoClose(languageId, this.autoClosingQuotes, true),\n            bracket: this._getShouldAutoClose(languageId, this.autoClosingBrackets, false)\n        };\n        this.autoClosingPairs = this.languageConfigurationService.getLanguageConfiguration(languageId).getAutoClosingPairs();\n        const surroundingPairs = this.languageConfigurationService.getLanguageConfiguration(languageId).getSurroundingPairs();\n        if (surroundingPairs) {\n            for (const pair of surroundingPairs) {\n                this.surroundingPairs[pair.open] = pair.close;\n            }\n        }\n    }\n    get electricChars() {\n        var _a;\n        if (!this._electricChars) {\n            this._electricChars = {};\n            const electricChars = (_a = this.languageConfigurationService.getLanguageConfiguration(this._languageId).electricCharacter) === null || _a === void 0 ? void 0 : _a.getElectricCharacters();\n            if (electricChars) {\n                for (const char of electricChars) {\n                    this._electricChars[char] = true;\n                }\n            }\n        }\n        return this._electricChars;\n    }\n    /**\n     * Should return opening bracket type to match indentation with\n     */\n    onElectricCharacter(character, context, column) {\n        const scopedLineTokens = createScopedLineTokens(context, column - 1);\n        const electricCharacterSupport = this.languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId).electricCharacter;\n        if (!electricCharacterSupport) {\n            return null;\n        }\n        return electricCharacterSupport.onElectricCharacter(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\n    }\n    normalizeIndentation(str) {\n        return normalizeIndentation(str, this.indentSize, this.insertSpaces);\n    }\n    _getShouldAutoClose(languageId, autoCloseConfig, forQuotes) {\n        switch (autoCloseConfig) {\n            case 'beforeWhitespace':\n                return autoCloseBeforeWhitespace;\n            case 'languageDefined':\n                return this._getLanguageDefinedShouldAutoClose(languageId, forQuotes);\n            case 'always':\n                return autoCloseAlways;\n            case 'never':\n                return autoCloseNever;\n        }\n    }\n    _getLanguageDefinedShouldAutoClose(languageId, forQuotes) {\n        const autoCloseBeforeSet = this.languageConfigurationService.getLanguageConfiguration(languageId).getAutoCloseBeforeSet(forQuotes);\n        return c => autoCloseBeforeSet.indexOf(c) !== -1;\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    visibleColumnFromColumn(model, position) {\n        return CursorColumns.visibleColumnFromColumn(model.getLineContent(position.lineNumber), position.column, this.tabSize);\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    columnFromVisibleColumn(model, lineNumber, visibleColumn) {\n        const result = CursorColumns.columnFromVisibleColumn(model.getLineContent(lineNumber), visibleColumn, this.tabSize);\n        const minColumn = model.getLineMinColumn(lineNumber);\n        if (result < minColumn) {\n            return minColumn;\n        }\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (result > maxColumn) {\n            return maxColumn;\n        }\n        return result;\n    }\n}\nexport class CursorState {\n    static fromModelState(modelState) {\n        return new PartialModelCursorState(modelState);\n    }\n    static fromViewState(viewState) {\n        return new PartialViewCursorState(viewState);\n    }\n    static fromModelSelection(modelSelection) {\n        const selection = Selection.liftSelection(modelSelection);\n        const modelState = new SingleCursorState(Range.fromPositions(selection.getSelectionStart()), 0 /* SelectionStartKind.Simple */, 0, selection.getPosition(), 0);\n        return CursorState.fromModelState(modelState);\n    }\n    static fromModelSelections(modelSelections) {\n        const states = [];\n        for (let i = 0, len = modelSelections.length; i < len; i++) {\n            states[i] = this.fromModelSelection(modelSelections[i]);\n        }\n        return states;\n    }\n    constructor(modelState, viewState) {\n        this._cursorStateBrand = undefined;\n        this.modelState = modelState;\n        this.viewState = viewState;\n    }\n    equals(other) {\n        return (this.viewState.equals(other.viewState) && this.modelState.equals(other.modelState));\n    }\n}\nexport class PartialModelCursorState {\n    constructor(modelState) {\n        this.modelState = modelState;\n        this.viewState = null;\n    }\n}\nexport class PartialViewCursorState {\n    constructor(viewState) {\n        this.modelState = null;\n        this.viewState = viewState;\n    }\n}\n/**\n * Represents the cursor state on either the model or on the view model.\n */\nexport class SingleCursorState {\n    constructor(selectionStart, selectionStartKind, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns) {\n        this.selectionStart = selectionStart;\n        this.selectionStartKind = selectionStartKind;\n        this.selectionStartLeftoverVisibleColumns = selectionStartLeftoverVisibleColumns;\n        this.position = position;\n        this.leftoverVisibleColumns = leftoverVisibleColumns;\n        this._singleCursorStateBrand = undefined;\n        this.selection = SingleCursorState._computeSelection(this.selectionStart, this.position);\n    }\n    equals(other) {\n        return (this.selectionStartLeftoverVisibleColumns === other.selectionStartLeftoverVisibleColumns\n            && this.leftoverVisibleColumns === other.leftoverVisibleColumns\n            && this.selectionStartKind === other.selectionStartKind\n            && this.position.equals(other.position)\n            && this.selectionStart.equalsRange(other.selectionStart));\n    }\n    hasSelection() {\n        return (!this.selection.isEmpty() || !this.selectionStart.isEmpty());\n    }\n    move(inSelectionMode, lineNumber, column, leftoverVisibleColumns) {\n        if (inSelectionMode) {\n            // move just position\n            return new SingleCursorState(this.selectionStart, this.selectionStartKind, this.selectionStartLeftoverVisibleColumns, new Position(lineNumber, column), leftoverVisibleColumns);\n        }\n        else {\n            // move everything\n            return new SingleCursorState(new Range(lineNumber, column, lineNumber, column), 0 /* SelectionStartKind.Simple */, leftoverVisibleColumns, new Position(lineNumber, column), leftoverVisibleColumns);\n        }\n    }\n    static _computeSelection(selectionStart, position) {\n        if (selectionStart.isEmpty() || !position.isBeforeOrEqual(selectionStart.getStartPosition())) {\n            return Selection.fromPositions(selectionStart.getStartPosition(), position);\n        }\n        else {\n            return Selection.fromPositions(selectionStart.getEndPosition(), position);\n        }\n    }\n}\nexport class EditOperationResult {\n    constructor(type, commands, opts) {\n        this._editOperationResultBrand = undefined;\n        this.type = type;\n        this.commands = commands;\n        this.shouldPushStackElementBefore = opts.shouldPushStackElementBefore;\n        this.shouldPushStackElementAfter = opts.shouldPushStackElementAfter;\n    }\n}\nexport function isQuote(ch) {\n    return (ch === '\\'' || ch === '\"' || ch === '`');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n */\nexport class LineRangeMapping {\n    constructor(originalRange, modifiedRange, innerChanges) {\n        this.originalRange = originalRange;\n        this.modifiedRange = modifiedRange;\n        this.innerChanges = innerChanges;\n    }\n    toString() {\n        return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;\n    }\n}\n/**\n * Maps a range in the original text model to a range in the modified text model.\n */\nexport class RangeMapping {\n    constructor(originalRange, modifiedRange) {\n        this.originalRange = originalRange;\n        this.modifiedRange = modifiedRange;\n    }\n    toString() {\n        return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;\n    }\n}\n/**\n * A range of lines (1-based).\n */\nexport class LineRange {\n    constructor(startLineNumber, endLineNumberExclusive) {\n        this.startLineNumber = startLineNumber;\n        this.endLineNumberExclusive = endLineNumberExclusive;\n    }\n    /**\n     * Indicates if this line range is empty.\n     */\n    get isEmpty() {\n        return this.startLineNumber === this.endLineNumberExclusive;\n    }\n    /**\n     * Moves this line range by the given offset of line numbers.\n     */\n    delta(offset) {\n        return new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);\n    }\n    /**\n     * The number of lines this line range spans.\n     */\n    get length() {\n        return this.endLineNumberExclusive - this.startLineNumber;\n    }\n    /**\n     * Creates a line range that combines this and the given line range.\n     */\n    join(other) {\n        return new LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));\n    }\n    toString() {\n        return `[${this.startLineNumber},${this.endLineNumberExclusive})`;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../base/common/diff/diff.js';\nimport { LineRange, RangeMapping, LineRangeMapping } from './linesDiffComputer.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Range } from '../core/range.js';\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\nexport class SmartLinesDiffComputer {\n    computeDiff(originalLines, modifiedLines, options) {\n        var _a;\n        const diffComputer = new DiffComputer(originalLines, modifiedLines, {\n            maxComputationTime: options.maxComputationTimeMs,\n            shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,\n            shouldComputeCharChanges: true,\n            shouldMakePrettyDiff: true,\n            shouldPostProcessCharChanges: true,\n        });\n        const result = diffComputer.computeDiff();\n        const changes = [];\n        let lastChange = null;\n        for (const c of result.changes) {\n            let originalRange;\n            if (c.originalEndLineNumber === 0) {\n                // Insertion\n                originalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);\n            }\n            else {\n                originalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);\n            }\n            let modifiedRange;\n            if (c.modifiedEndLineNumber === 0) {\n                // Deletion\n                modifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);\n            }\n            else {\n                modifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);\n            }\n            let change = new LineRangeMapping(originalRange, modifiedRange, (_a = c.charChanges) === null || _a === void 0 ? void 0 : _a.map(c => new RangeMapping(new Range(c.originalStartLineNumber, c.originalStartColumn, c.originalEndLineNumber, c.originalEndColumn), new Range(c.modifiedStartLineNumber, c.modifiedStartColumn, c.modifiedEndLineNumber, c.modifiedEndColumn))));\n            if (lastChange) {\n                if (lastChange.modifiedRange.endLineNumberExclusive === change.modifiedRange.startLineNumber\n                    || lastChange.originalRange.endLineNumberExclusive === change.originalRange.startLineNumber) {\n                    // join touching diffs. Probably moving diffs up/down in the algorithm causes touching diffs.\n                    change = new LineRangeMapping(lastChange.originalRange.join(change.originalRange), lastChange.modifiedRange.join(change.modifiedRange), lastChange.innerChanges && change.innerChanges ?\n                        lastChange.innerChanges.concat(change.innerChanges) : undefined);\n                    changes.pop();\n                }\n            }\n            changes.push(change);\n            lastChange = change;\n        }\n        assertFn(() => {\n            return checkAdjacentItems(changes, (m1, m2) => m2.originalRange.startLineNumber - m1.originalRange.endLineNumberExclusive === m2.modifiedRange.startLineNumber - m1.modifiedRange.endLineNumberExclusive &&\n                // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n                m1.originalRange.endLineNumberExclusive < m2.originalRange.startLineNumber &&\n                m1.modifiedRange.endLineNumberExclusive < m2.modifiedRange.startLineNumber);\n        });\n        return {\n            quitEarly: result.quitEarly,\n            changes,\n        };\n    }\n}\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n    return diffAlgo.ComputeDiff(pretty);\n}\nclass LineSequence {\n    constructor(lines) {\n        const startColumns = [];\n        const endColumns = [];\n        for (let i = 0, length = lines.length; i < length; i++) {\n            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n            endColumns[i] = getLastNonBlankColumn(lines[i], 1);\n        }\n        this.lines = lines;\n        this._startColumns = startColumns;\n        this._endColumns = endColumns;\n    }\n    getElements() {\n        const elements = [];\n        for (let i = 0, len = this.lines.length; i < len; i++) {\n            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n        }\n        return elements;\n    }\n    getStrictElement(index) {\n        return this.lines[index];\n    }\n    getStartLineNumber(i) {\n        return i + 1;\n    }\n    getEndLineNumber(i) {\n        return i + 1;\n    }\n    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\n        const charCodes = [];\n        const lineNumbers = [];\n        const columns = [];\n        let len = 0;\n        for (let index = startIndex; index <= endIndex; index++) {\n            const lineContent = this.lines[index];\n            const startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\n            const endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\n            for (let col = startColumn; col < endColumn; col++) {\n                charCodes[len] = lineContent.charCodeAt(col - 1);\n                lineNumbers[len] = index + 1;\n                columns[len] = col;\n                len++;\n            }\n            if (!shouldIgnoreTrimWhitespace && index < endIndex) {\n                // Add \\n if trim whitespace is not ignored\n                charCodes[len] = 10 /* CharCode.LineFeed */;\n                lineNumbers[len] = index + 1;\n                columns[len] = lineContent.length + 1;\n                len++;\n            }\n        }\n        return new CharSequence(charCodes, lineNumbers, columns);\n    }\n}\nclass CharSequence {\n    constructor(charCodes, lineNumbers, columns) {\n        this._charCodes = charCodes;\n        this._lineNumbers = lineNumbers;\n        this._columns = columns;\n    }\n    toString() {\n        return ('[' + this._charCodes.map((s, idx) => (s === 10 /* CharCode.LineFeed */ ? '\\\\n' : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(', ') + ']');\n    }\n    _assertIndex(index, arr) {\n        if (index < 0 || index >= arr.length) {\n            throw new Error(`Illegal index`);\n        }\n    }\n    getElements() {\n        return this._charCodes;\n    }\n    getStartLineNumber(i) {\n        if (i > 0 && i === this._lineNumbers.length) {\n            // the start line number of the element after the last element\n            // is the end line number of the last element\n            return this.getEndLineNumber(i - 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        return this._lineNumbers[i];\n    }\n    getEndLineNumber(i) {\n        if (i === -1) {\n            // the end line number of the element before the first element\n            // is the start line number of the first element\n            return this.getStartLineNumber(i + 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return this._lineNumbers[i] + 1;\n        }\n        return this._lineNumbers[i];\n    }\n    getStartColumn(i) {\n        if (i > 0 && i === this._columns.length) {\n            // the start column of the element after the last element\n            // is the end column of the last element\n            return this.getEndColumn(i - 1);\n        }\n        this._assertIndex(i, this._columns);\n        return this._columns[i];\n    }\n    getEndColumn(i) {\n        if (i === -1) {\n            // the end column of the element before the first element\n            // is the start column of the first element\n            return this.getStartColumn(i + 1);\n        }\n        this._assertIndex(i, this._columns);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return 1;\n        }\n        return this._columns[i] + 1;\n    }\n}\nclass CharChange {\n    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalStartColumn = originalStartColumn;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.originalEndColumn = originalEndColumn;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedStartColumn = modifiedStartColumn;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.modifiedEndColumn = modifiedEndColumn;\n    }\n    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\n        const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n        const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n        const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n        const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n        const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n        const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\n    }\n}\nfunction postProcessCharChanges(rawChanges) {\n    if (rawChanges.length <= 1) {\n        return rawChanges;\n    }\n    const result = [rawChanges[0]];\n    let prevChange = result[0];\n    for (let i = 1, len = rawChanges.length; i < len; i++) {\n        const currChange = rawChanges[i];\n        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n        // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n            // Merge the current change into the previous one\n            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n        }\n        else {\n            // Add the current change\n            result.push(currChange);\n            prevChange = currChange;\n        }\n    }\n    return result;\n}\nclass LineChange {\n    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.charChanges = charChanges;\n    }\n    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\n        let originalStartLineNumber;\n        let originalEndLineNumber;\n        let modifiedStartLineNumber;\n        let modifiedEndLineNumber;\n        let charChanges = undefined;\n        if (diffChange.originalLength === 0) {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n            originalEndLineNumber = 0;\n        }\n        else {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        }\n        if (diffChange.modifiedLength === 0) {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n            modifiedEndLineNumber = 0;\n        }\n        else {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        }\n        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n            // Compute character changes for diff chunks of at most 20 lines...\n            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n            if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {\n                let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n                if (shouldPostProcessCharChanges) {\n                    rawChanges = postProcessCharChanges(rawChanges);\n                }\n                charChanges = [];\n                for (let i = 0, length = rawChanges.length; i < length; i++) {\n                    charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n                }\n            }\n        }\n        return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n    }\n}\nexport class DiffComputer {\n    constructor(originalLines, modifiedLines, opts) {\n        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n        this.originalLines = originalLines;\n        this.modifiedLines = modifiedLines;\n        this.original = new LineSequence(originalLines);\n        this.modified = new LineSequence(modifiedLines);\n        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n    }\n    computeDiff() {\n        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n            // empty original => fast path\n            if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n                return {\n                    quitEarly: false,\n                    changes: []\n                };\n            }\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: 1,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: this.modified.lines.length,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n            // empty modified => fast path\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: this.original.lines.length,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: 1,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n        const rawChanges = diffResult.changes;\n        const quitEarly = diffResult.quitEarly;\n        // The diff is always computed with ignoring trim whitespace\n        // This ensures we get the prettiest diff\n        if (this.shouldIgnoreTrimWhitespace) {\n            const lineChanges = [];\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\n                lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n            }\n            return {\n                quitEarly: quitEarly,\n                changes: lineChanges\n            };\n        }\n        // Need to post-process and introduce changes where the trim whitespace is different\n        // Note that we are looping starting at -1 to also cover the lines before the first change\n        const result = [];\n        let originalLineIndex = 0;\n        let modifiedLineIndex = 0;\n        for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n            const nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\n            const originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\n            const modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\n            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n                const originalLine = this.originalLines[originalLineIndex];\n                const modifiedLine = this.modifiedLines[modifiedLineIndex];\n                if (originalLine !== modifiedLine) {\n                    // These lines differ only in trim whitespace\n                    // Check the leading whitespace\n                    {\n                        let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n                        let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {\n                            const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n                            const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalStartColumn--;\n                            modifiedStartColumn--;\n                        }\n                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n                        }\n                    }\n                    // Check the trailing whitespace\n                    {\n                        let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n                        let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n                        const originalMaxColumn = originalLine.length + 1;\n                        const modifiedMaxColumn = modifiedLine.length + 1;\n                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n                            const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n                            const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalEndColumn++;\n                            modifiedEndColumn++;\n                        }\n                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n                        }\n                    }\n                }\n                originalLineIndex++;\n                modifiedLineIndex++;\n            }\n            if (nextChange) {\n                // Emit the actual change\n                result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n                originalLineIndex += nextChange.originalLength;\n                modifiedLineIndex += nextChange.modifiedLength;\n            }\n        }\n        return {\n            quitEarly: quitEarly,\n            changes: result\n        };\n    }\n    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n            // Merged into previous\n            return;\n        }\n        let charChanges = undefined;\n        if (this.shouldComputeCharChanges) {\n            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\n        }\n        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\n    }\n    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        const len = result.length;\n        if (len === 0) {\n            return false;\n        }\n        const prevChange = result[len - 1];\n        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n            // Don't merge with inserts/deletes\n            return false;\n        }\n        if (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n            prevChange.originalEndLineNumber = originalLineNumber;\n            prevChange.modifiedEndLineNumber = modifiedLineNumber;\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        return false;\n    }\n}\nfunction getFirstNonBlankColumn(txt, defaultValue) {\n    const r = strings.firstNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 1;\n}\nfunction getLastNonBlankColumn(txt, defaultValue) {\n    const r = strings.lastNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 2;\n}\nfunction createContinueProcessingPredicate(maximumRuntime) {\n    if (maximumRuntime === 0) {\n        return () => true;\n    }\n    const startTime = Date.now();\n    return () => {\n        return Date.now() - startTime < maximumRuntime;\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class SequenceDiff {\n    constructor(seq1Range, seq2Range) {\n        this.seq1Range = seq1Range;\n        this.seq2Range = seq2Range;\n    }\n    reverse() {\n        return new SequenceDiff(this.seq2Range, this.seq1Range);\n    }\n    toString() {\n        return `${this.seq1Range} <-> ${this.seq2Range}`;\n    }\n}\n/**\n * Todo move this class to some top level utils.\n*/\nexport class OffsetRange {\n    constructor(start, endExclusive) {\n        this.start = start;\n        this.endExclusive = endExclusive;\n    }\n    get isEmpty() {\n        return this.start === this.endExclusive;\n    }\n    delta(offset) {\n        return new OffsetRange(this.start + offset, this.endExclusive + offset);\n    }\n    get length() {\n        return this.endExclusive - this.start;\n    }\n    toString() {\n        return `[${this.start}, ${this.endExclusive})`;\n    }\n    join(other) {\n        return new OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class Array2D {\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n        this.array = [];\n        this.array = new Array(width * height);\n    }\n    get(x, y) {\n        return this.array[x + y * this.width];\n    }\n    set(x, y, value) {\n        this.array[x + y * this.width] = value;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SequenceDiff, OffsetRange } from './diffAlgorithm.js';\nimport { Array2D } from './utils.js';\n/**\n * A O(MN) diffing algorithm that supports a score function.\n * The algorithm can be improved by processing the 2d array diagonally.\n*/\nexport class DynamicProgrammingDiffing {\n    compute(sequence1, sequence2, equalityScore) {\n        /**\n         * lcsLengths.get(i, j): Length of the longest common subsequence of sequence1.substring(0, i + 1) and sequence2.substring(0, j + 1).\n         */\n        const lcsLengths = new Array2D(sequence1.length, sequence2.length);\n        const directions = new Array2D(sequence1.length, sequence2.length);\n        const lengths = new Array2D(sequence1.length, sequence2.length);\n        // ==== Initializing lcsLengths ====\n        for (let s1 = 0; s1 < sequence1.length; s1++) {\n            for (let s2 = 0; s2 < sequence2.length; s2++) {\n                const horizontalLen = s1 === 0 ? 0 : lcsLengths.get(s1 - 1, s2);\n                const verticalLen = s2 === 0 ? 0 : lcsLengths.get(s1, s2 - 1);\n                let extendedSeqScore;\n                if (sequence1.getElement(s1) === sequence2.getElement(s2)) {\n                    if (s1 === 0 || s2 === 0) {\n                        extendedSeqScore = 0;\n                    }\n                    else {\n                        extendedSeqScore = lcsLengths.get(s1 - 1, s2 - 1);\n                    }\n                    if (s1 > 0 && s2 > 0 && directions.get(s1 - 1, s2 - 1) === 3) {\n                        // Prefer consecutive diagonals\n                        extendedSeqScore += lengths.get(s1 - 1, s2 - 1);\n                    }\n                    extendedSeqScore += (equalityScore ? equalityScore(s1, s2) : 1);\n                }\n                else {\n                    extendedSeqScore = -1;\n                }\n                const newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);\n                if (newValue === extendedSeqScore) {\n                    // Prefer diagonals\n                    const prevLen = s1 > 0 && s2 > 0 ? lengths.get(s1 - 1, s2 - 1) : 0;\n                    lengths.set(s1, s2, prevLen + 1);\n                    directions.set(s1, s2, 3);\n                }\n                else if (newValue === horizontalLen) {\n                    lengths.set(s1, s2, 0);\n                    directions.set(s1, s2, 1);\n                }\n                else if (newValue === verticalLen) {\n                    lengths.set(s1, s2, 0);\n                    directions.set(s1, s2, 2);\n                }\n                lcsLengths.set(s1, s2, newValue);\n            }\n        }\n        // ==== Backtracking ====\n        const result = [];\n        let lastAligningPosS1 = sequence1.length;\n        let lastAligningPosS2 = sequence2.length;\n        function reportDecreasingAligningPositions(s1, s2) {\n            if (s1 + 1 !== lastAligningPosS1 || s2 + 1 !== lastAligningPosS2) {\n                result.push(new SequenceDiff(new OffsetRange(s1 + 1, lastAligningPosS1), new OffsetRange(s2 + 1, lastAligningPosS2)));\n            }\n            lastAligningPosS1 = s1;\n            lastAligningPosS2 = s2;\n        }\n        let s1 = sequence1.length - 1;\n        let s2 = sequence2.length - 1;\n        while (s1 >= 0 && s2 >= 0) {\n            if (directions.get(s1, s2) === 3) {\n                reportDecreasingAligningPositions(s1, s2);\n                s1--;\n                s2--;\n            }\n            else {\n                if (directions.get(s1, s2) === 1) {\n                    s1--;\n                }\n                else {\n                    s2--;\n                }\n            }\n        }\n        reportDecreasingAligningPositions(-1, -1);\n        result.reverse();\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange, SequenceDiff } from './diffAlgorithm.js';\nexport function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    let result = sequenceDiffs;\n    result = joinSequenceDiffs(sequence1, sequence2, result);\n    result = shiftSequenceDiffs(sequence1, sequence2, result);\n    return result;\n}\nexport function smoothenSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    const result = [];\n    for (const s of sequenceDiffs) {\n        const last = result[result.length - 1];\n        if (!last) {\n            result.push(s);\n            continue;\n        }\n        if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {\n            result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));\n        }\n        else {\n            result.push(s);\n        }\n    }\n    return result;\n}\n/**\n * This function fixes issues like this:\n * ```\n * import { Baz, Bar } from \"foo\";\n * ```\n * <->\n * ```\n * import { Baz, Bar, Foo } from \"foo\";\n * ```\n * Computed diff: [ {Add \",\" after Bar}, {Add \"Foo \" after space} }\n * Improved diff: [{Add \", Foo\" after Bar}]\n */\nexport function joinSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    const result = [];\n    if (sequenceDiffs.length > 0) {\n        result.push(sequenceDiffs[0]);\n    }\n    for (let i = 1; i < sequenceDiffs.length; i++) {\n        const lastResult = result[result.length - 1];\n        const cur = sequenceDiffs[i];\n        if (cur.seq1Range.isEmpty) {\n            let all = true;\n            const length = cur.seq1Range.start - lastResult.seq1Range.endExclusive;\n            for (let i = 1; i <= length; i++) {\n                if (sequence2.getElement(cur.seq2Range.start - i) !== sequence2.getElement(cur.seq2Range.endExclusive - i)) {\n                    all = false;\n                    break;\n                }\n            }\n            if (all) {\n                // Merge previous and current diff\n                result[result.length - 1] = new SequenceDiff(lastResult.seq1Range, new OffsetRange(lastResult.seq2Range.start, cur.seq2Range.endExclusive - length));\n                continue;\n            }\n        }\n        result.push(cur);\n    }\n    return result;\n}\n// align character level diffs at whitespace characters\n// import { IBar } from \"foo\";\n// import { I[Arr, I]Bar } from \"foo\";\n// ->\n// import { [IArr, ]IBar } from \"foo\";\n// import { ITransaction, observableValue, transaction } from 'vs/base/common/observable';\n// import { ITransaction, observable[FromEvent, observable]Value, transaction } from 'vs/base/common/observable';\n// ->\n// import { ITransaction, [observableFromEvent, ]observableValue, transaction } from 'vs/base/common/observable';\n// collectBrackets(level + 1, levelPerBracketType);\n// collectBrackets(level + 1, levelPerBracket[ + 1, levelPerBracket]Type);\n// ->\n// collectBrackets(level + 1, [levelPerBracket + 1, ]levelPerBracketType);\nexport function shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\n        return sequenceDiffs;\n    }\n    for (let i = 0; i < sequenceDiffs.length; i++) {\n        const diff = sequenceDiffs[i];\n        if (diff.seq1Range.isEmpty) {\n            const seq2PrevEndExclusive = (i > 0 ? sequenceDiffs[i - 1].seq2Range.endExclusive : -1);\n            const seq2NextStart = (i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1].seq2Range.start : sequence2.length);\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq2NextStart, seq2PrevEndExclusive);\n        }\n        else if (diff.seq2Range.isEmpty) {\n            const seq1PrevEndExclusive = (i > 0 ? sequenceDiffs[i - 1].seq1Range.endExclusive : -1);\n            const seq1NextStart = (i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1].seq1Range.start : sequence1.length);\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff.reverse(), sequence2, sequence1, seq1NextStart, seq1PrevEndExclusive).reverse();\n        }\n    }\n    return sequenceDiffs;\n}\nfunction shiftDiffToBetterPosition(diff, sequence1, sequence2, seq2NextStart, seq2PrevEndExclusive) {\n    const maxShiftLimit = 20; // To prevent performance issues\n    // don't touch previous or next!\n    let deltaBefore = 1;\n    while (diff.seq2Range.start - deltaBefore > seq2PrevEndExclusive &&\n        sequence2.getElement(diff.seq2Range.start - deltaBefore) ===\n            sequence2.getElement(diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {\n        deltaBefore++;\n    }\n    deltaBefore--;\n    let deltaAfter = 0;\n    while (diff.seq2Range.start + deltaAfter < seq2NextStart &&\n        sequence2.getElement(diff.seq2Range.start + deltaAfter) ===\n            sequence2.getElement(diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {\n        deltaAfter++;\n    }\n    if (deltaBefore === 0 && deltaAfter === 0) {\n        return diff;\n    }\n    // Visualize `[sequence1.text, diff.seq1Range.start + deltaAfter]`\n    // and `[sequence2.text, diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter]`\n    let bestDelta = 0;\n    let bestScore = -1;\n    // find best scored delta\n    for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {\n        const seq2OffsetStart = diff.seq2Range.start + delta;\n        const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\n        const seq1Offset = diff.seq1Range.start + delta;\n        const score = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);\n        if (score > bestScore) {\n            bestScore = score;\n            bestDelta = delta;\n        }\n    }\n    if (bestDelta !== 0) {\n        return new SequenceDiff(diff.seq1Range.delta(bestDelta), diff.seq2Range.delta(bestDelta));\n    }\n    return diff;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SequenceDiff, OffsetRange } from './diffAlgorithm.js';\n/**\n * An O(ND) diff algorithm that has a quadratic space worst-case complexity.\n*/\nexport class MyersDiffAlgorithm {\n    compute(seq1, seq2) {\n        // These are common special cases.\n        // The early return improves performance dramatically.\n        if (seq1.length === 0) {\n            return [new SequenceDiff(new OffsetRange(0, 0), new OffsetRange(0, seq2.length))];\n        }\n        else if (seq2.length === 0) {\n            return [new SequenceDiff(new OffsetRange(0, seq1.length), new OffsetRange(0, 0))];\n        }\n        function getXAfterSnake(x, y) {\n            while (x < seq1.length && y < seq2.length && seq1.getElement(x) === seq2.getElement(y)) {\n                x++;\n                y++;\n            }\n            return x;\n        }\n        let d = 0;\n        // V[k]: X value of longest d-line that ends in diagonal k.\n        // d-line: path from (0,0) to (x,y) that uses exactly d non-diagonals.\n        // diagonal k: Set of points (x,y) with x-y = k.\n        const V = new FastInt32Array();\n        V.set(0, getXAfterSnake(0, 0));\n        const paths = new FastArrayNegativeIndices();\n        paths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));\n        let k = 0;\n        loop: while (true) {\n            d++;\n            for (k = -d; k <= d; k += 2) {\n                const maxXofDLineTop = k === d ? -1 : V.get(k + 1); // We take a vertical non-diagonal\n                const maxXofDLineLeft = k === -d ? -1 : V.get(k - 1) + 1; // We take a horizontal non-diagonal (+1 x)\n                const x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seq1.length);\n                const y = x - k;\n                const newMaxX = getXAfterSnake(x, y);\n                V.set(k, newMaxX);\n                const lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);\n                paths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);\n                if (V.get(k) === seq1.length && V.get(k) - k === seq2.length) {\n                    break loop;\n                }\n            }\n        }\n        let path = paths.get(k);\n        const result = [];\n        let lastAligningPosS1 = seq1.length;\n        let lastAligningPosS2 = seq2.length;\n        while (true) {\n            const endX = path ? path.x + path.length : 0;\n            const endY = path ? path.y + path.length : 0;\n            if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {\n                result.push(new SequenceDiff(new OffsetRange(endX, lastAligningPosS1), new OffsetRange(endY, lastAligningPosS2)));\n            }\n            if (!path) {\n                break;\n            }\n            lastAligningPosS1 = path.x;\n            lastAligningPosS2 = path.y;\n            path = path.prev;\n        }\n        result.reverse();\n        return result;\n    }\n}\nclass SnakePath {\n    constructor(prev, x, y, length) {\n        this.prev = prev;\n        this.x = x;\n        this.y = y;\n        this.length = length;\n    }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastInt32Array {\n    constructor() {\n        this.positiveArr = new Int32Array(10);\n        this.negativeArr = new Int32Array(10);\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            if (idx >= this.negativeArr.length) {\n                const arr = this.negativeArr;\n                this.negativeArr = new Int32Array(arr.length * 2);\n                this.negativeArr.set(arr);\n            }\n            this.negativeArr[idx] = value;\n        }\n        else {\n            if (idx >= this.positiveArr.length) {\n                const arr = this.positiveArr;\n                this.positiveArr = new Int32Array(arr.length * 2);\n                this.positiveArr.set(arr);\n            }\n            this.positiveArr[idx] = value;\n        }\n    }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastArrayNegativeIndices {\n    constructor() {\n        this.positiveArr = [];\n        this.negativeArr = [];\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            this.negativeArr[idx] = value;\n        }\n        else {\n            this.positiveArr[idx] = value;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { OffsetRange, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { DynamicProgrammingDiffing } from './algorithms/dynamicProgrammingDiffing.js';\nimport { optimizeSequenceDiffs, smoothenSequenceDiffs } from './algorithms/joinSequenceDiffs.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { LineRange, LineRangeMapping, RangeMapping } from './linesDiffComputer.js';\nexport class StandardLinesDiffComputer {\n    constructor() {\n        this.dynamicProgrammingDiffing = new DynamicProgrammingDiffing();\n        this.myersDiffingAlgorithm = new MyersDiffAlgorithm();\n    }\n    computeDiff(originalLines, modifiedLines, options) {\n        const perfectHashes = new Map();\n        function getOrCreateHash(text) {\n            let hash = perfectHashes.get(text);\n            if (hash === undefined) {\n                hash = perfectHashes.size;\n                perfectHashes.set(text, hash);\n            }\n            return hash;\n        }\n        const srcDocLines = originalLines.map((l) => getOrCreateHash(l.trim()));\n        const tgtDocLines = modifiedLines.map((l) => getOrCreateHash(l.trim()));\n        const sequence1 = new LineSequence(srcDocLines, originalLines);\n        const sequence2 = new LineSequence(tgtDocLines, modifiedLines);\n        let lineAlignments = (() => {\n            if (sequence1.length + sequence2.length < 1500) {\n                // Use the improved algorithm for small files\n                return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2]\n                    ? modifiedLines[offset2].length === 0\n                        ? 0.1\n                        : 1 + Math.log(1 + modifiedLines[offset2].length)\n                    : 0.99);\n            }\n            return this.myersDiffingAlgorithm.compute(sequence1, sequence2);\n        })();\n        lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);\n        const alignments = [];\n        const scanForWhitespaceChanges = (equalLinesCount) => {\n            for (let i = 0; i < equalLinesCount; i++) {\n                const seq1Offset = seq1LastStart + i;\n                const seq2Offset = seq2LastStart + i;\n                if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {\n                    // This is because of whitespace changes, diff these lines\n                    const characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(seq1Offset, seq1Offset + 1), new OffsetRange(seq2Offset, seq2Offset + 1)));\n                    for (const a of characterDiffs) {\n                        alignments.push(a);\n                    }\n                }\n            }\n        };\n        let seq1LastStart = 0;\n        let seq2LastStart = 0;\n        for (const diff of lineAlignments) {\n            assertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);\n            const equalLinesCount = diff.seq1Range.start - seq1LastStart;\n            scanForWhitespaceChanges(equalLinesCount);\n            seq1LastStart = diff.seq1Range.endExclusive;\n            seq2LastStart = diff.seq2Range.endExclusive;\n            const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff);\n            for (const a of characterDiffs) {\n                alignments.push(a);\n            }\n        }\n        scanForWhitespaceChanges(originalLines.length - seq1LastStart);\n        const changes = lineRangeMappingFromRangeMappings(alignments);\n        return {\n            quitEarly: false,\n            changes: changes,\n        };\n    }\n    refineDiff(originalLines, modifiedLines, diff) {\n        const sourceSlice = new Slice(originalLines, diff.seq1Range);\n        const targetSlice = new Slice(modifiedLines, diff.seq2Range);\n        const originalDiffs = sourceSlice.length + targetSlice.length < 500\n            ? this.dynamicProgrammingDiffing.compute(sourceSlice, targetSlice)\n            : this.myersDiffingAlgorithm.compute(sourceSlice, targetSlice);\n        let diffs = optimizeSequenceDiffs(sourceSlice, targetSlice, originalDiffs);\n        diffs = smoothenSequenceDiffs(sourceSlice, targetSlice, diffs);\n        const result = diffs.map((d) => new RangeMapping(sourceSlice.translateRange(d.seq1Range).delta(diff.seq1Range.start), targetSlice.translateRange(d.seq2Range).delta(diff.seq2Range.start)));\n        return result;\n    }\n}\nexport function lineRangeMappingFromRangeMappings(alignments) {\n    const changes = [];\n    for (const g of group(alignments, (a1, a2) => (a2.originalRange.startLineNumber - (a1.originalRange.endLineNumber - (a1.originalRange.endColumn > 1 ? 0 : 1)) <= 1)\n        || (a2.modifiedRange.startLineNumber - (a1.modifiedRange.endLineNumber - (a1.modifiedRange.endColumn > 1 ? 0 : 1)) <= 1))) {\n        const first = g[0];\n        const last = g[g.length - 1];\n        changes.push(new LineRangeMapping(new LineRange(first.originalRange.startLineNumber, last.originalRange.endLineNumber + (last.originalRange.endColumn > 1 || last.modifiedRange.endColumn > 1 ? 1 : 0)), new LineRange(first.modifiedRange.startLineNumber, last.modifiedRange.endLineNumber + (last.originalRange.endColumn > 1 || last.modifiedRange.endColumn > 1 ? 1 : 0)), g));\n    }\n    assertFn(() => {\n        return checkAdjacentItems(changes, (m1, m2) => m2.originalRange.startLineNumber - m1.originalRange.endLineNumberExclusive === m2.modifiedRange.startLineNumber - m1.modifiedRange.endLineNumberExclusive &&\n            // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n            m1.originalRange.endLineNumberExclusive < m2.originalRange.startLineNumber &&\n            m1.modifiedRange.endLineNumberExclusive < m2.modifiedRange.startLineNumber);\n    });\n    return changes;\n}\nfunction* group(items, shouldBeGrouped) {\n    let currentGroup;\n    let last;\n    for (const item of items) {\n        if (last !== undefined && shouldBeGrouped(last, item)) {\n            currentGroup.push(item);\n        }\n        else {\n            if (currentGroup) {\n                yield currentGroup;\n            }\n            currentGroup = [item];\n        }\n        last = item;\n    }\n    if (currentGroup) {\n        yield currentGroup;\n    }\n}\nexport class LineSequence {\n    constructor(trimmedHash, lines) {\n        this.trimmedHash = trimmedHash;\n        this.lines = lines;\n    }\n    getElement(offset) {\n        return this.trimmedHash[offset];\n    }\n    get length() {\n        return this.trimmedHash.length;\n    }\n    getBoundaryScore(length) {\n        const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);\n        const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);\n        return 1000 - (indentationBefore + indentationAfter);\n    }\n}\nfunction getIndentation(str) {\n    let i = 0;\n    while (i < str.length && (str.charCodeAt(i) === 32 /* CharCode.Space */ || str.charCodeAt(i) === 9 /* CharCode.Tab */)) {\n        i++;\n    }\n    return i;\n}\nclass Slice {\n    constructor(lines, lineRange) {\n        this.lines = lines;\n        this.lineRange = lineRange;\n        let chars = 0;\n        this.firstCharOnLineOffsets = new Int32Array(lineRange.length);\n        for (let i = lineRange.start; i < lineRange.endExclusive; i++) {\n            const line = lines[i];\n            chars += line.length;\n            this.firstCharOnLineOffsets[i - lineRange.start] = chars + 1;\n            chars++;\n        }\n        this.elements = new Int32Array(chars);\n        let offset = 0;\n        for (let i = lineRange.start; i < lineRange.endExclusive; i++) {\n            const line = lines[i];\n            for (let i = 0; i < line.length; i++) {\n                this.elements[offset + i] = line.charCodeAt(i);\n            }\n            offset += line.length;\n            if (i < lines.length - 1) {\n                this.elements[offset] = '\\n'.charCodeAt(0);\n                offset += 1;\n            }\n        }\n    }\n    getElement(offset) {\n        return this.elements[offset];\n    }\n    get length() {\n        return this.elements.length;\n    }\n    getBoundaryScore(length) {\n        //   a   b   c   ,           d   e   f\n        // 11  0   0   12  15  6   13  0   0   11\n        const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n        const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n        if (prevCategory === 6 /* CharBoundaryCategory.LineBreakCR */ && nextCategory === 7 /* CharBoundaryCategory.LineBreakLF */) {\n            // don't break between \\r and \\n\n            return 0;\n        }\n        let score = 0;\n        if (prevCategory !== nextCategory) {\n            score += 10;\n            if (nextCategory === 1 /* CharBoundaryCategory.WordUpper */) {\n                score += 1;\n            }\n        }\n        score += getCategoryBoundaryScore(prevCategory);\n        score += getCategoryBoundaryScore(nextCategory);\n        return score;\n    }\n    translateOffset(offset) {\n        // find smallest i, so that lineBreakOffsets[i] > offset using binary search\n        let i = 0;\n        let j = this.firstCharOnLineOffsets.length;\n        while (i < j) {\n            const k = Math.floor((i + j) / 2);\n            if (this.firstCharOnLineOffsets[k] > offset) {\n                j = k;\n            }\n            else {\n                i = k + 1;\n            }\n        }\n        const offsetOfPrevLineBreak = i === 0 ? 0 : this.firstCharOnLineOffsets[i - 1];\n        return new Position(i + 1, offset - offsetOfPrevLineBreak + 1);\n    }\n    translateRange(range) {\n        return Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));\n    }\n}\nconst score = {\n    [0 /* CharBoundaryCategory.WordLower */]: 0,\n    [1 /* CharBoundaryCategory.WordUpper */]: 0,\n    [2 /* CharBoundaryCategory.WordNumber */]: 0,\n    [3 /* CharBoundaryCategory.End */]: 10,\n    [4 /* CharBoundaryCategory.Other */]: 2,\n    [5 /* CharBoundaryCategory.Space */]: 3,\n    [6 /* CharBoundaryCategory.LineBreakCR */]: 10,\n    [7 /* CharBoundaryCategory.LineBreakLF */]: 10,\n};\nfunction getCategoryBoundaryScore(category) {\n    return score[category];\n}\nfunction getCategory(charCode) {\n    if (charCode === 10 /* CharCode.LineFeed */) {\n        return 7 /* CharBoundaryCategory.LineBreakLF */;\n    }\n    else if (charCode === 13 /* CharCode.CarriageReturn */) {\n        return 6 /* CharBoundaryCategory.LineBreakCR */;\n    }\n    else if (isSpace(charCode)) {\n        return 5 /* CharBoundaryCategory.Space */;\n    }\n    else if (charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */) {\n        return 0 /* CharBoundaryCategory.WordLower */;\n    }\n    else if (charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */) {\n        return 1 /* CharBoundaryCategory.WordUpper */;\n    }\n    else if (charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */) {\n        return 2 /* CharBoundaryCategory.WordNumber */;\n    }\n    else if (charCode === -1) {\n        return 3 /* CharBoundaryCategory.End */;\n    }\n    else {\n        return 4 /* CharBoundaryCategory.Other */;\n    }\n}\nfunction isSpace(charCode) {\n    return charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SmartLinesDiffComputer } from './smartLinesDiffComputer.js';\nimport { StandardLinesDiffComputer } from './standardLinesDiffComputer.js';\nexport const linesDiffComputers = {\n    smart: new SmartLinesDiffComputer(),\n    experimental: new StandardLinesDiffComputer(),\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class InternalEditorAction {\n    constructor(id, label, alias, precondition, run, contextKeyService) {\n        this.id = id;\n        this.label = label;\n        this.alias = alias;\n        this._precondition = precondition;\n        this._run = run;\n        this._contextKeyService = contextKeyService;\n    }\n    isSupported() {\n        return this._contextKeyService.contextMatchesRules(this._precondition);\n    }\n    run() {\n        if (!this.isSupported()) {\n            return Promise.resolve(undefined);\n        }\n        return this._run();\n    }\n}\n","/**\n * The type of the `IEditor`.\n */\nexport const EditorType = {\n    ICodeEditor: 'vs.editor.ICodeEditor',\n    IDiffEditor: 'vs.editor.IDiffEditor'\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../nls.js';\nimport { RawContextKey } from '../../platform/contextkey/common/contextkey.js';\nexport var EditorContextKeys;\n(function (EditorContextKeys) {\n    EditorContextKeys.editorSimpleInput = new RawContextKey('editorSimpleInput', false, true);\n    /**\n     * A context key that is set when the editor's text has focus (cursor is blinking).\n     * Is false when focus is in simple editor widgets (repl input, scm commit input).\n     */\n    EditorContextKeys.editorTextFocus = new RawContextKey('editorTextFocus', false, nls.localize('editorTextFocus', \"Whether the editor text has focus (cursor is blinking)\"));\n    /**\n     * A context key that is set when the editor's text or an editor's widget has focus.\n     */\n    EditorContextKeys.focus = new RawContextKey('editorFocus', false, nls.localize('editorFocus', \"Whether the editor or an editor widget has focus (e.g. focus is in the find widget)\"));\n    /**\n     * A context key that is set when any editor input has focus (regular editor, repl input...).\n     */\n    EditorContextKeys.textInputFocus = new RawContextKey('textInputFocus', false, nls.localize('textInputFocus', \"Whether an editor or a rich text input has focus (cursor is blinking)\"));\n    EditorContextKeys.readOnly = new RawContextKey('editorReadonly', false, nls.localize('editorReadonly', \"Whether the editor is read only\"));\n    EditorContextKeys.inDiffEditor = new RawContextKey('inDiffEditor', false, nls.localize('inDiffEditor', \"Whether the context is a diff editor\"));\n    EditorContextKeys.columnSelection = new RawContextKey('editorColumnSelection', false, nls.localize('editorColumnSelection', \"Whether `editor.columnSelection` is enabled\"));\n    EditorContextKeys.writable = EditorContextKeys.readOnly.toNegated();\n    EditorContextKeys.hasNonEmptySelection = new RawContextKey('editorHasSelection', false, nls.localize('editorHasSelection', \"Whether the editor has text selected\"));\n    EditorContextKeys.hasOnlyEmptySelection = EditorContextKeys.hasNonEmptySelection.toNegated();\n    EditorContextKeys.hasMultipleSelections = new RawContextKey('editorHasMultipleSelections', false, nls.localize('editorHasMultipleSelections', \"Whether the editor has multiple selections\"));\n    EditorContextKeys.hasSingleSelection = EditorContextKeys.hasMultipleSelections.toNegated();\n    EditorContextKeys.tabMovesFocus = new RawContextKey('editorTabMovesFocus', false, nls.localize('editorTabMovesFocus', \"Whether `Tab` will move focus out of the editor\"));\n    EditorContextKeys.tabDoesNotMoveFocus = EditorContextKeys.tabMovesFocus.toNegated();\n    EditorContextKeys.isInWalkThroughSnippet = new RawContextKey('isInEmbeddedEditor', false, true);\n    EditorContextKeys.canUndo = new RawContextKey('canUndo', false, true);\n    EditorContextKeys.canRedo = new RawContextKey('canRedo', false, true);\n    EditorContextKeys.hoverVisible = new RawContextKey('editorHoverVisible', false, nls.localize('editorHoverVisible', \"Whether the editor hover is visible\"));\n    /**\n     * A context key that is set when an editor is part of a larger editor, like notebooks or\n     * (future) a diff editor\n     */\n    EditorContextKeys.inCompositeEditor = new RawContextKey('inCompositeEditor', undefined, nls.localize('inCompositeEditor', \"Whether the editor is part of a larger editor (e.g. notebooks)\"));\n    EditorContextKeys.notInCompositeEditor = EditorContextKeys.inCompositeEditor.toNegated();\n    // -- mode context keys\n    EditorContextKeys.languageId = new RawContextKey('editorLangId', '', nls.localize('editorLangId', \"The language identifier of the editor\"));\n    EditorContextKeys.hasCompletionItemProvider = new RawContextKey('editorHasCompletionItemProvider', false, nls.localize('editorHasCompletionItemProvider', \"Whether the editor has a completion item provider\"));\n    EditorContextKeys.hasCodeActionsProvider = new RawContextKey('editorHasCodeActionsProvider', false, nls.localize('editorHasCodeActionsProvider', \"Whether the editor has a code actions provider\"));\n    EditorContextKeys.hasCodeLensProvider = new RawContextKey('editorHasCodeLensProvider', false, nls.localize('editorHasCodeLensProvider', \"Whether the editor has a code lens provider\"));\n    EditorContextKeys.hasDefinitionProvider = new RawContextKey('editorHasDefinitionProvider', false, nls.localize('editorHasDefinitionProvider', \"Whether the editor has a definition provider\"));\n    EditorContextKeys.hasDeclarationProvider = new RawContextKey('editorHasDeclarationProvider', false, nls.localize('editorHasDeclarationProvider', \"Whether the editor has a declaration provider\"));\n    EditorContextKeys.hasImplementationProvider = new RawContextKey('editorHasImplementationProvider', false, nls.localize('editorHasImplementationProvider', \"Whether the editor has an implementation provider\"));\n    EditorContextKeys.hasTypeDefinitionProvider = new RawContextKey('editorHasTypeDefinitionProvider', false, nls.localize('editorHasTypeDefinitionProvider', \"Whether the editor has a type definition provider\"));\n    EditorContextKeys.hasHoverProvider = new RawContextKey('editorHasHoverProvider', false, nls.localize('editorHasHoverProvider', \"Whether the editor has a hover provider\"));\n    EditorContextKeys.hasDocumentHighlightProvider = new RawContextKey('editorHasDocumentHighlightProvider', false, nls.localize('editorHasDocumentHighlightProvider', \"Whether the editor has a document highlight provider\"));\n    EditorContextKeys.hasDocumentSymbolProvider = new RawContextKey('editorHasDocumentSymbolProvider', false, nls.localize('editorHasDocumentSymbolProvider', \"Whether the editor has a document symbol provider\"));\n    EditorContextKeys.hasReferenceProvider = new RawContextKey('editorHasReferenceProvider', false, nls.localize('editorHasReferenceProvider', \"Whether the editor has a reference provider\"));\n    EditorContextKeys.hasRenameProvider = new RawContextKey('editorHasRenameProvider', false, nls.localize('editorHasRenameProvider', \"Whether the editor has a rename provider\"));\n    EditorContextKeys.hasSignatureHelpProvider = new RawContextKey('editorHasSignatureHelpProvider', false, nls.localize('editorHasSignatureHelpProvider', \"Whether the editor has a signature help provider\"));\n    EditorContextKeys.hasInlayHintsProvider = new RawContextKey('editorHasInlayHintsProvider', false, nls.localize('editorHasInlayHintsProvider', \"Whether the editor has an inline hints provider\"));\n    // -- mode context keys: formatting\n    EditorContextKeys.hasDocumentFormattingProvider = new RawContextKey('editorHasDocumentFormattingProvider', false, nls.localize('editorHasDocumentFormattingProvider', \"Whether the editor has a document formatting provider\"));\n    EditorContextKeys.hasDocumentSelectionFormattingProvider = new RawContextKey('editorHasDocumentSelectionFormattingProvider', false, nls.localize('editorHasDocumentSelectionFormattingProvider', \"Whether the editor has a document selection formatting provider\"));\n    EditorContextKeys.hasMultipleDocumentFormattingProvider = new RawContextKey('editorHasMultipleDocumentFormattingProvider', false, nls.localize('editorHasMultipleDocumentFormattingProvider', \"Whether the editor has multiple document formatting providers\"));\n    EditorContextKeys.hasMultipleDocumentSelectionFormattingProvider = new RawContextKey('editorHasMultipleDocumentSelectionFormattingProvider', false, nls.localize('editorHasMultipleDocumentSelectionFormattingProvider', \"Whether the editor has multiple document selection formatting providers\"));\n})(EditorContextKeys || (EditorContextKeys = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst editorFeatures = [];\n/**\n * Registers an editor feature. Editor features will be instantiated only once, as soon as\n * the first code editor is instantiated.\n */\nexport function registerEditorFeature(ctor) {\n    editorFeatures.push(ctor);\n}\nexport function getEditorFeatures() {\n    return editorFeatures.slice(0);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class EditorTheme {\n    get type() {\n        return this._theme.type;\n    }\n    get value() {\n        return this._theme;\n    }\n    constructor(theme) {\n        this._theme = theme;\n    }\n    update(theme) {\n        this._theme = theme;\n    }\n    getColor(color) {\n        return this._theme.getColor(color);\n    }\n}\n"],"names":["CharacterClassifier","_defaultValue","_classCallCheck","defaultValue","toUint8","this","_asciiMap","_createAsciiMap","_map","Map","_createClass","key","value","charCode","_value","set","get","fill","clear","asciiMap","Uint8Array","CharacterSet","_actual","CursorColumns","codePoint","visibleColumn","tabSize","nextRenderTabStop","strings","lineContent","column","textLen","Math","min","length","text","substring","iterator","result","eol","offset","nextGraphemeLength","_nextVisibleColumn","lineContentLength","beforeVisibleColumn","beforeColumn","afterVisibleColumn","afterColumn","indentSize","max","EditOperation","position","range","Range","lineNumber","forceMoveMarkers","editorLineHighlight","registerColor","dark","light","hcDark","hcLight","nls","editorLineHighlightBorder","contrastBorder","editorCursorForeground","activeContrastBorder","editorFindMatchHighlight","Color","editorCursorBackground","editorWhitespaces","editorIndentGuides","editorActiveIndentGuides","editorLineNumbers","deprecatedEditorActiveLineNumber","editorDimmedLineNumber","editorOverviewRulerBorder","editorOverviewRulerBackground","editorUnnecessaryCodeOpacity","editorBackground","transparent","rulerRangeDefault","RGBA","overviewRulerRangeHighlight","overviewRulerError","overviewRulerWarning","editorWarningForeground","editorWarningBorder","overviewRulerInfo","editorInfoForeground","editorInfoBorder","editorBracketHighlightingForeground1","editorBracketHighlightingForeground2","editorBracketHighlightingForeground3","editorBracketHighlightingForeground4","editorBracketHighlightingForeground5","editorBracketHighlightingForeground6","editorBracketHighlightingUnexpectedBracketForeground","editorBracketPairGuideBackground1","editorBracketPairGuideBackground2","editorBracketPairGuideBackground3","editorBracketPairGuideBackground4","editorBracketPairGuideBackground5","editorBracketPairGuideBackground6","editorBracketPairGuideActiveBackground1","editorBracketPairGuideActiveBackground2","editorBracketPairGuideActiveBackground3","editorBracketPairGuideActiveBackground4","editorBracketPairGuideActiveBackground5","editorBracketPairGuideActiveBackground6","registerThemingParticipant","theme","collector","background","getColor","lineHighlight","imeBackground","isTransparent","addRule","concat","countEOL","eolCount","firstLineLength","lastLineStart","i","len","chr","charCodeAt","normalizeIndentation","str","insertSpaces","firstNonWhitespaceIndex","spacesCnt","charAt","tabsCnt","floor","_normalizeIndentationFromWhitespace","Position","newLineNumber","arguments","undefined","newColumn","deltaLineNumber","deltaColumn","with","other","equals","isBefore","isBeforeOrEqual","a","b","aLineNumber","bLineNumber","pos","obj","startLineNumber","startColumn","endLineNumber","endColumn","isEmpty","containsPosition","containsRange","strictContainsRange","plusRange","intersectRanges","equalsRange","getEndPosition","getStartPosition","collapseToStart","collapseToEnd","lineCount","otherRange","resultStartLineNumber","resultStartColumn","resultEndLineNumber","resultEndColumn","otherStartLineNumber","otherStartColumn","otherEndLineNumber","otherEndColumn","start","end","aStartLineNumber","bStartLineNumber","aStartColumn","bStartColumn","aEndLineNumber","bEndLineNumber","RGBA8","r","g","_rgba8Brand","_clamp","c","Empty","Selection","_Range","_inherits","_super","_createSuper","selectionStartLineNumber","selectionStartColumn","positionLineNumber","positionColumn","_this","call","selectionsEqual","getDirection","direction","sel","_utf16LE_TextDecoder","_utf16BE_TextDecoder","_platformTextDecoder","getUTF16LE_TextDecoder","TextDecoder","getPlatformTextDecoder","platform","decodeUTF16LE","source","view","Uint16Array","buffer","resultLen","String","fromCharCode","join","compatDecodeUTF16LE","decode","StringBuilder","capacity","_capacity","_buffer","_completedStrings","_bufferLength","_flushBuffer","_buildBuffer","bufferString","remainingSpace","strLen","escapeNewLine","replace","TextChange","oldPosition","oldText","newPosition","newText","_writeStringSize","_writeString","dest","_readString","push","compressConsecutiveTextChanges","prevEdits","currEdits","TextChangeCompressor","compress","_prevEdits","_currEdits","_result","_resultLen","_prevLen","_prevDeltaOffset","_currLen","_currDeltaOffset","prevIndex","currIndex","prevEdit","_getPrev","currEdit","_getCurr","oldEnd","_acceptCurr","newEnd","_acceptPrev","_TextChangeCompressor","_splitCurr","_TextChangeCompressor2","_slicedToArray","e1","e2","_TextChangeCompressor3","_splitPrev","_TextChangeCompressor4","mergePrev","mergeCurr","_TextChangeCompressor5","oldLength","_TextChangeCompressor6","_TextChangeCompressor7","newLength","_TextChangeCompressor8","merged","_merge","_removeNoOps","_rebaseCurr","_rebasePrev","prevDeltaOffset","currDeltaOffset","edit","preText","substr","postText","edits","prev","curr","EDITOR_MODEL_DEFAULTS","detectIndentation","trimAutoWhitespace","largeFileOptimizations","bracketPairColorizationOptions","enabled","independentColorPoolPerBracketType","WordCharacterClassifier","_CharacterClassifier","wordSeparators","getMapForWordSeparators","computeFn","cache","input","hasOwnProperty","once","USUAL_WORD_SEPARATORS","DEFAULT_WORD_REGEXP","_step","allowInWords","_iterator","_createForOfIteratorHelper","s","n","done","sep","indexOf","err","e","f","RegExp","createWordRegExp","ensureValidWordDefinition","wordDefinition","global","flags","ignoreCase","multiline","unicode","lastIndex","_defaultConfig","LinkedList","getWordAtText","textOffset","config","Iterable","maxLen","t1","Date","now","prevRegexIndex","match","timeBudget","regexIndex","windowSize","thisMatch","_findRegexMatchEnclosingPosition","word","index","stopPos","exec","matchIndex","unshift","Cursor","context","_selTrackedRange","_trackSelection","_setState","SingleCursorState","_removeTrackedRange","_updateTrackedRange","model","_setTrackedRange","modelState","selection","CursorState","viewState","_getTrackedRange","_validateViewState","viewModel","selectionStart","validateRange","selectionStartLeftoverVisibleColumns","validatePosition","leftoverVisibleColumns","selectionStartKind","coordinatesConverter","convertViewRangeToModelRange","convertViewPositionToModelPosition","viewSelectionStart","validateViewRange","viewPosition","validateViewPosition","viewSelectionStart1","convertModelPositionToViewPosition","viewSelectionStart2","cacheInput","cacheOutput","normalizePosition","sStartPosition","sEndPosition","validPosition","validSStartPosition","_validatePositionWithCache","validSEndPosition","CursorCollection","cursors","lastAddedCursorIndex","dispose","_step2","_iterator2","startTrackingSelection","_step3","_iterator3","stopTrackingSelection","_step4","_iterator4","ensureValidState","map","readSelectionFromMarkers","asCursorState","findMinBy","compareBy","findLastMaxBy","selections","setStates","states","setState","_setSecondaryStates","slice","secondaryStates","secondaryCursorsLength","secondaryStatesLength","createCnt","_addSecondaryCursor","removeCnt","_removeSecondaryCursor","removeIndex","splice","sortedCursors","sort","sortedCursorIndex","current","next","currentSelection","nextSelection","cursorConfig","multiCursorMergeOverlapping","winnerSortedCursorIndex","looserSortedCursorIndex","looserIndex","winnerIndex","looserSelection","winnerSelection","equalsSelection","resultingRange","looserSelectionIsLTR","winnerSelectionIsLTR","resultingSelectionIsLTR","resultingSelection","resultingState","_step5","_iterator5","sortedCursor","CursorContext","_cursorContextBrand","CursorsController","_Disposable","_model","_knownModelVersionId","getVersionId","_viewModel","_coordinatesConverter","_cursors","_hasFocus","_isHandling","_compositionState","_columnSelectData","_autoClosedActions","_prevEditOperationType","_get","_getPrototypeOf","prototype","updateContext","eventsCollector","getCursorStates","hasFocus","getSelections","autoClosedAction","isValid","getPrimaryCursor","getLastAddedCursorIndex","getAll","reason","reachedMaxCursorCount","multiCursorLimit","oldState","CursorModelState","from","normalize","_validateAutoClosedActions","_emitStateChangedIfNecessary","columnSelectData","minimalReveal","verticalType","revealHorizontal","scrollType","viewPositions","getViewPositions","revealViewRange","revealViewSelections","getViewSelections","emitViewEvent","ViewRevealRangeRequestEvent","inSelectionMode","desiredSelections","state","revealPrimary","event","ModelInjectedTextChangedEvent","rawContentChangedEvent","versionId","hadFlushEvent","containsEvent","cursorState","isUndoing","isRedoing","selectionsFromMarkers","getTopMostViewPosition","getBottomMostViewPosition","primaryCursor","isReal","fromViewLineNumber","fromViewVisualColumn","visibleColumnFromColumn","toViewLineNumber","toViewVisualColumn","type","autoClosedCharactersRanges","autoClosedEnclosingRanges","autoClosedCharactersDeltaDecorations","autoClosedEnclosingDeltaDecorations","options","description","inlineClassName","stickiness","autoClosedCharactersDecorations","deltaDecorations","autoClosedEnclosingDecorations","AutoClosedAction","opResult","shouldPushStackElementBefore","pushStackElement","CommandExecutor","executeCommands","commands","_interpretCommandResult","command","TypeWithAutoClosingCommand","enclosingRange","closeCharacterRange","_pushAutoClosedAction","shouldPushStackElementAfter","setSelections","newState","viewSelections","ViewCursorStateChangedEvent","some","newCursorState","oldSelections","oldModelVersionId","modelVersionId","emitOutgoingEvent","CursorStateChangedEvent","indices","m","closeChar","autoClosingPairsCandidates","autoClosingPairs","autoClosingPairsCloseSingleChar","openChar","open","closeCharIndex","openCharIndex","lastIndexOf","cursorStateComputer","_this2","autoClosingIndices","_findAutoClosingPairs","_isTracked","pushEditOperations","undoEdits","_autoClosingIndices$i","openCharInnerIndex","closeCharInnerIndex","undoEdit","callback","cursorChangeReason","readOnly","stopTrackingSelections","onUnexpectedError","startTrackingSelections","getAllAutoClosedCharacters","CompositionState","_this3","compositionOutcome","deduceOutcome","_executeEdit","_executeEditOperation","TypeOperations","getAutoClosedCharacters","_this4","charLength","replacePrevCharCnt","replaceNextCharCnt","positionDelta","_this5","newSelections","getPosition","pasteOnNewLine","multicursorText","_this6","_this7","DeleteOperations","_this8","killSecondaryCursors","EditOperationResult","_this9","Disposable","cursor","_autoClosedCharactersDecorations","_autoClosedEnclosingDecorations","decorationRange","getDecorationRange","enclosingRanges","autoClosedActions","autoClosedCharacters","getAutoClosedCharactersRanges","selectionsBefore","ctx","trackedRanges","trackedRangesDirection","_innerExecuteCommands","_arrayIsEmpty","commandsData","_getEditOperations","operations","rawOperations","loserCursorsMap","_getLoserCursorMap","console","warn","filteredOperations","identifier","major","toString","hadTrackedEditOperation","selectionsAfter","inverseEditOperations","groupedInverseEditOperations","op","minorBasedSorter","minor","cursorSelections","_loop","_i3","computeCursorState","getInverseEditOperations","getTrackedSelection","id","idx","parseInt","losingCursors","losingCursorIndex","_i4","_losingCursors","losingCursor","_getEditOperationsFromCommand","majorIdentifier","operationMinor","addEditOperation","isAutoWhitespaceEdit","insertsAutoWhitespace","editOperationBuilder","addTrackedEditOperation","trackSelection","_selection","trackPreviousOnEmpty","maxLineColumn","getLineMaxColumn","l","getEditOperations","previousOp","currentOp","loserMajor","j","CompositionLineState","startSelection","endSelection","textModel","_original","_capture","_deduceOutcome","getLineContent","original","commonPrefix","commonSuffix","deletedText","insertedText","CompositionOutcome","AtomicTabMoveOperations","lineLength","prevTabStopPosition","prevTabStopVisibleColumn","left","_AtomicTabMoveOperati","whitespaceVisibleColumn","_AtomicTabMoveOperati2","currentVisibleColumn","targetVisibleColumn","ColumnSelection","fromLineNumber","fromVisibleColumn","toLineNumber","toVisibleColumn","abs","reversed","isRTL","isLTR","columnFromVisibleColumn","visibleStartColumn","visibleEndColumn","maxColumn","viewStates","fromVisualColumn","toVisualColumn","prevColumnSelectData","columnSelect","maxVisualViewColumn","minViewLineNumber","maxViewLineNumber","lineMaxViewColumn","lineMaxVisualViewColumn","isPaged","linesCount","pageSize","getLineCount","prevEditOperationType","deleteSelection","rightOfPosition","MoveOperations","ReplaceCommand","autoClosingDelete","autoClosingBrackets","autoClosingQuotes","autoClosingPairsOpen","lineText","character","autoClosingPairCandidates","isQuote","afterCharacter","foundAutoClosingPair","autoClosingPairCandidate","close","found","lenJ","autoClosedCharacter","isAutoClosingPairDelete","autoClosingPairsOpenByEnd","_runAutoClosingPairDelete","deleteRange","getDeleteRange","useTabStops","lastIndentationColumn","toColumn","getPositionAfterDeleteLeft","newLine","lastCutRange","emptySelectionClipboard","CursorMove","CursorMoveCommands","useLogicalLine","_moveToLineStart","currentViewStateColumn","isFirstLineOfWrappedLine","currentViewStatelineNumber","firstNonBlankColumn","getLineFirstNonWhitespaceColumn","_moveToLineStartByModel","_moveToLineStartByView","sticky","_moveToLineEnd","viewStatePosition","viewModelMaxColumn","isEndOfViewLine","modelStatePosition","modelMaxColumn","isEndLineOfWrappedLine","_moveToLineEndByModel","_moveToLineEndByView","_position","_viewPosition","selectToLineNumber","selectToColumn","enteringLineNumber","move","selectToViewLineNumber","selectToViewColumn","endPositionOfSelectionStart","WordOperations","hasSelection","line","unit","_moveHalfLineLeft","_moveLeft","_moveHalfLineRight","_moveRight","_moveUpByViewLines","_moveUpByModelLines","_moveDownByViewLines","_moveDownByModelLines","_moveToViewMinColumn","_moveToViewFirstNonWhitespaceColumn","_moveToViewCenterColumn","_moveToViewMaxColumn","_moveToViewLastNonWhitespaceColumn","visibleViewRange","getCompletelyVisibleViewRange","visibleModelRange","modelLineNumber","_firstLineNumberInRange","modelColumn","_moveToModelPosition","_lastLineNumberInRange","round","findPositionInViewportIfOutside","newViewLineNumber","viewLineNumber","count","getLineMinColumn","noOfColumns","halfLine","toViewColumn","toModelLineNumber","toModelColumn","viewColumn","_moveToViewPosition","getLineLastNonWhitespaceColumn","args","name","constraint","arg","types","cursorMoveArg","to","select","by","schema","RawDirection","Left","Right","Up","Down","PrevBlankLine","NextBlankLine","WrappedLineStart","WrappedLineFirstNonWhitespaceCharacter","WrappedLineColumnCenter","WrappedLineEnd","WrappedLineLastNonWhitespaceCharacter","ViewPortTop","ViewPortCenter","ViewPortBottom","ViewPortIfOutside","RawUnit","Line","WrappedLine","Character","HalfLine","parse","CursorPosition","_cursorPositionBrand","delta","getLineIndentColumn","minColumn","leftPosition","stickyTabStops","leftPositionAtomicSoftTabs","normalizedPos","clipPositionColumn","p","clipRange","rightPosition","rightPositionAtomicSoftTabs","right","allowMoveOnEdgeLine","normalizationAffinity","wasOnFirstPosition","wasOnLastPosition","wasAtEdgePosition","allowMoveOnLastLine","vertical","down","allowMoveOnFirstLine","up","_isBlankLine","lastLineNumber","lastColumn","ShiftCommand","isUnshift","autoIndent","languageConfigurationService","indentation","typeSelection","ReplaceCommandThatPreservesSelection","multiCursorPaste","lines","distributedPaste","_distributePasteToCursors","_distributedPaste","_simplePaste","action","expectedIndentAction","getInheritIndentForLine","expectedEnterAction","getEnterAction","appendText","IndentAction","shiftIndent","unshiftIndent","typeText","test","tokenization","isCheapToTokenize","goodIndent","_goodIndentForLine","possibleTypeText","startsWith","_replaceJumpToNextIndent","lineMaxColumn","_compositionType","shouldPushStackElementBetween","getValueInRange","ReplaceCommandWithOffsetCursorState","keepPosition","ReplaceCommandWithoutChangingPosition","_typeCommand","indentAction","normalIndent","increasedIndent","actualIndentation","ir","getIndentForEnter","indent","oldEndViewColumn","oldEndColumn","newLineContent","firstNonWhitespace","setEndPosition","afterEnter","ceil","ch","currentIndentation","getIndentationAtPosition","getIndentActionForType","autoClosingOvertype","has","chIsQuote","lineAfter","nextChar","potentialStartingBraces","autoClosingPairsOpenByStart","potentialClosingBraces","autoClosingPairsCloseByStart","isBeforeStartingBrace","x","isBeforeClosingBrace","positions","candidates","candidate","candidateIsMatch","pair","lastChar","autoClosingPairsCloseByEnd","includes","endsWith","chIsAlreadyTyped","autoCloseConfig","shouldAutoCloseBefore","quote","bracket","_findAutoClosingPairOpen","containedPair","_findContainedAutoClosingPair","containedPairClose","isContainedPairPresent","lineBefore","characterAfter","_isBeforeClosingBrace","characterBefore","forceTokenization","lineTokens","getLineTokens","scopedLineTokens","createScopedLineTokens","shouldAutoClose","firstCharOffset","neutralCharacter","findNeutralCharacter","tokenType","getTokenTypeIfInsertingCharacter","isOK","autoClosingPairClose","autoSurround","_shouldSurroundChar","surroundingPairs","_step6","isTypingAQuoteCharacter","_iterator6","selectionContainsOnlyWhitespace","startIndex","endIndex","selectedText","selectionText","closeCharacter","SurroundSelectionCommand","electricChars","electricAction","onElectricCharacter","matchOpenBracket","bracketPairs","findMatchingBracketUp","matchLine","matchLineIndentation","newIndentation","lineFirstNonBlankColumn","getTypingOperation","compositions","_step7","_iterator7","composition","_step8","hasDeletion","_iterator8","_step9","_iterator9","deletedSelectionStart","deletedSelectionEnd","_step10","_iterator10","CompositionSurroundSelectionCommand","_isAutoClosingOvertype","_getAutoClosingPairClose","_runAutoClosingOpenCharType","isDoingComposition","_enter","_isAutoIndentType","autoIndentFails","_runAutoIndentType","_runAutoClosingOvertype","_isSurroundSelectionType","_runSurroundSelectionType","_isTypeInterceptorElectricChar","_typeInterceptorElectricChar","opType","_ReplaceCommandWithOf","openCharacter","insertOpenCharacter","_openCharacter","_closeCharacter","helper","insertedSelectionStart","insertedSelectionEnd","typedText","previousTypingOperation","typingOperation","isTypingOperation","normalizeOperationType","wordType","nextCharClass","_doFindPreviousWordOnLine","chIndex","chCode","chClass","_createWord","_findEndOfWord","_doFindNextWordOnLine","_findStartOfWord","wordNavigationType","prevWordOnLine","_findPreviousWordOnLine","rightRight","movedDown","nextWordOnLine","_findNextWordOnLine","lastNonWhitespace","whitespaceHeuristics","_deleteWordLeftWhitespace","_deleteInsideWordWhitespace","_deleteInsideWordDetermineDeleteRange","leftIndex","_charAtIsWhitespace","rightIndex","touchesWord","createRangeWithPosition","deleteWordAndAdjacentWhitespace","expandedToTheRight","toPosition","_moveWordPartLeft","_findFirstNonWhitespaceChar","_deleteWordRightWhitespace","_moveWordPartRight","_wordSeparators","prevWord","_createWordAtPosition","nextWord","possiblePosition","WordPartOperations","_WordOperations","apply","enforceDefined","deleteWordLeft","_deleteWordPartLeft","deleteWordRight","_deleteWordPartRight","moveWordLeft","moveWordRight","arr","filter","el","Boolean","autoCloseAlways","autoCloseNever","autoCloseBeforeWhitespace","CursorConfiguration","languageId","modelOptions","configuration","_cursorMoveConfigurationBrand","_languageId","layoutInfo","fontInfo","lineHeight","typicalHalfwidthCharacterWidth","height","copyWithSyntaxHighlighting","_electricChars","_getShouldAutoClose","getLanguageConfiguration","getAutoClosingPairs","getSurroundingPairs","_a","electricCharacter","getElectricCharacters","char","electricCharacterSupport","forQuotes","_getLanguageDefinedShouldAutoClose","autoCloseBeforeSet","getAutoCloseBeforeSet","hasChanged","_cursorStateBrand","PartialModelCursorState","PartialViewCursorState","modelSelection","getSelectionStart","fromModelState","modelSelections","fromModelSelection","_singleCursorStateBrand","_computeSelection","opts","_editOperationResultBrand","LineRangeMapping","originalRange","modifiedRange","innerChanges","RangeMapping","LineRange","endLineNumberExclusive","SmartLinesDiffComputer","originalLines","modifiedLines","DiffComputer","maxComputationTime","maxComputationTimeMs","shouldIgnoreTrimWhitespace","ignoreTrimWhitespace","shouldComputeCharChanges","shouldMakePrettyDiff","shouldPostProcessCharChanges","computeDiff","changes","lastChange","originalEndLineNumber","originalStartLineNumber","modifiedEndLineNumber","modifiedStartLineNumber","change","charChanges","originalStartColumn","originalEndColumn","modifiedStartColumn","modifiedEndColumn","pop","assertFn","checkAdjacentItems","m1","m2","quitEarly","originalSequence","modifiedSequence","continueProcessingPredicate","pretty","LcsDiff","ComputeDiff","LineSequence","startColumns","endColumns","getFirstNonBlankColumn","getLastNonBlankColumn","_startColumns","_endColumns","elements","charCodes","lineNumbers","columns","col","CharSequence","_charCodes","_lineNumbers","_columns","Error","getEndLineNumber","_assertIndex","getStartLineNumber","getEndColumn","getStartColumn","CharChange","diffChange","originalCharSequence","modifiedCharSequence","originalStart","originalLength","modifiedStart","modifiedLength","LineChange","originalLineSequence","modifiedLineSequence","continueCharDiff","createCharSequence","getElements","rawChanges","prevChange","currChange","originalMatchingLength","modifiedMatchingLength","postProcessCharChanges","createFromDiffChange","modified","continueLineDiff","createContinueProcessingPredicate","diffResult","lineChanges","createFromDiffResult","originalLineIndex","modifiedLineIndex","nextChange","originalStop","modifiedStop","originalLine","modifiedLine","_pushTrimWhitespaceCharChange","originalMaxColumn","modifiedMaxColumn","originalLineNumber","modifiedLineNumber","_mergeTrimWhitespaceCharChange","txt","maximumRuntime","startTime","SequenceDiff","seq1Range","seq2Range","OffsetRange","endExclusive","Array2D","width","array","Array","y","DynamicProgrammingDiffing","sequence1","sequence2","equalityScore","lcsLengths","directions","lengths","s1","s2","horizontalLen","verticalLen","extendedSeqScore","getElement","newValue","prevLen","lastAligningPosS1","lastAligningPosS2","reportDecreasingAligningPositions","reverse","optimizeSequenceDiffs","sequenceDiffs","lastResult","cur","all","joinSequenceDiffs","getBoundaryScore","diff","seq2PrevEndExclusive","seq2NextStart","shiftDiffToBetterPosition","seq1PrevEndExclusive","seq1NextStart","shiftSequenceDiffs","deltaBefore","deltaAfter","bestDelta","bestScore","seq2OffsetStart","seq2OffsetEndExclusive","seq1Offset","score","MyersDiffAlgorithm","seq1","seq2","getXAfterSnake","d","V","FastInt32Array","paths","FastArrayNegativeIndices","SnakePath","k","loop","maxXofDLineTop","maxXofDLineLeft","newMaxX","lastPath","path","endX","endY","positiveArr","Int32Array","negativeArr","group","StandardLinesDiffComputer","dynamicProgrammingDiffing","myersDiffingAlgorithm","perfectHashes","getOrCreateHash","hash","size","srcDocLines","trim","tgtDocLines","lineAlignments","compute","offset1","offset2","log","alignments","scanForWhitespaceChanges","equalLinesCount","seq1LastStart","seq2Offset","seq2LastStart","characterDiffs","refineDiff","a1","a2","first","last","lineRangeMappingFromRangeMappings","sourceSlice","Slice","targetSlice","originalDiffs","diffs","smoothenSequenceDiffs","translateRange","items","shouldBeGrouped","currentGroup","item","_regeneratorRuntime","wrap","_context","t0","finish","stop","_marked","trimmedHash","getIndentation","lineRange","chars","firstCharOnLineOffsets","prevCategory","getCategory","nextCategory","getCategoryBoundaryScore","offsetOfPrevLineBreak","translateOffset","_score","_defineProperty","category","isSpace","linesDiffComputers","smart","experimental","InternalEditorAction","label","alias","precondition","run","contextKeyService","_precondition","_run","_contextKeyService","contextMatchesRules","isSupported","Promise","resolve","EditorType","ICodeEditor","IDiffEditor","EditorContextKeys","editorSimpleInput","RawContextKey","editorTextFocus","focus","textInputFocus","inDiffEditor","columnSelection","writable","toNegated","hasNonEmptySelection","hasOnlyEmptySelection","hasMultipleSelections","hasSingleSelection","tabMovesFocus","tabDoesNotMoveFocus","isInWalkThroughSnippet","canUndo","canRedo","hoverVisible","inCompositeEditor","notInCompositeEditor","hasCompletionItemProvider","hasCodeActionsProvider","hasCodeLensProvider","hasDefinitionProvider","hasDeclarationProvider","hasImplementationProvider","hasTypeDefinitionProvider","hasHoverProvider","hasDocumentHighlightProvider","hasDocumentSymbolProvider","hasReferenceProvider","hasRenameProvider","hasSignatureHelpProvider","hasInlayHintsProvider","hasDocumentFormattingProvider","hasDocumentSelectionFormattingProvider","hasMultipleDocumentFormattingProvider","hasMultipleDocumentSelectionFormattingProvider","editorFeatures","registerEditorFeature","ctor","getEditorFeatures","EditorTheme","_theme","color"],"sourceRoot":""}