{"version":3,"file":"static/js/monaco-editor-vendor.192dbdcc.5b196ca4.js","mappings":"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","sources":["../node_modules/monaco-editor/esm/vs/editor/common/textModelBracketPairs.js","../node_modules/monaco-editor/esm/vs/editor/common/textModelEvents.js","../node_modules/monaco-editor/esm/vs/editor/common/textModelGuides.js","../node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokens.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensEditing.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensStore.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/lineTokens.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseMultilineTokens.js","../node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseTokensStore.js","../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/lineDecorations.js","../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLineRenderer.js","../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLinesViewportData.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/minimapTokensColorTracker.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/modelLineProjectionData.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/monospaceLineBreaksComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/overviewZoneManager.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewContext.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewEventHandler.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewEvents.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModel.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelDecorations.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelEventDispatcher.js","../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/linesLayout.js","../node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLayout.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/modelLineProjection.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelLines.js","../node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelImpl.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class BracketInfo {\n    constructor(range, \n    /** 0-based level */\n    nestingLevel, isInvalid) {\n        this.range = range;\n        this.nestingLevel = nestingLevel;\n        this.isInvalid = isInvalid;\n    }\n}\nexport class BracketPairInfo {\n    constructor(range, openingBracketRange, closingBracketRange, \n    /**\n     * 0-based\n    */\n    nestingLevel) {\n        this.range = range;\n        this.openingBracketRange = openingBracketRange;\n        this.closingBracketRange = closingBracketRange;\n        this.nestingLevel = nestingLevel;\n    }\n}\nexport class BracketPairWithMinIndentationInfo extends BracketPairInfo {\n    constructor(range, openingBracketRange, closingBracketRange, \n    /**\n     * 0-based\n    */\n    nestingLevel, \n    /**\n     * -1 if not requested, otherwise the size of the minimum indentation in the bracket pair in terms of visible columns.\n    */\n    minVisibleColumnIndentation) {\n        super(range, openingBracketRange, closingBracketRange, nestingLevel);\n        this.minVisibleColumnIndentation = minVisibleColumnIndentation;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * An event describing that a model has been reset to a new value.\n * @internal\n */\nexport class ModelRawFlush {\n    constructor() {\n        this.changeType = 1 /* Flush */;\n    }\n}\n/**\n * Represents text injected on a line\n * @internal\n */\nexport class LineInjectedText {\n    constructor(ownerId, lineNumber, column, options, order) {\n        this.ownerId = ownerId;\n        this.lineNumber = lineNumber;\n        this.column = column;\n        this.options = options;\n        this.order = order;\n    }\n    static applyInjectedText(lineText, injectedTexts) {\n        if (!injectedTexts || injectedTexts.length === 0) {\n            return lineText;\n        }\n        let result = '';\n        let lastOriginalOffset = 0;\n        for (const injectedText of injectedTexts) {\n            result += lineText.substring(lastOriginalOffset, injectedText.column - 1);\n            lastOriginalOffset = injectedText.column - 1;\n            result += injectedText.options.content;\n        }\n        result += lineText.substring(lastOriginalOffset);\n        return result;\n    }\n    static fromDecorations(decorations) {\n        const result = [];\n        for (const decoration of decorations) {\n            if (decoration.options.before && decoration.options.before.content.length > 0) {\n                result.push(new LineInjectedText(decoration.ownerId, decoration.range.startLineNumber, decoration.range.startColumn, decoration.options.before, 0));\n            }\n            if (decoration.options.after && decoration.options.after.content.length > 0) {\n                result.push(new LineInjectedText(decoration.ownerId, decoration.range.endLineNumber, decoration.range.endColumn, decoration.options.after, 1));\n            }\n        }\n        result.sort((a, b) => {\n            if (a.lineNumber === b.lineNumber) {\n                if (a.column === b.column) {\n                    return a.order - b.order;\n                }\n                return a.column - b.column;\n            }\n            return a.lineNumber - b.lineNumber;\n        });\n        return result;\n    }\n}\n/**\n * An event describing that a line has changed in a model.\n * @internal\n */\nexport class ModelRawLineChanged {\n    constructor(lineNumber, detail, injectedText) {\n        this.changeType = 2 /* LineChanged */;\n        this.lineNumber = lineNumber;\n        this.detail = detail;\n        this.injectedText = injectedText;\n    }\n}\n/**\n * An event describing that line(s) have been deleted in a model.\n * @internal\n */\nexport class ModelRawLinesDeleted {\n    constructor(fromLineNumber, toLineNumber) {\n        this.changeType = 3 /* LinesDeleted */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n    }\n}\n/**\n * An event describing that line(s) have been inserted in a model.\n * @internal\n */\nexport class ModelRawLinesInserted {\n    constructor(fromLineNumber, toLineNumber, detail, injectedTexts) {\n        this.changeType = 4 /* LinesInserted */;\n        this.injectedTexts = injectedTexts;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n        this.detail = detail;\n    }\n}\n/**\n * An event describing that a model has had its EOL changed.\n * @internal\n */\nexport class ModelRawEOLChanged {\n    constructor() {\n        this.changeType = 5 /* EOLChanged */;\n    }\n}\n/**\n * An event describing a change in the text of a model.\n * @internal\n */\nexport class ModelRawContentChangedEvent {\n    constructor(changes, versionId, isUndoing, isRedoing) {\n        this.changes = changes;\n        this.versionId = versionId;\n        this.isUndoing = isUndoing;\n        this.isRedoing = isRedoing;\n        this.resultingSelection = null;\n    }\n    containsEvent(type) {\n        for (let i = 0, len = this.changes.length; i < len; i++) {\n            const change = this.changes[i];\n            if (change.changeType === type) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static merge(a, b) {\n        const changes = [].concat(a.changes).concat(b.changes);\n        const versionId = b.versionId;\n        const isUndoing = (a.isUndoing || b.isUndoing);\n        const isRedoing = (a.isRedoing || b.isRedoing);\n        return new ModelRawContentChangedEvent(changes, versionId, isUndoing, isRedoing);\n    }\n}\n/**\n * An event describing a change in injected text.\n * @internal\n */\nexport class ModelInjectedTextChangedEvent {\n    constructor(changes) {\n        this.changes = changes;\n    }\n}\n/**\n * @internal\n */\nexport class InternalModelContentChangeEvent {\n    constructor(rawContentChangedEvent, contentChangedEvent) {\n        this.rawContentChangedEvent = rawContentChangedEvent;\n        this.contentChangedEvent = contentChangedEvent;\n    }\n    merge(other) {\n        const rawContentChangedEvent = ModelRawContentChangedEvent.merge(this.rawContentChangedEvent, other.rawContentChangedEvent);\n        const contentChangedEvent = InternalModelContentChangeEvent._mergeChangeEvents(this.contentChangedEvent, other.contentChangedEvent);\n        return new InternalModelContentChangeEvent(rawContentChangedEvent, contentChangedEvent);\n    }\n    static _mergeChangeEvents(a, b) {\n        const changes = [].concat(a.changes).concat(b.changes);\n        const eol = b.eol;\n        const versionId = b.versionId;\n        const isUndoing = (a.isUndoing || b.isUndoing);\n        const isRedoing = (a.isRedoing || b.isRedoing);\n        const isFlush = (a.isFlush || b.isFlush);\n        return {\n            changes: changes,\n            eol: eol,\n            versionId: versionId,\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport var HorizontalGuidesState;\n(function (HorizontalGuidesState) {\n    HorizontalGuidesState[HorizontalGuidesState[\"Disabled\"] = 0] = \"Disabled\";\n    HorizontalGuidesState[HorizontalGuidesState[\"EnabledForActive\"] = 1] = \"EnabledForActive\";\n    HorizontalGuidesState[HorizontalGuidesState[\"Enabled\"] = 2] = \"Enabled\";\n})(HorizontalGuidesState || (HorizontalGuidesState = {}));\nexport class IndentGuide {\n    constructor(visibleColumn, className, \n    /**\n     * If set, this indent guide is a horizontal guide (no vertical part).\n     * It starts at visibleColumn and continues until endColumn.\n    */\n    horizontalLine) {\n        this.visibleColumn = visibleColumn;\n        this.className = className;\n        this.horizontalLine = horizontalLine;\n    }\n}\nexport class IndentGuideHorizontalLine {\n    constructor(top, endColumn) {\n        this.top = top;\n        this.endColumn = endColumn;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Emitter } from '../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../base/common/lifecycle.js';\nexport class TokenizationRegistry {\n    constructor() {\n        this._map = new Map();\n        this._factories = new Map();\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n        this._colorMap = null;\n    }\n    fire(languages) {\n        this._onDidChange.fire({\n            changedLanguages: languages,\n            changedColorMap: false\n        });\n    }\n    register(language, support) {\n        this._map.set(language, support);\n        this.fire([language]);\n        return toDisposable(() => {\n            if (this._map.get(language) !== support) {\n                return;\n            }\n            this._map.delete(language);\n            this.fire([language]);\n        });\n    }\n    registerFactory(languageId, factory) {\n        var _a;\n        (_a = this._factories.get(languageId)) === null || _a === void 0 ? void 0 : _a.dispose();\n        const myData = new TokenizationSupportFactoryData(this, languageId, factory);\n        this._factories.set(languageId, myData);\n        return toDisposable(() => {\n            const v = this._factories.get(languageId);\n            if (!v || v !== myData) {\n                return;\n            }\n            this._factories.delete(languageId);\n            v.dispose();\n        });\n    }\n    getOrCreate(languageId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // check first if the support is already set\n            const tokenizationSupport = this.get(languageId);\n            if (tokenizationSupport) {\n                return tokenizationSupport;\n            }\n            const factory = this._factories.get(languageId);\n            if (!factory || factory.isResolved) {\n                // no factory or factory.resolve already finished\n                return null;\n            }\n            yield factory.resolve();\n            return this.get(languageId);\n        });\n    }\n    get(language) {\n        return (this._map.get(language) || null);\n    }\n    isResolved(languageId) {\n        const tokenizationSupport = this.get(languageId);\n        if (tokenizationSupport) {\n            return true;\n        }\n        const factory = this._factories.get(languageId);\n        if (!factory || factory.isResolved) {\n            return true;\n        }\n        return false;\n    }\n    setColorMap(colorMap) {\n        this._colorMap = colorMap;\n        this._onDidChange.fire({\n            changedLanguages: Array.from(this._map.keys()),\n            changedColorMap: true\n        });\n    }\n    getColorMap() {\n        return this._colorMap;\n    }\n    getDefaultBackground() {\n        if (this._colorMap && this._colorMap.length > 2 /* DefaultBackground */) {\n            return this._colorMap[2 /* DefaultBackground */];\n        }\n        return null;\n    }\n}\nclass TokenizationSupportFactoryData extends Disposable {\n    constructor(_registry, _languageId, _factory) {\n        super();\n        this._registry = _registry;\n        this._languageId = _languageId;\n        this._factory = _factory;\n        this._isDisposed = false;\n        this._resolvePromise = null;\n        this._isResolved = false;\n    }\n    get isResolved() {\n        return this._isResolved;\n    }\n    dispose() {\n        this._isDisposed = true;\n        super.dispose();\n    }\n    resolve() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this._resolvePromise) {\n                this._resolvePromise = this._create();\n            }\n            return this._resolvePromise;\n        });\n    }\n    _create() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const value = yield Promise.resolve(this._factory.createTokenizationSupport());\n            this._isResolved = true;\n            if (value && !this._isDisposed) {\n                this._register(this._registry.register(this._languageId, value));\n            }\n        });\n    }\n}\n","/**\n * Represents contiguous tokens over a contiguous range of lines.\n */\nexport class ContiguousMultilineTokens {\n    constructor(startLineNumber, tokens) {\n        this._startLineNumber = startLineNumber;\n        this._tokens = tokens;\n    }\n    /**\n     * (Inclusive) start line number for these tokens.\n     */\n    get startLineNumber() {\n        return this._startLineNumber;\n    }\n    /**\n     * (Inclusive) end line number for these tokens.\n     */\n    get endLineNumber() {\n        return this._startLineNumber + this._tokens.length - 1;\n    }\n    /**\n     * @see {@link _tokens}\n     */\n    getLineTokens(lineNumber) {\n        return this._tokens[lineNumber - this._startLineNumber];\n    }\n    appendLineTokens(lineTokens) {\n        this._tokens.push(lineTokens);\n    }\n}\n","import { ContiguousMultilineTokens } from './contiguousMultilineTokens.js';\nexport class ContiguousMultilineTokensBuilder {\n    constructor() {\n        this._tokens = [];\n    }\n    add(lineNumber, lineTokens) {\n        if (this._tokens.length > 0) {\n            const last = this._tokens[this._tokens.length - 1];\n            if (last.endLineNumber + 1 === lineNumber) {\n                // append\n                last.appendLineTokens(lineTokens);\n                return;\n            }\n        }\n        this._tokens.push(new ContiguousMultilineTokens(lineNumber, [lineTokens]));\n    }\n    finalize() {\n        return this._tokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineTokens } from './lineTokens.js';\nexport const EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;\nexport class ContiguousTokensEditing {\n    static deleteBeginning(lineTokens, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        return ContiguousTokensEditing.delete(lineTokens, 0, toChIndex);\n    }\n    static deleteEnding(lineTokens, fromChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const lineTextLength = tokens[tokens.length - 2];\n        return ContiguousTokensEditing.delete(lineTokens, fromChIndex, lineTextLength);\n    }\n    static delete(lineTokens, fromChIndex, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        // special case: deleting everything\n        if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\n            return EMPTY_LINE_TOKENS;\n        }\n        const fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\n        const fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);\n        const fromTokenEndOffset = tokens[fromTokenIndex << 1];\n        if (toChIndex < fromTokenEndOffset) {\n            // the delete range is inside a single token\n            const delta = (toChIndex - fromChIndex);\n            for (let i = fromTokenIndex; i < tokensCount; i++) {\n                tokens[i << 1] -= delta;\n            }\n            return lineTokens;\n        }\n        let dest;\n        let lastEnd;\n        if (fromTokenStartOffset !== fromChIndex) {\n            tokens[fromTokenIndex << 1] = fromChIndex;\n            dest = ((fromTokenIndex + 1) << 1);\n            lastEnd = fromChIndex;\n        }\n        else {\n            dest = (fromTokenIndex << 1);\n            lastEnd = fromTokenStartOffset;\n        }\n        const delta = (toChIndex - fromChIndex);\n        for (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\n            const tokenEndOffset = tokens[tokenIndex << 1] - delta;\n            if (tokenEndOffset > lastEnd) {\n                tokens[dest++] = tokenEndOffset;\n                tokens[dest++] = tokens[(tokenIndex << 1) + 1];\n                lastEnd = tokenEndOffset;\n            }\n        }\n        if (dest === tokens.length) {\n            // nothing to trim\n            return lineTokens;\n        }\n        const tmp = new Uint32Array(dest);\n        tmp.set(tokens.subarray(0, dest), 0);\n        return tmp.buffer;\n    }\n    static append(lineTokens, _otherTokens) {\n        if (_otherTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        if (lineTokens === EMPTY_LINE_TOKENS) {\n            return _otherTokens;\n        }\n        if (lineTokens === null) {\n            return lineTokens;\n        }\n        if (_otherTokens === null) {\n            // cannot determine combined line length...\n            return null;\n        }\n        const myTokens = toUint32Array(lineTokens);\n        const otherTokens = toUint32Array(_otherTokens);\n        const otherTokensCount = (otherTokens.length >>> 1);\n        const result = new Uint32Array(myTokens.length + otherTokens.length);\n        result.set(myTokens, 0);\n        let dest = myTokens.length;\n        const delta = myTokens[myTokens.length - 2];\n        for (let i = 0; i < otherTokensCount; i++) {\n            result[dest++] = otherTokens[(i << 1)] + delta;\n            result[dest++] = otherTokens[(i << 1) + 1];\n        }\n        return result.buffer;\n    }\n    static insert(lineTokens, chIndex, textLength) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            // nothing to do\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        let fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\n        if (fromTokenIndex > 0) {\n            const fromTokenStartOffset = tokens[(fromTokenIndex - 1) << 1];\n            if (fromTokenStartOffset === chIndex) {\n                fromTokenIndex--;\n            }\n        }\n        for (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\n            tokens[tokenIndex << 1] += textLength;\n        }\n        return lineTokens;\n    }\n}\nexport function toUint32Array(arr) {\n    if (arr instanceof Uint32Array) {\n        return arr;\n    }\n    else {\n        return new Uint32Array(arr);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { ContiguousTokensEditing, EMPTY_LINE_TOKENS, toUint32Array } from './contiguousTokensEditing.js';\nimport { LineTokens } from './lineTokens.js';\nimport { TokenMetadata } from '../languages.js';\n/**\n * Represents contiguous tokens in a text model.\n */\nexport class ContiguousTokensStore {\n    constructor(languageIdCodec) {\n        this._lineTokens = [];\n        this._len = 0;\n        this._languageIdCodec = languageIdCodec;\n    }\n    flush() {\n        this._lineTokens = [];\n        this._len = 0;\n    }\n    getTokens(topLevelLanguageId, lineIndex, lineText) {\n        let rawLineTokens = null;\n        if (lineIndex < this._len) {\n            rawLineTokens = this._lineTokens[lineIndex];\n        }\n        if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n            return new LineTokens(toUint32Array(rawLineTokens), lineText, this._languageIdCodec);\n        }\n        const lineTokens = new Uint32Array(2);\n        lineTokens[0] = lineText.length;\n        lineTokens[1] = getDefaultMetadata(this._languageIdCodec.encodeLanguageId(topLevelLanguageId));\n        return new LineTokens(lineTokens, lineText, this._languageIdCodec);\n    }\n    static _massageTokens(topLevelLanguageId, lineTextLength, _tokens) {\n        const tokens = _tokens ? toUint32Array(_tokens) : null;\n        if (lineTextLength === 0) {\n            let hasDifferentLanguageId = false;\n            if (tokens && tokens.length > 1) {\n                hasDifferentLanguageId = (TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId);\n            }\n            if (!hasDifferentLanguageId) {\n                return EMPTY_LINE_TOKENS;\n            }\n        }\n        if (!tokens || tokens.length === 0) {\n            const tokens = new Uint32Array(2);\n            tokens[0] = lineTextLength;\n            tokens[1] = getDefaultMetadata(topLevelLanguageId);\n            return tokens.buffer;\n        }\n        // Ensure the last token covers the end of the text\n        tokens[tokens.length - 2] = lineTextLength;\n        if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\n            // Store directly the ArrayBuffer pointer to save an object\n            return tokens.buffer;\n        }\n        return tokens;\n    }\n    _ensureLine(lineIndex) {\n        while (lineIndex >= this._len) {\n            this._lineTokens[this._len] = null;\n            this._len++;\n        }\n    }\n    _deleteLines(start, deleteCount) {\n        if (deleteCount === 0) {\n            return;\n        }\n        if (start + deleteCount > this._len) {\n            deleteCount = this._len - start;\n        }\n        this._lineTokens.splice(start, deleteCount);\n        this._len -= deleteCount;\n    }\n    _insertLines(insertIndex, insertCount) {\n        if (insertCount === 0) {\n            return;\n        }\n        const lineTokens = [];\n        for (let i = 0; i < insertCount; i++) {\n            lineTokens[i] = null;\n        }\n        this._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\n        this._len += insertCount;\n    }\n    setTokens(topLevelLanguageId, lineIndex, lineTextLength, _tokens, checkEquality) {\n        const tokens = ContiguousTokensStore._massageTokens(this._languageIdCodec.encodeLanguageId(topLevelLanguageId), lineTextLength, _tokens);\n        this._ensureLine(lineIndex);\n        const oldTokens = this._lineTokens[lineIndex];\n        this._lineTokens[lineIndex] = tokens;\n        if (checkEquality) {\n            return !ContiguousTokensStore._equals(oldTokens, tokens);\n        }\n        return false;\n    }\n    static _equals(_a, _b) {\n        if (!_a || !_b) {\n            return !_a && !_b;\n        }\n        const a = toUint32Array(_a);\n        const b = toUint32Array(_b);\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    //#region Editing\n    acceptEdit(range, eolCount, firstLineLength) {\n        this._acceptDeleteRange(range);\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n    }\n    _acceptDeleteRange(range) {\n        const firstLineIndex = range.startLineNumber - 1;\n        if (firstLineIndex >= this._len) {\n            return;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            if (range.startColumn === range.endColumn) {\n                // Nothing to delete\n                return;\n            }\n            this._lineTokens[firstLineIndex] = ContiguousTokensEditing.delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n            return;\n        }\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\n        const lastLineIndex = range.endLineNumber - 1;\n        let lastLineTokens = null;\n        if (lastLineIndex < this._len) {\n            lastLineTokens = ContiguousTokensEditing.deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\n        }\n        // Take remaining text on last line and append it to remaining text on first line\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.append(this._lineTokens[firstLineIndex], lastLineTokens);\n        // Delete middle lines\n        this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n    }\n    _acceptInsertText(position, eolCount, firstLineLength) {\n        if (eolCount === 0 && firstLineLength === 0) {\n            // Nothing to insert\n            return;\n        }\n        const lineIndex = position.lineNumber - 1;\n        if (lineIndex >= this._len) {\n            return;\n        }\n        if (eolCount === 0) {\n            // Inserting text on one line\n            this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n            return;\n        }\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[lineIndex], position.column - 1);\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n        this._insertLines(position.lineNumber, eolCount);\n    }\n}\nfunction getDefaultMetadata(topLevelLanguageId) {\n    return ((topLevelLanguageId << 0 /* LANGUAGEID_OFFSET */)\n        | (0 /* Other */ << 8 /* TOKEN_TYPE_OFFSET */)\n        | (0 /* None */ << 10 /* FONT_STYLE_OFFSET */)\n        | (1 /* DefaultForeground */ << 14 /* FOREGROUND_OFFSET */)\n        | (2 /* DefaultBackground */ << 23 /* BACKGROUND_OFFSET */)) >>> 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TokenMetadata } from '../languages.js';\nexport class LineTokens {\n    constructor(tokens, text, decoder) {\n        this._lineTokensBrand = undefined;\n        this._tokens = tokens;\n        this._tokensCount = (this._tokens.length >>> 1);\n        this._text = text;\n        this._languageIdCodec = decoder;\n    }\n    static createEmpty(lineContent, decoder) {\n        const defaultMetadata = LineTokens.defaultTokenMetadata;\n        const tokens = new Uint32Array(2);\n        tokens[0] = lineContent.length;\n        tokens[1] = defaultMetadata;\n        return new LineTokens(tokens, lineContent, decoder);\n    }\n    equals(other) {\n        if (other instanceof LineTokens) {\n            return this.slicedEquals(other, 0, this._tokensCount);\n        }\n        return false;\n    }\n    slicedEquals(other, sliceFromTokenIndex, sliceTokenCount) {\n        if (this._text !== other._text) {\n            return false;\n        }\n        if (this._tokensCount !== other._tokensCount) {\n            return false;\n        }\n        const from = (sliceFromTokenIndex << 1);\n        const to = from + (sliceTokenCount << 1);\n        for (let i = from; i < to; i++) {\n            if (this._tokens[i] !== other._tokens[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    getLineContent() {\n        return this._text;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getStartOffset(tokenIndex) {\n        if (tokenIndex > 0) {\n            return this._tokens[(tokenIndex - 1) << 1];\n        }\n        return 0;\n    }\n    getMetadata(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return metadata;\n    }\n    getLanguageId(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        const languageId = TokenMetadata.getLanguageId(metadata);\n        return this._languageIdCodec.decodeLanguageId(languageId);\n    }\n    getStandardTokenType(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getTokenType(metadata);\n    }\n    getForeground(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getForeground(metadata);\n    }\n    getClassName(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getClassNameFromMetadata(metadata);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getPresentationFromMetadata(metadata);\n    }\n    getEndOffset(tokenIndex) {\n        return this._tokens[tokenIndex << 1];\n    }\n    /**\n     * Find the token containing offset `offset`.\n     * @param offset The search offset\n     * @return The index of the token containing the offset.\n     */\n    findTokenIndexAtOffset(offset) {\n        return LineTokens.findIndexInTokensArray(this._tokens, offset);\n    }\n    inflate() {\n        return this;\n    }\n    sliceAndInflate(startOffset, endOffset, deltaOffset) {\n        return new SliceLineTokens(this, startOffset, endOffset, deltaOffset);\n    }\n    static convertToEndOffset(tokens, lineTextLength) {\n        const tokenCount = (tokens.length >>> 1);\n        const lastTokenIndex = tokenCount - 1;\n        for (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n            tokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];\n        }\n        tokens[lastTokenIndex << 1] = lineTextLength;\n    }\n    static findIndexInTokensArray(tokens, desiredIndex) {\n        if (tokens.length <= 2) {\n            return 0;\n        }\n        let low = 0;\n        let high = (tokens.length >>> 1) - 1;\n        while (low < high) {\n            const mid = low + Math.floor((high - low) / 2);\n            const endOffset = tokens[(mid << 1)];\n            if (endOffset === desiredIndex) {\n                return mid + 1;\n            }\n            else if (endOffset < desiredIndex) {\n                low = mid + 1;\n            }\n            else if (endOffset > desiredIndex) {\n                high = mid;\n            }\n        }\n        return low;\n    }\n    /**\n     * @pure\n     * @param insertTokens Must be sorted by offset.\n    */\n    withInserted(insertTokens) {\n        if (insertTokens.length === 0) {\n            return this;\n        }\n        let nextOriginalTokenIdx = 0;\n        let nextInsertTokenIdx = 0;\n        let text = '';\n        const newTokens = new Array();\n        let originalEndOffset = 0;\n        while (true) {\n            const nextOriginalTokenEndOffset = nextOriginalTokenIdx < this._tokensCount ? this._tokens[nextOriginalTokenIdx << 1] : -1;\n            const nextInsertToken = nextInsertTokenIdx < insertTokens.length ? insertTokens[nextInsertTokenIdx] : null;\n            if (nextOriginalTokenEndOffset !== -1 && (nextInsertToken === null || nextOriginalTokenEndOffset <= nextInsertToken.offset)) {\n                // original token ends before next insert token\n                text += this._text.substring(originalEndOffset, nextOriginalTokenEndOffset);\n                const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                newTokens.push(text.length, metadata);\n                nextOriginalTokenIdx++;\n                originalEndOffset = nextOriginalTokenEndOffset;\n            }\n            else if (nextInsertToken) {\n                if (nextInsertToken.offset > originalEndOffset) {\n                    // insert token is in the middle of the next token.\n                    text += this._text.substring(originalEndOffset, nextInsertToken.offset);\n                    const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                    newTokens.push(text.length, metadata);\n                    originalEndOffset = nextInsertToken.offset;\n                }\n                text += nextInsertToken.text;\n                newTokens.push(text.length, nextInsertToken.tokenMetadata);\n                nextInsertTokenIdx++;\n            }\n            else {\n                break;\n            }\n        }\n        return new LineTokens(new Uint32Array(newTokens), text, this._languageIdCodec);\n    }\n}\nLineTokens.defaultTokenMetadata = ((0 /* None */ << 10 /* FONT_STYLE_OFFSET */)\n    | (1 /* DefaultForeground */ << 14 /* FOREGROUND_OFFSET */)\n    | (2 /* DefaultBackground */ << 23 /* BACKGROUND_OFFSET */)) >>> 0;\nclass SliceLineTokens {\n    constructor(source, startOffset, endOffset, deltaOffset) {\n        this._source = source;\n        this._startOffset = startOffset;\n        this._endOffset = endOffset;\n        this._deltaOffset = deltaOffset;\n        this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n        this._tokensCount = 0;\n        for (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n            const tokenStartOffset = source.getStartOffset(i);\n            if (tokenStartOffset >= endOffset) {\n                break;\n            }\n            this._tokensCount++;\n        }\n    }\n    getMetadata(tokenIndex) {\n        return this._source.getMetadata(this._firstTokenIndex + tokenIndex);\n    }\n    getLanguageId(tokenIndex) {\n        return this._source.getLanguageId(this._firstTokenIndex + tokenIndex);\n    }\n    getLineContent() {\n        return this._source.getLineContent().substring(this._startOffset, this._endOffset);\n    }\n    equals(other) {\n        if (other instanceof SliceLineTokens) {\n            return (this._startOffset === other._startOffset\n                && this._endOffset === other._endOffset\n                && this._deltaOffset === other._deltaOffset\n                && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount));\n        }\n        return false;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getForeground(tokenIndex) {\n        return this._source.getForeground(this._firstTokenIndex + tokenIndex);\n    }\n    getEndOffset(tokenIndex) {\n        const tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n        return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n    }\n    getClassName(tokenIndex) {\n        return this._source.getClassName(this._firstTokenIndex + tokenIndex);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        return this._source.getPresentation(this._firstTokenIndex + tokenIndex);\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { countEOL } from '../core/eolCounter.js';\n/**\n * Represents sparse tokens over a contiguous range of lines.\n */\nexport class SparseMultilineTokens {\n    constructor(startLineNumber, tokens) {\n        this._startLineNumber = startLineNumber;\n        this._tokens = tokens;\n        this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();\n    }\n    static create(startLineNumber, tokens) {\n        return new SparseMultilineTokens(startLineNumber, new SparseMultilineTokensStorage(tokens));\n    }\n    /**\n     * (Inclusive) start line number for these tokens.\n     */\n    get startLineNumber() {\n        return this._startLineNumber;\n    }\n    /**\n     * (Inclusive) end line number for these tokens.\n     */\n    get endLineNumber() {\n        return this._endLineNumber;\n    }\n    toString() {\n        return this._tokens.toString(this._startLineNumber);\n    }\n    _updateEndLineNumber() {\n        this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();\n    }\n    isEmpty() {\n        return this._tokens.isEmpty();\n    }\n    getLineTokens(lineNumber) {\n        if (this._startLineNumber <= lineNumber && lineNumber <= this._endLineNumber) {\n            return this._tokens.getLineTokens(lineNumber - this._startLineNumber);\n        }\n        return null;\n    }\n    getRange() {\n        const deltaRange = this._tokens.getRange();\n        if (!deltaRange) {\n            return deltaRange;\n        }\n        return new Range(this._startLineNumber + deltaRange.startLineNumber, deltaRange.startColumn, this._startLineNumber + deltaRange.endLineNumber, deltaRange.endColumn);\n    }\n    removeTokens(range) {\n        const startLineIndex = range.startLineNumber - this._startLineNumber;\n        const endLineIndex = range.endLineNumber - this._startLineNumber;\n        this._startLineNumber += this._tokens.removeTokens(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n        this._updateEndLineNumber();\n    }\n    split(range) {\n        // split tokens to two:\n        // a) all the tokens before `range`\n        // b) all the tokens after `range`\n        const startLineIndex = range.startLineNumber - this._startLineNumber;\n        const endLineIndex = range.endLineNumber - this._startLineNumber;\n        const [a, b, bDeltaLine] = this._tokens.split(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n        return [new SparseMultilineTokens(this._startLineNumber, a), new SparseMultilineTokens(this._startLineNumber + bDeltaLine, b)];\n    }\n    applyEdit(range, text) {\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        this.acceptEdit(range, eolCount, firstLineLength, lastLineLength, text.length > 0 ? text.charCodeAt(0) : 0 /* Null */);\n    }\n    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        this._acceptDeleteRange(range);\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength, lastLineLength, firstCharCode);\n        this._updateEndLineNumber();\n    }\n    _acceptDeleteRange(range) {\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n            // Nothing to delete\n            return;\n        }\n        const firstLineIndex = range.startLineNumber - this._startLineNumber;\n        const lastLineIndex = range.endLineNumber - this._startLineNumber;\n        if (lastLineIndex < 0) {\n            // this deletion occurs entirely before this block, so we only need to adjust line numbers\n            const deletedLinesCount = lastLineIndex - firstLineIndex;\n            this._startLineNumber -= deletedLinesCount;\n            return;\n        }\n        const tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();\n        if (firstLineIndex >= tokenMaxDeltaLine + 1) {\n            // this deletion occurs entirely after this block, so there is nothing to do\n            return;\n        }\n        if (firstLineIndex < 0 && lastLineIndex >= tokenMaxDeltaLine + 1) {\n            // this deletion completely encompasses this block\n            this._startLineNumber = 0;\n            this._tokens.clear();\n            return;\n        }\n        if (firstLineIndex < 0) {\n            const deletedBefore = -firstLineIndex;\n            this._startLineNumber -= deletedBefore;\n            this._tokens.acceptDeleteRange(range.startColumn - 1, 0, 0, lastLineIndex, range.endColumn - 1);\n        }\n        else {\n            this._tokens.acceptDeleteRange(0, firstLineIndex, range.startColumn - 1, lastLineIndex, range.endColumn - 1);\n        }\n    }\n    _acceptInsertText(position, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        if (eolCount === 0 && firstLineLength === 0) {\n            // Nothing to insert\n            return;\n        }\n        const lineIndex = position.lineNumber - this._startLineNumber;\n        if (lineIndex < 0) {\n            // this insertion occurs before this block, so we only need to adjust line numbers\n            this._startLineNumber += eolCount;\n            return;\n        }\n        const tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();\n        if (lineIndex >= tokenMaxDeltaLine + 1) {\n            // this insertion occurs after this block, so there is nothing to do\n            return;\n        }\n        this._tokens.acceptInsertText(lineIndex, position.column - 1, eolCount, firstLineLength, lastLineLength, firstCharCode);\n    }\n}\nclass SparseMultilineTokensStorage {\n    constructor(tokens) {\n        this._tokens = tokens;\n        this._tokenCount = tokens.length / 4;\n    }\n    toString(startLineNumber) {\n        const pieces = [];\n        for (let i = 0; i < this._tokenCount; i++) {\n            pieces.push(`(${this._getDeltaLine(i) + startLineNumber},${this._getStartCharacter(i)}-${this._getEndCharacter(i)})`);\n        }\n        return `[${pieces.join(',')}]`;\n    }\n    getMaxDeltaLine() {\n        const tokenCount = this._getTokenCount();\n        if (tokenCount === 0) {\n            return -1;\n        }\n        return this._getDeltaLine(tokenCount - 1);\n    }\n    getRange() {\n        const tokenCount = this._getTokenCount();\n        if (tokenCount === 0) {\n            return null;\n        }\n        const startChar = this._getStartCharacter(0);\n        const maxDeltaLine = this._getDeltaLine(tokenCount - 1);\n        const endChar = this._getEndCharacter(tokenCount - 1);\n        return new Range(0, startChar + 1, maxDeltaLine, endChar + 1);\n    }\n    _getTokenCount() {\n        return this._tokenCount;\n    }\n    _getDeltaLine(tokenIndex) {\n        return this._tokens[4 * tokenIndex];\n    }\n    _getStartCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 1];\n    }\n    _getEndCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 2];\n    }\n    isEmpty() {\n        return (this._getTokenCount() === 0);\n    }\n    getLineTokens(deltaLine) {\n        let low = 0;\n        let high = this._getTokenCount() - 1;\n        while (low < high) {\n            const mid = low + Math.floor((high - low) / 2);\n            const midDeltaLine = this._getDeltaLine(mid);\n            if (midDeltaLine < deltaLine) {\n                low = mid + 1;\n            }\n            else if (midDeltaLine > deltaLine) {\n                high = mid - 1;\n            }\n            else {\n                let min = mid;\n                while (min > low && this._getDeltaLine(min - 1) === deltaLine) {\n                    min--;\n                }\n                let max = mid;\n                while (max < high && this._getDeltaLine(max + 1) === deltaLine) {\n                    max++;\n                }\n                return new SparseLineTokens(this._tokens.subarray(4 * min, 4 * max + 4));\n            }\n        }\n        if (this._getDeltaLine(low) === deltaLine) {\n            return new SparseLineTokens(this._tokens.subarray(4 * low, 4 * low + 4));\n        }\n        return null;\n    }\n    clear() {\n        this._tokenCount = 0;\n    }\n    removeTokens(startDeltaLine, startChar, endDeltaLine, endChar) {\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        let newTokenCount = 0;\n        let hasDeletedTokens = false;\n        let firstDeltaLine = 0;\n        for (let i = 0; i < tokenCount; i++) {\n            const srcOffset = 4 * i;\n            const tokenDeltaLine = tokens[srcOffset];\n            const tokenStartCharacter = tokens[srcOffset + 1];\n            const tokenEndCharacter = tokens[srcOffset + 2];\n            const tokenMetadata = tokens[srcOffset + 3];\n            if ((tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))\n                && (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))) {\n                hasDeletedTokens = true;\n            }\n            else {\n                if (newTokenCount === 0) {\n                    firstDeltaLine = tokenDeltaLine;\n                }\n                if (hasDeletedTokens) {\n                    // must move the token to the left\n                    const destOffset = 4 * newTokenCount;\n                    tokens[destOffset] = tokenDeltaLine - firstDeltaLine;\n                    tokens[destOffset + 1] = tokenStartCharacter;\n                    tokens[destOffset + 2] = tokenEndCharacter;\n                    tokens[destOffset + 3] = tokenMetadata;\n                }\n                newTokenCount++;\n            }\n        }\n        this._tokenCount = newTokenCount;\n        return firstDeltaLine;\n    }\n    split(startDeltaLine, startChar, endDeltaLine, endChar) {\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        const aTokens = [];\n        const bTokens = [];\n        let destTokens = aTokens;\n        let destOffset = 0;\n        let destFirstDeltaLine = 0;\n        for (let i = 0; i < tokenCount; i++) {\n            const srcOffset = 4 * i;\n            const tokenDeltaLine = tokens[srcOffset];\n            const tokenStartCharacter = tokens[srcOffset + 1];\n            const tokenEndCharacter = tokens[srcOffset + 2];\n            const tokenMetadata = tokens[srcOffset + 3];\n            if ((tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))) {\n                if ((tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))) {\n                    // this token is touching the range\n                    continue;\n                }\n                else {\n                    // this token is after the range\n                    if (destTokens !== bTokens) {\n                        // this token is the first token after the range\n                        destTokens = bTokens;\n                        destOffset = 0;\n                        destFirstDeltaLine = tokenDeltaLine;\n                    }\n                }\n            }\n            destTokens[destOffset++] = tokenDeltaLine - destFirstDeltaLine;\n            destTokens[destOffset++] = tokenStartCharacter;\n            destTokens[destOffset++] = tokenEndCharacter;\n            destTokens[destOffset++] = tokenMetadata;\n        }\n        return [new SparseMultilineTokensStorage(new Uint32Array(aTokens)), new SparseMultilineTokensStorage(new Uint32Array(bTokens)), destFirstDeltaLine];\n    }\n    acceptDeleteRange(horizontalShiftForFirstLineTokens, startDeltaLine, startCharacter, endDeltaLine, endCharacter) {\n        // This is a bit complex, here are the cases I used to think about this:\n        //\n        // 1. The token starts before the deletion range\n        // 1a. The token is completely before the deletion range\n        //               -----------\n        //                          xxxxxxxxxxx\n        // 1b. The token starts before, the deletion range ends after the token\n        //               -----------\n        //                      xxxxxxxxxxx\n        // 1c. The token starts before, the deletion range ends precisely with the token\n        //               ---------------\n        //                      xxxxxxxx\n        // 1d. The token starts before, the deletion range is inside the token\n        //               ---------------\n        //                    xxxxx\n        //\n        // 2. The token starts at the same position with the deletion range\n        // 2a. The token starts at the same position, and ends inside the deletion range\n        //               -------\n        //               xxxxxxxxxxx\n        // 2b. The token starts at the same position, and ends at the same position as the deletion range\n        //               ----------\n        //               xxxxxxxxxx\n        // 2c. The token starts at the same position, and ends after the deletion range\n        //               -------------\n        //               xxxxxxx\n        //\n        // 3. The token starts inside the deletion range\n        // 3a. The token is inside the deletion range\n        //                -------\n        //             xxxxxxxxxxxxx\n        // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n        //                ----------\n        //             xxxxxxxxxxxxx\n        // 3c. The token starts inside the deletion range, and ends after the deletion range\n        //                ------------\n        //             xxxxxxxxxxx\n        //\n        // 4. The token starts after the deletion range\n        //                  -----------\n        //          xxxxxxxx\n        //\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        const deletedLineCount = (endDeltaLine - startDeltaLine);\n        let newTokenCount = 0;\n        let hasDeletedTokens = false;\n        for (let i = 0; i < tokenCount; i++) {\n            const srcOffset = 4 * i;\n            let tokenDeltaLine = tokens[srcOffset];\n            let tokenStartCharacter = tokens[srcOffset + 1];\n            let tokenEndCharacter = tokens[srcOffset + 2];\n            const tokenMetadata = tokens[srcOffset + 3];\n            if (tokenDeltaLine < startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter <= startCharacter)) {\n                // 1a. The token is completely before the deletion range\n                // => nothing to do\n                newTokenCount++;\n                continue;\n            }\n            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter < startCharacter) {\n                // 1b, 1c, 1d\n                // => the token survives, but it needs to shrink\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n                    // 1d. The token starts before, the deletion range is inside the token\n                    // => the token shrinks by the deletion character count\n                    tokenEndCharacter -= (endCharacter - startCharacter);\n                }\n                else {\n                    // 1b. The token starts before, the deletion range ends after the token\n                    // 1c. The token starts before, the deletion range ends precisely with the token\n                    // => the token shrinks its ending to the deletion start\n                    tokenEndCharacter = startCharacter;\n                }\n            }\n            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter === startCharacter) {\n                // 2a, 2b, 2c\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n                    // 2c. The token starts at the same position, and ends after the deletion range\n                    // => the token shrinks by the deletion character count\n                    tokenEndCharacter -= (endCharacter - startCharacter);\n                }\n                else {\n                    // 2a. The token starts at the same position, and ends inside the deletion range\n                    // 2b. The token starts at the same position, and ends at the same position as the deletion range\n                    // => the token is deleted\n                    hasDeletedTokens = true;\n                    continue;\n                }\n            }\n            else if (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter < endCharacter)) {\n                // 3a, 3b, 3c\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n                    // 3c. The token starts inside the deletion range, and ends after the deletion range\n                    // => the token moves left and shrinks\n                    if (tokenDeltaLine === startDeltaLine) {\n                        // the deletion started on the same line as the token\n                        // => the token moves left and shrinks\n                        tokenStartCharacter = startCharacter;\n                        tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n                    }\n                    else {\n                        // the deletion started on a line above the token\n                        // => the token moves to the beginning of the line\n                        tokenStartCharacter = 0;\n                        tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n                    }\n                }\n                else {\n                    // 3a. The token is inside the deletion range\n                    // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n                    // => the token is deleted\n                    hasDeletedTokens = true;\n                    continue;\n                }\n            }\n            else if (tokenDeltaLine > endDeltaLine) {\n                // 4. (partial) The token starts after the deletion range, on a line below...\n                if (deletedLineCount === 0 && !hasDeletedTokens) {\n                    // early stop, there is no need to walk all the tokens and do nothing...\n                    newTokenCount = tokenCount;\n                    break;\n                }\n                tokenDeltaLine -= deletedLineCount;\n            }\n            else if (tokenDeltaLine === endDeltaLine && tokenStartCharacter >= endCharacter) {\n                // 4. (continued) The token starts after the deletion range, on the last line where a deletion occurs\n                if (horizontalShiftForFirstLineTokens && tokenDeltaLine === 0) {\n                    tokenStartCharacter += horizontalShiftForFirstLineTokens;\n                    tokenEndCharacter += horizontalShiftForFirstLineTokens;\n                }\n                tokenDeltaLine -= deletedLineCount;\n                tokenStartCharacter -= (endCharacter - startCharacter);\n                tokenEndCharacter -= (endCharacter - startCharacter);\n            }\n            else {\n                throw new Error(`Not possible!`);\n            }\n            const destOffset = 4 * newTokenCount;\n            tokens[destOffset] = tokenDeltaLine;\n            tokens[destOffset + 1] = tokenStartCharacter;\n            tokens[destOffset + 2] = tokenEndCharacter;\n            tokens[destOffset + 3] = tokenMetadata;\n            newTokenCount++;\n        }\n        this._tokenCount = newTokenCount;\n    }\n    acceptInsertText(deltaLine, character, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        // Here are the cases I used to think about this:\n        //\n        // 1. The token is completely before the insertion point\n        //            -----------   |\n        // 2. The token ends precisely at the insertion point\n        //            -----------|\n        // 3. The token contains the insertion point\n        //            -----|------\n        // 4. The token starts precisely at the insertion point\n        //            |-----------\n        // 5. The token is completely after the insertion point\n        //            |   -----------\n        //\n        const isInsertingPreciselyOneWordCharacter = (eolCount === 0\n            && firstLineLength === 1\n            && ((firstCharCode >= 48 /* Digit0 */ && firstCharCode <= 57 /* Digit9 */)\n                || (firstCharCode >= 65 /* A */ && firstCharCode <= 90 /* Z */)\n                || (firstCharCode >= 97 /* a */ && firstCharCode <= 122 /* z */)));\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        for (let i = 0; i < tokenCount; i++) {\n            const offset = 4 * i;\n            let tokenDeltaLine = tokens[offset];\n            let tokenStartCharacter = tokens[offset + 1];\n            let tokenEndCharacter = tokens[offset + 2];\n            if (tokenDeltaLine < deltaLine || (tokenDeltaLine === deltaLine && tokenEndCharacter < character)) {\n                // 1. The token is completely before the insertion point\n                // => nothing to do\n                continue;\n            }\n            else if (tokenDeltaLine === deltaLine && tokenEndCharacter === character) {\n                // 2. The token ends precisely at the insertion point\n                // => expand the end character only if inserting precisely one character that is a word character\n                if (isInsertingPreciselyOneWordCharacter) {\n                    tokenEndCharacter += 1;\n                }\n                else {\n                    continue;\n                }\n            }\n            else if (tokenDeltaLine === deltaLine && tokenStartCharacter < character && character < tokenEndCharacter) {\n                // 3. The token contains the insertion point\n                if (eolCount === 0) {\n                    // => just expand the end character\n                    tokenEndCharacter += firstLineLength;\n                }\n                else {\n                    // => cut off the token\n                    tokenEndCharacter = character;\n                }\n            }\n            else {\n                // 4. or 5.\n                if (tokenDeltaLine === deltaLine && tokenStartCharacter === character) {\n                    // 4. The token starts precisely at the insertion point\n                    // => grow the token (by keeping its start constant) only if inserting precisely one character that is a word character\n                    // => otherwise behave as in case 5.\n                    if (isInsertingPreciselyOneWordCharacter) {\n                        continue;\n                    }\n                }\n                // => the token must move and keep its size constant\n                if (tokenDeltaLine === deltaLine) {\n                    tokenDeltaLine += eolCount;\n                    // this token is on the line where the insertion is taking place\n                    if (eolCount === 0) {\n                        tokenStartCharacter += firstLineLength;\n                        tokenEndCharacter += firstLineLength;\n                    }\n                    else {\n                        const tokenLength = tokenEndCharacter - tokenStartCharacter;\n                        tokenStartCharacter = lastLineLength + (tokenStartCharacter - character);\n                        tokenEndCharacter = tokenStartCharacter + tokenLength;\n                    }\n                }\n                else {\n                    tokenDeltaLine += eolCount;\n                }\n            }\n            tokens[offset] = tokenDeltaLine;\n            tokens[offset + 1] = tokenStartCharacter;\n            tokens[offset + 2] = tokenEndCharacter;\n        }\n    }\n}\nexport class SparseLineTokens {\n    constructor(tokens) {\n        this._tokens = tokens;\n    }\n    getCount() {\n        return this._tokens.length / 4;\n    }\n    getStartCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 1];\n    }\n    getEndCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 2];\n    }\n    getMetadata(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 3];\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { LineTokens } from './lineTokens.js';\n/**\n * Represents sparse tokens in a text model.\n */\nexport class SparseTokensStore {\n    constructor(languageIdCodec) {\n        this._pieces = [];\n        this._isComplete = false;\n        this._languageIdCodec = languageIdCodec;\n    }\n    flush() {\n        this._pieces = [];\n        this._isComplete = false;\n    }\n    isEmpty() {\n        return (this._pieces.length === 0);\n    }\n    set(pieces, isComplete) {\n        this._pieces = pieces || [];\n        this._isComplete = isComplete;\n    }\n    setPartial(_range, pieces) {\n        // console.log(`setPartial ${_range} ${pieces.map(p => p.toString()).join(', ')}`);\n        let range = _range;\n        if (pieces.length > 0) {\n            const _firstRange = pieces[0].getRange();\n            const _lastRange = pieces[pieces.length - 1].getRange();\n            if (!_firstRange || !_lastRange) {\n                return _range;\n            }\n            range = _range.plusRange(_firstRange).plusRange(_lastRange);\n        }\n        let insertPosition = null;\n        for (let i = 0, len = this._pieces.length; i < len; i++) {\n            const piece = this._pieces[i];\n            if (piece.endLineNumber < range.startLineNumber) {\n                // this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // this piece is after the range, so mark the spot before this piece\n                // as a good insertion position and stop looping\n                insertPosition = insertPosition || { index: i };\n                break;\n            }\n            // this piece might intersect with the range\n            piece.removeTokens(range);\n            if (piece.isEmpty()) {\n                // remove the piece if it became empty\n                this._pieces.splice(i, 1);\n                i--;\n                len--;\n                continue;\n            }\n            if (piece.endLineNumber < range.startLineNumber) {\n                // after removal, this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // after removal, this piece is after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            // after removal, this piece contains the range\n            const [a, b] = piece.split(range);\n            if (a.isEmpty()) {\n                // this piece is actually after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            if (b.isEmpty()) {\n                // this piece is actually before the range\n                continue;\n            }\n            this._pieces.splice(i, 1, a, b);\n            i++;\n            len++;\n            insertPosition = insertPosition || { index: i };\n        }\n        insertPosition = insertPosition || { index: this._pieces.length };\n        if (pieces.length > 0) {\n            this._pieces = arrays.arrayInsert(this._pieces, insertPosition.index, pieces);\n        }\n        // console.log(`I HAVE ${this._pieces.length} pieces`);\n        // console.log(`${this._pieces.map(p => p.toString()).join('\\n')}`);\n        return range;\n    }\n    isComplete() {\n        return this._isComplete;\n    }\n    addSparseTokens(lineNumber, aTokens) {\n        const pieces = this._pieces;\n        if (pieces.length === 0) {\n            return aTokens;\n        }\n        const pieceIndex = SparseTokensStore._findFirstPieceWithLine(pieces, lineNumber);\n        const bTokens = pieces[pieceIndex].getLineTokens(lineNumber);\n        if (!bTokens) {\n            return aTokens;\n        }\n        const aLen = aTokens.getCount();\n        const bLen = bTokens.getCount();\n        let aIndex = 0;\n        const result = [];\n        let resultLen = 0;\n        let lastEndOffset = 0;\n        const emitToken = (endOffset, metadata) => {\n            if (endOffset === lastEndOffset) {\n                return;\n            }\n            lastEndOffset = endOffset;\n            result[resultLen++] = endOffset;\n            result[resultLen++] = metadata;\n        };\n        for (let bIndex = 0; bIndex < bLen; bIndex++) {\n            const bStartCharacter = bTokens.getStartCharacter(bIndex);\n            const bEndCharacter = bTokens.getEndCharacter(bIndex);\n            const bMetadata = bTokens.getMetadata(bIndex);\n            const bMask = (((bMetadata & 1 /* SEMANTIC_USE_ITALIC */) ? 1024 /* ITALIC_MASK */ : 0)\n                | ((bMetadata & 2 /* SEMANTIC_USE_BOLD */) ? 2048 /* BOLD_MASK */ : 0)\n                | ((bMetadata & 4 /* SEMANTIC_USE_UNDERLINE */) ? 4096 /* UNDERLINE_MASK */ : 0)\n                | ((bMetadata & 8 /* SEMANTIC_USE_STRIKETHROUGH */) ? 8192 /* STRIKETHROUGH_MASK */ : 0)\n                | ((bMetadata & 16 /* SEMANTIC_USE_FOREGROUND */) ? 8372224 /* FOREGROUND_MASK */ : 0)\n                | ((bMetadata & 32 /* SEMANTIC_USE_BACKGROUND */) ? 4286578688 /* BACKGROUND_MASK */ : 0)) >>> 0;\n            const aMask = (~bMask) >>> 0;\n            // push any token from `a` that is before `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n                aIndex++;\n            }\n            // push the token from `a` if it intersects the token from `b`\n            if (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\n                emitToken(bStartCharacter, aTokens.getMetadata(aIndex));\n            }\n            // skip any tokens from `a` that are contained inside `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                aIndex++;\n            }\n            if (aIndex < aLen) {\n                emitToken(bEndCharacter, (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                if (aTokens.getEndOffset(aIndex) === bEndCharacter) {\n                    // `a` ends exactly at the same spot as `b`!\n                    aIndex++;\n                }\n            }\n            else {\n                const aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);\n                // push the token from `b`\n                emitToken(bEndCharacter, (aTokens.getMetadata(aMergeIndex) & aMask) | (bMetadata & bMask));\n            }\n        }\n        // push the remaining tokens from `a`\n        while (aIndex < aLen) {\n            emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n            aIndex++;\n        }\n        return new LineTokens(new Uint32Array(result), aTokens.getLineContent(), this._languageIdCodec);\n    }\n    static _findFirstPieceWithLine(pieces, lineNumber) {\n        let low = 0;\n        let high = pieces.length - 1;\n        while (low < high) {\n            let mid = low + Math.floor((high - low) / 2);\n            if (pieces[mid].endLineNumber < lineNumber) {\n                low = mid + 1;\n            }\n            else if (pieces[mid].startLineNumber > lineNumber) {\n                high = mid - 1;\n            }\n            else {\n                while (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\n                    mid--;\n                }\n                return mid;\n            }\n        }\n        return low;\n    }\n    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        for (const piece of this._pieces) {\n            piece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nexport class LineDecoration {\n    constructor(startColumn, endColumn, className, type) {\n        this.startColumn = startColumn;\n        this.endColumn = endColumn;\n        this.className = className;\n        this.type = type;\n        this._lineDecorationBrand = undefined;\n    }\n    static _equals(a, b) {\n        return (a.startColumn === b.startColumn\n            && a.endColumn === b.endColumn\n            && a.className === b.className\n            && a.type === b.type);\n    }\n    static equalsArr(a, b) {\n        const aLen = a.length;\n        const bLen = b.length;\n        if (aLen !== bLen) {\n            return false;\n        }\n        for (let i = 0; i < aLen; i++) {\n            if (!LineDecoration._equals(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static extractWrapped(arr, startOffset, endOffset) {\n        if (arr.length === 0) {\n            return arr;\n        }\n        const startColumn = startOffset + 1;\n        const endColumn = endOffset + 1;\n        const lineLength = endOffset - startOffset;\n        const r = [];\n        let rLength = 0;\n        for (const dec of arr) {\n            if (dec.endColumn <= startColumn || dec.startColumn >= endColumn) {\n                continue;\n            }\n            r[rLength++] = new LineDecoration(Math.max(1, dec.startColumn - startColumn + 1), Math.min(lineLength + 1, dec.endColumn - startColumn + 1), dec.className, dec.type);\n        }\n        return r;\n    }\n    static filter(lineDecorations, lineNumber, minLineColumn, maxLineColumn) {\n        if (lineDecorations.length === 0) {\n            return [];\n        }\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = lineDecorations.length; i < len; i++) {\n            const d = lineDecorations[i];\n            const range = d.range;\n            if (range.endLineNumber < lineNumber || range.startLineNumber > lineNumber) {\n                // Ignore decorations that sit outside this line\n                continue;\n            }\n            if (range.isEmpty() && (d.type === 0 /* Regular */ || d.type === 3 /* RegularAffectingLetterSpacing */)) {\n                // Ignore empty range decorations\n                continue;\n            }\n            const startColumn = (range.startLineNumber === lineNumber ? range.startColumn : minLineColumn);\n            const endColumn = (range.endLineNumber === lineNumber ? range.endColumn : maxLineColumn);\n            result[resultLen++] = new LineDecoration(startColumn, endColumn, d.inlineClassName, d.type);\n        }\n        return result;\n    }\n    static _typeCompare(a, b) {\n        const ORDER = [2, 0, 1, 3];\n        return ORDER[a] - ORDER[b];\n    }\n    static compare(a, b) {\n        if (a.startColumn !== b.startColumn) {\n            return a.startColumn - b.startColumn;\n        }\n        if (a.endColumn !== b.endColumn) {\n            return a.endColumn - b.endColumn;\n        }\n        const typeCmp = LineDecoration._typeCompare(a.type, b.type);\n        if (typeCmp !== 0) {\n            return typeCmp;\n        }\n        if (a.className !== b.className) {\n            return a.className < b.className ? -1 : 1;\n        }\n        return 0;\n    }\n}\nexport class DecorationSegment {\n    constructor(startOffset, endOffset, className, metadata) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.className = className;\n        this.metadata = metadata;\n    }\n}\nclass Stack {\n    constructor() {\n        this.stopOffsets = [];\n        this.classNames = [];\n        this.metadata = [];\n        this.count = 0;\n    }\n    static _metadata(metadata) {\n        let result = 0;\n        for (let i = 0, len = metadata.length; i < len; i++) {\n            result |= metadata[i];\n        }\n        return result;\n    }\n    consumeLowerThan(maxStopOffset, nextStartOffset, result) {\n        while (this.count > 0 && this.stopOffsets[0] < maxStopOffset) {\n            let i = 0;\n            // Take all equal stopping offsets\n            while (i + 1 < this.count && this.stopOffsets[i] === this.stopOffsets[i + 1]) {\n                i++;\n            }\n            // Basically we are consuming the first i + 1 elements of the stack\n            result.push(new DecorationSegment(nextStartOffset, this.stopOffsets[i], this.classNames.join(' '), Stack._metadata(this.metadata)));\n            nextStartOffset = this.stopOffsets[i] + 1;\n            // Consume them\n            this.stopOffsets.splice(0, i + 1);\n            this.classNames.splice(0, i + 1);\n            this.metadata.splice(0, i + 1);\n            this.count -= (i + 1);\n        }\n        if (this.count > 0 && nextStartOffset < maxStopOffset) {\n            result.push(new DecorationSegment(nextStartOffset, maxStopOffset - 1, this.classNames.join(' '), Stack._metadata(this.metadata)));\n            nextStartOffset = maxStopOffset;\n        }\n        return nextStartOffset;\n    }\n    insert(stopOffset, className, metadata) {\n        if (this.count === 0 || this.stopOffsets[this.count - 1] <= stopOffset) {\n            // Insert at the end\n            this.stopOffsets.push(stopOffset);\n            this.classNames.push(className);\n            this.metadata.push(metadata);\n        }\n        else {\n            // Find the insertion position for `stopOffset`\n            for (let i = 0; i < this.count; i++) {\n                if (this.stopOffsets[i] >= stopOffset) {\n                    this.stopOffsets.splice(i, 0, stopOffset);\n                    this.classNames.splice(i, 0, className);\n                    this.metadata.splice(i, 0, metadata);\n                    break;\n                }\n            }\n        }\n        this.count++;\n        return;\n    }\n}\nexport class LineDecorationsNormalizer {\n    /**\n     * Normalize line decorations. Overlapping decorations will generate multiple segments\n     */\n    static normalize(lineContent, lineDecorations) {\n        if (lineDecorations.length === 0) {\n            return [];\n        }\n        const result = [];\n        const stack = new Stack();\n        let nextStartOffset = 0;\n        for (let i = 0, len = lineDecorations.length; i < len; i++) {\n            const d = lineDecorations[i];\n            let startColumn = d.startColumn;\n            let endColumn = d.endColumn;\n            const className = d.className;\n            const metadata = (d.type === 1 /* Before */\n                ? 2 /* PSEUDO_BEFORE */\n                : d.type === 2 /* After */\n                    ? 4 /* PSEUDO_AFTER */\n                    : 0);\n            // If the position would end up in the middle of a high-low surrogate pair, we move it to before the pair\n            if (startColumn > 1) {\n                const charCodeBefore = lineContent.charCodeAt(startColumn - 2);\n                if (strings.isHighSurrogate(charCodeBefore)) {\n                    startColumn--;\n                }\n            }\n            if (endColumn > 1) {\n                const charCodeBefore = lineContent.charCodeAt(endColumn - 2);\n                if (strings.isHighSurrogate(charCodeBefore)) {\n                    endColumn--;\n                }\n            }\n            const currentStartOffset = startColumn - 1;\n            const currentEndOffset = endColumn - 2;\n            nextStartOffset = stack.consumeLowerThan(currentStartOffset, nextStartOffset, result);\n            if (stack.count === 0) {\n                nextStartOffset = currentStartOffset;\n            }\n            stack.insert(currentEndOffset, className, metadata);\n        }\n        stack.consumeLowerThan(1073741824 /* MAX_SAFE_SMALL_INTEGER */, nextStartOffset, result);\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { createStringBuilder } from '../core/stringBuilder.js';\nimport { LineDecoration, LineDecorationsNormalizer } from './lineDecorations.js';\nclass LinePart {\n    constructor(endIndex, type, metadata) {\n        this._linePartBrand = undefined;\n        this.endIndex = endIndex;\n        this.type = type;\n        this.metadata = metadata;\n    }\n    isWhitespace() {\n        return (this.metadata & 1 /* IS_WHITESPACE_MASK */ ? true : false);\n    }\n    isPseudoAfter() {\n        return (this.metadata & 4 /* PSEUDO_AFTER_MASK */ ? true : false);\n    }\n}\nexport class LineRange {\n    constructor(startIndex, endIndex) {\n        this.startOffset = startIndex;\n        this.endOffset = endIndex;\n    }\n    equals(otherLineRange) {\n        return this.startOffset === otherLineRange.startOffset\n            && this.endOffset === otherLineRange.endOffset;\n    }\n}\nexport class RenderLineInput {\n    constructor(useMonospaceOptimizations, canUseHalfwidthRightwardsArrow, lineContent, continuesWithWrappedLine, isBasicASCII, containsRTL, fauxIndentLength, lineTokens, lineDecorations, tabSize, startVisibleColumn, spaceWidth, middotWidth, wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures, selectionsOnLine) {\n        this.useMonospaceOptimizations = useMonospaceOptimizations;\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n        this.lineContent = lineContent;\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\n        this.isBasicASCII = isBasicASCII;\n        this.containsRTL = containsRTL;\n        this.fauxIndentLength = fauxIndentLength;\n        this.lineTokens = lineTokens;\n        this.lineDecorations = lineDecorations.sort(LineDecoration.compare);\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n        this.spaceWidth = spaceWidth;\n        this.stopRenderingLineAfter = stopRenderingLineAfter;\n        this.renderWhitespace = (renderWhitespace === 'all'\n            ? 4 /* All */\n            : renderWhitespace === 'boundary'\n                ? 1 /* Boundary */\n                : renderWhitespace === 'selection'\n                    ? 2 /* Selection */\n                    : renderWhitespace === 'trailing'\n                        ? 3 /* Trailing */\n                        : 0 /* None */);\n        this.renderControlCharacters = renderControlCharacters;\n        this.fontLigatures = fontLigatures;\n        this.selectionsOnLine = selectionsOnLine && selectionsOnLine.sort((a, b) => a.startOffset < b.startOffset ? -1 : 1);\n        const wsmiddotDiff = Math.abs(wsmiddotWidth - spaceWidth);\n        const middotDiff = Math.abs(middotWidth - spaceWidth);\n        if (wsmiddotDiff < middotDiff) {\n            this.renderSpaceWidth = wsmiddotWidth;\n            this.renderSpaceCharCode = 0x2E31; // U+2E31 - WORD SEPARATOR MIDDLE DOT\n        }\n        else {\n            this.renderSpaceWidth = middotWidth;\n            this.renderSpaceCharCode = 0xB7; // U+00B7 - MIDDLE DOT\n        }\n    }\n    sameSelection(otherSelections) {\n        if (this.selectionsOnLine === null) {\n            return otherSelections === null;\n        }\n        if (otherSelections === null) {\n            return false;\n        }\n        if (otherSelections.length !== this.selectionsOnLine.length) {\n            return false;\n        }\n        for (let i = 0; i < this.selectionsOnLine.length; i++) {\n            if (!this.selectionsOnLine[i].equals(otherSelections[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    equals(other) {\n        return (this.useMonospaceOptimizations === other.useMonospaceOptimizations\n            && this.canUseHalfwidthRightwardsArrow === other.canUseHalfwidthRightwardsArrow\n            && this.lineContent === other.lineContent\n            && this.continuesWithWrappedLine === other.continuesWithWrappedLine\n            && this.isBasicASCII === other.isBasicASCII\n            && this.containsRTL === other.containsRTL\n            && this.fauxIndentLength === other.fauxIndentLength\n            && this.tabSize === other.tabSize\n            && this.startVisibleColumn === other.startVisibleColumn\n            && this.spaceWidth === other.spaceWidth\n            && this.renderSpaceWidth === other.renderSpaceWidth\n            && this.renderSpaceCharCode === other.renderSpaceCharCode\n            && this.stopRenderingLineAfter === other.stopRenderingLineAfter\n            && this.renderWhitespace === other.renderWhitespace\n            && this.renderControlCharacters === other.renderControlCharacters\n            && this.fontLigatures === other.fontLigatures\n            && LineDecoration.equalsArr(this.lineDecorations, other.lineDecorations)\n            && this.lineTokens.equals(other.lineTokens)\n            && this.sameSelection(other.selectionsOnLine));\n    }\n}\nexport class DomPosition {\n    constructor(partIndex, charIndex) {\n        this.partIndex = partIndex;\n        this.charIndex = charIndex;\n    }\n}\n/**\n * Provides a both direction mapping between a line's character and its rendered position.\n */\nexport class CharacterMapping {\n    constructor(length, partCount) {\n        this.length = length;\n        this._data = new Uint32Array(this.length);\n        this._absoluteOffsets = new Uint32Array(this.length);\n    }\n    static getPartIndex(partData) {\n        return (partData & 4294901760 /* PART_INDEX_MASK */) >>> 16 /* PART_INDEX_OFFSET */;\n    }\n    static getCharIndex(partData) {\n        return (partData & 65535 /* CHAR_INDEX_MASK */) >>> 0 /* CHAR_INDEX_OFFSET */;\n    }\n    setColumnInfo(column, partIndex, charIndex, partAbsoluteOffset) {\n        const partData = ((partIndex << 16 /* PART_INDEX_OFFSET */)\n            | (charIndex << 0 /* CHAR_INDEX_OFFSET */)) >>> 0;\n        this._data[column - 1] = partData;\n        this._absoluteOffsets[column - 1] = partAbsoluteOffset + charIndex;\n    }\n    getAbsoluteOffset(column) {\n        if (this._absoluteOffsets.length === 0) {\n            // No characters on this line\n            return 0;\n        }\n        return this._absoluteOffsets[column - 1];\n    }\n    charOffsetToPartData(charOffset) {\n        if (this.length === 0) {\n            return 0;\n        }\n        if (charOffset < 0) {\n            return this._data[0];\n        }\n        if (charOffset >= this.length) {\n            return this._data[this.length - 1];\n        }\n        return this._data[charOffset];\n    }\n    getDomPosition(column) {\n        const partData = this.charOffsetToPartData(column - 1);\n        const partIndex = CharacterMapping.getPartIndex(partData);\n        const charIndex = CharacterMapping.getCharIndex(partData);\n        return new DomPosition(partIndex, charIndex);\n    }\n    getColumn(domPosition, partLength) {\n        const charOffset = this.partDataToCharOffset(domPosition.partIndex, partLength, domPosition.charIndex);\n        return charOffset + 1;\n    }\n    partDataToCharOffset(partIndex, partLength, charIndex) {\n        if (this.length === 0) {\n            return 0;\n        }\n        const searchEntry = ((partIndex << 16 /* PART_INDEX_OFFSET */)\n            | (charIndex << 0 /* CHAR_INDEX_OFFSET */)) >>> 0;\n        let min = 0;\n        let max = this.length - 1;\n        while (min + 1 < max) {\n            const mid = ((min + max) >>> 1);\n            const midEntry = this._data[mid];\n            if (midEntry === searchEntry) {\n                return mid;\n            }\n            else if (midEntry > searchEntry) {\n                max = mid;\n            }\n            else {\n                min = mid;\n            }\n        }\n        if (min === max) {\n            return min;\n        }\n        const minEntry = this._data[min];\n        const maxEntry = this._data[max];\n        if (minEntry === searchEntry) {\n            return min;\n        }\n        if (maxEntry === searchEntry) {\n            return max;\n        }\n        const minPartIndex = CharacterMapping.getPartIndex(minEntry);\n        const minCharIndex = CharacterMapping.getCharIndex(minEntry);\n        const maxPartIndex = CharacterMapping.getPartIndex(maxEntry);\n        let maxCharIndex;\n        if (minPartIndex !== maxPartIndex) {\n            // sitting between parts\n            maxCharIndex = partLength;\n        }\n        else {\n            maxCharIndex = CharacterMapping.getCharIndex(maxEntry);\n        }\n        const minEntryDistance = charIndex - minCharIndex;\n        const maxEntryDistance = maxCharIndex - charIndex;\n        if (minEntryDistance <= maxEntryDistance) {\n            return min;\n        }\n        return max;\n    }\n}\nexport class RenderLineOutput {\n    constructor(characterMapping, containsRTL, containsForeignElements) {\n        this._renderLineOutputBrand = undefined;\n        this.characterMapping = characterMapping;\n        this.containsRTL = containsRTL;\n        this.containsForeignElements = containsForeignElements;\n    }\n}\nexport function renderViewLine(input, sb) {\n    if (input.lineContent.length === 0) {\n        if (input.lineDecorations.length > 0) {\n            // This line is empty, but it contains inline decorations\n            sb.appendASCIIString(`<span>`);\n            let beforeCount = 0;\n            let afterCount = 0;\n            let containsForeignElements = 0 /* None */;\n            for (const lineDecoration of input.lineDecorations) {\n                if (lineDecoration.type === 1 /* Before */ || lineDecoration.type === 2 /* After */) {\n                    sb.appendASCIIString(`<span class=\"`);\n                    sb.appendASCIIString(lineDecoration.className);\n                    sb.appendASCIIString(`\"></span>`);\n                    if (lineDecoration.type === 1 /* Before */) {\n                        containsForeignElements |= 1 /* Before */;\n                        beforeCount++;\n                    }\n                    if (lineDecoration.type === 2 /* After */) {\n                        containsForeignElements |= 2 /* After */;\n                        afterCount++;\n                    }\n                }\n            }\n            sb.appendASCIIString(`</span>`);\n            const characterMapping = new CharacterMapping(1, beforeCount + afterCount);\n            characterMapping.setColumnInfo(1, beforeCount, 0, 0);\n            return new RenderLineOutput(characterMapping, false, containsForeignElements);\n        }\n        // completely empty line\n        sb.appendASCIIString('<span><span></span></span>');\n        return new RenderLineOutput(new CharacterMapping(0, 0), false, 0 /* None */);\n    }\n    return _renderLine(resolveRenderLineInput(input), sb);\n}\nexport class RenderLineOutput2 {\n    constructor(characterMapping, html, containsRTL, containsForeignElements) {\n        this.characterMapping = characterMapping;\n        this.html = html;\n        this.containsRTL = containsRTL;\n        this.containsForeignElements = containsForeignElements;\n    }\n}\nexport function renderViewLine2(input) {\n    const sb = createStringBuilder(10000);\n    const out = renderViewLine(input, sb);\n    return new RenderLineOutput2(out.characterMapping, sb.build(), out.containsRTL, out.containsForeignElements);\n}\nclass ResolvedRenderLineInput {\n    constructor(fontIsMonospace, canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, parts, containsForeignElements, fauxIndentLength, tabSize, startVisibleColumn, containsRTL, spaceWidth, renderSpaceCharCode, renderWhitespace, renderControlCharacters) {\n        this.fontIsMonospace = fontIsMonospace;\n        this.canUseHalfwidthRightwardsArrow = canUseHalfwidthRightwardsArrow;\n        this.lineContent = lineContent;\n        this.len = len;\n        this.isOverflowing = isOverflowing;\n        this.parts = parts;\n        this.containsForeignElements = containsForeignElements;\n        this.fauxIndentLength = fauxIndentLength;\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n        this.containsRTL = containsRTL;\n        this.spaceWidth = spaceWidth;\n        this.renderSpaceCharCode = renderSpaceCharCode;\n        this.renderWhitespace = renderWhitespace;\n        this.renderControlCharacters = renderControlCharacters;\n        //\n    }\n}\nfunction resolveRenderLineInput(input) {\n    const lineContent = input.lineContent;\n    let isOverflowing;\n    let len;\n    if (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {\n        isOverflowing = true;\n        len = input.stopRenderingLineAfter;\n    }\n    else {\n        isOverflowing = false;\n        len = lineContent.length;\n    }\n    let tokens = transformAndRemoveOverflowing(input.lineTokens, input.fauxIndentLength, len);\n    if (input.renderControlCharacters && !input.isBasicASCII) {\n        // Calling `extractControlCharacters` before adding (possibly empty) line parts\n        // for inline decorations. `extractControlCharacters` removes empty line parts.\n        tokens = extractControlCharacters(lineContent, tokens);\n    }\n    if (input.renderWhitespace === 4 /* All */ ||\n        input.renderWhitespace === 1 /* Boundary */ ||\n        (input.renderWhitespace === 2 /* Selection */ && !!input.selectionsOnLine) ||\n        input.renderWhitespace === 3 /* Trailing */) {\n        tokens = _applyRenderWhitespace(input, lineContent, len, tokens);\n    }\n    let containsForeignElements = 0 /* None */;\n    if (input.lineDecorations.length > 0) {\n        for (let i = 0, len = input.lineDecorations.length; i < len; i++) {\n            const lineDecoration = input.lineDecorations[i];\n            if (lineDecoration.type === 3 /* RegularAffectingLetterSpacing */) {\n                // Pretend there are foreign elements... although not 100% accurate.\n                containsForeignElements |= 1 /* Before */;\n            }\n            else if (lineDecoration.type === 1 /* Before */) {\n                containsForeignElements |= 1 /* Before */;\n            }\n            else if (lineDecoration.type === 2 /* After */) {\n                containsForeignElements |= 2 /* After */;\n            }\n        }\n        tokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);\n    }\n    if (!input.containsRTL) {\n        // We can never split RTL text, as it ruins the rendering\n        tokens = splitLargeTokens(lineContent, tokens, !input.isBasicASCII || input.fontLigatures);\n    }\n    return new ResolvedRenderLineInput(input.useMonospaceOptimizations, input.canUseHalfwidthRightwardsArrow, lineContent, len, isOverflowing, tokens, containsForeignElements, input.fauxIndentLength, input.tabSize, input.startVisibleColumn, input.containsRTL, input.spaceWidth, input.renderSpaceCharCode, input.renderWhitespace, input.renderControlCharacters);\n}\n/**\n * In the rendering phase, characters are always looped until token.endIndex.\n * Ensure that all tokens end before `len` and the last one ends precisely at `len`.\n */\nfunction transformAndRemoveOverflowing(tokens, fauxIndentLength, len) {\n    const result = [];\n    let resultLen = 0;\n    // The faux indent part of the line should have no token type\n    if (fauxIndentLength > 0) {\n        result[resultLen++] = new LinePart(fauxIndentLength, '', 0);\n    }\n    for (let tokenIndex = 0, tokensLen = tokens.getCount(); tokenIndex < tokensLen; tokenIndex++) {\n        const endIndex = tokens.getEndOffset(tokenIndex);\n        if (endIndex <= fauxIndentLength) {\n            // The faux indent part of the line should have no token type\n            continue;\n        }\n        const type = tokens.getClassName(tokenIndex);\n        if (endIndex >= len) {\n            result[resultLen++] = new LinePart(len, type, 0);\n            break;\n        }\n        result[resultLen++] = new LinePart(endIndex, type, 0);\n    }\n    return result;\n}\n/**\n * See https://github.com/microsoft/vscode/issues/6885.\n * It appears that having very large spans causes very slow reading of character positions.\n * So here we try to avoid that.\n */\nfunction splitLargeTokens(lineContent, tokens, onlyAtSpaces) {\n    let lastTokenEndIndex = 0;\n    const result = [];\n    let resultLen = 0;\n    if (onlyAtSpaces) {\n        // Split only at spaces => we need to walk each character\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const token = tokens[i];\n            const tokenEndIndex = token.endIndex;\n            if (lastTokenEndIndex + 50 /* LongToken */ < tokenEndIndex) {\n                const tokenType = token.type;\n                const tokenMetadata = token.metadata;\n                let lastSpaceOffset = -1;\n                let currTokenStart = lastTokenEndIndex;\n                for (let j = lastTokenEndIndex; j < tokenEndIndex; j++) {\n                    if (lineContent.charCodeAt(j) === 32 /* Space */) {\n                        lastSpaceOffset = j;\n                    }\n                    if (lastSpaceOffset !== -1 && j - currTokenStart >= 50 /* LongToken */) {\n                        // Split at `lastSpaceOffset` + 1\n                        result[resultLen++] = new LinePart(lastSpaceOffset + 1, tokenType, tokenMetadata);\n                        currTokenStart = lastSpaceOffset + 1;\n                        lastSpaceOffset = -1;\n                    }\n                }\n                if (currTokenStart !== tokenEndIndex) {\n                    result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata);\n                }\n            }\n            else {\n                result[resultLen++] = token;\n            }\n            lastTokenEndIndex = tokenEndIndex;\n        }\n    }\n    else {\n        // Split anywhere => we don't need to walk each character\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const token = tokens[i];\n            const tokenEndIndex = token.endIndex;\n            const diff = (tokenEndIndex - lastTokenEndIndex);\n            if (diff > 50 /* LongToken */) {\n                const tokenType = token.type;\n                const tokenMetadata = token.metadata;\n                const piecesCount = Math.ceil(diff / 50 /* LongToken */);\n                for (let j = 1; j < piecesCount; j++) {\n                    const pieceEndIndex = lastTokenEndIndex + (j * 50 /* LongToken */);\n                    result[resultLen++] = new LinePart(pieceEndIndex, tokenType, tokenMetadata);\n                }\n                result[resultLen++] = new LinePart(tokenEndIndex, tokenType, tokenMetadata);\n            }\n            else {\n                result[resultLen++] = token;\n            }\n            lastTokenEndIndex = tokenEndIndex;\n        }\n    }\n    return result;\n}\nfunction isControlCharacter(charCode) {\n    if (charCode < 32) {\n        return (charCode !== 9 /* Tab */);\n    }\n    if (charCode === 127) {\n        // DEL\n        return true;\n    }\n    if ((charCode >= 0x202A && charCode <= 0x202E)\n        || (charCode >= 0x2066 && charCode <= 0x2069)\n        || (charCode >= 0x200E && charCode <= 0x200F)\n        || charCode === 0x061C) {\n        // Unicode Directional Formatting Characters\n        // LRE\tU+202A\tLEFT-TO-RIGHT EMBEDDING\n        // RLE\tU+202B\tRIGHT-TO-LEFT EMBEDDING\n        // PDF\tU+202C\tPOP DIRECTIONAL FORMATTING\n        // LRO\tU+202D\tLEFT-TO-RIGHT OVERRIDE\n        // RLO\tU+202E\tRIGHT-TO-LEFT OVERRIDE\n        // LRI\tU+2066\tLEFT-TO-RIGHT ISOLATE\n        // RLI\tU+2067\tRIGHT-TO-LEFT ISOLATE\n        // FSI\tU+2068\tFIRST STRONG ISOLATE\n        // PDI\tU+2069\tPOP DIRECTIONAL ISOLATE\n        // LRM\tU+200E\tLEFT-TO-RIGHT MARK\n        // RLM\tU+200F\tRIGHT-TO-LEFT MARK\n        // ALM\tU+061C\tARABIC LETTER MARK\n        return true;\n    }\n    return false;\n}\nfunction extractControlCharacters(lineContent, tokens) {\n    const result = [];\n    let lastLinePart = new LinePart(0, '', 0);\n    let charOffset = 0;\n    for (const token of tokens) {\n        const tokenEndIndex = token.endIndex;\n        for (; charOffset < tokenEndIndex; charOffset++) {\n            const charCode = lineContent.charCodeAt(charOffset);\n            if (isControlCharacter(charCode)) {\n                if (charOffset > lastLinePart.endIndex) {\n                    // emit previous part if it has text\n                    lastLinePart = new LinePart(charOffset, token.type, token.metadata);\n                    result.push(lastLinePart);\n                }\n                lastLinePart = new LinePart(charOffset + 1, 'mtkcontrol', token.metadata);\n                result.push(lastLinePart);\n            }\n        }\n        if (charOffset > lastLinePart.endIndex) {\n            // emit previous part if it has text\n            lastLinePart = new LinePart(tokenEndIndex, token.type, token.metadata);\n            result.push(lastLinePart);\n        }\n    }\n    return result;\n}\n/**\n * Whitespace is rendered by \"replacing\" tokens with a special-purpose `mtkw` type that is later recognized in the rendering phase.\n * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.\n * The rendering phase will generate `style=\"width:...\"` for these tokens.\n */\nfunction _applyRenderWhitespace(input, lineContent, len, tokens) {\n    const continuesWithWrappedLine = input.continuesWithWrappedLine;\n    const fauxIndentLength = input.fauxIndentLength;\n    const tabSize = input.tabSize;\n    const startVisibleColumn = input.startVisibleColumn;\n    const useMonospaceOptimizations = input.useMonospaceOptimizations;\n    const selections = input.selectionsOnLine;\n    const onlyBoundary = (input.renderWhitespace === 1 /* Boundary */);\n    const onlyTrailing = (input.renderWhitespace === 3 /* Trailing */);\n    const generateLinePartForEachWhitespace = (input.renderSpaceWidth !== input.spaceWidth);\n    const result = [];\n    let resultLen = 0;\n    let tokenIndex = 0;\n    let tokenType = tokens[tokenIndex].type;\n    let tokenEndIndex = tokens[tokenIndex].endIndex;\n    const tokensLength = tokens.length;\n    let lineIsEmptyOrWhitespace = false;\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n    let lastNonWhitespaceIndex;\n    if (firstNonWhitespaceIndex === -1) {\n        lineIsEmptyOrWhitespace = true;\n        firstNonWhitespaceIndex = len;\n        lastNonWhitespaceIndex = len;\n    }\n    else {\n        lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);\n    }\n    let wasInWhitespace = false;\n    let currentSelectionIndex = 0;\n    let currentSelection = selections && selections[currentSelectionIndex];\n    let tmpIndent = startVisibleColumn % tabSize;\n    for (let charIndex = fauxIndentLength; charIndex < len; charIndex++) {\n        const chCode = lineContent.charCodeAt(charIndex);\n        if (currentSelection && charIndex >= currentSelection.endOffset) {\n            currentSelectionIndex++;\n            currentSelection = selections && selections[currentSelectionIndex];\n        }\n        let isInWhitespace;\n        if (charIndex < firstNonWhitespaceIndex || charIndex > lastNonWhitespaceIndex) {\n            // in leading or trailing whitespace\n            isInWhitespace = true;\n        }\n        else if (chCode === 9 /* Tab */) {\n            // a tab character is rendered both in all and boundary cases\n            isInWhitespace = true;\n        }\n        else if (chCode === 32 /* Space */) {\n            // hit a space character\n            if (onlyBoundary) {\n                // rendering only boundary whitespace\n                if (wasInWhitespace) {\n                    isInWhitespace = true;\n                }\n                else {\n                    const nextChCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* Null */);\n                    isInWhitespace = (nextChCode === 32 /* Space */ || nextChCode === 9 /* Tab */);\n                }\n            }\n            else {\n                isInWhitespace = true;\n            }\n        }\n        else {\n            isInWhitespace = false;\n        }\n        // If rendering whitespace on selection, check that the charIndex falls within a selection\n        if (isInWhitespace && selections) {\n            isInWhitespace = !!currentSelection && currentSelection.startOffset <= charIndex && currentSelection.endOffset > charIndex;\n        }\n        // If rendering only trailing whitespace, check that the charIndex points to trailing whitespace.\n        if (isInWhitespace && onlyTrailing) {\n            isInWhitespace = lineIsEmptyOrWhitespace || charIndex > lastNonWhitespaceIndex;\n        }\n        if (wasInWhitespace) {\n            // was in whitespace token\n            if (!isInWhitespace || (!useMonospaceOptimizations && tmpIndent >= tabSize)) {\n                // leaving whitespace token or entering a new indent\n                if (generateLinePartForEachWhitespace) {\n                    const lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\n                    for (let i = lastEndIndex + 1; i <= charIndex; i++) {\n                        result[resultLen++] = new LinePart(i, 'mtkw', 1 /* IS_WHITESPACE */);\n                    }\n                }\n                else {\n                    result[resultLen++] = new LinePart(charIndex, 'mtkw', 1 /* IS_WHITESPACE */);\n                }\n                tmpIndent = tmpIndent % tabSize;\n            }\n        }\n        else {\n            // was in regular token\n            if (charIndex === tokenEndIndex || (isInWhitespace && charIndex > fauxIndentLength)) {\n                result[resultLen++] = new LinePart(charIndex, tokenType, 0);\n                tmpIndent = tmpIndent % tabSize;\n            }\n        }\n        if (chCode === 9 /* Tab */) {\n            tmpIndent = tabSize;\n        }\n        else if (strings.isFullWidthCharacter(chCode)) {\n            tmpIndent += 2;\n        }\n        else {\n            tmpIndent++;\n        }\n        wasInWhitespace = isInWhitespace;\n        while (charIndex === tokenEndIndex) {\n            tokenIndex++;\n            if (tokenIndex < tokensLength) {\n                tokenType = tokens[tokenIndex].type;\n                tokenEndIndex = tokens[tokenIndex].endIndex;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    let generateWhitespace = false;\n    if (wasInWhitespace) {\n        // was in whitespace token\n        if (continuesWithWrappedLine && onlyBoundary) {\n            const lastCharCode = (len > 0 ? lineContent.charCodeAt(len - 1) : 0 /* Null */);\n            const prevCharCode = (len > 1 ? lineContent.charCodeAt(len - 2) : 0 /* Null */);\n            const isSingleTrailingSpace = (lastCharCode === 32 /* Space */ && (prevCharCode !== 32 /* Space */ && prevCharCode !== 9 /* Tab */));\n            if (!isSingleTrailingSpace) {\n                generateWhitespace = true;\n            }\n        }\n        else {\n            generateWhitespace = true;\n        }\n    }\n    if (generateWhitespace) {\n        if (generateLinePartForEachWhitespace) {\n            const lastEndIndex = (resultLen > 0 ? result[resultLen - 1].endIndex : fauxIndentLength);\n            for (let i = lastEndIndex + 1; i <= len; i++) {\n                result[resultLen++] = new LinePart(i, 'mtkw', 1 /* IS_WHITESPACE */);\n            }\n        }\n        else {\n            result[resultLen++] = new LinePart(len, 'mtkw', 1 /* IS_WHITESPACE */);\n        }\n    }\n    else {\n        result[resultLen++] = new LinePart(len, tokenType, 0);\n    }\n    return result;\n}\n/**\n * Inline decorations are \"merged\" on top of tokens.\n * Special care must be taken when multiple inline decorations are at play and they overlap.\n */\nfunction _applyInlineDecorations(lineContent, len, tokens, _lineDecorations) {\n    _lineDecorations.sort(LineDecoration.compare);\n    const lineDecorations = LineDecorationsNormalizer.normalize(lineContent, _lineDecorations);\n    const lineDecorationsLen = lineDecorations.length;\n    let lineDecorationIndex = 0;\n    const result = [];\n    let resultLen = 0;\n    let lastResultEndIndex = 0;\n    for (let tokenIndex = 0, len = tokens.length; tokenIndex < len; tokenIndex++) {\n        const token = tokens[tokenIndex];\n        const tokenEndIndex = token.endIndex;\n        const tokenType = token.type;\n        const tokenMetadata = token.metadata;\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {\n            const lineDecoration = lineDecorations[lineDecorationIndex];\n            if (lineDecoration.startOffset > lastResultEndIndex) {\n                lastResultEndIndex = lineDecoration.startOffset;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata);\n            }\n            if (lineDecoration.endOffset + 1 <= tokenEndIndex) {\n                // This line decoration ends before this token ends\n                lastResultEndIndex = lineDecoration.endOffset + 1;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata);\n                lineDecorationIndex++;\n            }\n            else {\n                // This line decoration continues on to the next token\n                lastResultEndIndex = tokenEndIndex;\n                result[resultLen++] = new LinePart(lastResultEndIndex, tokenType + ' ' + lineDecoration.className, tokenMetadata | lineDecoration.metadata);\n                break;\n            }\n        }\n        if (tokenEndIndex > lastResultEndIndex) {\n            lastResultEndIndex = tokenEndIndex;\n            result[resultLen++] = new LinePart(lastResultEndIndex, tokenType, tokenMetadata);\n        }\n    }\n    const lastTokenEndIndex = tokens[tokens.length - 1].endIndex;\n    if (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n        while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset === lastTokenEndIndex) {\n            const lineDecoration = lineDecorations[lineDecorationIndex];\n            result[resultLen++] = new LinePart(lastResultEndIndex, lineDecoration.className, lineDecoration.metadata);\n            lineDecorationIndex++;\n        }\n    }\n    return result;\n}\n/**\n * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).\n * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).\n */\nfunction _renderLine(input, sb) {\n    const fontIsMonospace = input.fontIsMonospace;\n    const canUseHalfwidthRightwardsArrow = input.canUseHalfwidthRightwardsArrow;\n    const containsForeignElements = input.containsForeignElements;\n    const lineContent = input.lineContent;\n    const len = input.len;\n    const isOverflowing = input.isOverflowing;\n    const parts = input.parts;\n    const fauxIndentLength = input.fauxIndentLength;\n    const tabSize = input.tabSize;\n    const startVisibleColumn = input.startVisibleColumn;\n    const containsRTL = input.containsRTL;\n    const spaceWidth = input.spaceWidth;\n    const renderSpaceCharCode = input.renderSpaceCharCode;\n    const renderWhitespace = input.renderWhitespace;\n    const renderControlCharacters = input.renderControlCharacters;\n    const characterMapping = new CharacterMapping(len + 1, parts.length);\n    let lastCharacterMappingDefined = false;\n    let charIndex = 0;\n    let visibleColumn = startVisibleColumn;\n    let charOffsetInPart = 0;\n    let partDisplacement = 0;\n    let prevPartContentCnt = 0;\n    let partAbsoluteOffset = 0;\n    if (containsRTL) {\n        sb.appendASCIIString('<span dir=\"ltr\">');\n    }\n    else {\n        sb.appendASCIIString('<span>');\n    }\n    for (let partIndex = 0, tokensLen = parts.length; partIndex < tokensLen; partIndex++) {\n        partAbsoluteOffset += prevPartContentCnt;\n        const part = parts[partIndex];\n        const partEndIndex = part.endIndex;\n        const partType = part.type;\n        const partRendersWhitespace = (renderWhitespace !== 0 /* None */ && part.isWhitespace());\n        const partRendersWhitespaceWithWidth = partRendersWhitespace && !fontIsMonospace && (partType === 'mtkw' /*only whitespace*/ || !containsForeignElements);\n        const partIsEmptyAndHasPseudoAfter = (charIndex === partEndIndex && part.isPseudoAfter());\n        charOffsetInPart = 0;\n        sb.appendASCIIString('<span class=\"');\n        sb.appendASCIIString(partRendersWhitespaceWithWidth ? 'mtkz' : partType);\n        sb.appendASCII(34 /* DoubleQuote */);\n        if (partRendersWhitespace) {\n            let partContentCnt = 0;\n            {\n                let _charIndex = charIndex;\n                let _visibleColumn = visibleColumn;\n                for (; _charIndex < partEndIndex; _charIndex++) {\n                    const charCode = lineContent.charCodeAt(_charIndex);\n                    const charWidth = (charCode === 9 /* Tab */ ? (tabSize - (_visibleColumn % tabSize)) : 1) | 0;\n                    partContentCnt += charWidth;\n                    if (_charIndex >= fauxIndentLength) {\n                        _visibleColumn += charWidth;\n                    }\n                }\n            }\n            if (partRendersWhitespaceWithWidth) {\n                sb.appendASCIIString(' style=\"width:');\n                sb.appendASCIIString(String(spaceWidth * partContentCnt));\n                sb.appendASCIIString('px\"');\n            }\n            sb.appendASCII(62 /* GreaterThan */);\n            for (; charIndex < partEndIndex; charIndex++) {\n                characterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, partAbsoluteOffset);\n                partDisplacement = 0;\n                const charCode = lineContent.charCodeAt(charIndex);\n                let charWidth;\n                if (charCode === 9 /* Tab */) {\n                    charWidth = (tabSize - (visibleColumn % tabSize)) | 0;\n                    if (!canUseHalfwidthRightwardsArrow || charWidth > 1) {\n                        sb.write1(0x2192); // RIGHTWARDS ARROW\n                    }\n                    else {\n                        sb.write1(0xFFEB); // HALFWIDTH RIGHTWARDS ARROW\n                    }\n                    for (let space = 2; space <= charWidth; space++) {\n                        sb.write1(0xA0); // &nbsp;\n                    }\n                }\n                else { // must be CharCode.Space\n                    charWidth = 1;\n                    sb.write1(renderSpaceCharCode); // &middot; or word separator middle dot\n                }\n                charOffsetInPart += charWidth;\n                if (charIndex >= fauxIndentLength) {\n                    visibleColumn += charWidth;\n                }\n            }\n            prevPartContentCnt = partContentCnt;\n        }\n        else {\n            let partContentCnt = 0;\n            sb.appendASCII(62 /* GreaterThan */);\n            for (; charIndex < partEndIndex; charIndex++) {\n                characterMapping.setColumnInfo(charIndex + 1, partIndex - partDisplacement, charOffsetInPart, partAbsoluteOffset);\n                partDisplacement = 0;\n                const charCode = lineContent.charCodeAt(charIndex);\n                let producedCharacters = 1;\n                let charWidth = 1;\n                switch (charCode) {\n                    case 9 /* Tab */:\n                        producedCharacters = (tabSize - (visibleColumn % tabSize));\n                        charWidth = producedCharacters;\n                        for (let space = 1; space <= producedCharacters; space++) {\n                            sb.write1(0xA0); // &nbsp;\n                        }\n                        break;\n                    case 32 /* Space */:\n                        sb.write1(0xA0); // &nbsp;\n                        break;\n                    case 60 /* LessThan */:\n                        sb.appendASCIIString('&lt;');\n                        break;\n                    case 62 /* GreaterThan */:\n                        sb.appendASCIIString('&gt;');\n                        break;\n                    case 38 /* Ampersand */:\n                        sb.appendASCIIString('&amp;');\n                        break;\n                    case 0 /* Null */:\n                        if (renderControlCharacters) {\n                            // See https://unicode-table.com/en/blocks/control-pictures/\n                            sb.write1(9216);\n                        }\n                        else {\n                            sb.appendASCIIString('&#00;');\n                        }\n                        break;\n                    case 65279 /* UTF8_BOM */:\n                    case 8232 /* LINE_SEPARATOR */:\n                    case 8233 /* PARAGRAPH_SEPARATOR */:\n                    case 133 /* NEXT_LINE */:\n                        sb.write1(0xFFFD);\n                        break;\n                    default:\n                        if (strings.isFullWidthCharacter(charCode)) {\n                            charWidth++;\n                        }\n                        // See https://unicode-table.com/en/blocks/control-pictures/\n                        if (renderControlCharacters && charCode < 32) {\n                            sb.write1(9216 + charCode);\n                        }\n                        else if (renderControlCharacters && charCode === 127) {\n                            // DEL\n                            sb.write1(9249);\n                        }\n                        else if (renderControlCharacters && isControlCharacter(charCode)) {\n                            sb.appendASCIIString('[U+');\n                            sb.appendASCIIString(to4CharHex(charCode));\n                            sb.appendASCIIString(']');\n                            producedCharacters = 8;\n                        }\n                        else {\n                            sb.write1(charCode);\n                        }\n                }\n                charOffsetInPart += producedCharacters;\n                partContentCnt += producedCharacters;\n                if (charIndex >= fauxIndentLength) {\n                    visibleColumn += charWidth;\n                }\n            }\n            prevPartContentCnt = partContentCnt;\n        }\n        if (partIsEmptyAndHasPseudoAfter) {\n            partDisplacement++;\n        }\n        else {\n            partDisplacement = 0;\n        }\n        if (charIndex >= len && !lastCharacterMappingDefined && part.isPseudoAfter()) {\n            lastCharacterMappingDefined = true;\n            characterMapping.setColumnInfo(charIndex + 1, partIndex, charOffsetInPart, partAbsoluteOffset);\n        }\n        sb.appendASCIIString('</span>');\n    }\n    if (!lastCharacterMappingDefined) {\n        // When getting client rects for the last character, we will position the\n        // text range at the end of the span, insteaf of at the beginning of next span\n        characterMapping.setColumnInfo(len + 1, parts.length - 1, charOffsetInPart, partAbsoluteOffset);\n    }\n    if (isOverflowing) {\n        sb.appendASCIIString('<span>&hellip;</span>');\n    }\n    sb.appendASCIIString('</span>');\n    return new RenderLineOutput(characterMapping, containsRTL, containsForeignElements);\n}\nfunction to4CharHex(n) {\n    return n.toString(16).toUpperCase().padStart(4, '0');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../core/range.js';\n/**\n * Contains all data needed to render at a specific viewport.\n */\nexport class ViewportData {\n    constructor(selections, partialData, whitespaceViewportData, model) {\n        this.selections = selections;\n        this.startLineNumber = partialData.startLineNumber | 0;\n        this.endLineNumber = partialData.endLineNumber | 0;\n        this.relativeVerticalOffset = partialData.relativeVerticalOffset;\n        this.bigNumbersDelta = partialData.bigNumbersDelta | 0;\n        this.whitespaceViewportData = whitespaceViewportData;\n        this._model = model;\n        this.visibleRange = new Range(partialData.startLineNumber, this._model.getLineMinColumn(partialData.startLineNumber), partialData.endLineNumber, this._model.getLineMaxColumn(partialData.endLineNumber));\n    }\n    getViewLineRenderingData(lineNumber) {\n        return this._model.getViewLineRenderingData(this.visibleRange, lineNumber);\n    }\n    getDecorationsInViewport() {\n        return this._model.getDecorationsInViewport(this.visibleRange);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, markAsSingleton } from '../../../base/common/lifecycle.js';\nimport { RGBA8 } from '../core/rgba.js';\nimport { TokenizationRegistry } from '../languages.js';\nexport class MinimapTokensColorTracker extends Disposable {\n    constructor() {\n        super();\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n        this._updateColorMap();\n        this._register(TokenizationRegistry.onDidChange(e => {\n            if (e.changedColorMap) {\n                this._updateColorMap();\n            }\n        }));\n    }\n    static getInstance() {\n        if (!this._INSTANCE) {\n            this._INSTANCE = markAsSingleton(new MinimapTokensColorTracker());\n        }\n        return this._INSTANCE;\n    }\n    _updateColorMap() {\n        const colorMap = TokenizationRegistry.getColorMap();\n        if (!colorMap) {\n            this._colors = [RGBA8.Empty];\n            this._backgroundIsLight = true;\n            return;\n        }\n        this._colors = [RGBA8.Empty];\n        for (let colorId = 1; colorId < colorMap.length; colorId++) {\n            const source = colorMap[colorId].rgba;\n            // Use a VM friendly data-type\n            this._colors[colorId] = new RGBA8(source.r, source.g, source.b, Math.round(source.a * 255));\n        }\n        const backgroundLuminosity = colorMap[2 /* DefaultBackground */].getRelativeLuminance();\n        this._backgroundIsLight = backgroundLuminosity >= 0.5;\n        this._onDidChange.fire(undefined);\n    }\n    getColor(colorId) {\n        if (colorId < 1 || colorId >= this._colors.length) {\n            // background color (basically invisible)\n            colorId = 2 /* DefaultBackground */;\n        }\n        return this._colors[colorId];\n    }\n    backgroundIsLight() {\n        return this._backgroundIsLight;\n    }\n}\nMinimapTokensColorTracker._INSTANCE = null;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertNever } from '../../../base/common/types.js';\nimport { Position } from '../core/position.js';\nimport { InjectedTextCursorStops } from '../model.js';\n/**\n * *input*:\n * ```\n * xxxxxxxxxxxxxxxxxxxxxxxxxxx\n * ```\n *\n * -> Applying injections `[i...i]`, *inputWithInjections*:\n * ```\n * xxxxxx[iiiiiiiiii]xxxxxxxxxxxxxxxxx[ii]xxxx\n * ```\n *\n * -> breaking at offsets `|` in `xxxxxx[iiiiiii|iii]xxxxxxxxxxx|xxxxxx[ii]xxxx|`:\n * ```\n * xxxxxx[iiiiiii\n * iii]xxxxxxxxxxx\n * xxxxxx[ii]xxxx\n * ```\n *\n * -> applying wrappedTextIndentLength, *output*:\n * ```\n * xxxxxx[iiiiiii\n *    iii]xxxxxxxxxxx\n *    xxxxxx[ii]xxxx\n * ```\n */\nexport class ModelLineProjectionData {\n    constructor(injectionOffsets, \n    /**\n     * `injectionOptions.length` must equal `injectionOffsets.length`\n     */\n    injectionOptions, \n    /**\n     * Refers to offsets after applying injections to the source.\n     * The last break offset indicates the length of the source after applying injections.\n     */\n    breakOffsets, \n    /**\n     * Refers to offsets after applying injections\n     */\n    breakOffsetsVisibleColumn, wrappedTextIndentLength) {\n        this.injectionOffsets = injectionOffsets;\n        this.injectionOptions = injectionOptions;\n        this.breakOffsets = breakOffsets;\n        this.breakOffsetsVisibleColumn = breakOffsetsVisibleColumn;\n        this.wrappedTextIndentLength = wrappedTextIndentLength;\n    }\n    getOutputLineCount() {\n        return this.breakOffsets.length;\n    }\n    getMinOutputOffset(outputLineIndex) {\n        if (outputLineIndex > 0) {\n            return this.wrappedTextIndentLength;\n        }\n        return 0;\n    }\n    getLineLength(outputLineIndex) {\n        // These offsets refer to model text with injected text.\n        const startOffset = outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0;\n        const endOffset = this.breakOffsets[outputLineIndex];\n        let lineLength = endOffset - startOffset;\n        if (outputLineIndex > 0) {\n            lineLength += this.wrappedTextIndentLength;\n        }\n        return lineLength;\n    }\n    getMaxOutputOffset(outputLineIndex) {\n        return this.getLineLength(outputLineIndex);\n    }\n    translateToInputOffset(outputLineIndex, outputOffset) {\n        if (outputLineIndex > 0) {\n            outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n        }\n        const offsetInInputWithInjection = outputLineIndex === 0 ? outputOffset : this.breakOffsets[outputLineIndex - 1] + outputOffset;\n        let offsetInInput = offsetInInputWithInjection;\n        if (this.injectionOffsets !== null) {\n            for (let i = 0; i < this.injectionOffsets.length; i++) {\n                if (offsetInInput > this.injectionOffsets[i]) {\n                    if (offsetInInput < this.injectionOffsets[i] + this.injectionOptions[i].content.length) {\n                        // `inputOffset` is within injected text\n                        offsetInInput = this.injectionOffsets[i];\n                    }\n                    else {\n                        offsetInInput -= this.injectionOptions[i].content.length;\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        return offsetInInput;\n    }\n    translateToOutputPosition(inputOffset, affinity = 2 /* None */) {\n        let inputOffsetInInputWithInjection = inputOffset;\n        if (this.injectionOffsets !== null) {\n            for (let i = 0; i < this.injectionOffsets.length; i++) {\n                if (inputOffset < this.injectionOffsets[i]) {\n                    break;\n                }\n                if (affinity !== 1 /* Right */ && inputOffset === this.injectionOffsets[i]) {\n                    break;\n                }\n                inputOffsetInInputWithInjection += this.injectionOptions[i].content.length;\n            }\n        }\n        return this.offsetInInputWithInjectionsToOutputPosition(inputOffsetInInputWithInjection, affinity);\n    }\n    offsetInInputWithInjectionsToOutputPosition(offsetInInputWithInjections, affinity = 2 /* None */) {\n        let low = 0;\n        let high = this.breakOffsets.length - 1;\n        let mid = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            const midStop = this.breakOffsets[mid];\n            midStart = mid > 0 ? this.breakOffsets[mid - 1] : 0;\n            if (affinity === 0 /* Left */) {\n                if (offsetInInputWithInjections <= midStart) {\n                    high = mid - 1;\n                }\n                else if (offsetInInputWithInjections > midStop) {\n                    low = mid + 1;\n                }\n                else {\n                    break;\n                }\n            }\n            else {\n                if (offsetInInputWithInjections < midStart) {\n                    high = mid - 1;\n                }\n                else if (offsetInInputWithInjections >= midStop) {\n                    low = mid + 1;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        let outputOffset = offsetInInputWithInjections - midStart;\n        if (mid > 0) {\n            outputOffset += this.wrappedTextIndentLength;\n        }\n        return new OutputPosition(mid, outputOffset);\n    }\n    normalizeOutputPosition(outputLineIndex, outputOffset, affinity) {\n        if (this.injectionOffsets !== null) {\n            const offsetInInputWithInjections = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n            const normalizedOffsetInUnwrappedLine = this.normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity);\n            if (normalizedOffsetInUnwrappedLine !== offsetInInputWithInjections) {\n                // injected text caused a change\n                return this.offsetInInputWithInjectionsToOutputPosition(normalizedOffsetInUnwrappedLine, affinity);\n            }\n        }\n        if (affinity === 0 /* Left */) {\n            if (outputLineIndex > 0 && outputOffset === this.getMinOutputOffset(outputLineIndex)) {\n                return new OutputPosition(outputLineIndex - 1, this.getMaxOutputOffset(outputLineIndex - 1));\n            }\n        }\n        else if (affinity === 1 /* Right */) {\n            const maxOutputLineIndex = this.getOutputLineCount() - 1;\n            if (outputLineIndex < maxOutputLineIndex && outputOffset === this.getMaxOutputOffset(outputLineIndex)) {\n                return new OutputPosition(outputLineIndex + 1, this.getMinOutputOffset(outputLineIndex + 1));\n            }\n        }\n        return new OutputPosition(outputLineIndex, outputOffset);\n    }\n    outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset) {\n        if (outputLineIndex > 0) {\n            outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n        }\n        const result = (outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0) + outputOffset;\n        return result;\n    }\n    normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity) {\n        const injectedText = this.getInjectedTextAtOffset(offsetInInputWithInjections);\n        if (!injectedText) {\n            return offsetInInputWithInjections;\n        }\n        if (affinity === 2 /* None */) {\n            if (offsetInInputWithInjections === injectedText.offsetInInputWithInjections + injectedText.length\n                && hasRightCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {\n                return injectedText.offsetInInputWithInjections + injectedText.length;\n            }\n            else {\n                let result = injectedText.offsetInInputWithInjections;\n                if (hasLeftCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {\n                    return result;\n                }\n                let index = injectedText.injectedTextIndex - 1;\n                while (index >= 0 && this.injectionOffsets[index] === this.injectionOffsets[injectedText.injectedTextIndex]) {\n                    if (hasRightCursorStop(this.injectionOptions[index].cursorStops)) {\n                        break;\n                    }\n                    result -= this.injectionOptions[index].content.length;\n                    if (hasLeftCursorStop(this.injectionOptions[index].cursorStops)) {\n                        break;\n                    }\n                    index--;\n                }\n                return result;\n            }\n        }\n        else if (affinity === 1 /* Right */) {\n            let result = injectedText.offsetInInputWithInjections + injectedText.length;\n            let index = injectedText.injectedTextIndex;\n            // traverse all injected text that touch each other\n            while (index + 1 < this.injectionOffsets.length && this.injectionOffsets[index + 1] === this.injectionOffsets[index]) {\n                result += this.injectionOptions[index + 1].content.length;\n                index++;\n            }\n            return result;\n        }\n        else if (affinity === 0 /* Left */) {\n            // affinity is left\n            let result = injectedText.offsetInInputWithInjections;\n            let index = injectedText.injectedTextIndex;\n            // traverse all injected text that touch each other\n            while (index - 1 >= 0 && this.injectionOffsets[index - 1] === this.injectionOffsets[index]) {\n                result -= this.injectionOptions[index - 1].content.length;\n                index--;\n            }\n            return result;\n        }\n        assertNever(affinity);\n    }\n    getInjectedText(outputLineIndex, outputOffset) {\n        const offset = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n        const injectedText = this.getInjectedTextAtOffset(offset);\n        if (!injectedText) {\n            return null;\n        }\n        return {\n            options: this.injectionOptions[injectedText.injectedTextIndex]\n        };\n    }\n    getInjectedTextAtOffset(offsetInInputWithInjections) {\n        const injectionOffsets = this.injectionOffsets;\n        const injectionOptions = this.injectionOptions;\n        if (injectionOffsets !== null) {\n            let totalInjectedTextLengthBefore = 0;\n            for (let i = 0; i < injectionOffsets.length; i++) {\n                const length = injectionOptions[i].content.length;\n                const injectedTextStartOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore;\n                const injectedTextEndOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore + length;\n                if (injectedTextStartOffsetInInputWithInjections > offsetInInputWithInjections) {\n                    // Injected text starts later.\n                    break; // All later injected texts have an even larger offset.\n                }\n                if (offsetInInputWithInjections <= injectedTextEndOffsetInInputWithInjections) {\n                    // Injected text ends after or with the given position (but also starts with or before it).\n                    return {\n                        injectedTextIndex: i,\n                        offsetInInputWithInjections: injectedTextStartOffsetInInputWithInjections,\n                        length\n                    };\n                }\n                totalInjectedTextLengthBefore += length;\n            }\n        }\n        return undefined;\n    }\n}\nfunction hasRightCursorStop(cursorStop) {\n    if (cursorStop === null || cursorStop === undefined) {\n        return true;\n    }\n    return cursorStop === InjectedTextCursorStops.Right || cursorStop === InjectedTextCursorStops.Both;\n}\nfunction hasLeftCursorStop(cursorStop) {\n    if (cursorStop === null || cursorStop === undefined) {\n        return true;\n    }\n    return cursorStop === InjectedTextCursorStops.Left || cursorStop === InjectedTextCursorStops.Both;\n}\nexport class InjectedText {\n    constructor(options) {\n        this.options = options;\n    }\n}\nexport class OutputPosition {\n    constructor(outputLineIndex, outputOffset) {\n        this.outputLineIndex = outputLineIndex;\n        this.outputOffset = outputOffset;\n    }\n    toString() {\n        return `${this.outputLineIndex}:${this.outputOffset}`;\n    }\n    toPosition(baseLineNumber) {\n        return new Position(baseLineNumber + this.outputLineIndex, this.outputOffset + 1);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CharacterClassifier } from '../core/characterClassifier.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport { ModelLineProjectionData } from './modelLineProjectionData.js';\nexport class MonospaceLineBreaksComputerFactory {\n    constructor(breakBeforeChars, breakAfterChars) {\n        this.classifier = new WrappingCharacterClassifier(breakBeforeChars, breakAfterChars);\n    }\n    static create(options) {\n        return new MonospaceLineBreaksComputerFactory(options.get(120 /* wordWrapBreakBeforeCharacters */), options.get(119 /* wordWrapBreakAfterCharacters */));\n    }\n    createLineBreaksComputer(fontInfo, tabSize, wrappingColumn, wrappingIndent) {\n        const requests = [];\n        const injectedTexts = [];\n        const previousBreakingData = [];\n        return {\n            addRequest: (lineText, injectedText, previousLineBreakData) => {\n                requests.push(lineText);\n                injectedTexts.push(injectedText);\n                previousBreakingData.push(previousLineBreakData);\n            },\n            finalize: () => {\n                const columnsForFullWidthChar = fontInfo.typicalFullwidthCharacterWidth / fontInfo.typicalHalfwidthCharacterWidth;\n                const result = [];\n                for (let i = 0, len = requests.length; i < len; i++) {\n                    const injectedText = injectedTexts[i];\n                    const previousLineBreakData = previousBreakingData[i];\n                    if (previousLineBreakData && !previousLineBreakData.injectionOptions && !injectedText) {\n                        result[i] = createLineBreaksFromPreviousLineBreaks(this.classifier, previousLineBreakData, requests[i], tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent);\n                    }\n                    else {\n                        result[i] = createLineBreaks(this.classifier, requests[i], injectedText, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent);\n                    }\n                }\n                arrPool1.length = 0;\n                arrPool2.length = 0;\n                return result;\n            }\n        };\n    }\n}\nclass WrappingCharacterClassifier extends CharacterClassifier {\n    constructor(BREAK_BEFORE, BREAK_AFTER) {\n        super(0 /* NONE */);\n        for (let i = 0; i < BREAK_BEFORE.length; i++) {\n            this.set(BREAK_BEFORE.charCodeAt(i), 1 /* BREAK_BEFORE */);\n        }\n        for (let i = 0; i < BREAK_AFTER.length; i++) {\n            this.set(BREAK_AFTER.charCodeAt(i), 2 /* BREAK_AFTER */);\n        }\n    }\n    get(charCode) {\n        if (charCode >= 0 && charCode < 256) {\n            return this._asciiMap[charCode];\n        }\n        else {\n            // Initialize CharacterClass.BREAK_IDEOGRAPHIC for these Unicode ranges:\n            // 1. CJK Unified Ideographs (0x4E00 -- 0x9FFF)\n            // 2. CJK Unified Ideographs Extension A (0x3400 -- 0x4DBF)\n            // 3. Hiragana and Katakana (0x3040 -- 0x30FF)\n            if ((charCode >= 0x3040 && charCode <= 0x30FF)\n                || (charCode >= 0x3400 && charCode <= 0x4DBF)\n                || (charCode >= 0x4E00 && charCode <= 0x9FFF)) {\n                return 3 /* BREAK_IDEOGRAPHIC */;\n            }\n            return (this._map.get(charCode) || this._defaultValue);\n        }\n    }\n}\nlet arrPool1 = [];\nlet arrPool2 = [];\nfunction createLineBreaksFromPreviousLineBreaks(classifier, previousBreakingData, lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n    if (firstLineBreakColumn === -1) {\n        return null;\n    }\n    const len = lineText.length;\n    if (len <= 1) {\n        return null;\n    }\n    const prevBreakingOffsets = previousBreakingData.breakOffsets;\n    const prevBreakingOffsetsVisibleColumn = previousBreakingData.breakOffsetsVisibleColumn;\n    const wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n    const wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n    const breakingOffsets = arrPool1;\n    const breakingOffsetsVisibleColumn = arrPool2;\n    let breakingOffsetsCount = 0;\n    let lastBreakingOffset = 0;\n    let lastBreakingOffsetVisibleColumn = 0;\n    let breakingColumn = firstLineBreakColumn;\n    const prevLen = prevBreakingOffsets.length;\n    let prevIndex = 0;\n    if (prevIndex >= 0) {\n        let bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n        while (prevIndex + 1 < prevLen) {\n            const distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n            if (distance >= bestDistance) {\n                break;\n            }\n            bestDistance = distance;\n            prevIndex++;\n        }\n    }\n    while (prevIndex < prevLen) {\n        // Allow for prevIndex to be -1 (for the case where we hit a tab when walking backwards from the first break)\n        let prevBreakOffset = prevIndex < 0 ? 0 : prevBreakingOffsets[prevIndex];\n        let prevBreakOffsetVisibleColumn = prevIndex < 0 ? 0 : prevBreakingOffsetsVisibleColumn[prevIndex];\n        if (lastBreakingOffset > prevBreakOffset) {\n            prevBreakOffset = lastBreakingOffset;\n            prevBreakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn;\n        }\n        let breakOffset = 0;\n        let breakOffsetVisibleColumn = 0;\n        let forcedBreakOffset = 0;\n        let forcedBreakOffsetVisibleColumn = 0;\n        // initially, we search as much as possible to the right (if it fits)\n        if (prevBreakOffsetVisibleColumn <= breakingColumn) {\n            let visibleColumn = prevBreakOffsetVisibleColumn;\n            let prevCharCode = prevBreakOffset === 0 ? 0 /* Null */ : lineText.charCodeAt(prevBreakOffset - 1);\n            let prevCharCodeClass = prevBreakOffset === 0 ? 0 /* NONE */ : classifier.get(prevCharCode);\n            let entireLineFits = true;\n            for (let i = prevBreakOffset; i < len; i++) {\n                const charStartOffset = i;\n                const charCode = lineText.charCodeAt(i);\n                let charCodeClass;\n                let charWidth;\n                if (strings.isHighSurrogate(charCode)) {\n                    // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                    i++;\n                    charCodeClass = 0 /* NONE */;\n                    charWidth = 2;\n                }\n                else {\n                    charCodeClass = classifier.get(charCode);\n                    charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n                }\n                if (charStartOffset > lastBreakingOffset && canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\n                    breakOffset = charStartOffset;\n                    breakOffsetVisibleColumn = visibleColumn;\n                }\n                visibleColumn += charWidth;\n                // check if adding character at `i` will go over the breaking column\n                if (visibleColumn > breakingColumn) {\n                    // We need to break at least before character at `i`:\n                    if (charStartOffset > lastBreakingOffset) {\n                        forcedBreakOffset = charStartOffset;\n                        forcedBreakOffsetVisibleColumn = visibleColumn - charWidth;\n                    }\n                    else {\n                        // we need to advance at least by one character\n                        forcedBreakOffset = i + 1;\n                        forcedBreakOffsetVisibleColumn = visibleColumn;\n                    }\n                    if (visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n                        // Cannot break at `breakOffset` => reset it if it was set\n                        breakOffset = 0;\n                    }\n                    entireLineFits = false;\n                    break;\n                }\n                prevCharCode = charCode;\n                prevCharCodeClass = charCodeClass;\n            }\n            if (entireLineFits) {\n                // there is no more need to break => stop the outer loop!\n                if (breakingOffsetsCount > 0) {\n                    // Add last segment, no need to assign to `lastBreakingOffset` and `lastBreakingOffsetVisibleColumn`\n                    breakingOffsets[breakingOffsetsCount] = prevBreakingOffsets[prevBreakingOffsets.length - 1];\n                    breakingOffsetsVisibleColumn[breakingOffsetsCount] = prevBreakingOffsetsVisibleColumn[prevBreakingOffsets.length - 1];\n                    breakingOffsetsCount++;\n                }\n                break;\n            }\n        }\n        if (breakOffset === 0) {\n            // must search left\n            let visibleColumn = prevBreakOffsetVisibleColumn;\n            let charCode = lineText.charCodeAt(prevBreakOffset);\n            let charCodeClass = classifier.get(charCode);\n            let hitATabCharacter = false;\n            for (let i = prevBreakOffset - 1; i >= lastBreakingOffset; i--) {\n                const charStartOffset = i + 1;\n                const prevCharCode = lineText.charCodeAt(i);\n                if (prevCharCode === 9 /* Tab */) {\n                    // cannot determine the width of a tab when going backwards, so we must go forwards\n                    hitATabCharacter = true;\n                    break;\n                }\n                let prevCharCodeClass;\n                let prevCharWidth;\n                if (strings.isLowSurrogate(prevCharCode)) {\n                    // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                    i--;\n                    prevCharCodeClass = 0 /* NONE */;\n                    prevCharWidth = 2;\n                }\n                else {\n                    prevCharCodeClass = classifier.get(prevCharCode);\n                    prevCharWidth = (strings.isFullWidthCharacter(prevCharCode) ? columnsForFullWidthChar : 1);\n                }\n                if (visibleColumn <= breakingColumn) {\n                    if (forcedBreakOffset === 0) {\n                        forcedBreakOffset = charStartOffset;\n                        forcedBreakOffsetVisibleColumn = visibleColumn;\n                    }\n                    if (visibleColumn <= breakingColumn - wrappedLineBreakColumn) {\n                        // went too far!\n                        break;\n                    }\n                    if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\n                        breakOffset = charStartOffset;\n                        breakOffsetVisibleColumn = visibleColumn;\n                        break;\n                    }\n                }\n                visibleColumn -= prevCharWidth;\n                charCode = prevCharCode;\n                charCodeClass = prevCharCodeClass;\n            }\n            if (breakOffset !== 0) {\n                const remainingWidthOfNextLine = wrappedLineBreakColumn - (forcedBreakOffsetVisibleColumn - breakOffsetVisibleColumn);\n                if (remainingWidthOfNextLine <= tabSize) {\n                    const charCodeAtForcedBreakOffset = lineText.charCodeAt(forcedBreakOffset);\n                    let charWidth;\n                    if (strings.isHighSurrogate(charCodeAtForcedBreakOffset)) {\n                        // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                        charWidth = 2;\n                    }\n                    else {\n                        charWidth = computeCharWidth(charCodeAtForcedBreakOffset, forcedBreakOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n                    }\n                    if (remainingWidthOfNextLine - charWidth < 0) {\n                        // it is not worth it to break at breakOffset, it just introduces an extra needless line!\n                        breakOffset = 0;\n                    }\n                }\n            }\n            if (hitATabCharacter) {\n                // cannot determine the width of a tab when going backwards, so we must go forwards from the previous break\n                prevIndex--;\n                continue;\n            }\n        }\n        if (breakOffset === 0) {\n            // Could not find a good breaking point\n            breakOffset = forcedBreakOffset;\n            breakOffsetVisibleColumn = forcedBreakOffsetVisibleColumn;\n        }\n        if (breakOffset <= lastBreakingOffset) {\n            // Make sure that we are advancing (at least one character)\n            const charCode = lineText.charCodeAt(lastBreakingOffset);\n            if (strings.isHighSurrogate(charCode)) {\n                // A surrogate pair must always be considered as a single unit, so it is never to be broken\n                breakOffset = lastBreakingOffset + 2;\n                breakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn + 2;\n            }\n            else {\n                breakOffset = lastBreakingOffset + 1;\n                breakOffsetVisibleColumn = lastBreakingOffsetVisibleColumn + computeCharWidth(charCode, lastBreakingOffsetVisibleColumn, tabSize, columnsForFullWidthChar);\n            }\n        }\n        lastBreakingOffset = breakOffset;\n        breakingOffsets[breakingOffsetsCount] = breakOffset;\n        lastBreakingOffsetVisibleColumn = breakOffsetVisibleColumn;\n        breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n        breakingOffsetsCount++;\n        breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n        while (prevIndex < 0 || (prevIndex < prevLen && prevBreakingOffsetsVisibleColumn[prevIndex] < breakOffsetVisibleColumn)) {\n            prevIndex++;\n        }\n        let bestDistance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex] - breakingColumn);\n        while (prevIndex + 1 < prevLen) {\n            const distance = Math.abs(prevBreakingOffsetsVisibleColumn[prevIndex + 1] - breakingColumn);\n            if (distance >= bestDistance) {\n                break;\n            }\n            bestDistance = distance;\n            prevIndex++;\n        }\n    }\n    if (breakingOffsetsCount === 0) {\n        return null;\n    }\n    // Doing here some object reuse which ends up helping a huge deal with GC pauses!\n    breakingOffsets.length = breakingOffsetsCount;\n    breakingOffsetsVisibleColumn.length = breakingOffsetsCount;\n    arrPool1 = previousBreakingData.breakOffsets;\n    arrPool2 = previousBreakingData.breakOffsetsVisibleColumn;\n    previousBreakingData.breakOffsets = breakingOffsets;\n    previousBreakingData.breakOffsetsVisibleColumn = breakingOffsetsVisibleColumn;\n    previousBreakingData.wrappedTextIndentLength = wrappedTextIndentLength;\n    return previousBreakingData;\n}\nfunction createLineBreaks(classifier, _lineText, injectedTexts, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n    const lineText = LineInjectedText.applyInjectedText(_lineText, injectedTexts);\n    let injectionOptions;\n    let injectionOffsets;\n    if (injectedTexts && injectedTexts.length > 0) {\n        injectionOptions = injectedTexts.map(t => t.options);\n        injectionOffsets = injectedTexts.map(text => text.column - 1);\n    }\n    else {\n        injectionOptions = null;\n        injectionOffsets = null;\n    }\n    if (firstLineBreakColumn === -1) {\n        if (!injectionOptions) {\n            return null;\n        }\n        // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n        // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n        return new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n    }\n    const len = lineText.length;\n    if (len <= 1) {\n        if (!injectionOptions) {\n            return null;\n        }\n        // creating a `LineBreakData` with an invalid `breakOffsetsVisibleColumn` is OK\n        // because `breakOffsetsVisibleColumn` will never be used because it contains injected text\n        return new ModelLineProjectionData(injectionOffsets, injectionOptions, [lineText.length], [], 0);\n    }\n    const wrappedTextIndentLength = computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent);\n    const wrappedLineBreakColumn = firstLineBreakColumn - wrappedTextIndentLength;\n    const breakingOffsets = [];\n    const breakingOffsetsVisibleColumn = [];\n    let breakingOffsetsCount = 0;\n    let breakOffset = 0;\n    let breakOffsetVisibleColumn = 0;\n    let breakingColumn = firstLineBreakColumn;\n    let prevCharCode = lineText.charCodeAt(0);\n    let prevCharCodeClass = classifier.get(prevCharCode);\n    let visibleColumn = computeCharWidth(prevCharCode, 0, tabSize, columnsForFullWidthChar);\n    let startOffset = 1;\n    if (strings.isHighSurrogate(prevCharCode)) {\n        // A surrogate pair must always be considered as a single unit, so it is never to be broken\n        visibleColumn += 1;\n        prevCharCode = lineText.charCodeAt(1);\n        prevCharCodeClass = classifier.get(prevCharCode);\n        startOffset++;\n    }\n    for (let i = startOffset; i < len; i++) {\n        const charStartOffset = i;\n        const charCode = lineText.charCodeAt(i);\n        let charCodeClass;\n        let charWidth;\n        if (strings.isHighSurrogate(charCode)) {\n            // A surrogate pair must always be considered as a single unit, so it is never to be broken\n            i++;\n            charCodeClass = 0 /* NONE */;\n            charWidth = 2;\n        }\n        else {\n            charCodeClass = classifier.get(charCode);\n            charWidth = computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar);\n        }\n        if (canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass)) {\n            breakOffset = charStartOffset;\n            breakOffsetVisibleColumn = visibleColumn;\n        }\n        visibleColumn += charWidth;\n        // check if adding character at `i` will go over the breaking column\n        if (visibleColumn > breakingColumn) {\n            // We need to break at least before character at `i`:\n            if (breakOffset === 0 || visibleColumn - breakOffsetVisibleColumn > wrappedLineBreakColumn) {\n                // Cannot break at `breakOffset`, must break at `i`\n                breakOffset = charStartOffset;\n                breakOffsetVisibleColumn = visibleColumn - charWidth;\n            }\n            breakingOffsets[breakingOffsetsCount] = breakOffset;\n            breakingOffsetsVisibleColumn[breakingOffsetsCount] = breakOffsetVisibleColumn;\n            breakingOffsetsCount++;\n            breakingColumn = breakOffsetVisibleColumn + wrappedLineBreakColumn;\n            breakOffset = 0;\n        }\n        prevCharCode = charCode;\n        prevCharCodeClass = charCodeClass;\n    }\n    if (breakingOffsetsCount === 0 && (!injectedTexts || injectedTexts.length === 0)) {\n        return null;\n    }\n    // Add last segment\n    breakingOffsets[breakingOffsetsCount] = len;\n    breakingOffsetsVisibleColumn[breakingOffsetsCount] = visibleColumn;\n    return new ModelLineProjectionData(injectionOffsets, injectionOptions, breakingOffsets, breakingOffsetsVisibleColumn, wrappedTextIndentLength);\n}\nfunction computeCharWidth(charCode, visibleColumn, tabSize, columnsForFullWidthChar) {\n    if (charCode === 9 /* Tab */) {\n        return (tabSize - (visibleColumn % tabSize));\n    }\n    if (strings.isFullWidthCharacter(charCode)) {\n        return columnsForFullWidthChar;\n    }\n    if (charCode < 32) {\n        // when using `editor.renderControlCharacters`, the substitutions are often wide\n        return columnsForFullWidthChar;\n    }\n    return 1;\n}\nfunction tabCharacterWidth(visibleColumn, tabSize) {\n    return (tabSize - (visibleColumn % tabSize));\n}\n/**\n * Kinsoku Shori : Don't break after a leading character, like an open bracket\n * Kinsoku Shori : Don't break before a trailing character, like a period\n */\nfunction canBreak(prevCharCode, prevCharCodeClass, charCode, charCodeClass) {\n    return (charCode !== 32 /* Space */\n        && ((prevCharCodeClass === 2 /* BREAK_AFTER */)\n            || (prevCharCodeClass === 3 /* BREAK_IDEOGRAPHIC */ && charCodeClass !== 2 /* BREAK_AFTER */)\n            || (charCodeClass === 1 /* BREAK_BEFORE */)\n            || (charCodeClass === 3 /* BREAK_IDEOGRAPHIC */ && prevCharCodeClass !== 1 /* BREAK_BEFORE */)));\n}\nfunction computeWrappedTextIndentLength(lineText, tabSize, firstLineBreakColumn, columnsForFullWidthChar, wrappingIndent) {\n    let wrappedTextIndentLength = 0;\n    if (wrappingIndent !== 0 /* None */) {\n        const firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineText);\n        if (firstNonWhitespaceIndex !== -1) {\n            // Track existing indent\n            for (let i = 0; i < firstNonWhitespaceIndex; i++) {\n                const charWidth = (lineText.charCodeAt(i) === 9 /* Tab */ ? tabCharacterWidth(wrappedTextIndentLength, tabSize) : 1);\n                wrappedTextIndentLength += charWidth;\n            }\n            // Increase indent of continuation lines, if desired\n            const numberOfAdditionalTabs = (wrappingIndent === 3 /* DeepIndent */ ? 2 : wrappingIndent === 2 /* Indent */ ? 1 : 0);\n            for (let i = 0; i < numberOfAdditionalTabs; i++) {\n                const charWidth = tabCharacterWidth(wrappedTextIndentLength, tabSize);\n                wrappedTextIndentLength += charWidth;\n            }\n            // Force sticking to beginning of line if no character would fit except for the indentation\n            if (wrappedTextIndentLength + columnsForFullWidthChar > firstLineBreakColumn) {\n                wrappedTextIndentLength = 0;\n            }\n        }\n    }\n    return wrappedTextIndentLength;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class ColorZone {\n    constructor(from, to, colorId) {\n        this._colorZoneBrand = undefined;\n        this.from = from | 0;\n        this.to = to | 0;\n        this.colorId = colorId | 0;\n    }\n    static compare(a, b) {\n        if (a.colorId === b.colorId) {\n            if (a.from === b.from) {\n                return a.to - b.to;\n            }\n            return a.from - b.from;\n        }\n        return a.colorId - b.colorId;\n    }\n}\n/**\n * A zone in the overview ruler\n */\nexport class OverviewRulerZone {\n    constructor(startLineNumber, endLineNumber, color) {\n        this._overviewRulerZoneBrand = undefined;\n        this.startLineNumber = startLineNumber;\n        this.endLineNumber = endLineNumber;\n        this.color = color;\n        this._colorZone = null;\n    }\n    static compare(a, b) {\n        if (a.color === b.color) {\n            if (a.startLineNumber === b.startLineNumber) {\n                return a.endLineNumber - b.endLineNumber;\n            }\n            return a.startLineNumber - b.startLineNumber;\n        }\n        return a.color < b.color ? -1 : 1;\n    }\n    setColorZone(colorZone) {\n        this._colorZone = colorZone;\n    }\n    getColorZones() {\n        return this._colorZone;\n    }\n}\nexport class OverviewZoneManager {\n    constructor(getVerticalOffsetForLine) {\n        this._getVerticalOffsetForLine = getVerticalOffsetForLine;\n        this._zones = [];\n        this._colorZonesInvalid = false;\n        this._lineHeight = 0;\n        this._domWidth = 0;\n        this._domHeight = 0;\n        this._outerHeight = 0;\n        this._pixelRatio = 1;\n        this._lastAssignedId = 0;\n        this._color2Id = Object.create(null);\n        this._id2Color = [];\n    }\n    getId2Color() {\n        return this._id2Color;\n    }\n    setZones(newZones) {\n        this._zones = newZones;\n        this._zones.sort(OverviewRulerZone.compare);\n    }\n    setLineHeight(lineHeight) {\n        if (this._lineHeight === lineHeight) {\n            return false;\n        }\n        this._lineHeight = lineHeight;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    setPixelRatio(pixelRatio) {\n        this._pixelRatio = pixelRatio;\n        this._colorZonesInvalid = true;\n    }\n    getDOMWidth() {\n        return this._domWidth;\n    }\n    getCanvasWidth() {\n        return this._domWidth * this._pixelRatio;\n    }\n    setDOMWidth(width) {\n        if (this._domWidth === width) {\n            return false;\n        }\n        this._domWidth = width;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    getDOMHeight() {\n        return this._domHeight;\n    }\n    getCanvasHeight() {\n        return this._domHeight * this._pixelRatio;\n    }\n    setDOMHeight(height) {\n        if (this._domHeight === height) {\n            return false;\n        }\n        this._domHeight = height;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    getOuterHeight() {\n        return this._outerHeight;\n    }\n    setOuterHeight(outerHeight) {\n        if (this._outerHeight === outerHeight) {\n            return false;\n        }\n        this._outerHeight = outerHeight;\n        this._colorZonesInvalid = true;\n        return true;\n    }\n    resolveColorZones() {\n        const colorZonesInvalid = this._colorZonesInvalid;\n        const lineHeight = Math.floor(this._lineHeight);\n        const totalHeight = Math.floor(this.getCanvasHeight());\n        const outerHeight = Math.floor(this._outerHeight);\n        const heightRatio = totalHeight / outerHeight;\n        const halfMinimumHeight = Math.floor(4 /* MINIMUM_HEIGHT */ * this._pixelRatio / 2);\n        const allColorZones = [];\n        for (let i = 0, len = this._zones.length; i < len; i++) {\n            const zone = this._zones[i];\n            if (!colorZonesInvalid) {\n                const colorZone = zone.getColorZones();\n                if (colorZone) {\n                    allColorZones.push(colorZone);\n                    continue;\n                }\n            }\n            const y1 = Math.floor(heightRatio * (this._getVerticalOffsetForLine(zone.startLineNumber)));\n            const y2 = Math.floor(heightRatio * (this._getVerticalOffsetForLine(zone.endLineNumber) + lineHeight));\n            let ycenter = Math.floor((y1 + y2) / 2);\n            let halfHeight = (y2 - ycenter);\n            if (halfHeight < halfMinimumHeight) {\n                halfHeight = halfMinimumHeight;\n            }\n            if (ycenter - halfHeight < 0) {\n                ycenter = halfHeight;\n            }\n            if (ycenter + halfHeight > totalHeight) {\n                ycenter = totalHeight - halfHeight;\n            }\n            const color = zone.color;\n            let colorId = this._color2Id[color];\n            if (!colorId) {\n                colorId = (++this._lastAssignedId);\n                this._color2Id[color] = colorId;\n                this._id2Color[colorId] = color;\n            }\n            const colorZone = new ColorZone(ycenter - halfHeight, ycenter + halfHeight, colorId);\n            zone.setColorZone(colorZone);\n            allColorZones.push(colorZone);\n        }\n        this._colorZonesInvalid = false;\n        allColorZones.sort(ColorZone.compare);\n        return allColorZones;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class EditorTheme {\n    constructor(theme) {\n        this._theme = theme;\n    }\n    get type() {\n        return this._theme.type;\n    }\n    get value() {\n        return this._theme;\n    }\n    update(theme) {\n        this._theme = theme;\n    }\n    getColor(color) {\n        return this._theme.getColor(color);\n    }\n}\nexport class ViewContext {\n    constructor(configuration, theme, model) {\n        this.configuration = configuration;\n        this.theme = new EditorTheme(theme);\n        this.model = model;\n        this.viewLayout = model.viewLayout;\n    }\n    addEventHandler(eventHandler) {\n        this.model.addViewEventHandler(eventHandler);\n    }\n    removeEventHandler(eventHandler) {\n        this.model.removeViewEventHandler(eventHandler);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Disposable } from '../../../base/common/lifecycle.js';\nexport class ViewEventHandler extends Disposable {\n    constructor() {\n        super();\n        this._shouldRender = true;\n    }\n    shouldRender() {\n        return this._shouldRender;\n    }\n    forceShouldRender() {\n        this._shouldRender = true;\n    }\n    setShouldRender() {\n        this._shouldRender = true;\n    }\n    onDidRender() {\n        this._shouldRender = false;\n    }\n    // --- begin event handlers\n    onCompositionStart(e) {\n        return false;\n    }\n    onCompositionEnd(e) {\n        return false;\n    }\n    onConfigurationChanged(e) {\n        return false;\n    }\n    onCursorStateChanged(e) {\n        return false;\n    }\n    onDecorationsChanged(e) {\n        return false;\n    }\n    onFlushed(e) {\n        return false;\n    }\n    onFocusChanged(e) {\n        return false;\n    }\n    onLanguageConfigurationChanged(e) {\n        return false;\n    }\n    onLineMappingChanged(e) {\n        return false;\n    }\n    onLinesChanged(e) {\n        return false;\n    }\n    onLinesDeleted(e) {\n        return false;\n    }\n    onLinesInserted(e) {\n        return false;\n    }\n    onRevealRangeRequest(e) {\n        return false;\n    }\n    onScrollChanged(e) {\n        return false;\n    }\n    onThemeChanged(e) {\n        return false;\n    }\n    onTokensChanged(e) {\n        return false;\n    }\n    onTokensColorsChanged(e) {\n        return false;\n    }\n    onZonesChanged(e) {\n        return false;\n    }\n    // --- end event handlers\n    handleEvents(events) {\n        let shouldRender = false;\n        for (let i = 0, len = events.length; i < len; i++) {\n            const e = events[i];\n            switch (e.type) {\n                case 0 /* ViewCompositionStart */:\n                    if (this.onCompositionStart(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 1 /* ViewCompositionEnd */:\n                    if (this.onCompositionEnd(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 2 /* ViewConfigurationChanged */:\n                    if (this.onConfigurationChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 3 /* ViewCursorStateChanged */:\n                    if (this.onCursorStateChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 4 /* ViewDecorationsChanged */:\n                    if (this.onDecorationsChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 5 /* ViewFlushed */:\n                    if (this.onFlushed(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 6 /* ViewFocusChanged */:\n                    if (this.onFocusChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 7 /* ViewLanguageConfigurationChanged */:\n                    if (this.onLanguageConfigurationChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 8 /* ViewLineMappingChanged */:\n                    if (this.onLineMappingChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 9 /* ViewLinesChanged */:\n                    if (this.onLinesChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 10 /* ViewLinesDeleted */:\n                    if (this.onLinesDeleted(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 11 /* ViewLinesInserted */:\n                    if (this.onLinesInserted(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 12 /* ViewRevealRangeRequest */:\n                    if (this.onRevealRangeRequest(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 13 /* ViewScrollChanged */:\n                    if (this.onScrollChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 15 /* ViewTokensChanged */:\n                    if (this.onTokensChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 14 /* ViewThemeChanged */:\n                    if (this.onThemeChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 16 /* ViewTokensColorsChanged */:\n                    if (this.onTokensColorsChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                case 17 /* ViewZonesChanged */:\n                    if (this.onZonesChanged(e)) {\n                        shouldRender = true;\n                    }\n                    break;\n                default:\n                    console.info('View received unknown event: ');\n                    console.info(e);\n            }\n        }\n        if (shouldRender) {\n            this._shouldRender = true;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class ViewCompositionStartEvent {\n    constructor() {\n        this.type = 0 /* ViewCompositionStart */;\n    }\n}\nexport class ViewCompositionEndEvent {\n    constructor() {\n        this.type = 1 /* ViewCompositionEnd */;\n    }\n}\nexport class ViewConfigurationChangedEvent {\n    constructor(source) {\n        this.type = 2 /* ViewConfigurationChanged */;\n        this._source = source;\n    }\n    hasChanged(id) {\n        return this._source.hasChanged(id);\n    }\n}\nexport class ViewCursorStateChangedEvent {\n    constructor(selections, modelSelections) {\n        this.type = 3 /* ViewCursorStateChanged */;\n        this.selections = selections;\n        this.modelSelections = modelSelections;\n    }\n}\nexport class ViewDecorationsChangedEvent {\n    constructor(source) {\n        this.type = 4 /* ViewDecorationsChanged */;\n        if (source) {\n            this.affectsMinimap = source.affectsMinimap;\n            this.affectsOverviewRuler = source.affectsOverviewRuler;\n        }\n        else {\n            this.affectsMinimap = true;\n            this.affectsOverviewRuler = true;\n        }\n    }\n}\nexport class ViewFlushedEvent {\n    constructor() {\n        this.type = 5 /* ViewFlushed */;\n        // Nothing to do\n    }\n}\nexport class ViewFocusChangedEvent {\n    constructor(isFocused) {\n        this.type = 6 /* ViewFocusChanged */;\n        this.isFocused = isFocused;\n    }\n}\nexport class ViewLanguageConfigurationEvent {\n    constructor() {\n        this.type = 7 /* ViewLanguageConfigurationChanged */;\n    }\n}\nexport class ViewLineMappingChangedEvent {\n    constructor() {\n        this.type = 8 /* ViewLineMappingChanged */;\n        // Nothing to do\n    }\n}\nexport class ViewLinesChangedEvent {\n    constructor(fromLineNumber, toLineNumber) {\n        this.type = 9 /* ViewLinesChanged */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n    }\n}\nexport class ViewLinesDeletedEvent {\n    constructor(fromLineNumber, toLineNumber) {\n        this.type = 10 /* ViewLinesDeleted */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n    }\n}\nexport class ViewLinesInsertedEvent {\n    constructor(fromLineNumber, toLineNumber) {\n        this.type = 11 /* ViewLinesInserted */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n    }\n}\nexport class ViewRevealRangeRequestEvent {\n    constructor(\n    /**\n     * Source of the call that caused the event.\n     */\n    source, \n    /**\n     * Reduce the revealing to a minimum (e.g. avoid scrolling if the bounding box is visible and near the viewport edge).\n     */\n    minimalReveal, \n    /**\n     * Range to be reavealed.\n     */\n    range, \n    /**\n     * Selections to be revealed.\n     */\n    selections, \n    /**\n     * The vertical reveal strategy.\n     */\n    verticalType, \n    /**\n     * If true: there should be a horizontal & vertical revealing.\n     * If false: there should be just a vertical revealing.\n     */\n    revealHorizontal, \n    /**\n     * The scroll type.\n     */\n    scrollType) {\n        this.source = source;\n        this.minimalReveal = minimalReveal;\n        this.range = range;\n        this.selections = selections;\n        this.verticalType = verticalType;\n        this.revealHorizontal = revealHorizontal;\n        this.scrollType = scrollType;\n        this.type = 12 /* ViewRevealRangeRequest */;\n    }\n}\nexport class ViewScrollChangedEvent {\n    constructor(source) {\n        this.type = 13 /* ViewScrollChanged */;\n        this.scrollWidth = source.scrollWidth;\n        this.scrollLeft = source.scrollLeft;\n        this.scrollHeight = source.scrollHeight;\n        this.scrollTop = source.scrollTop;\n        this.scrollWidthChanged = source.scrollWidthChanged;\n        this.scrollLeftChanged = source.scrollLeftChanged;\n        this.scrollHeightChanged = source.scrollHeightChanged;\n        this.scrollTopChanged = source.scrollTopChanged;\n    }\n}\nexport class ViewThemeChangedEvent {\n    constructor() {\n        this.type = 14 /* ViewThemeChanged */;\n    }\n}\nexport class ViewTokensChangedEvent {\n    constructor(ranges) {\n        this.type = 15 /* ViewTokensChanged */;\n        this.ranges = ranges;\n    }\n}\nexport class ViewTokensColorsChangedEvent {\n    constructor() {\n        this.type = 16 /* ViewTokensColorsChanged */;\n        // Nothing to do\n    }\n}\nexport class ViewZonesChangedEvent {\n    constructor() {\n        this.type = 17 /* ViewZonesChanged */;\n        // Nothing to do\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { Range } from '../core/range.js';\nexport class Viewport {\n    constructor(top, left, width, height) {\n        this._viewportBrand = undefined;\n        this.top = top | 0;\n        this.left = left | 0;\n        this.width = width | 0;\n        this.height = height | 0;\n    }\n}\nexport class MinimapLinesRenderingData {\n    constructor(tabSize, data) {\n        this.tabSize = tabSize;\n        this.data = data;\n    }\n}\nexport class ViewLineData {\n    constructor(content, continuesWithWrappedLine, minColumn, maxColumn, startVisibleColumn, tokens, inlineDecorations) {\n        this._viewLineDataBrand = undefined;\n        this.content = content;\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\n        this.minColumn = minColumn;\n        this.maxColumn = maxColumn;\n        this.startVisibleColumn = startVisibleColumn;\n        this.tokens = tokens;\n        this.inlineDecorations = inlineDecorations;\n    }\n}\nexport class ViewLineRenderingData {\n    constructor(minColumn, maxColumn, content, continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, tokens, inlineDecorations, tabSize, startVisibleColumn) {\n        this.minColumn = minColumn;\n        this.maxColumn = maxColumn;\n        this.content = content;\n        this.continuesWithWrappedLine = continuesWithWrappedLine;\n        this.isBasicASCII = ViewLineRenderingData.isBasicASCII(content, mightContainNonBasicASCII);\n        this.containsRTL = ViewLineRenderingData.containsRTL(content, this.isBasicASCII, mightContainRTL);\n        this.tokens = tokens;\n        this.inlineDecorations = inlineDecorations;\n        this.tabSize = tabSize;\n        this.startVisibleColumn = startVisibleColumn;\n    }\n    static isBasicASCII(lineContent, mightContainNonBasicASCII) {\n        if (mightContainNonBasicASCII) {\n            return strings.isBasicASCII(lineContent);\n        }\n        return true;\n    }\n    static containsRTL(lineContent, isBasicASCII, mightContainRTL) {\n        if (!isBasicASCII && mightContainRTL) {\n            return strings.containsRTL(lineContent);\n        }\n        return false;\n    }\n}\nexport class InlineDecoration {\n    constructor(range, inlineClassName, type) {\n        this.range = range;\n        this.inlineClassName = inlineClassName;\n        this.type = type;\n    }\n}\nexport class SingleLineInlineDecoration {\n    constructor(startOffset, endOffset, inlineClassName, inlineClassNameAffectsLetterSpacing) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.inlineClassName = inlineClassName;\n        this.inlineClassNameAffectsLetterSpacing = inlineClassNameAffectsLetterSpacing;\n    }\n    toInlineDecoration(lineNumber) {\n        return new InlineDecoration(new Range(lineNumber, this.startOffset + 1, lineNumber, this.endOffset + 1), this.inlineClassName, this.inlineClassNameAffectsLetterSpacing ? 3 /* RegularAffectingLetterSpacing */ : 0 /* Regular */);\n    }\n}\nexport class ViewModelDecoration {\n    constructor(range, options) {\n        this._viewModelDecorationBrand = undefined;\n        this.range = range;\n        this.options = options;\n    }\n}\nexport class OverviewRulerDecorationsGroup {\n    constructor(color, zIndex, \n    /**\n     * Decorations are encoded in a number array using the following scheme:\n     *  - 3*i = lane\n     *  - 3*i+1 = startLineNumber\n     *  - 3*i+2 = endLineNumber\n     */\n    data) {\n        this.color = color;\n        this.zIndex = zIndex;\n        this.data = data;\n    }\n    static cmp(a, b) {\n        if (a.zIndex === b.zIndex) {\n            if (a.color < b.color) {\n                return -1;\n            }\n            if (a.color > b.color) {\n                return 1;\n            }\n            return 0;\n        }\n        return a.zIndex - b.zIndex;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { InlineDecoration, ViewModelDecoration } from './viewModel.js';\nimport { filterValidationDecorations } from '../config/editorOptions.js';\nexport class ViewModelDecorations {\n    constructor(editorId, model, configuration, linesCollection, coordinatesConverter) {\n        this.editorId = editorId;\n        this.model = model;\n        this.configuration = configuration;\n        this._linesCollection = linesCollection;\n        this._coordinatesConverter = coordinatesConverter;\n        this._decorationsCache = Object.create(null);\n        this._cachedModelDecorationsResolver = null;\n        this._cachedModelDecorationsResolverViewRange = null;\n    }\n    _clearCachedModelDecorationsResolver() {\n        this._cachedModelDecorationsResolver = null;\n        this._cachedModelDecorationsResolverViewRange = null;\n    }\n    dispose() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    reset() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    onModelDecorationsChanged() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    onLineMappingChanged() {\n        this._decorationsCache = Object.create(null);\n        this._clearCachedModelDecorationsResolver();\n    }\n    _getOrCreateViewModelDecoration(modelDecoration) {\n        const id = modelDecoration.id;\n        let r = this._decorationsCache[id];\n        if (!r) {\n            const modelRange = modelDecoration.range;\n            const options = modelDecoration.options;\n            let viewRange;\n            if (options.isWholeLine) {\n                const start = this._coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.startLineNumber, 1), 0 /* Left */);\n                const end = this._coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.endLineNumber, this.model.getLineMaxColumn(modelRange.endLineNumber)), 1 /* Right */);\n                viewRange = new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n            }\n            else {\n                // For backwards compatibility reasons, we want injected text before any decoration.\n                // Thus, move decorations to the right.\n                viewRange = this._coordinatesConverter.convertModelRangeToViewRange(modelRange, 1 /* Right */);\n            }\n            r = new ViewModelDecoration(viewRange, options);\n            this._decorationsCache[id] = r;\n        }\n        return r;\n    }\n    getDecorationsViewportData(viewRange) {\n        let cacheIsValid = (this._cachedModelDecorationsResolver !== null);\n        cacheIsValid = cacheIsValid && (viewRange.equalsRange(this._cachedModelDecorationsResolverViewRange));\n        if (!cacheIsValid) {\n            this._cachedModelDecorationsResolver = this._getDecorationsViewportData(viewRange);\n            this._cachedModelDecorationsResolverViewRange = viewRange;\n        }\n        return this._cachedModelDecorationsResolver;\n    }\n    _getDecorationsViewportData(viewportRange) {\n        const modelDecorations = this._linesCollection.getDecorationsInRange(viewportRange, this.editorId, filterValidationDecorations(this.configuration.options));\n        const startLineNumber = viewportRange.startLineNumber;\n        const endLineNumber = viewportRange.endLineNumber;\n        const decorationsInViewport = [];\n        let decorationsInViewportLen = 0;\n        const inlineDecorations = [];\n        for (let j = startLineNumber; j <= endLineNumber; j++) {\n            inlineDecorations[j - startLineNumber] = [];\n        }\n        for (let i = 0, len = modelDecorations.length; i < len; i++) {\n            const modelDecoration = modelDecorations[i];\n            const decorationOptions = modelDecoration.options;\n            if (!isModelDecorationVisible(this.model, modelDecoration)) {\n                continue;\n            }\n            const viewModelDecoration = this._getOrCreateViewModelDecoration(modelDecoration);\n            const viewRange = viewModelDecoration.range;\n            decorationsInViewport[decorationsInViewportLen++] = viewModelDecoration;\n            if (decorationOptions.inlineClassName) {\n                const inlineDecoration = new InlineDecoration(viewRange, decorationOptions.inlineClassName, decorationOptions.inlineClassNameAffectsLetterSpacing ? 3 /* RegularAffectingLetterSpacing */ : 0 /* Regular */);\n                const intersectedStartLineNumber = Math.max(startLineNumber, viewRange.startLineNumber);\n                const intersectedEndLineNumber = Math.min(endLineNumber, viewRange.endLineNumber);\n                for (let j = intersectedStartLineNumber; j <= intersectedEndLineNumber; j++) {\n                    inlineDecorations[j - startLineNumber].push(inlineDecoration);\n                }\n            }\n            if (decorationOptions.beforeContentClassName) {\n                if (startLineNumber <= viewRange.startLineNumber && viewRange.startLineNumber <= endLineNumber) {\n                    const inlineDecoration = new InlineDecoration(new Range(viewRange.startLineNumber, viewRange.startColumn, viewRange.startLineNumber, viewRange.startColumn), decorationOptions.beforeContentClassName, 1 /* Before */);\n                    inlineDecorations[viewRange.startLineNumber - startLineNumber].push(inlineDecoration);\n                }\n            }\n            if (decorationOptions.afterContentClassName) {\n                if (startLineNumber <= viewRange.endLineNumber && viewRange.endLineNumber <= endLineNumber) {\n                    const inlineDecoration = new InlineDecoration(new Range(viewRange.endLineNumber, viewRange.endColumn, viewRange.endLineNumber, viewRange.endColumn), decorationOptions.afterContentClassName, 2 /* After */);\n                    inlineDecorations[viewRange.endLineNumber - startLineNumber].push(inlineDecoration);\n                }\n            }\n        }\n        return {\n            decorations: decorationsInViewport,\n            inlineDecorations: inlineDecorations\n        };\n    }\n}\nexport function isModelDecorationVisible(model, decoration) {\n    if (decoration.options.hideInCommentTokens && isModelDecorationInComment(model, decoration)) {\n        return false;\n    }\n    if (decoration.options.hideInStringTokens && isModelDecorationInString(model, decoration)) {\n        return false;\n    }\n    return true;\n}\nexport function isModelDecorationInComment(model, decoration) {\n    return testTokensInRange(model, decoration.range, (tokenType) => tokenType === 1 /* Comment */);\n}\nexport function isModelDecorationInString(model, decoration) {\n    return testTokensInRange(model, decoration.range, (tokenType) => tokenType === 2 /* String */);\n}\n/**\n * Calls the callback for every token that intersects the range.\n * If the callback returns `false`, iteration stops and `false` is returned.\n * Otherwise, `true` is returned.\n */\nfunction testTokensInRange(model, range, callback) {\n    for (let lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {\n        const lineTokens = model.getLineTokens(lineNumber);\n        const isFirstLine = lineNumber === range.startLineNumber;\n        const isEndLine = lineNumber === range.endLineNumber;\n        let tokenIdx = isFirstLine ? lineTokens.findTokenIndexAtOffset(range.startColumn - 1) : 0;\n        while (tokenIdx < lineTokens.getCount()) {\n            if (isEndLine) {\n                const startOffset = lineTokens.getStartOffset(tokenIdx);\n                if (startOffset > range.endColumn - 1) {\n                    break;\n                }\n            }\n            const callbackResult = callback(lineTokens.getStandardTokenType(tokenIdx));\n            if (!callbackResult) {\n                return false;\n            }\n            tokenIdx++;\n        }\n    }\n    return true;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nexport class ViewModelEventDispatcher extends Disposable {\n    constructor() {\n        super();\n        this._onEvent = this._register(new Emitter());\n        this.onEvent = this._onEvent.event;\n        this._eventHandlers = [];\n        this._viewEventQueue = null;\n        this._isConsumingViewEventQueue = false;\n        this._collector = null;\n        this._collectorCnt = 0;\n        this._outgoingEvents = [];\n    }\n    emitOutgoingEvent(e) {\n        this._addOutgoingEvent(e);\n        this._emitOutgoingEvents();\n    }\n    _addOutgoingEvent(e) {\n        for (let i = 0, len = this._outgoingEvents.length; i < len; i++) {\n            if (this._outgoingEvents[i].kind === e.kind) {\n                this._outgoingEvents[i] = this._outgoingEvents[i].merge(e);\n                return;\n            }\n        }\n        // not merged\n        this._outgoingEvents.push(e);\n    }\n    _emitOutgoingEvents() {\n        while (this._outgoingEvents.length > 0) {\n            if (this._collector || this._isConsumingViewEventQueue) {\n                // right now collecting or emitting view events, so let's postpone emitting\n                return;\n            }\n            const event = this._outgoingEvents.shift();\n            if (event.isNoOp()) {\n                continue;\n            }\n            this._onEvent.fire(event);\n        }\n    }\n    addViewEventHandler(eventHandler) {\n        for (let i = 0, len = this._eventHandlers.length; i < len; i++) {\n            if (this._eventHandlers[i] === eventHandler) {\n                console.warn('Detected duplicate listener in ViewEventDispatcher', eventHandler);\n            }\n        }\n        this._eventHandlers.push(eventHandler);\n    }\n    removeViewEventHandler(eventHandler) {\n        for (let i = 0; i < this._eventHandlers.length; i++) {\n            if (this._eventHandlers[i] === eventHandler) {\n                this._eventHandlers.splice(i, 1);\n                break;\n            }\n        }\n    }\n    beginEmitViewEvents() {\n        this._collectorCnt++;\n        if (this._collectorCnt === 1) {\n            this._collector = new ViewModelEventsCollector();\n        }\n        return this._collector;\n    }\n    endEmitViewEvents() {\n        this._collectorCnt--;\n        if (this._collectorCnt === 0) {\n            const outgoingEvents = this._collector.outgoingEvents;\n            const viewEvents = this._collector.viewEvents;\n            this._collector = null;\n            for (const outgoingEvent of outgoingEvents) {\n                this._addOutgoingEvent(outgoingEvent);\n            }\n            if (viewEvents.length > 0) {\n                this._emitMany(viewEvents);\n            }\n        }\n        this._emitOutgoingEvents();\n    }\n    emitSingleViewEvent(event) {\n        try {\n            const eventsCollector = this.beginEmitViewEvents();\n            eventsCollector.emitViewEvent(event);\n        }\n        finally {\n            this.endEmitViewEvents();\n        }\n    }\n    _emitMany(events) {\n        if (this._viewEventQueue) {\n            this._viewEventQueue = this._viewEventQueue.concat(events);\n        }\n        else {\n            this._viewEventQueue = events;\n        }\n        if (!this._isConsumingViewEventQueue) {\n            this._consumeViewEventQueue();\n        }\n    }\n    _consumeViewEventQueue() {\n        try {\n            this._isConsumingViewEventQueue = true;\n            this._doConsumeQueue();\n        }\n        finally {\n            this._isConsumingViewEventQueue = false;\n        }\n    }\n    _doConsumeQueue() {\n        while (this._viewEventQueue) {\n            // Empty event queue, as events might come in while sending these off\n            const events = this._viewEventQueue;\n            this._viewEventQueue = null;\n            // Use a clone of the event handlers list, as they might remove themselves\n            const eventHandlers = this._eventHandlers.slice(0);\n            for (const eventHandler of eventHandlers) {\n                eventHandler.handleEvents(events);\n            }\n        }\n    }\n}\nexport class ViewModelEventsCollector {\n    constructor() {\n        this.viewEvents = [];\n        this.outgoingEvents = [];\n    }\n    emitViewEvent(event) {\n        this.viewEvents.push(event);\n    }\n    emitOutgoingEvent(e) {\n        this.outgoingEvents.push(e);\n    }\n}\nexport class ContentSizeChangedEvent {\n    constructor(oldContentWidth, oldContentHeight, contentWidth, contentHeight) {\n        this.kind = 0 /* ContentSizeChanged */;\n        this._oldContentWidth = oldContentWidth;\n        this._oldContentHeight = oldContentHeight;\n        this.contentWidth = contentWidth;\n        this.contentHeight = contentHeight;\n        this.contentWidthChanged = (this._oldContentWidth !== this.contentWidth);\n        this.contentHeightChanged = (this._oldContentHeight !== this.contentHeight);\n    }\n    isNoOp() {\n        return (!this.contentWidthChanged && !this.contentHeightChanged);\n    }\n    merge(other) {\n        if (other.kind !== 0 /* ContentSizeChanged */) {\n            return this;\n        }\n        return new ContentSizeChangedEvent(this._oldContentWidth, this._oldContentHeight, other.contentWidth, other.contentHeight);\n    }\n}\nexport class FocusChangedEvent {\n    constructor(oldHasFocus, hasFocus) {\n        this.kind = 1 /* FocusChanged */;\n        this.oldHasFocus = oldHasFocus;\n        this.hasFocus = hasFocus;\n    }\n    isNoOp() {\n        return (this.oldHasFocus === this.hasFocus);\n    }\n    merge(other) {\n        if (other.kind !== 1 /* FocusChanged */) {\n            return this;\n        }\n        return new FocusChangedEvent(this.oldHasFocus, other.hasFocus);\n    }\n}\nexport class ScrollChangedEvent {\n    constructor(oldScrollWidth, oldScrollLeft, oldScrollHeight, oldScrollTop, scrollWidth, scrollLeft, scrollHeight, scrollTop) {\n        this.kind = 2 /* ScrollChanged */;\n        this._oldScrollWidth = oldScrollWidth;\n        this._oldScrollLeft = oldScrollLeft;\n        this._oldScrollHeight = oldScrollHeight;\n        this._oldScrollTop = oldScrollTop;\n        this.scrollWidth = scrollWidth;\n        this.scrollLeft = scrollLeft;\n        this.scrollHeight = scrollHeight;\n        this.scrollTop = scrollTop;\n        this.scrollWidthChanged = (this._oldScrollWidth !== this.scrollWidth);\n        this.scrollLeftChanged = (this._oldScrollLeft !== this.scrollLeft);\n        this.scrollHeightChanged = (this._oldScrollHeight !== this.scrollHeight);\n        this.scrollTopChanged = (this._oldScrollTop !== this.scrollTop);\n    }\n    isNoOp() {\n        return (!this.scrollWidthChanged && !this.scrollLeftChanged && !this.scrollHeightChanged && !this.scrollTopChanged);\n    }\n    merge(other) {\n        if (other.kind !== 2 /* ScrollChanged */) {\n            return this;\n        }\n        return new ScrollChangedEvent(this._oldScrollWidth, this._oldScrollLeft, this._oldScrollHeight, this._oldScrollTop, other.scrollWidth, other.scrollLeft, other.scrollHeight, other.scrollTop);\n    }\n}\nexport class ViewZonesChangedEvent {\n    constructor() {\n        this.kind = 3 /* ViewZonesChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    merge(other) {\n        return this;\n    }\n}\nexport class HiddenAreasChangedEvent {\n    constructor() {\n        this.kind = 4 /* HiddenAreasChanged */;\n    }\n    isNoOp() {\n        return false;\n    }\n    merge(other) {\n        return this;\n    }\n}\nexport class CursorStateChangedEvent {\n    constructor(oldSelections, selections, oldModelVersionId, modelVersionId, source, reason, reachedMaxCursorCount) {\n        this.kind = 6 /* CursorStateChanged */;\n        this.oldSelections = oldSelections;\n        this.selections = selections;\n        this.oldModelVersionId = oldModelVersionId;\n        this.modelVersionId = modelVersionId;\n        this.source = source;\n        this.reason = reason;\n        this.reachedMaxCursorCount = reachedMaxCursorCount;\n    }\n    static _selectionsAreEqual(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        if (!a || !b) {\n            return false;\n        }\n        const aLen = a.length;\n        const bLen = b.length;\n        if (aLen !== bLen) {\n            return false;\n        }\n        for (let i = 0; i < aLen; i++) {\n            if (!a[i].equalsSelection(b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isNoOp() {\n        return (CursorStateChangedEvent._selectionsAreEqual(this.oldSelections, this.selections)\n            && this.oldModelVersionId === this.modelVersionId);\n    }\n    merge(other) {\n        if (other.kind !== 6 /* CursorStateChanged */) {\n            return this;\n        }\n        return new CursorStateChangedEvent(this.oldSelections, other.selections, this.oldModelVersionId, other.modelVersionId, other.source, other.reason, this.reachedMaxCursorCount || other.reachedMaxCursorCount);\n    }\n}\nexport class ReadOnlyEditAttemptEvent {\n    constructor() {\n        this.kind = 5 /* ReadOnlyEditAttempt */;\n    }\n    isNoOp() {\n        return false;\n    }\n    merge(other) {\n        return this;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nclass PendingChanges {\n    constructor() {\n        this._hasPending = false;\n        this._inserts = [];\n        this._changes = [];\n        this._removes = [];\n    }\n    insert(x) {\n        this._hasPending = true;\n        this._inserts.push(x);\n    }\n    change(x) {\n        this._hasPending = true;\n        this._changes.push(x);\n    }\n    remove(x) {\n        this._hasPending = true;\n        this._removes.push(x);\n    }\n    mustCommit() {\n        return this._hasPending;\n    }\n    commit(linesLayout) {\n        if (!this._hasPending) {\n            return;\n        }\n        const inserts = this._inserts;\n        const changes = this._changes;\n        const removes = this._removes;\n        this._hasPending = false;\n        this._inserts = [];\n        this._changes = [];\n        this._removes = [];\n        linesLayout._commitPendingChanges(inserts, changes, removes);\n    }\n}\nexport class EditorWhitespace {\n    constructor(id, afterLineNumber, ordinal, height, minWidth) {\n        this.id = id;\n        this.afterLineNumber = afterLineNumber;\n        this.ordinal = ordinal;\n        this.height = height;\n        this.minWidth = minWidth;\n        this.prefixSum = 0;\n    }\n}\n/**\n * Layouting of objects that take vertical space (by having a height) and push down other objects.\n *\n * These objects are basically either text (lines) or spaces between those lines (whitespaces).\n * This provides commodity operations for working with lines that contain whitespace that pushes lines lower (vertically).\n */\nexport class LinesLayout {\n    constructor(lineCount, lineHeight, paddingTop, paddingBottom) {\n        this._instanceId = strings.singleLetterHash(++LinesLayout.INSTANCE_COUNT);\n        this._pendingChanges = new PendingChanges();\n        this._lastWhitespaceId = 0;\n        this._arr = [];\n        this._prefixSumValidIndex = -1;\n        this._minWidth = -1; /* marker for not being computed */\n        this._lineCount = lineCount;\n        this._lineHeight = lineHeight;\n        this._paddingTop = paddingTop;\n        this._paddingBottom = paddingBottom;\n    }\n    /**\n     * Find the insertion index for a new value inside a sorted array of values.\n     * If the value is already present in the sorted array, the insertion index will be after the already existing value.\n     */\n    static findInsertionIndex(arr, afterLineNumber, ordinal) {\n        let low = 0;\n        let high = arr.length;\n        while (low < high) {\n            const mid = ((low + high) >>> 1);\n            if (afterLineNumber === arr[mid].afterLineNumber) {\n                if (ordinal < arr[mid].ordinal) {\n                    high = mid;\n                }\n                else {\n                    low = mid + 1;\n                }\n            }\n            else if (afterLineNumber < arr[mid].afterLineNumber) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        return low;\n    }\n    /**\n     * Change the height of a line in pixels.\n     */\n    setLineHeight(lineHeight) {\n        this._checkPendingChanges();\n        this._lineHeight = lineHeight;\n    }\n    /**\n     * Changes the padding used to calculate vertical offsets.\n     */\n    setPadding(paddingTop, paddingBottom) {\n        this._paddingTop = paddingTop;\n        this._paddingBottom = paddingBottom;\n    }\n    /**\n     * Set the number of lines.\n     *\n     * @param lineCount New number of lines.\n     */\n    onFlushed(lineCount) {\n        this._checkPendingChanges();\n        this._lineCount = lineCount;\n    }\n    changeWhitespace(callback) {\n        let hadAChange = false;\n        try {\n            const accessor = {\n                insertWhitespace: (afterLineNumber, ordinal, heightInPx, minWidth) => {\n                    hadAChange = true;\n                    afterLineNumber = afterLineNumber | 0;\n                    ordinal = ordinal | 0;\n                    heightInPx = heightInPx | 0;\n                    minWidth = minWidth | 0;\n                    const id = this._instanceId + (++this._lastWhitespaceId);\n                    this._pendingChanges.insert(new EditorWhitespace(id, afterLineNumber, ordinal, heightInPx, minWidth));\n                    return id;\n                },\n                changeOneWhitespace: (id, newAfterLineNumber, newHeight) => {\n                    hadAChange = true;\n                    newAfterLineNumber = newAfterLineNumber | 0;\n                    newHeight = newHeight | 0;\n                    this._pendingChanges.change({ id, newAfterLineNumber, newHeight });\n                },\n                removeWhitespace: (id) => {\n                    hadAChange = true;\n                    this._pendingChanges.remove({ id });\n                }\n            };\n            callback(accessor);\n        }\n        finally {\n            this._pendingChanges.commit(this);\n        }\n        return hadAChange;\n    }\n    _commitPendingChanges(inserts, changes, removes) {\n        if (inserts.length > 0 || removes.length > 0) {\n            this._minWidth = -1; /* marker for not being computed */\n        }\n        if (inserts.length + changes.length + removes.length <= 1) {\n            // when only one thing happened, handle it \"delicately\"\n            for (const insert of inserts) {\n                this._insertWhitespace(insert);\n            }\n            for (const change of changes) {\n                this._changeOneWhitespace(change.id, change.newAfterLineNumber, change.newHeight);\n            }\n            for (const remove of removes) {\n                const index = this._findWhitespaceIndex(remove.id);\n                if (index === -1) {\n                    continue;\n                }\n                this._removeWhitespace(index);\n            }\n            return;\n        }\n        // simply rebuild the entire datastructure\n        const toRemove = new Set();\n        for (const remove of removes) {\n            toRemove.add(remove.id);\n        }\n        const toChange = new Map();\n        for (const change of changes) {\n            toChange.set(change.id, change);\n        }\n        const applyRemoveAndChange = (whitespaces) => {\n            const result = [];\n            for (const whitespace of whitespaces) {\n                if (toRemove.has(whitespace.id)) {\n                    continue;\n                }\n                if (toChange.has(whitespace.id)) {\n                    const change = toChange.get(whitespace.id);\n                    whitespace.afterLineNumber = change.newAfterLineNumber;\n                    whitespace.height = change.newHeight;\n                }\n                result.push(whitespace);\n            }\n            return result;\n        };\n        const result = applyRemoveAndChange(this._arr).concat(applyRemoveAndChange(inserts));\n        result.sort((a, b) => {\n            if (a.afterLineNumber === b.afterLineNumber) {\n                return a.ordinal - b.ordinal;\n            }\n            return a.afterLineNumber - b.afterLineNumber;\n        });\n        this._arr = result;\n        this._prefixSumValidIndex = -1;\n    }\n    _checkPendingChanges() {\n        if (this._pendingChanges.mustCommit()) {\n            this._pendingChanges.commit(this);\n        }\n    }\n    _insertWhitespace(whitespace) {\n        const insertIndex = LinesLayout.findInsertionIndex(this._arr, whitespace.afterLineNumber, whitespace.ordinal);\n        this._arr.splice(insertIndex, 0, whitespace);\n        this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, insertIndex - 1);\n    }\n    _findWhitespaceIndex(id) {\n        const arr = this._arr;\n        for (let i = 0, len = arr.length; i < len; i++) {\n            if (arr[i].id === id) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    _changeOneWhitespace(id, newAfterLineNumber, newHeight) {\n        const index = this._findWhitespaceIndex(id);\n        if (index === -1) {\n            return;\n        }\n        if (this._arr[index].height !== newHeight) {\n            this._arr[index].height = newHeight;\n            this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, index - 1);\n        }\n        if (this._arr[index].afterLineNumber !== newAfterLineNumber) {\n            // `afterLineNumber` changed for this whitespace\n            // Record old whitespace\n            const whitespace = this._arr[index];\n            // Since changing `afterLineNumber` can trigger a reordering, we're gonna remove this whitespace\n            this._removeWhitespace(index);\n            whitespace.afterLineNumber = newAfterLineNumber;\n            // And add it again\n            this._insertWhitespace(whitespace);\n        }\n    }\n    _removeWhitespace(removeIndex) {\n        this._arr.splice(removeIndex, 1);\n        this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, removeIndex - 1);\n    }\n    /**\n     * Notify the layouter that lines have been deleted (a continuous zone of lines).\n     *\n     * @param fromLineNumber The line number at which the deletion started, inclusive\n     * @param toLineNumber The line number at which the deletion ended, inclusive\n     */\n    onLinesDeleted(fromLineNumber, toLineNumber) {\n        this._checkPendingChanges();\n        fromLineNumber = fromLineNumber | 0;\n        toLineNumber = toLineNumber | 0;\n        this._lineCount -= (toLineNumber - fromLineNumber + 1);\n        for (let i = 0, len = this._arr.length; i < len; i++) {\n            const afterLineNumber = this._arr[i].afterLineNumber;\n            if (fromLineNumber <= afterLineNumber && afterLineNumber <= toLineNumber) {\n                // The line this whitespace was after has been deleted\n                //  => move whitespace to before first deleted line\n                this._arr[i].afterLineNumber = fromLineNumber - 1;\n            }\n            else if (afterLineNumber > toLineNumber) {\n                // The line this whitespace was after has been moved up\n                //  => move whitespace up\n                this._arr[i].afterLineNumber -= (toLineNumber - fromLineNumber + 1);\n            }\n        }\n    }\n    /**\n     * Notify the layouter that lines have been inserted (a continuous zone of lines).\n     *\n     * @param fromLineNumber The line number at which the insertion started, inclusive\n     * @param toLineNumber The line number at which the insertion ended, inclusive.\n     */\n    onLinesInserted(fromLineNumber, toLineNumber) {\n        this._checkPendingChanges();\n        fromLineNumber = fromLineNumber | 0;\n        toLineNumber = toLineNumber | 0;\n        this._lineCount += (toLineNumber - fromLineNumber + 1);\n        for (let i = 0, len = this._arr.length; i < len; i++) {\n            const afterLineNumber = this._arr[i].afterLineNumber;\n            if (fromLineNumber <= afterLineNumber) {\n                this._arr[i].afterLineNumber += (toLineNumber - fromLineNumber + 1);\n            }\n        }\n    }\n    /**\n     * Get the sum of all the whitespaces.\n     */\n    getWhitespacesTotalHeight() {\n        this._checkPendingChanges();\n        if (this._arr.length === 0) {\n            return 0;\n        }\n        return this.getWhitespacesAccumulatedHeight(this._arr.length - 1);\n    }\n    /**\n     * Return the sum of the heights of the whitespaces at [0..index].\n     * This includes the whitespace at `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.\n     */\n    getWhitespacesAccumulatedHeight(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        let startIndex = Math.max(0, this._prefixSumValidIndex + 1);\n        if (startIndex === 0) {\n            this._arr[0].prefixSum = this._arr[0].height;\n            startIndex++;\n        }\n        for (let i = startIndex; i <= index; i++) {\n            this._arr[i].prefixSum = this._arr[i - 1].prefixSum + this._arr[i].height;\n        }\n        this._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, index);\n        return this._arr[index].prefixSum;\n    }\n    /**\n     * Get the sum of heights for all objects.\n     *\n     * @return The sum of heights for all objects.\n     */\n    getLinesTotalHeight() {\n        this._checkPendingChanges();\n        const linesHeight = this._lineHeight * this._lineCount;\n        const whitespacesHeight = this.getWhitespacesTotalHeight();\n        return linesHeight + whitespacesHeight + this._paddingTop + this._paddingBottom;\n    }\n    /**\n     * Returns the accumulated height of whitespaces before the given line number.\n     *\n     * @param lineNumber The line number\n     */\n    getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        const lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n        if (lastWhitespaceBeforeLineNumber === -1) {\n            return 0;\n        }\n        return this.getWhitespacesAccumulatedHeight(lastWhitespaceBeforeLineNumber);\n    }\n    _findLastWhitespaceBeforeLineNumber(lineNumber) {\n        lineNumber = lineNumber | 0;\n        // Find the whitespace before line number\n        const arr = this._arr;\n        let low = 0;\n        let high = arr.length - 1;\n        while (low <= high) {\n            const delta = (high - low) | 0;\n            const halfDelta = (delta / 2) | 0;\n            const mid = (low + halfDelta) | 0;\n            if (arr[mid].afterLineNumber < lineNumber) {\n                if (mid + 1 >= arr.length || arr[mid + 1].afterLineNumber >= lineNumber) {\n                    return mid;\n                }\n                else {\n                    low = (mid + 1) | 0;\n                }\n            }\n            else {\n                high = (mid - 1) | 0;\n            }\n        }\n        return -1;\n    }\n    _findFirstWhitespaceAfterLineNumber(lineNumber) {\n        lineNumber = lineNumber | 0;\n        const lastWhitespaceBeforeLineNumber = this._findLastWhitespaceBeforeLineNumber(lineNumber);\n        const firstWhitespaceAfterLineNumber = lastWhitespaceBeforeLineNumber + 1;\n        if (firstWhitespaceAfterLineNumber < this._arr.length) {\n            return firstWhitespaceAfterLineNumber;\n        }\n        return -1;\n    }\n    /**\n     * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.\n     * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.\n     */\n    getFirstWhitespaceIndexAfterLineNumber(lineNumber) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        return this._findFirstWhitespaceAfterLineNumber(lineNumber);\n    }\n    /**\n     * Get the vertical offset (the sum of heights for all objects above) a certain line number.\n     *\n     * @param lineNumber The line number\n     * @return The sum of heights for all objects above `lineNumber`.\n     */\n    getVerticalOffsetForLineNumber(lineNumber) {\n        this._checkPendingChanges();\n        lineNumber = lineNumber | 0;\n        let previousLinesHeight;\n        if (lineNumber > 1) {\n            previousLinesHeight = this._lineHeight * (lineNumber - 1);\n        }\n        else {\n            previousLinesHeight = 0;\n        }\n        const previousWhitespacesHeight = this.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber);\n        return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    /**\n     * The maximum min width for all whitespaces.\n     */\n    getWhitespaceMinWidth() {\n        this._checkPendingChanges();\n        if (this._minWidth === -1) {\n            let minWidth = 0;\n            for (let i = 0, len = this._arr.length; i < len; i++) {\n                minWidth = Math.max(minWidth, this._arr[i].minWidth);\n            }\n            this._minWidth = minWidth;\n        }\n        return this._minWidth;\n    }\n    /**\n     * Check if `verticalOffset` is below all lines.\n     */\n    isAfterLines(verticalOffset) {\n        this._checkPendingChanges();\n        const totalHeight = this.getLinesTotalHeight();\n        return verticalOffset > totalHeight;\n    }\n    isInTopPadding(verticalOffset) {\n        if (this._paddingTop === 0) {\n            return false;\n        }\n        this._checkPendingChanges();\n        return (verticalOffset < this._paddingTop);\n    }\n    isInBottomPadding(verticalOffset) {\n        if (this._paddingBottom === 0) {\n            return false;\n        }\n        this._checkPendingChanges();\n        const totalHeight = this.getLinesTotalHeight();\n        return (verticalOffset >= totalHeight - this._paddingBottom);\n    }\n    /**\n     * Find the first line number that is at or after vertical offset `verticalOffset`.\n     * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then\n     * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.\n     *\n     * @param verticalOffset The vertical offset to search at.\n     * @return The line number at or after vertical offset `verticalOffset`.\n     */\n    getLineNumberAtOrAfterVerticalOffset(verticalOffset) {\n        this._checkPendingChanges();\n        verticalOffset = verticalOffset | 0;\n        if (verticalOffset < 0) {\n            return 1;\n        }\n        const linesCount = this._lineCount | 0;\n        const lineHeight = this._lineHeight;\n        let minLineNumber = 1;\n        let maxLineNumber = linesCount;\n        while (minLineNumber < maxLineNumber) {\n            const midLineNumber = ((minLineNumber + maxLineNumber) / 2) | 0;\n            const midLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(midLineNumber) | 0;\n            if (verticalOffset >= midLineNumberVerticalOffset + lineHeight) {\n                // vertical offset is after mid line number\n                minLineNumber = midLineNumber + 1;\n            }\n            else if (verticalOffset >= midLineNumberVerticalOffset) {\n                // Hit\n                return midLineNumber;\n            }\n            else {\n                // vertical offset is before mid line number, but mid line number could still be what we're searching for\n                maxLineNumber = midLineNumber;\n            }\n        }\n        if (minLineNumber > linesCount) {\n            return linesCount;\n        }\n        return minLineNumber;\n    }\n    /**\n     * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.\n     *\n     * @param verticalOffset1 The beginning of the viewport.\n     * @param verticalOffset2 The end of the viewport.\n     * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.\n     */\n    getLinesViewportData(verticalOffset1, verticalOffset2) {\n        this._checkPendingChanges();\n        verticalOffset1 = verticalOffset1 | 0;\n        verticalOffset2 = verticalOffset2 | 0;\n        const lineHeight = this._lineHeight;\n        // Find first line number\n        // We don't live in a perfect world, so the line number might start before or after verticalOffset1\n        const startLineNumber = this.getLineNumberAtOrAfterVerticalOffset(verticalOffset1) | 0;\n        const startLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(startLineNumber) | 0;\n        let endLineNumber = this._lineCount | 0;\n        // Also keep track of what whitespace we've got\n        let whitespaceIndex = this.getFirstWhitespaceIndexAfterLineNumber(startLineNumber) | 0;\n        const whitespaceCount = this.getWhitespacesCount() | 0;\n        let currentWhitespaceHeight;\n        let currentWhitespaceAfterLineNumber;\n        if (whitespaceIndex === -1) {\n            whitespaceIndex = whitespaceCount;\n            currentWhitespaceAfterLineNumber = endLineNumber + 1;\n            currentWhitespaceHeight = 0;\n        }\n        else {\n            currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n            currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n        }\n        let currentVerticalOffset = startLineNumberVerticalOffset;\n        let currentLineRelativeOffset = currentVerticalOffset;\n        // IE (all versions) cannot handle units above about 1,533,908 px, so every 500k pixels bring numbers down\n        const STEP_SIZE = 500000;\n        let bigNumbersDelta = 0;\n        if (startLineNumberVerticalOffset >= STEP_SIZE) {\n            // Compute a delta that guarantees that lines are positioned at `lineHeight` increments\n            bigNumbersDelta = Math.floor(startLineNumberVerticalOffset / STEP_SIZE) * STEP_SIZE;\n            bigNumbersDelta = Math.floor(bigNumbersDelta / lineHeight) * lineHeight;\n            currentLineRelativeOffset -= bigNumbersDelta;\n        }\n        const linesOffsets = [];\n        const verticalCenter = verticalOffset1 + (verticalOffset2 - verticalOffset1) / 2;\n        let centeredLineNumber = -1;\n        // Figure out how far the lines go\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            if (centeredLineNumber === -1) {\n                const currentLineTop = currentVerticalOffset;\n                const currentLineBottom = currentVerticalOffset + lineHeight;\n                if ((currentLineTop <= verticalCenter && verticalCenter < currentLineBottom) || currentLineTop > verticalCenter) {\n                    centeredLineNumber = lineNumber;\n                }\n            }\n            // Count current line height in the vertical offsets\n            currentVerticalOffset += lineHeight;\n            linesOffsets[lineNumber - startLineNumber] = currentLineRelativeOffset;\n            // Next line starts immediately after this one\n            currentLineRelativeOffset += lineHeight;\n            while (currentWhitespaceAfterLineNumber === lineNumber) {\n                // Push down next line with the height of the current whitespace\n                currentLineRelativeOffset += currentWhitespaceHeight;\n                // Count current whitespace in the vertical offsets\n                currentVerticalOffset += currentWhitespaceHeight;\n                whitespaceIndex++;\n                if (whitespaceIndex >= whitespaceCount) {\n                    currentWhitespaceAfterLineNumber = endLineNumber + 1;\n                }\n                else {\n                    currentWhitespaceAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;\n                    currentWhitespaceHeight = this.getHeightForWhitespaceIndex(whitespaceIndex) | 0;\n                }\n            }\n            if (currentVerticalOffset >= verticalOffset2) {\n                // We have covered the entire viewport area, time to stop\n                endLineNumber = lineNumber;\n                break;\n            }\n        }\n        if (centeredLineNumber === -1) {\n            centeredLineNumber = endLineNumber;\n        }\n        const endLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(endLineNumber) | 0;\n        let completelyVisibleStartLineNumber = startLineNumber;\n        let completelyVisibleEndLineNumber = endLineNumber;\n        if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n            if (startLineNumberVerticalOffset < verticalOffset1) {\n                completelyVisibleStartLineNumber++;\n            }\n        }\n        if (completelyVisibleStartLineNumber < completelyVisibleEndLineNumber) {\n            if (endLineNumberVerticalOffset + lineHeight > verticalOffset2) {\n                completelyVisibleEndLineNumber--;\n            }\n        }\n        return {\n            bigNumbersDelta: bigNumbersDelta,\n            startLineNumber: startLineNumber,\n            endLineNumber: endLineNumber,\n            relativeVerticalOffset: linesOffsets,\n            centeredLineNumber: centeredLineNumber,\n            completelyVisibleStartLineNumber: completelyVisibleStartLineNumber,\n            completelyVisibleEndLineNumber: completelyVisibleEndLineNumber\n        };\n    }\n    getVerticalOffsetForWhitespaceIndex(whitespaceIndex) {\n        this._checkPendingChanges();\n        whitespaceIndex = whitespaceIndex | 0;\n        const afterLineNumber = this.getAfterLineNumberForWhitespaceIndex(whitespaceIndex);\n        let previousLinesHeight;\n        if (afterLineNumber >= 1) {\n            previousLinesHeight = this._lineHeight * afterLineNumber;\n        }\n        else {\n            previousLinesHeight = 0;\n        }\n        let previousWhitespacesHeight;\n        if (whitespaceIndex > 0) {\n            previousWhitespacesHeight = this.getWhitespacesAccumulatedHeight(whitespaceIndex - 1);\n        }\n        else {\n            previousWhitespacesHeight = 0;\n        }\n        return previousLinesHeight + previousWhitespacesHeight + this._paddingTop;\n    }\n    getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset) {\n        this._checkPendingChanges();\n        verticalOffset = verticalOffset | 0;\n        let minWhitespaceIndex = 0;\n        let maxWhitespaceIndex = this.getWhitespacesCount() - 1;\n        if (maxWhitespaceIndex < 0) {\n            return -1;\n        }\n        // Special case: nothing to be found\n        const maxWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(maxWhitespaceIndex);\n        const maxWhitespaceHeight = this.getHeightForWhitespaceIndex(maxWhitespaceIndex);\n        if (verticalOffset >= maxWhitespaceVerticalOffset + maxWhitespaceHeight) {\n            return -1;\n        }\n        while (minWhitespaceIndex < maxWhitespaceIndex) {\n            const midWhitespaceIndex = Math.floor((minWhitespaceIndex + maxWhitespaceIndex) / 2);\n            const midWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(midWhitespaceIndex);\n            const midWhitespaceHeight = this.getHeightForWhitespaceIndex(midWhitespaceIndex);\n            if (verticalOffset >= midWhitespaceVerticalOffset + midWhitespaceHeight) {\n                // vertical offset is after whitespace\n                minWhitespaceIndex = midWhitespaceIndex + 1;\n            }\n            else if (verticalOffset >= midWhitespaceVerticalOffset) {\n                // Hit\n                return midWhitespaceIndex;\n            }\n            else {\n                // vertical offset is before whitespace, but midWhitespaceIndex might still be what we're searching for\n                maxWhitespaceIndex = midWhitespaceIndex;\n            }\n        }\n        return minWhitespaceIndex;\n    }\n    /**\n     * Get exactly the whitespace that is layouted at `verticalOffset`.\n     *\n     * @param verticalOffset The vertical offset.\n     * @return Precisely the whitespace that is layouted at `verticaloffset` or null.\n     */\n    getWhitespaceAtVerticalOffset(verticalOffset) {\n        this._checkPendingChanges();\n        verticalOffset = verticalOffset | 0;\n        const candidateIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset);\n        if (candidateIndex < 0) {\n            return null;\n        }\n        if (candidateIndex >= this.getWhitespacesCount()) {\n            return null;\n        }\n        const candidateTop = this.getVerticalOffsetForWhitespaceIndex(candidateIndex);\n        if (candidateTop > verticalOffset) {\n            return null;\n        }\n        const candidateHeight = this.getHeightForWhitespaceIndex(candidateIndex);\n        const candidateId = this.getIdForWhitespaceIndex(candidateIndex);\n        const candidateAfterLineNumber = this.getAfterLineNumberForWhitespaceIndex(candidateIndex);\n        return {\n            id: candidateId,\n            afterLineNumber: candidateAfterLineNumber,\n            verticalOffset: candidateTop,\n            height: candidateHeight\n        };\n    }\n    /**\n     * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.\n     *\n     * @param verticalOffset1 The beginning of the viewport.\n     * @param verticalOffset2 The end of the viewport.\n     * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.\n     */\n    getWhitespaceViewportData(verticalOffset1, verticalOffset2) {\n        this._checkPendingChanges();\n        verticalOffset1 = verticalOffset1 | 0;\n        verticalOffset2 = verticalOffset2 | 0;\n        const startIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset1);\n        const endIndex = this.getWhitespacesCount() - 1;\n        if (startIndex < 0) {\n            return [];\n        }\n        const result = [];\n        for (let i = startIndex; i <= endIndex; i++) {\n            const top = this.getVerticalOffsetForWhitespaceIndex(i);\n            const height = this.getHeightForWhitespaceIndex(i);\n            if (top >= verticalOffset2) {\n                break;\n            }\n            result.push({\n                id: this.getIdForWhitespaceIndex(i),\n                afterLineNumber: this.getAfterLineNumberForWhitespaceIndex(i),\n                verticalOffset: top,\n                height: height\n            });\n        }\n        return result;\n    }\n    /**\n     * Get all whitespaces.\n     */\n    getWhitespaces() {\n        this._checkPendingChanges();\n        return this._arr.slice(0);\n    }\n    /**\n     * The number of whitespaces.\n     */\n    getWhitespacesCount() {\n        this._checkPendingChanges();\n        return this._arr.length;\n    }\n    /**\n     * Get the `id` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `id` of whitespace at `index`.\n     */\n    getIdForWhitespaceIndex(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        return this._arr[index].id;\n    }\n    /**\n     * Get the `afterLineNumber` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `afterLineNumber` of whitespace at `index`.\n     */\n    getAfterLineNumberForWhitespaceIndex(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        return this._arr[index].afterLineNumber;\n    }\n    /**\n     * Get the `height` for whitespace at index `index`.\n     *\n     * @param index The index of the whitespace.\n     * @return `height` of whitespace at `index`.\n     */\n    getHeightForWhitespaceIndex(index) {\n        this._checkPendingChanges();\n        index = index | 0;\n        return this._arr[index].height;\n    }\n}\nLinesLayout.INSTANCE_COUNT = 0;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { Scrollable } from '../../../base/common/scrollable.js';\nimport { LinesLayout } from './linesLayout.js';\nimport { Viewport } from '../viewModel/viewModel.js';\nimport { ContentSizeChangedEvent } from '../viewModel/viewModelEventDispatcher.js';\nconst SMOOTH_SCROLLING_TIME = 125;\nclass EditorScrollDimensions {\n    constructor(width, contentWidth, height, contentHeight) {\n        width = width | 0;\n        contentWidth = contentWidth | 0;\n        height = height | 0;\n        contentHeight = contentHeight | 0;\n        if (width < 0) {\n            width = 0;\n        }\n        if (contentWidth < 0) {\n            contentWidth = 0;\n        }\n        if (height < 0) {\n            height = 0;\n        }\n        if (contentHeight < 0) {\n            contentHeight = 0;\n        }\n        this.width = width;\n        this.contentWidth = contentWidth;\n        this.scrollWidth = Math.max(width, contentWidth);\n        this.height = height;\n        this.contentHeight = contentHeight;\n        this.scrollHeight = Math.max(height, contentHeight);\n    }\n    equals(other) {\n        return (this.width === other.width\n            && this.contentWidth === other.contentWidth\n            && this.height === other.height\n            && this.contentHeight === other.contentHeight);\n    }\n}\nclass EditorScrollable extends Disposable {\n    constructor(smoothScrollDuration, scheduleAtNextAnimationFrame) {\n        super();\n        this._onDidContentSizeChange = this._register(new Emitter());\n        this.onDidContentSizeChange = this._onDidContentSizeChange.event;\n        this._dimensions = new EditorScrollDimensions(0, 0, 0, 0);\n        this._scrollable = this._register(new Scrollable({\n            forceIntegerValues: true,\n            smoothScrollDuration,\n            scheduleAtNextAnimationFrame\n        }));\n        this.onDidScroll = this._scrollable.onScroll;\n    }\n    getScrollable() {\n        return this._scrollable;\n    }\n    setSmoothScrollDuration(smoothScrollDuration) {\n        this._scrollable.setSmoothScrollDuration(smoothScrollDuration);\n    }\n    validateScrollPosition(scrollPosition) {\n        return this._scrollable.validateScrollPosition(scrollPosition);\n    }\n    getScrollDimensions() {\n        return this._dimensions;\n    }\n    setScrollDimensions(dimensions) {\n        if (this._dimensions.equals(dimensions)) {\n            return;\n        }\n        const oldDimensions = this._dimensions;\n        this._dimensions = dimensions;\n        this._scrollable.setScrollDimensions({\n            width: dimensions.width,\n            scrollWidth: dimensions.scrollWidth,\n            height: dimensions.height,\n            scrollHeight: dimensions.scrollHeight\n        }, true);\n        const contentWidthChanged = (oldDimensions.contentWidth !== dimensions.contentWidth);\n        const contentHeightChanged = (oldDimensions.contentHeight !== dimensions.contentHeight);\n        if (contentWidthChanged || contentHeightChanged) {\n            this._onDidContentSizeChange.fire(new ContentSizeChangedEvent(oldDimensions.contentWidth, oldDimensions.contentHeight, dimensions.contentWidth, dimensions.contentHeight));\n        }\n    }\n    getFutureScrollPosition() {\n        return this._scrollable.getFutureScrollPosition();\n    }\n    getCurrentScrollPosition() {\n        return this._scrollable.getCurrentScrollPosition();\n    }\n    setScrollPositionNow(update) {\n        this._scrollable.setScrollPositionNow(update);\n    }\n    setScrollPositionSmooth(update) {\n        this._scrollable.setScrollPositionSmooth(update);\n    }\n}\nexport class ViewLayout extends Disposable {\n    constructor(configuration, lineCount, scheduleAtNextAnimationFrame) {\n        super();\n        this._configuration = configuration;\n        const options = this._configuration.options;\n        const layoutInfo = options.get(131 /* layoutInfo */);\n        const padding = options.get(75 /* padding */);\n        this._linesLayout = new LinesLayout(lineCount, options.get(59 /* lineHeight */), padding.top, padding.bottom);\n        this._scrollable = this._register(new EditorScrollable(0, scheduleAtNextAnimationFrame));\n        this._configureSmoothScrollDuration();\n        this._scrollable.setScrollDimensions(new EditorScrollDimensions(layoutInfo.contentWidth, 0, layoutInfo.height, 0));\n        this.onDidScroll = this._scrollable.onDidScroll;\n        this.onDidContentSizeChange = this._scrollable.onDidContentSizeChange;\n        this._updateHeight();\n    }\n    dispose() {\n        super.dispose();\n    }\n    getScrollable() {\n        return this._scrollable.getScrollable();\n    }\n    onHeightMaybeChanged() {\n        this._updateHeight();\n    }\n    _configureSmoothScrollDuration() {\n        this._scrollable.setSmoothScrollDuration(this._configuration.options.get(103 /* smoothScrolling */) ? SMOOTH_SCROLLING_TIME : 0);\n    }\n    // ---- begin view event handlers\n    onConfigurationChanged(e) {\n        const options = this._configuration.options;\n        if (e.hasChanged(59 /* lineHeight */)) {\n            this._linesLayout.setLineHeight(options.get(59 /* lineHeight */));\n        }\n        if (e.hasChanged(75 /* padding */)) {\n            const padding = options.get(75 /* padding */);\n            this._linesLayout.setPadding(padding.top, padding.bottom);\n        }\n        if (e.hasChanged(131 /* layoutInfo */)) {\n            const layoutInfo = options.get(131 /* layoutInfo */);\n            const width = layoutInfo.contentWidth;\n            const height = layoutInfo.height;\n            const scrollDimensions = this._scrollable.getScrollDimensions();\n            const contentWidth = scrollDimensions.contentWidth;\n            this._scrollable.setScrollDimensions(new EditorScrollDimensions(width, scrollDimensions.contentWidth, height, this._getContentHeight(width, height, contentWidth)));\n        }\n        else {\n            this._updateHeight();\n        }\n        if (e.hasChanged(103 /* smoothScrolling */)) {\n            this._configureSmoothScrollDuration();\n        }\n    }\n    onFlushed(lineCount) {\n        this._linesLayout.onFlushed(lineCount);\n    }\n    onLinesDeleted(fromLineNumber, toLineNumber) {\n        this._linesLayout.onLinesDeleted(fromLineNumber, toLineNumber);\n    }\n    onLinesInserted(fromLineNumber, toLineNumber) {\n        this._linesLayout.onLinesInserted(fromLineNumber, toLineNumber);\n    }\n    // ---- end view event handlers\n    _getHorizontalScrollbarHeight(width, scrollWidth) {\n        const options = this._configuration.options;\n        const scrollbar = options.get(92 /* scrollbar */);\n        if (scrollbar.horizontal === 2 /* Hidden */) {\n            // horizontal scrollbar not visible\n            return 0;\n        }\n        if (width >= scrollWidth) {\n            // horizontal scrollbar not visible\n            return 0;\n        }\n        return scrollbar.horizontalScrollbarSize;\n    }\n    _getContentHeight(width, height, contentWidth) {\n        const options = this._configuration.options;\n        let result = this._linesLayout.getLinesTotalHeight();\n        if (options.get(94 /* scrollBeyondLastLine */)) {\n            result += Math.max(0, height - options.get(59 /* lineHeight */) - options.get(75 /* padding */).bottom);\n        }\n        else {\n            result += this._getHorizontalScrollbarHeight(width, contentWidth);\n        }\n        return result;\n    }\n    _updateHeight() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        const width = scrollDimensions.width;\n        const height = scrollDimensions.height;\n        const contentWidth = scrollDimensions.contentWidth;\n        this._scrollable.setScrollDimensions(new EditorScrollDimensions(width, scrollDimensions.contentWidth, height, this._getContentHeight(width, height, contentWidth)));\n    }\n    // ---- Layouting logic\n    getCurrentViewport() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        return new Viewport(currentScrollPosition.scrollTop, currentScrollPosition.scrollLeft, scrollDimensions.width, scrollDimensions.height);\n    }\n    getFutureViewport() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        const currentScrollPosition = this._scrollable.getFutureScrollPosition();\n        return new Viewport(currentScrollPosition.scrollTop, currentScrollPosition.scrollLeft, scrollDimensions.width, scrollDimensions.height);\n    }\n    _computeContentWidth(maxLineWidth) {\n        const options = this._configuration.options;\n        const wrappingInfo = options.get(132 /* wrappingInfo */);\n        const fontInfo = options.get(44 /* fontInfo */);\n        if (wrappingInfo.isViewportWrapping) {\n            const layoutInfo = options.get(131 /* layoutInfo */);\n            const minimap = options.get(65 /* minimap */);\n            if (maxLineWidth > layoutInfo.contentWidth + fontInfo.typicalHalfwidthCharacterWidth) {\n                // This is a case where viewport wrapping is on, but the line extends above the viewport\n                if (minimap.enabled && minimap.side === 'right') {\n                    // We need to accomodate the scrollbar width\n                    return maxLineWidth + layoutInfo.verticalScrollbarWidth;\n                }\n            }\n            return maxLineWidth;\n        }\n        else {\n            const extraHorizontalSpace = options.get(93 /* scrollBeyondLastColumn */) * fontInfo.typicalHalfwidthCharacterWidth;\n            const whitespaceMinWidth = this._linesLayout.getWhitespaceMinWidth();\n            return Math.max(maxLineWidth + extraHorizontalSpace, whitespaceMinWidth);\n        }\n    }\n    setMaxLineWidth(maxLineWidth) {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        // const newScrollWidth = ;\n        this._scrollable.setScrollDimensions(new EditorScrollDimensions(scrollDimensions.width, this._computeContentWidth(maxLineWidth), scrollDimensions.height, scrollDimensions.contentHeight));\n        // The height might depend on the fact that there is a horizontal scrollbar or not\n        this._updateHeight();\n    }\n    // ---- view state\n    saveState() {\n        const currentScrollPosition = this._scrollable.getFutureScrollPosition();\n        const scrollTop = currentScrollPosition.scrollTop;\n        const firstLineNumberInViewport = this._linesLayout.getLineNumberAtOrAfterVerticalOffset(scrollTop);\n        const whitespaceAboveFirstLine = this._linesLayout.getWhitespaceAccumulatedHeightBeforeLineNumber(firstLineNumberInViewport);\n        return {\n            scrollTop: scrollTop,\n            scrollTopWithoutViewZones: scrollTop - whitespaceAboveFirstLine,\n            scrollLeft: currentScrollPosition.scrollLeft\n        };\n    }\n    // ---- IVerticalLayoutProvider\n    changeWhitespace(callback) {\n        const hadAChange = this._linesLayout.changeWhitespace(callback);\n        if (hadAChange) {\n            this.onHeightMaybeChanged();\n        }\n        return hadAChange;\n    }\n    getVerticalOffsetForLineNumber(lineNumber) {\n        return this._linesLayout.getVerticalOffsetForLineNumber(lineNumber);\n    }\n    isAfterLines(verticalOffset) {\n        return this._linesLayout.isAfterLines(verticalOffset);\n    }\n    isInTopPadding(verticalOffset) {\n        return this._linesLayout.isInTopPadding(verticalOffset);\n    }\n    isInBottomPadding(verticalOffset) {\n        return this._linesLayout.isInBottomPadding(verticalOffset);\n    }\n    getLineNumberAtVerticalOffset(verticalOffset) {\n        return this._linesLayout.getLineNumberAtOrAfterVerticalOffset(verticalOffset);\n    }\n    getWhitespaceAtVerticalOffset(verticalOffset) {\n        return this._linesLayout.getWhitespaceAtVerticalOffset(verticalOffset);\n    }\n    getLinesViewportData() {\n        const visibleBox = this.getCurrentViewport();\n        return this._linesLayout.getLinesViewportData(visibleBox.top, visibleBox.top + visibleBox.height);\n    }\n    getLinesViewportDataAtScrollTop(scrollTop) {\n        // do some minimal validations on scrollTop\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        if (scrollTop + scrollDimensions.height > scrollDimensions.scrollHeight) {\n            scrollTop = scrollDimensions.scrollHeight - scrollDimensions.height;\n        }\n        if (scrollTop < 0) {\n            scrollTop = 0;\n        }\n        return this._linesLayout.getLinesViewportData(scrollTop, scrollTop + scrollDimensions.height);\n    }\n    getWhitespaceViewportData() {\n        const visibleBox = this.getCurrentViewport();\n        return this._linesLayout.getWhitespaceViewportData(visibleBox.top, visibleBox.top + visibleBox.height);\n    }\n    getWhitespaces() {\n        return this._linesLayout.getWhitespaces();\n    }\n    // ---- IScrollingProvider\n    getContentWidth() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.contentWidth;\n    }\n    getScrollWidth() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.scrollWidth;\n    }\n    getContentHeight() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.contentHeight;\n    }\n    getScrollHeight() {\n        const scrollDimensions = this._scrollable.getScrollDimensions();\n        return scrollDimensions.scrollHeight;\n    }\n    getCurrentScrollLeft() {\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        return currentScrollPosition.scrollLeft;\n    }\n    getCurrentScrollTop() {\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        return currentScrollPosition.scrollTop;\n    }\n    validateScrollPosition(scrollPosition) {\n        return this._scrollable.validateScrollPosition(scrollPosition);\n    }\n    setScrollPosition(position, type) {\n        if (type === 1 /* Immediate */) {\n            this._scrollable.setScrollPositionNow(position);\n        }\n        else {\n            this._scrollable.setScrollPositionSmooth(position);\n        }\n    }\n    deltaScrollNow(deltaScrollLeft, deltaScrollTop) {\n        const currentScrollPosition = this._scrollable.getCurrentScrollPosition();\n        this._scrollable.setScrollPositionNow({\n            scrollLeft: currentScrollPosition.scrollLeft + deltaScrollLeft,\n            scrollTop: currentScrollPosition.scrollTop + deltaScrollTop\n        });\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { Position } from '../core/position.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport { SingleLineInlineDecoration, ViewLineData } from './viewModel.js';\nexport function createModelLineProjection(lineBreakData, isVisible) {\n    if (lineBreakData === null) {\n        // No mapping needed\n        if (isVisible) {\n            return IdentityModelLineProjection.INSTANCE;\n        }\n        return HiddenModelLineProjection.INSTANCE;\n    }\n    else {\n        return new ModelLineProjection(lineBreakData, isVisible);\n    }\n}\n/**\n * This projection is used to\n * * wrap model lines\n * * inject text\n */\nclass ModelLineProjection {\n    constructor(lineBreakData, isVisible) {\n        this._projectionData = lineBreakData;\n        this._isVisible = isVisible;\n    }\n    isVisible() {\n        return this._isVisible;\n    }\n    setVisible(isVisible) {\n        this._isVisible = isVisible;\n        return this;\n    }\n    getProjectionData() {\n        return this._projectionData;\n    }\n    getViewLineCount() {\n        if (!this._isVisible) {\n            return 0;\n        }\n        return this._projectionData.getOutputLineCount();\n    }\n    getViewLineContent(model, modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        const startOffsetInInputWithInjections = outputLineIndex > 0 ? this._projectionData.breakOffsets[outputLineIndex - 1] : 0;\n        const endOffsetInInputWithInjections = this._projectionData.breakOffsets[outputLineIndex];\n        let r;\n        if (this._projectionData.injectionOffsets !== null) {\n            const injectedTexts = this._projectionData.injectionOffsets.map((offset, idx) => new LineInjectedText(0, 0, offset + 1, this._projectionData.injectionOptions[idx], 0));\n            const lineWithInjections = LineInjectedText.applyInjectedText(model.getLineContent(modelLineNumber), injectedTexts);\n            r = lineWithInjections.substring(startOffsetInInputWithInjections, endOffsetInInputWithInjections);\n        }\n        else {\n            r = model.getValueInRange({\n                startLineNumber: modelLineNumber,\n                startColumn: startOffsetInInputWithInjections + 1,\n                endLineNumber: modelLineNumber,\n                endColumn: endOffsetInInputWithInjections + 1\n            });\n        }\n        if (outputLineIndex > 0) {\n            r = spaces(this._projectionData.wrappedTextIndentLength) + r;\n        }\n        return r;\n    }\n    getViewLineLength(model, modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        return this._projectionData.getLineLength(outputLineIndex);\n    }\n    getViewLineMinColumn(_model, _modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        return this._projectionData.getMinOutputOffset(outputLineIndex) + 1;\n    }\n    getViewLineMaxColumn(model, modelLineNumber, outputLineIndex) {\n        this._assertVisible();\n        return this._projectionData.getMaxOutputOffset(outputLineIndex) + 1;\n    }\n    /**\n     * Try using {@link getViewLinesData} instead.\n    */\n    getViewLineData(model, modelLineNumber, outputLineIndex) {\n        const arr = new Array();\n        this.getViewLinesData(model, modelLineNumber, outputLineIndex, 1, 0, [true], arr);\n        return arr[0];\n    }\n    getViewLinesData(model, modelLineNumber, outputLineIdx, lineCount, globalStartIndex, needed, result) {\n        this._assertVisible();\n        const lineBreakData = this._projectionData;\n        const injectionOffsets = lineBreakData.injectionOffsets;\n        const injectionOptions = lineBreakData.injectionOptions;\n        let inlineDecorationsPerOutputLine = null;\n        if (injectionOffsets) {\n            inlineDecorationsPerOutputLine = [];\n            let totalInjectedTextLengthBefore = 0;\n            let currentInjectedOffset = 0;\n            for (let outputLineIndex = 0; outputLineIndex < lineBreakData.getOutputLineCount(); outputLineIndex++) {\n                const inlineDecorations = new Array();\n                inlineDecorationsPerOutputLine[outputLineIndex] = inlineDecorations;\n                const lineStartOffsetInInputWithInjections = outputLineIndex > 0 ? lineBreakData.breakOffsets[outputLineIndex - 1] : 0;\n                const lineEndOffsetInInputWithInjections = lineBreakData.breakOffsets[outputLineIndex];\n                while (currentInjectedOffset < injectionOffsets.length) {\n                    const length = injectionOptions[currentInjectedOffset].content.length;\n                    const injectedTextStartOffsetInInputWithInjections = injectionOffsets[currentInjectedOffset] + totalInjectedTextLengthBefore;\n                    const injectedTextEndOffsetInInputWithInjections = injectedTextStartOffsetInInputWithInjections + length;\n                    if (injectedTextStartOffsetInInputWithInjections > lineEndOffsetInInputWithInjections) {\n                        // Injected text only starts in later wrapped lines.\n                        break;\n                    }\n                    if (lineStartOffsetInInputWithInjections < injectedTextEndOffsetInInputWithInjections) {\n                        // Injected text ends after or in this line (but also starts in or before this line).\n                        const options = injectionOptions[currentInjectedOffset];\n                        if (options.inlineClassName) {\n                            const offset = (outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength : 0);\n                            const start = offset + Math.max(injectedTextStartOffsetInInputWithInjections - lineStartOffsetInInputWithInjections, 0);\n                            const end = offset + Math.min(injectedTextEndOffsetInInputWithInjections - lineStartOffsetInInputWithInjections, lineEndOffsetInInputWithInjections);\n                            if (start !== end) {\n                                inlineDecorations.push(new SingleLineInlineDecoration(start, end, options.inlineClassName, options.inlineClassNameAffectsLetterSpacing));\n                            }\n                        }\n                    }\n                    if (injectedTextEndOffsetInInputWithInjections <= lineEndOffsetInInputWithInjections) {\n                        totalInjectedTextLengthBefore += length;\n                        currentInjectedOffset++;\n                    }\n                    else {\n                        // injected text breaks into next line, process it again\n                        break;\n                    }\n                }\n            }\n        }\n        let lineWithInjections;\n        if (injectionOffsets) {\n            lineWithInjections = model.getLineTokens(modelLineNumber).withInserted(injectionOffsets.map((offset, idx) => ({\n                offset,\n                text: injectionOptions[idx].content,\n                tokenMetadata: LineTokens.defaultTokenMetadata\n            })));\n        }\n        else {\n            lineWithInjections = model.getLineTokens(modelLineNumber);\n        }\n        for (let outputLineIndex = outputLineIdx; outputLineIndex < outputLineIdx + lineCount; outputLineIndex++) {\n            const globalIndex = globalStartIndex + outputLineIndex - outputLineIdx;\n            if (!needed[globalIndex]) {\n                result[globalIndex] = null;\n                continue;\n            }\n            result[globalIndex] = this._getViewLineData(lineWithInjections, inlineDecorationsPerOutputLine ? inlineDecorationsPerOutputLine[outputLineIndex] : null, outputLineIndex);\n        }\n    }\n    _getViewLineData(lineWithInjections, inlineDecorations, outputLineIndex) {\n        this._assertVisible();\n        const lineBreakData = this._projectionData;\n        const deltaStartIndex = (outputLineIndex > 0 ? lineBreakData.wrappedTextIndentLength : 0);\n        const lineStartOffsetInInputWithInjections = outputLineIndex > 0 ? lineBreakData.breakOffsets[outputLineIndex - 1] : 0;\n        const lineEndOffsetInInputWithInjections = lineBreakData.breakOffsets[outputLineIndex];\n        const tokens = lineWithInjections.sliceAndInflate(lineStartOffsetInInputWithInjections, lineEndOffsetInInputWithInjections, deltaStartIndex);\n        let lineContent = tokens.getLineContent();\n        if (outputLineIndex > 0) {\n            lineContent = spaces(lineBreakData.wrappedTextIndentLength) + lineContent;\n        }\n        const minColumn = this._projectionData.getMinOutputOffset(outputLineIndex) + 1;\n        const maxColumn = lineContent.length + 1;\n        const continuesWithWrappedLine = (outputLineIndex + 1 < this.getViewLineCount());\n        const startVisibleColumn = (outputLineIndex === 0 ? 0 : lineBreakData.breakOffsetsVisibleColumn[outputLineIndex - 1]);\n        return new ViewLineData(lineContent, continuesWithWrappedLine, minColumn, maxColumn, startVisibleColumn, tokens, inlineDecorations);\n    }\n    getModelColumnOfViewPosition(outputLineIndex, outputColumn) {\n        this._assertVisible();\n        return this._projectionData.translateToInputOffset(outputLineIndex, outputColumn - 1) + 1;\n    }\n    getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity = 2 /* None */) {\n        this._assertVisible();\n        const r = this._projectionData.translateToOutputPosition(inputColumn - 1, affinity);\n        return r.toPosition(deltaLineNumber);\n    }\n    getViewLineNumberOfModelPosition(deltaLineNumber, inputColumn) {\n        this._assertVisible();\n        const r = this._projectionData.translateToOutputPosition(inputColumn - 1);\n        return deltaLineNumber + r.outputLineIndex;\n    }\n    normalizePosition(outputLineIndex, outputPosition, affinity) {\n        const baseViewLineNumber = outputPosition.lineNumber - outputLineIndex;\n        const normalizedOutputPosition = this._projectionData.normalizeOutputPosition(outputLineIndex, outputPosition.column - 1, affinity);\n        const result = normalizedOutputPosition.toPosition(baseViewLineNumber);\n        return result;\n    }\n    getInjectedTextAt(outputLineIndex, outputColumn) {\n        return this._projectionData.getInjectedText(outputLineIndex, outputColumn - 1);\n    }\n    _assertVisible() {\n        if (!this._isVisible) {\n            throw new Error('Not supported');\n        }\n    }\n}\n/**\n * This projection does not change the model line.\n*/\nclass IdentityModelLineProjection {\n    constructor() { }\n    isVisible() {\n        return true;\n    }\n    setVisible(isVisible) {\n        if (isVisible) {\n            return this;\n        }\n        return HiddenModelLineProjection.INSTANCE;\n    }\n    getProjectionData() {\n        return null;\n    }\n    getViewLineCount() {\n        return 1;\n    }\n    getViewLineContent(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineContent(modelLineNumber);\n    }\n    getViewLineLength(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineLength(modelLineNumber);\n    }\n    getViewLineMinColumn(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineMinColumn(modelLineNumber);\n    }\n    getViewLineMaxColumn(model, modelLineNumber, _outputLineIndex) {\n        return model.getLineMaxColumn(modelLineNumber);\n    }\n    getViewLineData(model, modelLineNumber, _outputLineIndex) {\n        const lineTokens = model.getLineTokens(modelLineNumber);\n        const lineContent = lineTokens.getLineContent();\n        return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate(), null);\n    }\n    getViewLinesData(model, modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, globalStartIndex, needed, result) {\n        if (!needed[globalStartIndex]) {\n            result[globalStartIndex] = null;\n            return;\n        }\n        result[globalStartIndex] = this.getViewLineData(model, modelLineNumber, 0);\n    }\n    getModelColumnOfViewPosition(_outputLineIndex, outputColumn) {\n        return outputColumn;\n    }\n    getViewPositionOfModelPosition(deltaLineNumber, inputColumn) {\n        return new Position(deltaLineNumber, inputColumn);\n    }\n    getViewLineNumberOfModelPosition(deltaLineNumber, _inputColumn) {\n        return deltaLineNumber;\n    }\n    normalizePosition(outputLineIndex, outputPosition, affinity) {\n        return outputPosition;\n    }\n    getInjectedTextAt(_outputLineIndex, _outputColumn) {\n        return null;\n    }\n}\nIdentityModelLineProjection.INSTANCE = new IdentityModelLineProjection();\n/**\n * This projection hides the model line.\n */\nclass HiddenModelLineProjection {\n    constructor() { }\n    isVisible() {\n        return false;\n    }\n    setVisible(isVisible) {\n        if (!isVisible) {\n            return this;\n        }\n        return IdentityModelLineProjection.INSTANCE;\n    }\n    getProjectionData() {\n        return null;\n    }\n    getViewLineCount() {\n        return 0;\n    }\n    getViewLineContent(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineLength(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineMinColumn(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineMaxColumn(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLineData(_model, _modelLineNumber, _outputLineIndex) {\n        throw new Error('Not supported');\n    }\n    getViewLinesData(_model, _modelLineNumber, _fromOuputLineIndex, _toOutputLineIndex, _globalStartIndex, _needed, _result) {\n        throw new Error('Not supported');\n    }\n    getModelColumnOfViewPosition(_outputLineIndex, _outputColumn) {\n        throw new Error('Not supported');\n    }\n    getViewPositionOfModelPosition(_deltaLineNumber, _inputColumn) {\n        throw new Error('Not supported');\n    }\n    getViewLineNumberOfModelPosition(_deltaLineNumber, _inputColumn) {\n        throw new Error('Not supported');\n    }\n    normalizePosition(outputLineIndex, outputPosition, affinity) {\n        throw new Error('Not supported');\n    }\n    getInjectedTextAt(_outputLineIndex, _outputColumn) {\n        throw new Error('Not supported');\n    }\n}\nHiddenModelLineProjection.INSTANCE = new HiddenModelLineProjection();\nlet _spaces = [''];\nfunction spaces(count) {\n    if (count >= _spaces.length) {\n        for (let i = 1; i <= count; i++) {\n            _spaces[i] = _makeSpaces(i);\n        }\n    }\n    return _spaces[count];\n}\nfunction _makeSpaces(count) {\n    return new Array(count + 1).join(' ');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { ModelDecorationOptions } from '../model/textModel.js';\nimport { LineInjectedText } from '../textModelEvents.js';\nimport * as viewEvents from './viewEvents.js';\nimport { createModelLineProjection } from './modelLineProjection.js';\nimport { ConstantTimePrefixSumComputer } from '../model/prefixSumComputer.js';\nimport { ViewLineData } from './viewModel.js';\nexport class ViewModelLinesFromProjectedModel {\n    constructor(editorId, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, tabSize, wrappingStrategy, wrappingColumn, wrappingIndent) {\n        this._editorId = editorId;\n        this.model = model;\n        this._validModelVersionId = -1;\n        this._domLineBreaksComputerFactory = domLineBreaksComputerFactory;\n        this._monospaceLineBreaksComputerFactory = monospaceLineBreaksComputerFactory;\n        this.fontInfo = fontInfo;\n        this.tabSize = tabSize;\n        this.wrappingStrategy = wrappingStrategy;\n        this.wrappingColumn = wrappingColumn;\n        this.wrappingIndent = wrappingIndent;\n        this._constructLines(/*resetHiddenAreas*/ true, null);\n    }\n    dispose() {\n        this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n    }\n    createCoordinatesConverter() {\n        return new CoordinatesConverter(this);\n    }\n    _constructLines(resetHiddenAreas, previousLineBreaks) {\n        this.modelLineProjections = [];\n        if (resetHiddenAreas) {\n            this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);\n        }\n        const linesContent = this.model.getLinesContent();\n        const injectedTextDecorations = this.model.getInjectedTextDecorations(this._editorId);\n        const lineCount = linesContent.length;\n        const lineBreaksComputer = this.createLineBreaksComputer();\n        const injectedTextQueue = new arrays.ArrayQueue(LineInjectedText.fromDecorations(injectedTextDecorations));\n        for (let i = 0; i < lineCount; i++) {\n            const lineInjectedText = injectedTextQueue.takeWhile(t => t.lineNumber === i + 1);\n            lineBreaksComputer.addRequest(linesContent[i], lineInjectedText, previousLineBreaks ? previousLineBreaks[i] : null);\n        }\n        const linesBreaks = lineBreaksComputer.finalize();\n        const values = [];\n        const hiddenAreas = this.hiddenAreasDecorationIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n        let hiddenAreaStart = 1, hiddenAreaEnd = 0;\n        let hiddenAreaIdx = -1;\n        let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n        for (let i = 0; i < lineCount; i++) {\n            const lineNumber = i + 1;\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n                hiddenAreaIdx++;\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;\n            }\n            const isInHiddenArea = (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd);\n            const line = createModelLineProjection(linesBreaks[i], !isInHiddenArea);\n            values[i] = line.getViewLineCount();\n            this.modelLineProjections[i] = line;\n        }\n        this._validModelVersionId = this.model.getVersionId();\n        this.projectedModelLineLineCounts = new ConstantTimePrefixSumComputer(values);\n    }\n    getHiddenAreas() {\n        return this.hiddenAreasDecorationIds.map((decId) => this.model.getDecorationRange(decId));\n    }\n    setHiddenAreas(_ranges) {\n        const validatedRanges = _ranges.map(r => this.model.validateRange(r));\n        const newRanges = normalizeLineRanges(validatedRanges);\n        // TODO@Martin: Please stop calling this method on each model change!\n        // This checks if there really was a change\n        const oldRanges = this.hiddenAreasDecorationIds.map((areaId) => this.model.getDecorationRange(areaId)).sort(Range.compareRangesUsingStarts);\n        if (newRanges.length === oldRanges.length) {\n            let hasDifference = false;\n            for (let i = 0; i < newRanges.length; i++) {\n                if (!newRanges[i].equalsRange(oldRanges[i])) {\n                    hasDifference = true;\n                    break;\n                }\n            }\n            if (!hasDifference) {\n                return false;\n            }\n        }\n        const newDecorations = newRanges.map((r) => ({\n            range: r,\n            options: ModelDecorationOptions.EMPTY,\n        }));\n        this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, newDecorations);\n        const hiddenAreas = newRanges;\n        let hiddenAreaStart = 1, hiddenAreaEnd = 0;\n        let hiddenAreaIdx = -1;\n        let nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n        let hasVisibleLine = false;\n        for (let i = 0; i < this.modelLineProjections.length; i++) {\n            const lineNumber = i + 1;\n            if (lineNumber === nextLineNumberToUpdateHiddenArea) {\n                hiddenAreaIdx++;\n                hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;\n                hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;\n                nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.modelLineProjections.length + 2;\n            }\n            let lineChanged = false;\n            if (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {\n                // Line should be hidden\n                if (this.modelLineProjections[i].isVisible()) {\n                    this.modelLineProjections[i] = this.modelLineProjections[i].setVisible(false);\n                    lineChanged = true;\n                }\n            }\n            else {\n                hasVisibleLine = true;\n                // Line should be visible\n                if (!this.modelLineProjections[i].isVisible()) {\n                    this.modelLineProjections[i] = this.modelLineProjections[i].setVisible(true);\n                    lineChanged = true;\n                }\n            }\n            if (lineChanged) {\n                const newOutputLineCount = this.modelLineProjections[i].getViewLineCount();\n                this.projectedModelLineLineCounts.setValue(i, newOutputLineCount);\n            }\n        }\n        if (!hasVisibleLine) {\n            // Cannot have everything be hidden => reveal everything!\n            this.setHiddenAreas([]);\n        }\n        return true;\n    }\n    modelPositionIsVisible(modelLineNumber, _modelColumn) {\n        if (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n            // invalid arguments\n            return false;\n        }\n        return this.modelLineProjections[modelLineNumber - 1].isVisible();\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        if (modelLineNumber < 1 || modelLineNumber > this.modelLineProjections.length) {\n            // invalid arguments\n            return 1;\n        }\n        return this.modelLineProjections[modelLineNumber - 1].getViewLineCount();\n    }\n    setTabSize(newTabSize) {\n        if (this.tabSize === newTabSize) {\n            return false;\n        }\n        this.tabSize = newTabSize;\n        this._constructLines(/*resetHiddenAreas*/ false, null);\n        return true;\n    }\n    setWrappingSettings(fontInfo, wrappingStrategy, wrappingColumn, wrappingIndent) {\n        const equalFontInfo = this.fontInfo.equals(fontInfo);\n        const equalWrappingStrategy = (this.wrappingStrategy === wrappingStrategy);\n        const equalWrappingColumn = (this.wrappingColumn === wrappingColumn);\n        const equalWrappingIndent = (this.wrappingIndent === wrappingIndent);\n        if (equalFontInfo && equalWrappingStrategy && equalWrappingColumn && equalWrappingIndent) {\n            return false;\n        }\n        const onlyWrappingColumnChanged = (equalFontInfo && equalWrappingStrategy && !equalWrappingColumn && equalWrappingIndent);\n        this.fontInfo = fontInfo;\n        this.wrappingStrategy = wrappingStrategy;\n        this.wrappingColumn = wrappingColumn;\n        this.wrappingIndent = wrappingIndent;\n        let previousLineBreaks = null;\n        if (onlyWrappingColumnChanged) {\n            previousLineBreaks = [];\n            for (let i = 0, len = this.modelLineProjections.length; i < len; i++) {\n                previousLineBreaks[i] = this.modelLineProjections[i].getProjectionData();\n            }\n        }\n        this._constructLines(/*resetHiddenAreas*/ false, previousLineBreaks);\n        return true;\n    }\n    createLineBreaksComputer() {\n        const lineBreaksComputerFactory = (this.wrappingStrategy === 'advanced'\n            ? this._domLineBreaksComputerFactory\n            : this._monospaceLineBreaksComputerFactory);\n        return lineBreaksComputerFactory.createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent);\n    }\n    onModelFlushed() {\n        this._constructLines(/*resetHiddenAreas*/ true, null);\n    }\n    onModelLinesDeleted(versionId, fromLineNumber, toLineNumber) {\n        if (!versionId || versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return null;\n        }\n        const outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1);\n        const outputToLineNumber = this.projectedModelLineLineCounts.getPrefixSum(toLineNumber);\n        this.modelLineProjections.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n        this.projectedModelLineLineCounts.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);\n        return new viewEvents.ViewLinesDeletedEvent(outputFromLineNumber, outputToLineNumber);\n    }\n    onModelLinesInserted(versionId, fromLineNumber, _toLineNumber, lineBreaks) {\n        if (!versionId || versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return null;\n        }\n        // cannot use this.getHiddenAreas() because those decorations have already seen the effect of this model change\n        const isInHiddenArea = (fromLineNumber > 2 && !this.modelLineProjections[fromLineNumber - 2].isVisible());\n        const outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(fromLineNumber - 1) + 1);\n        let totalOutputLineCount = 0;\n        const insertLines = [];\n        const insertPrefixSumValues = [];\n        for (let i = 0, len = lineBreaks.length; i < len; i++) {\n            const line = createModelLineProjection(lineBreaks[i], !isInHiddenArea);\n            insertLines.push(line);\n            const outputLineCount = line.getViewLineCount();\n            totalOutputLineCount += outputLineCount;\n            insertPrefixSumValues[i] = outputLineCount;\n        }\n        // TODO@Alex: use arrays.arrayInsert\n        this.modelLineProjections =\n            this.modelLineProjections.slice(0, fromLineNumber - 1)\n                .concat(insertLines)\n                .concat(this.modelLineProjections.slice(fromLineNumber - 1));\n        this.projectedModelLineLineCounts.insertValues(fromLineNumber - 1, insertPrefixSumValues);\n        return new viewEvents.ViewLinesInsertedEvent(outputFromLineNumber, outputFromLineNumber + totalOutputLineCount - 1);\n    }\n    onModelLineChanged(versionId, lineNumber, lineBreakData) {\n        if (versionId !== null && versionId <= this._validModelVersionId) {\n            // Here we check for versionId in case the lines were reconstructed in the meantime.\n            // We don't want to apply stale change events on top of a newer read model state.\n            return [false, null, null, null];\n        }\n        const lineIndex = lineNumber - 1;\n        const oldOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n        const isVisible = this.modelLineProjections[lineIndex].isVisible();\n        const line = createModelLineProjection(lineBreakData, isVisible);\n        this.modelLineProjections[lineIndex] = line;\n        const newOutputLineCount = this.modelLineProjections[lineIndex].getViewLineCount();\n        let lineMappingChanged = false;\n        let changeFrom = 0;\n        let changeTo = -1;\n        let insertFrom = 0;\n        let insertTo = -1;\n        let deleteFrom = 0;\n        let deleteTo = -1;\n        if (oldOutputLineCount > newOutputLineCount) {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + newOutputLineCount - 1;\n            deleteFrom = changeTo + 1;\n            deleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;\n            lineMappingChanged = true;\n        }\n        else if (oldOutputLineCount < newOutputLineCount) {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + oldOutputLineCount - 1;\n            insertFrom = changeTo + 1;\n            insertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;\n            lineMappingChanged = true;\n        }\n        else {\n            changeFrom = this.projectedModelLineLineCounts.getPrefixSum(lineNumber - 1) + 1;\n            changeTo = changeFrom + newOutputLineCount - 1;\n        }\n        this.projectedModelLineLineCounts.setValue(lineIndex, newOutputLineCount);\n        const viewLinesChangedEvent = (changeFrom <= changeTo ? new viewEvents.ViewLinesChangedEvent(changeFrom, changeTo) : null);\n        const viewLinesInsertedEvent = (insertFrom <= insertTo ? new viewEvents.ViewLinesInsertedEvent(insertFrom, insertTo) : null);\n        const viewLinesDeletedEvent = (deleteFrom <= deleteTo ? new viewEvents.ViewLinesDeletedEvent(deleteFrom, deleteTo) : null);\n        return [lineMappingChanged, viewLinesChangedEvent, viewLinesInsertedEvent, viewLinesDeletedEvent];\n    }\n    acceptVersionId(versionId) {\n        this._validModelVersionId = versionId;\n        if (this.modelLineProjections.length === 1 && !this.modelLineProjections[0].isVisible()) {\n            // At least one line must be visible => reset hidden areas\n            this.setHiddenAreas([]);\n        }\n    }\n    getViewLineCount() {\n        return this.projectedModelLineLineCounts.getTotalSum();\n    }\n    _toValidViewLineNumber(viewLineNumber) {\n        if (viewLineNumber < 1) {\n            return 1;\n        }\n        const viewLineCount = this.getViewLineCount();\n        if (viewLineNumber > viewLineCount) {\n            return viewLineCount;\n        }\n        return viewLineNumber | 0;\n    }\n    getActiveIndentGuide(viewLineNumber, minLineNumber, maxLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        minLineNumber = this._toValidViewLineNumber(minLineNumber);\n        maxLineNumber = this._toValidViewLineNumber(maxLineNumber);\n        const modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, this.getViewLineMinColumn(viewLineNumber));\n        const modelMinPosition = this.convertViewPositionToModelPosition(minLineNumber, this.getViewLineMinColumn(minLineNumber));\n        const modelMaxPosition = this.convertViewPositionToModelPosition(maxLineNumber, this.getViewLineMinColumn(maxLineNumber));\n        const result = this.model.guides.getActiveIndentGuide(modelPosition.lineNumber, modelMinPosition.lineNumber, modelMaxPosition.lineNumber);\n        const viewStartPosition = this.convertModelPositionToViewPosition(result.startLineNumber, 1);\n        const viewEndPosition = this.convertModelPositionToViewPosition(result.endLineNumber, this.model.getLineMaxColumn(result.endLineNumber));\n        return {\n            startLineNumber: viewStartPosition.lineNumber,\n            endLineNumber: viewEndPosition.lineNumber,\n            indent: result.indent\n        };\n    }\n    // #region ViewLineInfo\n    getViewLineInfo(viewLineNumber) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        const r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n        const lineIndex = r.index;\n        const remainder = r.remainder;\n        return new ViewLineInfo(lineIndex + 1, remainder);\n    }\n    getMinColumnOfViewLine(viewLineInfo) {\n        return this.modelLineProjections[viewLineInfo.modelLineNumber - 1].getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n    }\n    getModelStartPositionOfViewLine(viewLineInfo) {\n        const line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n        const minViewColumn = line.getViewLineMinColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n        const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, minViewColumn);\n        return new Position(viewLineInfo.modelLineNumber, column);\n    }\n    getModelEndPositionOfViewLine(viewLineInfo) {\n        const line = this.modelLineProjections[viewLineInfo.modelLineNumber - 1];\n        const maxViewColumn = line.getViewLineMaxColumn(this.model, viewLineInfo.modelLineNumber, viewLineInfo.modelLineWrappedLineIdx);\n        const column = line.getModelColumnOfViewPosition(viewLineInfo.modelLineWrappedLineIdx, maxViewColumn);\n        return new Position(viewLineInfo.modelLineNumber, column);\n    }\n    getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber) {\n        const startViewLine = this.getViewLineInfo(viewStartLineNumber);\n        const endViewLine = this.getViewLineInfo(viewEndLineNumber);\n        const result = new Array();\n        let lastVisibleModelPos = this.getModelStartPositionOfViewLine(startViewLine);\n        let viewLines = new Array();\n        for (let curModelLine = startViewLine.modelLineNumber; curModelLine <= endViewLine.modelLineNumber; curModelLine++) {\n            const line = this.modelLineProjections[curModelLine - 1];\n            if (line.isVisible()) {\n                const startOffset = curModelLine === startViewLine.modelLineNumber\n                    ? startViewLine.modelLineWrappedLineIdx\n                    : 0;\n                const endOffset = curModelLine === endViewLine.modelLineNumber\n                    ? endViewLine.modelLineWrappedLineIdx + 1\n                    : line.getViewLineCount();\n                for (let i = startOffset; i < endOffset; i++) {\n                    viewLines.push(new ViewLineInfo(curModelLine, i));\n                }\n            }\n            if (!line.isVisible() && lastVisibleModelPos) {\n                const lastVisibleModelPos2 = new Position(curModelLine - 1, this.model.getLineMaxColumn(curModelLine - 1) + 1);\n                const modelRange = Range.fromPositions(lastVisibleModelPos, lastVisibleModelPos2);\n                result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n                viewLines = [];\n                lastVisibleModelPos = null;\n            }\n            else if (line.isVisible() && !lastVisibleModelPos) {\n                lastVisibleModelPos = new Position(curModelLine, 1);\n            }\n        }\n        if (lastVisibleModelPos) {\n            const modelRange = Range.fromPositions(lastVisibleModelPos, this.getModelEndPositionOfViewLine(endViewLine));\n            result.push(new ViewLineInfoGroupedByModelRange(modelRange, viewLines));\n        }\n        return result;\n    }\n    // #endregion\n    getViewLinesBracketGuides(viewStartLineNumber, viewEndLineNumber, activeViewPosition, options) {\n        const modelActivePosition = activeViewPosition ? this.convertViewPositionToModelPosition(activeViewPosition.lineNumber, activeViewPosition.column) : null;\n        const resultPerViewLine = [];\n        for (const group of this.getViewLineInfosGroupedByModelRanges(viewStartLineNumber, viewEndLineNumber)) {\n            const modelRangeStartLineNumber = group.modelRange.startLineNumber;\n            const bracketGuidesPerModelLine = this.model.guides.getLinesBracketGuides(modelRangeStartLineNumber, group.modelRange.endLineNumber, modelActivePosition, options);\n            for (const viewLineInfo of group.viewLines) {\n                if (viewLineInfo.isWrappedLineContinuation && this.getMinColumnOfViewLine(viewLineInfo) === 1) {\n                    // Don't add indent guides when the wrapped line continuation has no wrapping-indentation.\n                    resultPerViewLine.push([]);\n                }\n                else {\n                    let bracketGuides = bracketGuidesPerModelLine[viewLineInfo.modelLineNumber - modelRangeStartLineNumber];\n                    // visibleColumns stay as they are (this is a bug and needs to be fixed, but it is not a regression)\n                    // model-columns must be converted to view-model columns.\n                    bracketGuides = bracketGuides.map(g => g.horizontalLine ?\n                        new IndentGuide(g.visibleColumn, g.className, new IndentGuideHorizontalLine(g.horizontalLine.top, this.convertModelPositionToViewPosition(viewLineInfo.modelLineNumber, g.horizontalLine.endColumn).column)) : g);\n                    resultPerViewLine.push(bracketGuides);\n                }\n            }\n        }\n        return resultPerViewLine;\n    }\n    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n        // TODO: Use the same code as in `getViewLinesBracketGuides`.\n        // Future TODO: Merge with `getViewLinesBracketGuides`.\n        // However, this requires more refactoring of indent guides.\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n        const modelStart = this.convertViewPositionToModelPosition(viewStartLineNumber, this.getViewLineMinColumn(viewStartLineNumber));\n        const modelEnd = this.convertViewPositionToModelPosition(viewEndLineNumber, this.getViewLineMaxColumn(viewEndLineNumber));\n        let result = [];\n        const resultRepeatCount = [];\n        const resultRepeatOption = [];\n        const modelStartLineIndex = modelStart.lineNumber - 1;\n        const modelEndLineIndex = modelEnd.lineNumber - 1;\n        let reqStart = null;\n        for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (line.isVisible()) {\n                const viewLineStartIndex = line.getViewLineNumberOfModelPosition(0, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n                const viewLineEndIndex = line.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(modelLineIndex + 1));\n                const count = viewLineEndIndex - viewLineStartIndex + 1;\n                let option = 0 /* BlockNone */;\n                if (count > 1 && line.getViewLineMinColumn(this.model, modelLineIndex + 1, viewLineEndIndex) === 1) {\n                    // wrapped lines should block indent guides\n                    option = (viewLineStartIndex === 0 ? 1 /* BlockSubsequent */ : 2 /* BlockAll */);\n                }\n                resultRepeatCount.push(count);\n                resultRepeatOption.push(option);\n                // merge into previous request\n                if (reqStart === null) {\n                    reqStart = new Position(modelLineIndex + 1, 0);\n                }\n            }\n            else {\n                // hit invisible line => flush request\n                if (reqStart !== null) {\n                    result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelLineIndex));\n                    reqStart = null;\n                }\n            }\n        }\n        if (reqStart !== null) {\n            result = result.concat(this.model.guides.getLinesIndentGuides(reqStart.lineNumber, modelEnd.lineNumber));\n            reqStart = null;\n        }\n        const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n        const viewIndents = new Array(viewLineCount);\n        let currIndex = 0;\n        for (let i = 0, len = result.length; i < len; i++) {\n            let value = result[i];\n            const count = Math.min(viewLineCount - currIndex, resultRepeatCount[i]);\n            const option = resultRepeatOption[i];\n            let blockAtIndex;\n            if (option === 2 /* BlockAll */) {\n                blockAtIndex = 0;\n            }\n            else if (option === 1 /* BlockSubsequent */) {\n                blockAtIndex = 1;\n            }\n            else {\n                blockAtIndex = count;\n            }\n            for (let j = 0; j < count; j++) {\n                if (j === blockAtIndex) {\n                    value = 0;\n                }\n                viewIndents[currIndex++] = value;\n            }\n        }\n        return viewIndents;\n    }\n    getViewLineContent(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineContent(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineLength(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineLength(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineMinColumn(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineMinColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineMaxColumn(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineMaxColumn(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLineData(viewLineNumber) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getViewLineData(this.model, info.modelLineNumber, info.modelLineWrappedLineIdx);\n    }\n    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n        viewStartLineNumber = this._toValidViewLineNumber(viewStartLineNumber);\n        viewEndLineNumber = this._toValidViewLineNumber(viewEndLineNumber);\n        const start = this.projectedModelLineLineCounts.getIndexOf(viewStartLineNumber - 1);\n        let viewLineNumber = viewStartLineNumber;\n        const startModelLineIndex = start.index;\n        const startRemainder = start.remainder;\n        const result = [];\n        for (let modelLineIndex = startModelLineIndex, len = this.model.getLineCount(); modelLineIndex < len; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (!line.isVisible()) {\n                continue;\n            }\n            const fromViewLineIndex = (modelLineIndex === startModelLineIndex ? startRemainder : 0);\n            let remainingViewLineCount = line.getViewLineCount() - fromViewLineIndex;\n            let lastLine = false;\n            if (viewLineNumber + remainingViewLineCount > viewEndLineNumber) {\n                lastLine = true;\n                remainingViewLineCount = viewEndLineNumber - viewLineNumber + 1;\n            }\n            line.getViewLinesData(this.model, modelLineIndex + 1, fromViewLineIndex, remainingViewLineCount, viewLineNumber - viewStartLineNumber, needed, result);\n            viewLineNumber += remainingViewLineCount;\n            if (lastLine) {\n                break;\n            }\n        }\n        return result;\n    }\n    validateViewPosition(viewLineNumber, viewColumn, expectedModelPosition) {\n        viewLineNumber = this._toValidViewLineNumber(viewLineNumber);\n        const r = this.projectedModelLineLineCounts.getIndexOf(viewLineNumber - 1);\n        const lineIndex = r.index;\n        const remainder = r.remainder;\n        const line = this.modelLineProjections[lineIndex];\n        const minColumn = line.getViewLineMinColumn(this.model, lineIndex + 1, remainder);\n        const maxColumn = line.getViewLineMaxColumn(this.model, lineIndex + 1, remainder);\n        if (viewColumn < minColumn) {\n            viewColumn = minColumn;\n        }\n        if (viewColumn > maxColumn) {\n            viewColumn = maxColumn;\n        }\n        const computedModelColumn = line.getModelColumnOfViewPosition(remainder, viewColumn);\n        const computedModelPosition = this.model.validatePosition(new Position(lineIndex + 1, computedModelColumn));\n        if (computedModelPosition.equals(expectedModelPosition)) {\n            return new Position(viewLineNumber, viewColumn);\n        }\n        return this.convertModelPositionToViewPosition(expectedModelPosition.lineNumber, expectedModelPosition.column);\n    }\n    validateViewRange(viewRange, expectedModelRange) {\n        const validViewStart = this.validateViewPosition(viewRange.startLineNumber, viewRange.startColumn, expectedModelRange.getStartPosition());\n        const validViewEnd = this.validateViewPosition(viewRange.endLineNumber, viewRange.endColumn, expectedModelRange.getEndPosition());\n        return new Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);\n    }\n    convertViewPositionToModelPosition(viewLineNumber, viewColumn) {\n        const info = this.getViewLineInfo(viewLineNumber);\n        const inputColumn = this.modelLineProjections[info.modelLineNumber - 1].getModelColumnOfViewPosition(info.modelLineWrappedLineIdx, viewColumn);\n        // console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);\n        return this.model.validatePosition(new Position(info.modelLineNumber, inputColumn));\n    }\n    convertViewRangeToModelRange(viewRange) {\n        const start = this.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);\n        const end = this.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    convertModelPositionToViewPosition(_modelLineNumber, _modelColumn, affinity = 2 /* None */) {\n        const validPosition = this.model.validatePosition(new Position(_modelLineNumber, _modelColumn));\n        const inputLineNumber = validPosition.lineNumber;\n        const inputColumn = validPosition.column;\n        let lineIndex = inputLineNumber - 1, lineIndexChanged = false;\n        while (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            lineIndex--;\n            lineIndexChanged = true;\n        }\n        if (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            // Could not reach a real line\n            // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);\n            return new Position(1, 1);\n        }\n        const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n        let r;\n        if (lineIndexChanged) {\n            r = this.modelLineProjections[lineIndex].getViewPositionOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1), affinity);\n        }\n        else {\n            r = this.modelLineProjections[inputLineNumber - 1].getViewPositionOfModelPosition(deltaLineNumber, inputColumn, affinity);\n        }\n        // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);\n        return r;\n    }\n    /**\n     * @param affinity The affinity in case of an empty range. Has no effect for non-empty ranges.\n    */\n    convertModelRangeToViewRange(modelRange, affinity = 0 /* Left */) {\n        if (modelRange.isEmpty()) {\n            const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, affinity);\n            return Range.fromPositions(start);\n        }\n        else {\n            const start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn, 1 /* Right */);\n            const end = this.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn, 0 /* Left */);\n            return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n        }\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        let lineIndex = modelLineNumber - 1;\n        if (this.modelLineProjections[lineIndex].isVisible()) {\n            // this model line is visible\n            const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n            return this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, modelColumn);\n        }\n        // this model line is not visible\n        while (lineIndex > 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            lineIndex--;\n        }\n        if (lineIndex === 0 && !this.modelLineProjections[lineIndex].isVisible()) {\n            // Could not reach a real line\n            return 1;\n        }\n        const deltaLineNumber = 1 + this.projectedModelLineLineCounts.getPrefixSum(lineIndex);\n        return this.modelLineProjections[lineIndex].getViewLineNumberOfModelPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));\n    }\n    getDecorationsInRange(range, ownerId, filterOutValidation) {\n        const modelStart = this.convertViewPositionToModelPosition(range.startLineNumber, range.startColumn);\n        const modelEnd = this.convertViewPositionToModelPosition(range.endLineNumber, range.endColumn);\n        if (modelEnd.lineNumber - modelStart.lineNumber <= range.endLineNumber - range.startLineNumber) {\n            // most likely there are no hidden lines => fast path\n            // fetch decorations from column 1 to cover the case of wrapped lines that have whole line decorations at column 1\n            return this.model.getDecorationsInRange(new Range(modelStart.lineNumber, 1, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation);\n        }\n        let result = [];\n        const modelStartLineIndex = modelStart.lineNumber - 1;\n        const modelEndLineIndex = modelEnd.lineNumber - 1;\n        let reqStart = null;\n        for (let modelLineIndex = modelStartLineIndex; modelLineIndex <= modelEndLineIndex; modelLineIndex++) {\n            const line = this.modelLineProjections[modelLineIndex];\n            if (line.isVisible()) {\n                // merge into previous request\n                if (reqStart === null) {\n                    reqStart = new Position(modelLineIndex + 1, modelLineIndex === modelStartLineIndex ? modelStart.column : 1);\n                }\n            }\n            else {\n                // hit invisible line => flush request\n                if (reqStart !== null) {\n                    const maxLineColumn = this.model.getLineMaxColumn(modelLineIndex);\n                    result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelLineIndex, maxLineColumn), ownerId, filterOutValidation));\n                    reqStart = null;\n                }\n            }\n        }\n        if (reqStart !== null) {\n            result = result.concat(this.model.getDecorationsInRange(new Range(reqStart.lineNumber, reqStart.column, modelEnd.lineNumber, modelEnd.column), ownerId, filterOutValidation));\n            reqStart = null;\n        }\n        result.sort((a, b) => {\n            const res = Range.compareRangesUsingStarts(a.range, b.range);\n            if (res === 0) {\n                if (a.id < b.id) {\n                    return -1;\n                }\n                if (a.id > b.id) {\n                    return 1;\n                }\n                return 0;\n            }\n            return res;\n        });\n        // Eliminate duplicate decorations that might have intersected our visible ranges multiple times\n        let finalResult = [], finalResultLen = 0;\n        let prevDecId = null;\n        for (const dec of result) {\n            const decId = dec.id;\n            if (prevDecId === decId) {\n                // skip\n                continue;\n            }\n            prevDecId = decId;\n            finalResult[finalResultLen++] = dec;\n        }\n        return finalResult;\n    }\n    getInjectedTextAt(position) {\n        const info = this.getViewLineInfo(position.lineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].getInjectedTextAt(info.modelLineWrappedLineIdx, position.column);\n    }\n    normalizePosition(position, affinity) {\n        const info = this.getViewLineInfo(position.lineNumber);\n        return this.modelLineProjections[info.modelLineNumber - 1].normalizePosition(info.modelLineWrappedLineIdx, position, affinity);\n    }\n    getLineIndentColumn(lineNumber) {\n        const info = this.getViewLineInfo(lineNumber);\n        if (info.modelLineWrappedLineIdx === 0) {\n            return this.model.getLineIndentColumn(info.modelLineNumber);\n        }\n        // wrapped lines have no indentation.\n        // We deliberately don't handle the case that indentation is wrapped\n        // to avoid two view lines reporting indentation for the very same model line.\n        return 0;\n    }\n}\n/**\n * Overlapping unsorted ranges:\n * [   )      [ )       [  )\n *    [    )      [       )\n * ->\n * Non overlapping sorted ranges:\n * [       )  [ ) [        )\n *\n * Note: This function only considers line information! Columns are ignored.\n*/\nfunction normalizeLineRanges(ranges) {\n    if (ranges.length === 0) {\n        return [];\n    }\n    const sortedRanges = ranges.slice();\n    sortedRanges.sort(Range.compareRangesUsingStarts);\n    const result = [];\n    let currentRangeStart = sortedRanges[0].startLineNumber;\n    let currentRangeEnd = sortedRanges[0].endLineNumber;\n    for (let i = 1, len = sortedRanges.length; i < len; i++) {\n        const range = sortedRanges[i];\n        if (range.startLineNumber > currentRangeEnd + 1) {\n            result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n            currentRangeStart = range.startLineNumber;\n            currentRangeEnd = range.endLineNumber;\n        }\n        else if (range.endLineNumber > currentRangeEnd) {\n            currentRangeEnd = range.endLineNumber;\n        }\n    }\n    result.push(new Range(currentRangeStart, 1, currentRangeEnd, 1));\n    return result;\n}\n/**\n * Represents a view line. Can be used to efficiently query more information about it.\n */\nclass ViewLineInfo {\n    constructor(modelLineNumber, modelLineWrappedLineIdx) {\n        this.modelLineNumber = modelLineNumber;\n        this.modelLineWrappedLineIdx = modelLineWrappedLineIdx;\n    }\n    get isWrappedLineContinuation() {\n        return this.modelLineWrappedLineIdx > 0;\n    }\n}\n/**\n * A list of view lines that have a contiguous span in the model.\n*/\nclass ViewLineInfoGroupedByModelRange {\n    constructor(modelRange, viewLines) {\n        this.modelRange = modelRange;\n        this.viewLines = viewLines;\n    }\n}\nclass CoordinatesConverter {\n    constructor(lines) {\n        this._lines = lines;\n    }\n    // View -> Model conversion and related methods\n    convertViewPositionToModelPosition(viewPosition) {\n        return this._lines.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);\n    }\n    convertViewRangeToModelRange(viewRange) {\n        return this._lines.convertViewRangeToModelRange(viewRange);\n    }\n    validateViewPosition(viewPosition, expectedModelPosition) {\n        return this._lines.validateViewPosition(viewPosition.lineNumber, viewPosition.column, expectedModelPosition);\n    }\n    validateViewRange(viewRange, expectedModelRange) {\n        return this._lines.validateViewRange(viewRange, expectedModelRange);\n    }\n    // Model -> View conversion and related methods\n    convertModelPositionToViewPosition(modelPosition, affinity) {\n        return this._lines.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column, affinity);\n    }\n    convertModelRangeToViewRange(modelRange, affinity) {\n        return this._lines.convertModelRangeToViewRange(modelRange, affinity);\n    }\n    modelPositionIsVisible(modelPosition) {\n        return this._lines.modelPositionIsVisible(modelPosition.lineNumber, modelPosition.column);\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        return this._lines.getModelLineViewLineCount(modelLineNumber);\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        return this._lines.getViewLineNumberOfModelPosition(modelLineNumber, modelColumn);\n    }\n}\nexport class ViewModelLinesFromModelAsIs {\n    constructor(model) {\n        this.model = model;\n    }\n    dispose() {\n    }\n    createCoordinatesConverter() {\n        return new IdentityCoordinatesConverter(this);\n    }\n    getHiddenAreas() {\n        return [];\n    }\n    setHiddenAreas(_ranges) {\n        return false;\n    }\n    setTabSize(_newTabSize) {\n        return false;\n    }\n    setWrappingSettings(_fontInfo, _wrappingStrategy, _wrappingColumn, _wrappingIndent) {\n        return false;\n    }\n    createLineBreaksComputer() {\n        const result = [];\n        return {\n            addRequest: (lineText, injectedText, previousLineBreakData) => {\n                result.push(null);\n            },\n            finalize: () => {\n                return result;\n            }\n        };\n    }\n    onModelFlushed() {\n    }\n    onModelLinesDeleted(_versionId, fromLineNumber, toLineNumber) {\n        return new viewEvents.ViewLinesDeletedEvent(fromLineNumber, toLineNumber);\n    }\n    onModelLinesInserted(_versionId, fromLineNumber, toLineNumber, lineBreaks) {\n        return new viewEvents.ViewLinesInsertedEvent(fromLineNumber, toLineNumber);\n    }\n    onModelLineChanged(_versionId, lineNumber, lineBreakData) {\n        return [false, new viewEvents.ViewLinesChangedEvent(lineNumber, lineNumber), null, null];\n    }\n    acceptVersionId(_versionId) {\n    }\n    getViewLineCount() {\n        return this.model.getLineCount();\n    }\n    getActiveIndentGuide(viewLineNumber, _minLineNumber, _maxLineNumber) {\n        return {\n            startLineNumber: viewLineNumber,\n            endLineNumber: viewLineNumber,\n            indent: 0\n        };\n    }\n    getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition) {\n        return new Array(endLineNumber - startLineNumber + 1).fill([]);\n    }\n    getViewLinesIndentGuides(viewStartLineNumber, viewEndLineNumber) {\n        const viewLineCount = viewEndLineNumber - viewStartLineNumber + 1;\n        const result = new Array(viewLineCount);\n        for (let i = 0; i < viewLineCount; i++) {\n            result[i] = 0;\n        }\n        return result;\n    }\n    getViewLineContent(viewLineNumber) {\n        return this.model.getLineContent(viewLineNumber);\n    }\n    getViewLineLength(viewLineNumber) {\n        return this.model.getLineLength(viewLineNumber);\n    }\n    getViewLineMinColumn(viewLineNumber) {\n        return this.model.getLineMinColumn(viewLineNumber);\n    }\n    getViewLineMaxColumn(viewLineNumber) {\n        return this.model.getLineMaxColumn(viewLineNumber);\n    }\n    getViewLineData(viewLineNumber) {\n        const lineTokens = this.model.getLineTokens(viewLineNumber);\n        const lineContent = lineTokens.getLineContent();\n        return new ViewLineData(lineContent, false, 1, lineContent.length + 1, 0, lineTokens.inflate(), null);\n    }\n    getViewLinesData(viewStartLineNumber, viewEndLineNumber, needed) {\n        const lineCount = this.model.getLineCount();\n        viewStartLineNumber = Math.min(Math.max(1, viewStartLineNumber), lineCount);\n        viewEndLineNumber = Math.min(Math.max(1, viewEndLineNumber), lineCount);\n        const result = [];\n        for (let lineNumber = viewStartLineNumber; lineNumber <= viewEndLineNumber; lineNumber++) {\n            const idx = lineNumber - viewStartLineNumber;\n            result[idx] = needed[idx] ? this.getViewLineData(lineNumber) : null;\n        }\n        return result;\n    }\n    getDecorationsInRange(range, ownerId, filterOutValidation) {\n        return this.model.getDecorationsInRange(range, ownerId, filterOutValidation);\n    }\n    normalizePosition(position, affinity) {\n        return this.model.normalizePosition(position, affinity);\n    }\n    getLineIndentColumn(lineNumber) {\n        return this.model.getLineIndentColumn(lineNumber);\n    }\n    getInjectedTextAt(position) {\n        // Identity lines collection does not support injected text.\n        return null;\n    }\n}\nclass IdentityCoordinatesConverter {\n    constructor(lines) {\n        this._lines = lines;\n    }\n    _validPosition(pos) {\n        return this._lines.model.validatePosition(pos);\n    }\n    _validRange(range) {\n        return this._lines.model.validateRange(range);\n    }\n    // View -> Model conversion and related methods\n    convertViewPositionToModelPosition(viewPosition) {\n        return this._validPosition(viewPosition);\n    }\n    convertViewRangeToModelRange(viewRange) {\n        return this._validRange(viewRange);\n    }\n    validateViewPosition(_viewPosition, expectedModelPosition) {\n        return this._validPosition(expectedModelPosition);\n    }\n    validateViewRange(_viewRange, expectedModelRange) {\n        return this._validRange(expectedModelRange);\n    }\n    // Model -> View conversion and related methods\n    convertModelPositionToViewPosition(modelPosition) {\n        return this._validPosition(modelPosition);\n    }\n    convertModelRangeToViewRange(modelRange) {\n        return this._validRange(modelRange);\n    }\n    modelPositionIsVisible(modelPosition) {\n        const lineCount = this._lines.model.getLineCount();\n        if (modelPosition.lineNumber < 1 || modelPosition.lineNumber > lineCount) {\n            // invalid arguments\n            return false;\n        }\n        return true;\n    }\n    getModelLineViewLineCount(modelLineNumber) {\n        return 1;\n    }\n    getViewLineNumberOfModelPosition(modelLineNumber, modelColumn) {\n        return modelLineNumber;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue } from '../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Color } from '../../../base/common/color.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { EDITOR_FONT_DEFAULTS, filterValidationDecorations } from '../config/editorOptions.js';\nimport { CursorsController } from '../cursor/cursor.js';\nimport { CursorConfiguration } from '../cursor/cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport * as textModelEvents from '../textModelEvents.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { tokenizeLineToHTML } from '../languages/textToHtmlTokenizer.js';\nimport * as viewEvents from './viewEvents.js';\nimport { ViewLayout } from '../viewLayout/viewLayout.js';\nimport { MinimapTokensColorTracker } from './minimapTokensColorTracker.js';\nimport { MinimapLinesRenderingData, OverviewRulerDecorationsGroup, ViewLineRenderingData } from './viewModel.js';\nimport { ViewModelDecorations } from './viewModelDecorations.js';\nimport { FocusChangedEvent, ReadOnlyEditAttemptEvent, ScrollChangedEvent, ViewModelEventDispatcher, ViewZonesChangedEvent } from './viewModelEventDispatcher.js';\nimport { ViewModelLinesFromModelAsIs, ViewModelLinesFromProjectedModel } from './viewModelLines.js';\nconst USE_IDENTITY_LINES_COLLECTION = true;\nexport class ViewModel extends Disposable {\n    constructor(editorId, configuration, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, scheduleAtNextAnimationFrame, languageConfigurationService) {\n        super();\n        this.languageConfigurationService = languageConfigurationService;\n        this._editorId = editorId;\n        this._configuration = configuration;\n        this.model = model;\n        this._eventDispatcher = new ViewModelEventDispatcher();\n        this.onEvent = this._eventDispatcher.onEvent;\n        this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n        this._tokenizeViewportSoon = this._register(new RunOnceScheduler(() => this.tokenizeViewport(), 50));\n        this._updateConfigurationViewLineCount = this._register(new RunOnceScheduler(() => this._updateConfigurationViewLineCountNow(), 0));\n        this._hasFocus = false;\n        this._viewportStartLine = -1;\n        this._viewportStartLineTrackedRange = null;\n        this._viewportStartLineDelta = 0;\n        if (USE_IDENTITY_LINES_COLLECTION && this.model.isTooLargeForTokenization()) {\n            this._lines = new ViewModelLinesFromModelAsIs(this.model);\n        }\n        else {\n            const options = this._configuration.options;\n            const fontInfo = options.get(44 /* fontInfo */);\n            const wrappingStrategy = options.get(125 /* wrappingStrategy */);\n            const wrappingInfo = options.get(132 /* wrappingInfo */);\n            const wrappingIndent = options.get(124 /* wrappingIndent */);\n            this._lines = new ViewModelLinesFromProjectedModel(this._editorId, this.model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, this.model.getOptions().tabSize, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent);\n        }\n        this.coordinatesConverter = this._lines.createCoordinatesConverter();\n        this._cursor = this._register(new CursorsController(model, this, this.coordinatesConverter, this.cursorConfig));\n        this.viewLayout = this._register(new ViewLayout(this._configuration, this.getLineCount(), scheduleAtNextAnimationFrame));\n        this._register(this.viewLayout.onDidScroll((e) => {\n            if (e.scrollTopChanged) {\n                this._tokenizeViewportSoon.schedule();\n            }\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewScrollChangedEvent(e));\n            this._eventDispatcher.emitOutgoingEvent(new ScrollChangedEvent(e.oldScrollWidth, e.oldScrollLeft, e.oldScrollHeight, e.oldScrollTop, e.scrollWidth, e.scrollLeft, e.scrollHeight, e.scrollTop));\n        }));\n        this._register(this.viewLayout.onDidContentSizeChange((e) => {\n            this._eventDispatcher.emitOutgoingEvent(e);\n        }));\n        this._decorations = new ViewModelDecorations(this._editorId, this.model, this._configuration, this._lines, this.coordinatesConverter);\n        this._registerModelEvents();\n        this._register(this._configuration.onDidChangeFast((e) => {\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                this._onConfigurationChanged(eventsCollector, e);\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n        }));\n        this._register(MinimapTokensColorTracker.getInstance().onDidChange(() => {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensColorsChangedEvent());\n        }));\n        this._updateConfigurationViewLineCountNow();\n    }\n    dispose() {\n        // First remove listeners, as disposing the lines might end up sending\n        // model decoration changed events ... and we no longer care about them ...\n        super.dispose();\n        this._decorations.dispose();\n        this._lines.dispose();\n        this.invalidateMinimapColorCache();\n        this._viewportStartLineTrackedRange = this.model._setTrackedRange(this._viewportStartLineTrackedRange, null, 1 /* NeverGrowsWhenTypingAtEdges */);\n        this._eventDispatcher.dispose();\n    }\n    createLineBreaksComputer() {\n        return this._lines.createLineBreaksComputer();\n    }\n    addViewEventHandler(eventHandler) {\n        this._eventDispatcher.addViewEventHandler(eventHandler);\n    }\n    removeViewEventHandler(eventHandler) {\n        this._eventDispatcher.removeViewEventHandler(eventHandler);\n    }\n    _updateConfigurationViewLineCountNow() {\n        this._configuration.setViewLineCount(this._lines.getViewLineCount());\n    }\n    tokenizeViewport() {\n        const linesViewportData = this.viewLayout.getLinesViewportData();\n        const viewVisibleRange = new Range(linesViewportData.startLineNumber, this.getLineMinColumn(linesViewportData.startLineNumber), linesViewportData.endLineNumber, this.getLineMaxColumn(linesViewportData.endLineNumber));\n        const modelVisibleRanges = this._toModelVisibleRanges(viewVisibleRange);\n        for (const modelVisibleRange of modelVisibleRanges) {\n            this.model.tokenizeViewport(modelVisibleRange.startLineNumber, modelVisibleRange.endLineNumber);\n        }\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n        this._cursor.setHasFocus(hasFocus);\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewFocusChangedEvent(hasFocus));\n        this._eventDispatcher.emitOutgoingEvent(new FocusChangedEvent(!hasFocus, hasFocus));\n    }\n    onCompositionStart() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionStartEvent());\n    }\n    onCompositionEnd() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionEndEvent());\n    }\n    onDidColorThemeChange() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewThemeChangedEvent());\n    }\n    _onConfigurationChanged(eventsCollector, e) {\n        // We might need to restore the current centered view range, so save it (if available)\n        let previousViewportStartModelPosition = null;\n        if (this._viewportStartLine !== -1) {\n            const previousViewportStartViewPosition = new Position(this._viewportStartLine, this.getLineMinColumn(this._viewportStartLine));\n            previousViewportStartModelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(previousViewportStartViewPosition);\n        }\n        let restorePreviousViewportStart = false;\n        const options = this._configuration.options;\n        const fontInfo = options.get(44 /* fontInfo */);\n        const wrappingStrategy = options.get(125 /* wrappingStrategy */);\n        const wrappingInfo = options.get(132 /* wrappingInfo */);\n        const wrappingIndent = options.get(124 /* wrappingIndent */);\n        if (this._lines.setWrappingSettings(fontInfo, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent)) {\n            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n            eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n            this._cursor.onLineMappingChanged(eventsCollector);\n            this._decorations.onLineMappingChanged();\n            this.viewLayout.onFlushed(this.getLineCount());\n            if (this.viewLayout.getCurrentScrollTop() !== 0) {\n                // Never change the scroll position from 0 to something else...\n                restorePreviousViewportStart = true;\n            }\n            this._updateConfigurationViewLineCount.schedule();\n        }\n        if (e.hasChanged(81 /* readOnly */)) {\n            // Must read again all decorations due to readOnly filtering\n            this._decorations.reset();\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n        }\n        eventsCollector.emitViewEvent(new viewEvents.ViewConfigurationChangedEvent(e));\n        this.viewLayout.onConfigurationChanged(e);\n        if (restorePreviousViewportStart && previousViewportStartModelPosition) {\n            const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(previousViewportStartModelPosition);\n            const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n            this.viewLayout.setScrollPosition({ scrollTop: viewPositionTop + this._viewportStartLineDelta }, 1 /* Immediate */);\n        }\n        if (CursorConfiguration.shouldRecreate(e)) {\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n        }\n    }\n    _registerModelEvents() {\n        this._register(this.model.onDidChangeContentOrInjectedText((e) => {\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                let hadOtherModelChange = false;\n                let hadModelLineChangeThatChangedLineMapping = false;\n                const changes = e.changes;\n                const versionId = (e instanceof textModelEvents.ModelRawContentChangedEvent ? e.versionId : null);\n                // Do a first pass to compute line mappings, and a second pass to actually interpret them\n                const lineBreaksComputer = this._lines.createLineBreaksComputer();\n                for (const change of changes) {\n                    switch (change.changeType) {\n                        case 4 /* LinesInserted */: {\n                            for (let lineIdx = 0; lineIdx < change.detail.length; lineIdx++) {\n                                const line = change.detail[lineIdx];\n                                let injectedText = change.injectedTexts[lineIdx];\n                                if (injectedText) {\n                                    injectedText = injectedText.filter(element => (!element.ownerId || element.ownerId === this._editorId));\n                                }\n                                lineBreaksComputer.addRequest(line, injectedText, null);\n                            }\n                            break;\n                        }\n                        case 2 /* LineChanged */: {\n                            let injectedText = null;\n                            if (change.injectedText) {\n                                injectedText = change.injectedText.filter(element => (!element.ownerId || element.ownerId === this._editorId));\n                            }\n                            lineBreaksComputer.addRequest(change.detail, injectedText, null);\n                            break;\n                        }\n                    }\n                }\n                const lineBreaks = lineBreaksComputer.finalize();\n                const lineBreakQueue = new ArrayQueue(lineBreaks);\n                for (const change of changes) {\n                    switch (change.changeType) {\n                        case 1 /* Flush */: {\n                            this._lines.onModelFlushed();\n                            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                            this._decorations.reset();\n                            this.viewLayout.onFlushed(this.getLineCount());\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 3 /* LinesDeleted */: {\n                            const linesDeletedEvent = this._lines.onModelLinesDeleted(versionId, change.fromLineNumber, change.toLineNumber);\n                            if (linesDeletedEvent !== null) {\n                                eventsCollector.emitViewEvent(linesDeletedEvent);\n                                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                            }\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 4 /* LinesInserted */: {\n                            const insertedLineBreaks = lineBreakQueue.takeCount(change.detail.length);\n                            const linesInsertedEvent = this._lines.onModelLinesInserted(versionId, change.fromLineNumber, change.toLineNumber, insertedLineBreaks);\n                            if (linesInsertedEvent !== null) {\n                                eventsCollector.emitViewEvent(linesInsertedEvent);\n                                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                            }\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 2 /* LineChanged */: {\n                            const changedLineBreakData = lineBreakQueue.dequeue();\n                            const [lineMappingChanged, linesChangedEvent, linesInsertedEvent, linesDeletedEvent] = this._lines.onModelLineChanged(versionId, change.lineNumber, changedLineBreakData);\n                            hadModelLineChangeThatChangedLineMapping = lineMappingChanged;\n                            if (linesChangedEvent) {\n                                eventsCollector.emitViewEvent(linesChangedEvent);\n                            }\n                            if (linesInsertedEvent) {\n                                eventsCollector.emitViewEvent(linesInsertedEvent);\n                                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                            }\n                            if (linesDeletedEvent) {\n                                eventsCollector.emitViewEvent(linesDeletedEvent);\n                                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                            }\n                            break;\n                        }\n                        case 5 /* EOLChanged */: {\n                            // Nothing to do. The new version will be accepted below\n                            break;\n                        }\n                    }\n                }\n                if (versionId !== null) {\n                    this._lines.acceptVersionId(versionId);\n                }\n                this.viewLayout.onHeightMaybeChanged();\n                if (!hadOtherModelChange && hadModelLineChangeThatChangedLineMapping) {\n                    eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                    this._cursor.onLineMappingChanged(eventsCollector);\n                    this._decorations.onLineMappingChanged();\n                }\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n            // Update the configuration and reset the centered view line\n            this._viewportStartLine = -1;\n            this._configuration.setModelLineCount(this.model.getLineCount());\n            this._updateConfigurationViewLineCountNow();\n            // Recover viewport\n            if (!this._hasFocus && this.model.getAttachedEditorCount() >= 2 && this._viewportStartLineTrackedRange) {\n                const modelRange = this.model._getTrackedRange(this._viewportStartLineTrackedRange);\n                if (modelRange) {\n                    const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelRange.getStartPosition());\n                    const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n                    this.viewLayout.setScrollPosition({ scrollTop: viewPositionTop + this._viewportStartLineDelta }, 1 /* Immediate */);\n                }\n            }\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                this._cursor.onModelContentChanged(eventsCollector, e);\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n            this._tokenizeViewportSoon.schedule();\n        }));\n        this._register(this.model.onDidChangeTokens((e) => {\n            const viewRanges = [];\n            for (let j = 0, lenJ = e.ranges.length; j < lenJ; j++) {\n                const modelRange = e.ranges[j];\n                const viewStartLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.fromLineNumber, 1)).lineNumber;\n                const viewEndLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.toLineNumber, this.model.getLineMaxColumn(modelRange.toLineNumber))).lineNumber;\n                viewRanges[j] = {\n                    fromLineNumber: viewStartLineNumber,\n                    toLineNumber: viewEndLineNumber\n                };\n            }\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensChangedEvent(viewRanges));\n            if (e.tokenizationSupportChanged) {\n                this._tokenizeViewportSoon.schedule();\n            }\n        }));\n        this._register(this.model.onDidChangeLanguageConfiguration((e) => {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewLanguageConfigurationEvent());\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n        }));\n        this._register(this.model.onDidChangeLanguage((e) => {\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n        }));\n        this._register(this.model.onDidChangeOptions((e) => {\n            // A tab size change causes a line mapping changed event => all view parts will repaint OK, no further event needed here\n            if (this._lines.setTabSize(this.model.getOptions().tabSize)) {\n                try {\n                    const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                    eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                    this._cursor.onLineMappingChanged(eventsCollector);\n                    this._decorations.onLineMappingChanged();\n                    this.viewLayout.onFlushed(this.getLineCount());\n                }\n                finally {\n                    this._eventDispatcher.endEmitViewEvents();\n                }\n                this._updateConfigurationViewLineCount.schedule();\n            }\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n        }));\n        this._register(this.model.onDidChangeDecorations((e) => {\n            this._decorations.onModelDecorationsChanged();\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewDecorationsChangedEvent(e));\n        }));\n    }\n    setHiddenAreas(ranges) {\n        let lineMappingChanged = false;\n        try {\n            const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n            lineMappingChanged = this._lines.setHiddenAreas(ranges);\n            if (lineMappingChanged) {\n                eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                this._cursor.onLineMappingChanged(eventsCollector);\n                this._decorations.onLineMappingChanged();\n                this.viewLayout.onFlushed(this.getLineCount());\n                this.viewLayout.onHeightMaybeChanged();\n            }\n        }\n        finally {\n            this._eventDispatcher.endEmitViewEvents();\n        }\n        this._updateConfigurationViewLineCount.schedule();\n        if (lineMappingChanged) {\n            this._eventDispatcher.emitOutgoingEvent(new ViewZonesChangedEvent());\n        }\n    }\n    getVisibleRangesPlusViewportAboveBelow() {\n        const layoutInfo = this._configuration.options.get(131 /* layoutInfo */);\n        const lineHeight = this._configuration.options.get(59 /* lineHeight */);\n        const linesAround = Math.max(20, Math.round(layoutInfo.height / lineHeight));\n        const partialData = this.viewLayout.getLinesViewportData();\n        const startViewLineNumber = Math.max(1, partialData.completelyVisibleStartLineNumber - linesAround);\n        const endViewLineNumber = Math.min(this.getLineCount(), partialData.completelyVisibleEndLineNumber + linesAround);\n        return this._toModelVisibleRanges(new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber)));\n    }\n    getVisibleRanges() {\n        const visibleViewRange = this.getCompletelyVisibleViewRange();\n        return this._toModelVisibleRanges(visibleViewRange);\n    }\n    _toModelVisibleRanges(visibleViewRange) {\n        const visibleRange = this.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n        const hiddenAreas = this._lines.getHiddenAreas();\n        if (hiddenAreas.length === 0) {\n            return [visibleRange];\n        }\n        const result = [];\n        let resultLen = 0;\n        let startLineNumber = visibleRange.startLineNumber;\n        let startColumn = visibleRange.startColumn;\n        const endLineNumber = visibleRange.endLineNumber;\n        const endColumn = visibleRange.endColumn;\n        for (let i = 0, len = hiddenAreas.length; i < len; i++) {\n            const hiddenStartLineNumber = hiddenAreas[i].startLineNumber;\n            const hiddenEndLineNumber = hiddenAreas[i].endLineNumber;\n            if (hiddenEndLineNumber < startLineNumber) {\n                continue;\n            }\n            if (hiddenStartLineNumber > endLineNumber) {\n                continue;\n            }\n            if (startLineNumber < hiddenStartLineNumber) {\n                result[resultLen++] = new Range(startLineNumber, startColumn, hiddenStartLineNumber - 1, this.model.getLineMaxColumn(hiddenStartLineNumber - 1));\n            }\n            startLineNumber = hiddenEndLineNumber + 1;\n            startColumn = 1;\n        }\n        if (startLineNumber < endLineNumber || (startLineNumber === endLineNumber && startColumn < endColumn)) {\n            result[resultLen++] = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        return result;\n    }\n    getCompletelyVisibleViewRange() {\n        const partialData = this.viewLayout.getLinesViewportData();\n        const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n        const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n    }\n    getCompletelyVisibleViewRangeAtScrollTop(scrollTop) {\n        const partialData = this.viewLayout.getLinesViewportDataAtScrollTop(scrollTop);\n        const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n        const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n    }\n    saveState() {\n        const compatViewState = this.viewLayout.saveState();\n        const scrollTop = compatViewState.scrollTop;\n        const firstViewLineNumber = this.viewLayout.getLineNumberAtVerticalOffset(scrollTop);\n        const firstPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(firstViewLineNumber, this.getLineMinColumn(firstViewLineNumber)));\n        const firstPositionDeltaTop = this.viewLayout.getVerticalOffsetForLineNumber(firstViewLineNumber) - scrollTop;\n        return {\n            scrollLeft: compatViewState.scrollLeft,\n            firstPosition: firstPosition,\n            firstPositionDeltaTop: firstPositionDeltaTop\n        };\n    }\n    reduceRestoreState(state) {\n        if (typeof state.firstPosition === 'undefined') {\n            // This is a view state serialized by an older version\n            return this._reduceRestoreStateCompatibility(state);\n        }\n        const modelPosition = this.model.validatePosition(state.firstPosition);\n        const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);\n        const scrollTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber) - state.firstPositionDeltaTop;\n        return {\n            scrollLeft: state.scrollLeft,\n            scrollTop: scrollTop\n        };\n    }\n    _reduceRestoreStateCompatibility(state) {\n        return {\n            scrollLeft: state.scrollLeft,\n            scrollTop: state.scrollTopWithoutViewZones\n        };\n    }\n    getTabSize() {\n        return this.model.getOptions().tabSize;\n    }\n    getTextModelOptions() {\n        return this.model.getOptions();\n    }\n    getLineCount() {\n        return this._lines.getViewLineCount();\n    }\n    /**\n     * Gives a hint that a lot of requests are about to come in for these line numbers.\n     */\n    setViewport(startLineNumber, endLineNumber, centeredLineNumber) {\n        this._viewportStartLine = startLineNumber;\n        const position = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(startLineNumber, this.getLineMinColumn(startLineNumber)));\n        this._viewportStartLineTrackedRange = this.model._setTrackedRange(this._viewportStartLineTrackedRange, new Range(position.lineNumber, position.column, position.lineNumber, position.column), 1 /* NeverGrowsWhenTypingAtEdges */);\n        const viewportStartLineTop = this.viewLayout.getVerticalOffsetForLineNumber(startLineNumber);\n        const scrollTop = this.viewLayout.getCurrentScrollTop();\n        this._viewportStartLineDelta = scrollTop - viewportStartLineTop;\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        return this._lines.getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        return this._lines.getViewLinesIndentGuides(startLineNumber, endLineNumber);\n    }\n    getBracketGuidesInRangeByLine(startLineNumber, endLineNumber, activePosition, options) {\n        return this._lines.getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options);\n    }\n    getLineContent(lineNumber) {\n        return this._lines.getViewLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        return this._lines.getViewLineLength(lineNumber);\n    }\n    getLineMinColumn(lineNumber) {\n        return this._lines.getViewLineMinColumn(lineNumber);\n    }\n    getLineMaxColumn(lineNumber) {\n        return this._lines.getViewLineMaxColumn(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    getDecorationsInViewport(visibleRange) {\n        return this._decorations.getDecorationsViewportData(visibleRange).decorations;\n    }\n    getInjectedTextAt(viewPosition) {\n        return this._lines.getInjectedTextAt(viewPosition);\n    }\n    getViewLineRenderingData(visibleRange, lineNumber) {\n        const mightContainRTL = this.model.mightContainRTL();\n        const mightContainNonBasicASCII = this.model.mightContainNonBasicASCII();\n        const tabSize = this.getTabSize();\n        const lineData = this._lines.getViewLineData(lineNumber);\n        const allInlineDecorations = this._decorations.getDecorationsViewportData(visibleRange).inlineDecorations;\n        let inlineDecorations = allInlineDecorations[lineNumber - visibleRange.startLineNumber];\n        if (lineData.inlineDecorations) {\n            inlineDecorations = [\n                ...inlineDecorations,\n                ...lineData.inlineDecorations.map(d => d.toInlineDecoration(lineNumber))\n            ];\n        }\n        return new ViewLineRenderingData(lineData.minColumn, lineData.maxColumn, lineData.content, lineData.continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, lineData.tokens, inlineDecorations, tabSize, lineData.startVisibleColumn);\n    }\n    getViewLineData(lineNumber) {\n        return this._lines.getViewLineData(lineNumber);\n    }\n    getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n        const result = this._lines.getViewLinesData(startLineNumber, endLineNumber, needed);\n        return new MinimapLinesRenderingData(this.getTabSize(), result);\n    }\n    getAllOverviewRulerDecorations(theme) {\n        const decorations = this.model.getOverviewRulerDecorations(this._editorId, filterValidationDecorations(this._configuration.options));\n        const result = new OverviewRulerDecorations();\n        for (const decoration of decorations) {\n            const decorationOptions = decoration.options;\n            const opts = decorationOptions.overviewRuler;\n            if (!opts) {\n                continue;\n            }\n            const lane = opts.position;\n            if (lane === 0) {\n                continue;\n            }\n            const color = opts.getColor(theme.value);\n            const viewStartLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.startLineNumber, decoration.range.startColumn);\n            const viewEndLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.endLineNumber, decoration.range.endColumn);\n            result.accept(color, decorationOptions.zIndex, viewStartLineNumber, viewEndLineNumber, lane);\n        }\n        return result.asArray;\n    }\n    invalidateOverviewRulerColorCache() {\n        const decorations = this.model.getOverviewRulerDecorations();\n        for (const decoration of decorations) {\n            const opts = decoration.options.overviewRuler;\n            if (opts) {\n                opts.invalidateCachedColor();\n            }\n        }\n    }\n    invalidateMinimapColorCache() {\n        const decorations = this.model.getAllDecorations();\n        for (const decoration of decorations) {\n            const opts = decoration.options.minimap;\n            if (opts) {\n                opts.invalidateCachedColor();\n            }\n        }\n    }\n    getValueInRange(range, eol) {\n        const modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range);\n        return this.model.getValueInRange(modelRange, eol);\n    }\n    getModelLineMaxColumn(modelLineNumber) {\n        return this.model.getLineMaxColumn(modelLineNumber);\n    }\n    validateModelPosition(position) {\n        return this.model.validatePosition(position);\n    }\n    validateModelRange(range) {\n        return this.model.validateRange(range);\n    }\n    deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt) {\n        const modelAnchor = this.coordinatesConverter.convertViewPositionToModelPosition(viewAnchorPosition);\n        if (this.model.getEOL().length === 2) {\n            // This model uses CRLF, so the delta must take that into account\n            if (deltaOffset < 0) {\n                deltaOffset -= lineFeedCnt;\n            }\n            else {\n                deltaOffset += lineFeedCnt;\n            }\n        }\n        const modelAnchorOffset = this.model.getOffsetAt(modelAnchor);\n        const resultOffset = modelAnchorOffset + deltaOffset;\n        return this.model.getPositionAt(resultOffset);\n    }\n    getEOL() {\n        return this.model.getEOL();\n    }\n    getPlainTextToCopy(modelRanges, emptySelectionClipboard, forceCRLF) {\n        const newLineCharacter = forceCRLF ? '\\r\\n' : this.model.getEOL();\n        modelRanges = modelRanges.slice(0);\n        modelRanges.sort(Range.compareRangesUsingStarts);\n        let hasEmptyRange = false;\n        let hasNonEmptyRange = false;\n        for (const range of modelRanges) {\n            if (range.isEmpty()) {\n                hasEmptyRange = true;\n            }\n            else {\n                hasNonEmptyRange = true;\n            }\n        }\n        if (!hasNonEmptyRange) {\n            // all ranges are empty\n            if (!emptySelectionClipboard) {\n                return '';\n            }\n            const modelLineNumbers = modelRanges.map((r) => r.startLineNumber);\n            let result = '';\n            for (let i = 0; i < modelLineNumbers.length; i++) {\n                if (i > 0 && modelLineNumbers[i - 1] === modelLineNumbers[i]) {\n                    continue;\n                }\n                result += this.model.getLineContent(modelLineNumbers[i]) + newLineCharacter;\n            }\n            return result;\n        }\n        if (hasEmptyRange && emptySelectionClipboard) {\n            // mixed empty selections and non-empty selections\n            const result = [];\n            let prevModelLineNumber = 0;\n            for (const modelRange of modelRanges) {\n                const modelLineNumber = modelRange.startLineNumber;\n                if (modelRange.isEmpty()) {\n                    if (modelLineNumber !== prevModelLineNumber) {\n                        result.push(this.model.getLineContent(modelLineNumber));\n                    }\n                }\n                else {\n                    result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* CRLF */ : 0 /* TextDefined */));\n                }\n                prevModelLineNumber = modelLineNumber;\n            }\n            return result.length === 1 ? result[0] : result;\n        }\n        const result = [];\n        for (const modelRange of modelRanges) {\n            if (!modelRange.isEmpty()) {\n                result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* CRLF */ : 0 /* TextDefined */));\n            }\n        }\n        return result.length === 1 ? result[0] : result;\n    }\n    getRichTextToCopy(modelRanges, emptySelectionClipboard) {\n        const languageId = this.model.getLanguageId();\n        if (languageId === PLAINTEXT_LANGUAGE_ID) {\n            return null;\n        }\n        if (modelRanges.length !== 1) {\n            // no multiple selection support at this time\n            return null;\n        }\n        let range = modelRanges[0];\n        if (range.isEmpty()) {\n            if (!emptySelectionClipboard) {\n                // nothing to copy\n                return null;\n            }\n            const lineNumber = range.startLineNumber;\n            range = new Range(lineNumber, this.model.getLineMinColumn(lineNumber), lineNumber, this.model.getLineMaxColumn(lineNumber));\n        }\n        const fontInfo = this._configuration.options.get(44 /* fontInfo */);\n        const colorMap = this._getColorMap();\n        const hasBadChars = (/[:;\\\\\\/<>]/.test(fontInfo.fontFamily));\n        const useDefaultFontFamily = (hasBadChars || fontInfo.fontFamily === EDITOR_FONT_DEFAULTS.fontFamily);\n        let fontFamily;\n        if (useDefaultFontFamily) {\n            fontFamily = EDITOR_FONT_DEFAULTS.fontFamily;\n        }\n        else {\n            fontFamily = fontInfo.fontFamily;\n            fontFamily = fontFamily.replace(/\"/g, '\\'');\n            const hasQuotesOrIsList = /[,']/.test(fontFamily);\n            if (!hasQuotesOrIsList) {\n                const needsQuotes = /[+ ]/.test(fontFamily);\n                if (needsQuotes) {\n                    fontFamily = `'${fontFamily}'`;\n                }\n            }\n            fontFamily = `${fontFamily}, ${EDITOR_FONT_DEFAULTS.fontFamily}`;\n        }\n        return {\n            mode: languageId,\n            html: (`<div style=\"`\n                + `color: ${colorMap[1 /* DefaultForeground */]};`\n                + `background-color: ${colorMap[2 /* DefaultBackground */]};`\n                + `font-family: ${fontFamily};`\n                + `font-weight: ${fontInfo.fontWeight};`\n                + `font-size: ${fontInfo.fontSize}px;`\n                + `line-height: ${fontInfo.lineHeight}px;`\n                + `white-space: pre;`\n                + `\">`\n                + this._getHTMLToCopy(range, colorMap)\n                + '</div>')\n        };\n    }\n    _getHTMLToCopy(modelRange, colorMap) {\n        const startLineNumber = modelRange.startLineNumber;\n        const startColumn = modelRange.startColumn;\n        const endLineNumber = modelRange.endLineNumber;\n        const endColumn = modelRange.endColumn;\n        const tabSize = this.getTabSize();\n        let result = '';\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const lineTokens = this.model.getLineTokens(lineNumber);\n            const lineContent = lineTokens.getLineContent();\n            const startOffset = (lineNumber === startLineNumber ? startColumn - 1 : 0);\n            const endOffset = (lineNumber === endLineNumber ? endColumn - 1 : lineContent.length);\n            if (lineContent === '') {\n                result += '<br>';\n            }\n            else {\n                result += tokenizeLineToHTML(lineContent, lineTokens.inflate(), colorMap, startOffset, endOffset, tabSize, platform.isWindows);\n            }\n        }\n        return result;\n    }\n    _getColorMap() {\n        const colorMap = TokenizationRegistry.getColorMap();\n        const result = ['#000000'];\n        if (colorMap) {\n            for (let i = 1, len = colorMap.length; i < len; i++) {\n                result[i] = Color.Format.CSS.formatHex(colorMap[i]);\n            }\n        }\n        return result;\n    }\n    //#region model\n    pushStackElement() {\n        this.model.pushStackElement();\n    }\n    //#endregion\n    //#region cursor operations\n    getPrimaryCursorState() {\n        return this._cursor.getPrimaryCursorState();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursor.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursor.getCursorStates();\n    }\n    setCursorStates(source, reason, states) {\n        return this._withViewEventsCollector(eventsCollector => this._cursor.setStates(eventsCollector, source, reason, states));\n    }\n    getCursorColumnSelectData() {\n        return this._cursor.getCursorColumnSelectData();\n    }\n    getCursorAutoClosedCharacters() {\n        return this._cursor.getAutoClosedCharacters();\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._cursor.setCursorColumnSelectData(columnSelectData);\n    }\n    getPrevEditOperationType() {\n        return this._cursor.getPrevEditOperationType();\n    }\n    setPrevEditOperationType(type) {\n        this._cursor.setPrevEditOperationType(type);\n    }\n    getSelection() {\n        return this._cursor.getSelection();\n    }\n    getSelections() {\n        return this._cursor.getSelections();\n    }\n    getPosition() {\n        return this._cursor.getPrimaryCursorState().modelState.position;\n    }\n    setSelections(source, selections, reason = 0 /* NotSet */) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.setSelections(eventsCollector, source, selections, reason));\n    }\n    saveCursorState() {\n        return this._cursor.saveState();\n    }\n    restoreCursorState(states) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.restoreState(eventsCollector, states));\n    }\n    _executeCursorEdit(callback) {\n        if (this._cursor.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            this._eventDispatcher.emitOutgoingEvent(new ReadOnlyEditAttemptEvent());\n            return;\n        }\n        this._withViewEventsCollector(callback);\n    }\n    executeEdits(source, edits, cursorStateComputer) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeEdits(eventsCollector, source, edits, cursorStateComputer));\n    }\n    startComposition() {\n        this._cursor.setIsDoingComposition(true);\n        this._executeCursorEdit(eventsCollector => this._cursor.startComposition(eventsCollector));\n    }\n    endComposition(source) {\n        this._cursor.setIsDoingComposition(false);\n        this._executeCursorEdit(eventsCollector => this._cursor.endComposition(eventsCollector, source));\n    }\n    type(text, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.type(eventsCollector, text, source));\n    }\n    compositionType(text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source));\n    }\n    paste(text, pasteOnNewLine, multicursorText, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.paste(eventsCollector, text, pasteOnNewLine, multicursorText, source));\n    }\n    cut(source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.cut(eventsCollector, source));\n    }\n    executeCommand(command, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeCommand(eventsCollector, command, source));\n    }\n    executeCommands(commands, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeCommands(eventsCollector, commands, source));\n    }\n    revealPrimaryCursor(source, revealHorizontal, minimalReveal = false) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.revealPrimary(eventsCollector, source, minimalReveal, 0 /* Simple */, revealHorizontal, 0 /* Smooth */));\n    }\n    revealTopMostCursor(source) {\n        const viewPosition = this._cursor.getTopMostViewPosition();\n        const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, 0 /* Simple */, true, 0 /* Smooth */)));\n    }\n    revealBottomMostCursor(source) {\n        const viewPosition = this._cursor.getBottomMostViewPosition();\n        const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, 0 /* Simple */, true, 0 /* Smooth */)));\n    }\n    revealRange(source, revealHorizontal, viewRange, verticalType, scrollType) {\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, verticalType, revealHorizontal, scrollType)));\n    }\n    //#endregion\n    //#region viewLayout\n    getVerticalOffsetForLineNumber(viewLineNumber) {\n        return this.viewLayout.getVerticalOffsetForLineNumber(viewLineNumber);\n    }\n    getScrollTop() {\n        return this.viewLayout.getCurrentScrollTop();\n    }\n    setScrollTop(newScrollTop, scrollType) {\n        this.viewLayout.setScrollPosition({ scrollTop: newScrollTop }, scrollType);\n    }\n    setScrollPosition(position, type) {\n        this.viewLayout.setScrollPosition(position, type);\n    }\n    deltaScrollNow(deltaScrollLeft, deltaScrollTop) {\n        this.viewLayout.deltaScrollNow(deltaScrollLeft, deltaScrollTop);\n    }\n    changeWhitespace(callback) {\n        const hadAChange = this.viewLayout.changeWhitespace(callback);\n        if (hadAChange) {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewZonesChangedEvent());\n            this._eventDispatcher.emitOutgoingEvent(new ViewZonesChangedEvent());\n        }\n    }\n    setMaxLineWidth(maxLineWidth) {\n        this.viewLayout.setMaxLineWidth(maxLineWidth);\n    }\n    //#endregion\n    _withViewEventsCollector(callback) {\n        try {\n            const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n            return callback(eventsCollector);\n        }\n        finally {\n            this._eventDispatcher.endEmitViewEvents();\n        }\n    }\n    normalizePosition(position, affinity) {\n        return this._lines.normalizePosition(position, affinity);\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        return this._lines.getLineIndentColumn(lineNumber);\n    }\n}\nclass OverviewRulerDecorations {\n    constructor() {\n        this._asMap = Object.create(null);\n        this.asArray = [];\n    }\n    accept(color, zIndex, startLineNumber, endLineNumber, lane) {\n        const prevGroup = this._asMap[color];\n        if (prevGroup) {\n            const prevData = prevGroup.data;\n            const prevLane = prevData[prevData.length - 3];\n            const prevEndLineNumber = prevData[prevData.length - 1];\n            if (prevLane === lane && prevEndLineNumber + 1 >= startLineNumber) {\n                // merge into prev\n                if (endLineNumber > prevEndLineNumber) {\n                    prevData[prevData.length - 1] = endLineNumber;\n                }\n                return;\n            }\n            // push\n            prevData.push(lane, startLineNumber, endLineNumber);\n        }\n        else {\n            const group = new OverviewRulerDecorationsGroup(color, zIndex, [lane, startLineNumber, endLineNumber]);\n            this._asMap[color] = group;\n            this.asArray.push(group);\n        }\n    }\n}\n"],"names":["BracketInfo","range","nestingLevel","isInvalid","this","BracketPairWithMinIndentationInfo","openingBracketRange","closingBracketRange","minVisibleColumnIndentation","ModelRawFlush","changeType","LineInjectedText","ownerId","lineNumber","column","options","order","lineText","injectedTexts","length","result","lastOriginalOffset","injectedText","substring","content","decorations","decoration","before","push","startLineNumber","startColumn","after","endLineNumber","endColumn","sort","a","b","ModelRawLineChanged","detail","ModelRawLinesDeleted","fromLineNumber","toLineNumber","ModelRawLinesInserted","ModelRawEOLChanged","ModelRawContentChangedEvent","changes","versionId","isUndoing","isRedoing","resultingSelection","type","i","len","concat","ModelInjectedTextChangedEvent","InternalModelContentChangeEvent","rawContentChangedEvent","contentChangedEvent","other","merge","_mergeChangeEvents","eol","isFlush","HorizontalGuidesState","IndentGuide","visibleColumn","className","horizontalLine","IndentGuideHorizontalLine","top","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","done","then","apply","TokenizationRegistry","_map","Map","_factories","_onDidChange","Emitter","onDidChange","event","_colorMap","languages","fire","changedLanguages","changedColorMap","language","support","set","toDisposable","get","delete","languageId","factory","_a","dispose","myData","TokenizationSupportFactoryData","v","tokenizationSupport","isResolved","colorMap","Array","from","keys","_registry","_languageId","_factory","_isDisposed","_resolvePromise","_isResolved","_create","createTokenizationSupport","_register","register","Disposable","ContiguousMultilineTokens","tokens","_startLineNumber","_tokens","lineTokens","ContiguousMultilineTokensBuilder","last","appendLineTokens","EMPTY_LINE_TOKENS","Uint32Array","buffer","ContiguousTokensEditing","toChIndex","fromChIndex","toUint32Array","lineTextLength","tokensCount","dest","lastEnd","fromTokenIndex","LineTokens","fromTokenStartOffset","delta","tokenIndex","tokenEndOffset","tmp","subarray","_otherTokens","myTokens","otherTokens","otherTokensCount","chIndex","textLength","arr","ContiguousTokensStore","languageIdCodec","_lineTokens","_len","_languageIdCodec","topLevelLanguageId","lineIndex","rawLineTokens","getDefaultMetadata","encodeLanguageId","start","deleteCount","splice","insertIndex","insertCount","arrays","checkEquality","_massageTokens","_ensureLine","oldTokens","_equals","eolCount","firstLineLength","_acceptDeleteRange","_acceptInsertText","Position","firstLineIndex","deleteEnding","lastLineIndex","lastLineTokens","deleteBeginning","append","_deleteLines","position","insert","_insertLines","hasDifferentLanguageId","TokenMetadata","byteOffset","byteLength","_b","text","decoder","_lineTokensBrand","undefined","_tokensCount","_text","slicedEquals","sliceFromTokenIndex","sliceTokenCount","to","metadata","decodeLanguageId","offset","findIndexInTokensArray","startOffset","endOffset","deltaOffset","SliceLineTokens","insertTokens","nextOriginalTokenIdx","nextInsertTokenIdx","newTokens","originalEndOffset","nextOriginalTokenEndOffset","nextInsertToken","tokenMetadata","lineContent","defaultMetadata","defaultTokenMetadata","lastTokenIndex","desiredIndex","low","high","mid","Math","floor","source","_source","_startOffset","_endOffset","_deltaOffset","_firstTokenIndex","findTokenIndexAtOffset","getCount","getStartOffset","getMetadata","getLanguageId","getLineContent","getForeground","getEndOffset","min","getClassName","getInlineStyle","getPresentation","SparseMultilineTokens","_endLineNumber","getMaxDeltaLine","toString","isEmpty","getLineTokens","deltaRange","getRange","Range","startLineIndex","endLineIndex","removeTokens","_updateEndLineNumber","split","bDeltaLine","countEOL","lastLineLength","acceptEdit","charCodeAt","firstCharCode","deletedLinesCount","tokenMaxDeltaLine","clear","deletedBefore","acceptDeleteRange","acceptInsertText","SparseMultilineTokensStorage","_tokenCount","pieces","_getDeltaLine","_getStartCharacter","_getEndCharacter","join","tokenCount","_getTokenCount","startChar","maxDeltaLine","endChar","deltaLine","midDeltaLine","max","SparseLineTokens","startDeltaLine","endDeltaLine","newTokenCount","hasDeletedTokens","firstDeltaLine","srcOffset","tokenDeltaLine","tokenStartCharacter","tokenEndCharacter","destOffset","aTokens","bTokens","destTokens","destFirstDeltaLine","horizontalShiftForFirstLineTokens","startCharacter","endCharacter","deletedLineCount","Error","character","isInsertingPreciselyOneWordCharacter","tokenLength","SparseTokensStore","_pieces","_isComplete","isComplete","_range","_firstRange","_lastRange","plusRange","insertPosition","piece","index","_findFirstPieceWithLine","aLen","bLen","aIndex","resultLen","lastEndOffset","emitToken","bIndex","bStartCharacter","getStartCharacter","bEndCharacter","getEndCharacter","bMetadata","bMask","aMask","aMergeIndex","LineDecoration","_lineDecorationBrand","lineLength","r","rLength","dec","lineDecorations","minLineColumn","maxLineColumn","d","inlineClassName","ORDER","typeCmp","_typeCompare","DecorationSegment","Stack","stopOffsets","classNames","count","maxStopOffset","nextStartOffset","_metadata","stopOffset","LineDecorationsNormalizer","stack","charCodeBefore","strings","currentStartOffset","currentEndOffset","consumeLowerThan","LinePart","endIndex","_linePartBrand","LineRange","startIndex","otherLineRange","RenderLineInput","useMonospaceOptimizations","canUseHalfwidthRightwardsArrow","continuesWithWrappedLine","isBasicASCII","containsRTL","fauxIndentLength","tabSize","startVisibleColumn","spaceWidth","middotWidth","wsmiddotWidth","stopRenderingLineAfter","renderWhitespace","renderControlCharacters","fontLigatures","selectionsOnLine","abs","renderSpaceWidth","renderSpaceCharCode","otherSelections","equals","sameSelection","DomPosition","partIndex","charIndex","CharacterMapping","partCount","_data","_absoluteOffsets","partAbsoluteOffset","partData","charOffset","charOffsetToPartData","getPartIndex","getCharIndex","domPosition","partLength","partDataToCharOffset","searchEntry","midEntry","minEntry","maxEntry","minPartIndex","RenderLineOutput","characterMapping","containsForeignElements","_renderLineOutputBrand","renderViewLine","input","sb","appendASCIIString","beforeCount","afterCount","lineDecoration","setColumnInfo","fontIsMonospace","isOverflowing","parts","lastCharacterMappingDefined","charOffsetInPart","partDisplacement","prevPartContentCnt","tokensLen","part","partEndIndex","partType","partRendersWhitespace","isWhitespace","partRendersWhitespaceWithWidth","partIsEmptyAndHasPseudoAfter","isPseudoAfter","appendASCII","partContentCnt","_charIndex","_visibleColumn","charWidth","String","write1","space","charCode","producedCharacters","isControlCharacter","to4CharHex","_renderLine","transformAndRemoveOverflowing","lastLinePart","token","tokenEndIndex","extractControlCharacters","lastNonWhitespaceIndex","selections","onlyBoundary","onlyTrailing","generateLinePartForEachWhitespace","tokenType","tokensLength","lineIsEmptyOrWhitespace","firstNonWhitespaceIndex","wasInWhitespace","currentSelectionIndex","currentSelection","tmpIndent","chCode","isInWhitespace","nextChCode","generateWhitespace","lastCharCode","prevCharCode","_applyRenderWhitespace","_lineDecorations","lineDecorationsLen","lineDecorationIndex","lastResultEndIndex","lastTokenEndIndex","_applyInlineDecorations","onlyAtSpaces","lastSpaceOffset","currTokenStart","j","diff","piecesCount","ceil","pieceEndIndex","splitLargeTokens","ResolvedRenderLineInput","resolveRenderLineInput","RenderLineOutput2","html","renderViewLine2","createStringBuilder","out","build","n","toUpperCase","padStart","ViewportData","partialData","whitespaceViewportData","model","relativeVerticalOffset","bigNumbersDelta","_model","visibleRange","getLineMinColumn","getLineMaxColumn","getViewLineRenderingData","getDecorationsInViewport","MinimapTokensColorTracker","_updateColorMap","_colors","RGBA8","_backgroundIsLight","colorId","rgba","g","round","backgroundLuminosity","getRelativeLuminance","_INSTANCE","markAsSingleton","ModelLineProjectionData","injectionOffsets","injectionOptions","breakOffsets","breakOffsetsVisibleColumn","wrappedTextIndentLength","outputLineIndex","getLineLength","outputOffset","offsetInInput","inputOffset","affinity","inputOffsetInInputWithInjection","offsetInInputWithInjectionsToOutputPosition","offsetInInputWithInjections","midStart","midStop","OutputPosition","outputPositionToOffsetInInputWithInjections","normalizedOffsetInUnwrappedLine","normalizeOffsetInInputWithInjectionsAroundInjections","getMinOutputOffset","getMaxOutputOffset","getOutputLineCount","getInjectedTextAtOffset","hasRightCursorStop","injectedTextIndex","cursorStops","hasLeftCursorStop","assertNever","totalInjectedTextLengthBefore","injectedTextStartOffsetInInputWithInjections","injectedTextEndOffsetInInputWithInjections","cursorStop","InjectedTextCursorStops","baseLineNumber","MonospaceLineBreaksComputerFactory","breakBeforeChars","breakAfterChars","classifier","WrappingCharacterClassifier","fontInfo","wrappingColumn","wrappingIndent","requests","previousBreakingData","addRequest","previousLineBreakData","finalize","columnsForFullWidthChar","typicalFullwidthCharacterWidth","typicalHalfwidthCharacterWidth","createLineBreaks","createLineBreaksFromPreviousLineBreaks","arrPool1","arrPool2","BREAK_BEFORE","BREAK_AFTER","_asciiMap","_defaultValue","CharacterClassifier","firstLineBreakColumn","prevBreakingOffsets","prevBreakingOffsetsVisibleColumn","computeWrappedTextIndentLength","wrappedLineBreakColumn","breakingOffsets","breakingOffsetsVisibleColumn","breakingOffsetsCount","lastBreakingOffset","lastBreakingOffsetVisibleColumn","breakingColumn","prevLen","prevIndex","bestDistance","distance","prevBreakOffset","prevBreakOffsetVisibleColumn","breakOffset","breakOffsetVisibleColumn","forcedBreakOffset","forcedBreakOffsetVisibleColumn","prevCharCodeClass","entireLineFits","charStartOffset","charCodeClass","computeCharWidth","canBreak","hitATabCharacter","prevCharWidth","remainingWidthOfNextLine","charCodeAtForcedBreakOffset","_lineText","map","t","tabCharacterWidth","numberOfAdditionalTabs","ColorZone","_colorZoneBrand","OverviewRulerZone","color","_overviewRulerZoneBrand","_colorZone","colorZone","OverviewZoneManager","getVerticalOffsetForLine","_getVerticalOffsetForLine","_zones","_colorZonesInvalid","_lineHeight","_domWidth","_domHeight","_outerHeight","_pixelRatio","_lastAssignedId","_color2Id","Object","create","_id2Color","newZones","compare","lineHeight","pixelRatio","width","height","outerHeight","colorZonesInvalid","totalHeight","getCanvasHeight","heightRatio","halfMinimumHeight","allColorZones","zone","getColorZones","y1","y2","ycenter","halfHeight","setColorZone","EditorTheme","theme","_theme","getColor","ViewContext","configuration","viewLayout","eventHandler","addViewEventHandler","removeViewEventHandler","ViewEventHandler","_shouldRender","events","shouldRender","onCompositionStart","onCompositionEnd","onConfigurationChanged","onCursorStateChanged","onDecorationsChanged","onFlushed","onFocusChanged","onLanguageConfigurationChanged","onLineMappingChanged","onLinesChanged","onLinesDeleted","onLinesInserted","onRevealRangeRequest","onScrollChanged","onTokensChanged","onThemeChanged","onTokensColorsChanged","onZonesChanged","console","info","ViewCompositionStartEvent","ViewCompositionEndEvent","ViewConfigurationChangedEvent","id","hasChanged","ViewCursorStateChangedEvent","modelSelections","ViewDecorationsChangedEvent","affectsMinimap","affectsOverviewRuler","ViewFlushedEvent","ViewFocusChangedEvent","isFocused","ViewLanguageConfigurationEvent","ViewLineMappingChangedEvent","ViewLinesChangedEvent","ViewLinesDeletedEvent","ViewLinesInsertedEvent","ViewRevealRangeRequestEvent","minimalReveal","verticalType","revealHorizontal","scrollType","ViewScrollChangedEvent","scrollWidth","scrollLeft","scrollHeight","scrollTop","scrollWidthChanged","scrollLeftChanged","scrollHeightChanged","scrollTopChanged","ViewThemeChangedEvent","ViewTokensChangedEvent","ranges","ViewTokensColorsChangedEvent","ViewZonesChangedEvent","Viewport","left","_viewportBrand","MinimapLinesRenderingData","data","ViewLineData","minColumn","maxColumn","inlineDecorations","_viewLineDataBrand","ViewLineRenderingData","mightContainRTL","mightContainNonBasicASCII","InlineDecoration","SingleLineInlineDecoration","inlineClassNameAffectsLetterSpacing","ViewModelDecoration","_viewModelDecorationBrand","OverviewRulerDecorationsGroup","zIndex","ViewModelDecorations","editorId","linesCollection","coordinatesConverter","_linesCollection","_coordinatesConverter","_decorationsCache","_cachedModelDecorationsResolver","_cachedModelDecorationsResolverViewRange","_clearCachedModelDecorationsResolver","modelDecoration","viewRange","modelRange","isWholeLine","convertModelPositionToViewPosition","end","convertModelRangeToViewRange","cacheIsValid","equalsRange","_getDecorationsViewportData","viewportRange","modelDecorations","getDecorationsInRange","filterValidationDecorations","decorationsInViewport","decorationsInViewportLen","decorationOptions","isModelDecorationVisible","viewModelDecoration","_getOrCreateViewModelDecoration","inlineDecoration","intersectedStartLineNumber","intersectedEndLineNumber","beforeContentClassName","afterContentClassName","hideInCommentTokens","isModelDecorationInComment","hideInStringTokens","isModelDecorationInString","testTokensInRange","callback","isFirstLine","isEndLine","tokenIdx","getStandardTokenType","ViewModelEventDispatcher","_onEvent","onEvent","_eventHandlers","_viewEventQueue","_isConsumingViewEventQueue","_collector","_collectorCnt","_outgoingEvents","_addOutgoingEvent","_emitOutgoingEvents","kind","shift","isNoOp","warn","ViewModelEventsCollector","outgoingEvents","viewEvents","outgoingEvent","_emitMany","beginEmitViewEvents","emitViewEvent","endEmitViewEvents","_consumeViewEventQueue","_doConsumeQueue","eventHandlers","slice","handleEvents","ContentSizeChangedEvent","oldContentWidth","oldContentHeight","contentWidth","contentHeight","_oldContentWidth","_oldContentHeight","contentWidthChanged","contentHeightChanged","FocusChangedEvent","oldHasFocus","hasFocus","ScrollChangedEvent","oldScrollWidth","oldScrollLeft","oldScrollHeight","oldScrollTop","_oldScrollWidth","_oldScrollLeft","_oldScrollHeight","_oldScrollTop","CursorStateChangedEvent","oldSelections","oldModelVersionId","modelVersionId","reason","reachedMaxCursorCount","_selectionsAreEqual","equalsSelection","ReadOnlyEditAttemptEvent","PendingChanges","_hasPending","_inserts","_changes","_removes","x","linesLayout","inserts","removes","_commitPendingChanges","EditorWhitespace","afterLineNumber","ordinal","minWidth","prefixSum","LinesLayout","lineCount","paddingTop","paddingBottom","_instanceId","INSTANCE_COUNT","_pendingChanges","_lastWhitespaceId","_arr","_prefixSumValidIndex","_minWidth","_lineCount","_paddingTop","_paddingBottom","_checkPendingChanges","hadAChange","insertWhitespace","heightInPx","changeOneWhitespace","newAfterLineNumber","newHeight","change","removeWhitespace","remove","commit","_insertWhitespace","_changeOneWhitespace","_findWhitespaceIndex","_removeWhitespace","toRemove","Set","add","toChange","applyRemoveAndChange","whitespaces","whitespace","has","mustCommit","findInsertionIndex","removeIndex","getWhitespacesAccumulatedHeight","getWhitespacesTotalHeight","lastWhitespaceBeforeLineNumber","_findLastWhitespaceBeforeLineNumber","firstWhitespaceAfterLineNumber","_findFirstWhitespaceAfterLineNumber","getWhitespaceAccumulatedHeightBeforeLineNumber","verticalOffset","getLinesTotalHeight","linesCount","minLineNumber","maxLineNumber","midLineNumber","midLineNumberVerticalOffset","getVerticalOffsetForLineNumber","verticalOffset1","verticalOffset2","currentWhitespaceHeight","currentWhitespaceAfterLineNumber","getLineNumberAtOrAfterVerticalOffset","startLineNumberVerticalOffset","whitespaceIndex","getFirstWhitespaceIndexAfterLineNumber","whitespaceCount","getWhitespacesCount","getAfterLineNumberForWhitespaceIndex","getHeightForWhitespaceIndex","currentVerticalOffset","currentLineRelativeOffset","STEP_SIZE","linesOffsets","verticalCenter","centeredLineNumber","endLineNumberVerticalOffset","completelyVisibleStartLineNumber","completelyVisibleEndLineNumber","minWhitespaceIndex","maxWhitespaceIndex","getVerticalOffsetForWhitespaceIndex","midWhitespaceIndex","midWhitespaceVerticalOffset","candidateIndex","getWhitespaceIndexAtOrAfterVerticallOffset","candidateTop","candidateHeight","getIdForWhitespaceIndex","EditorScrollDimensions","EditorScrollable","smoothScrollDuration","scheduleAtNextAnimationFrame","_onDidContentSizeChange","onDidContentSizeChange","_dimensions","_scrollable","Scrollable","forceIntegerValues","onDidScroll","onScroll","setSmoothScrollDuration","scrollPosition","validateScrollPosition","dimensions","oldDimensions","setScrollDimensions","getFutureScrollPosition","getCurrentScrollPosition","update","setScrollPositionNow","setScrollPositionSmooth","ViewLayout","_configuration","layoutInfo","padding","_linesLayout","bottom","_configureSmoothScrollDuration","_updateHeight","getScrollable","setLineHeight","setPadding","scrollDimensions","getScrollDimensions","_getContentHeight","scrollbar","horizontal","horizontalScrollbarSize","_getHorizontalScrollbarHeight","currentScrollPosition","maxLineWidth","wrappingInfo","isViewportWrapping","minimap","enabled","side","verticalScrollbarWidth","extraHorizontalSpace","whitespaceMinWidth","getWhitespaceMinWidth","_computeContentWidth","firstLineNumberInViewport","scrollTopWithoutViewZones","changeWhitespace","onHeightMaybeChanged","isAfterLines","isInTopPadding","isInBottomPadding","getWhitespaceAtVerticalOffset","visibleBox","getCurrentViewport","getLinesViewportData","getWhitespaceViewportData","getWhitespaces","deltaScrollLeft","deltaScrollTop","createModelLineProjection","lineBreakData","isVisible","IdentityModelLineProjection","INSTANCE","HiddenModelLineProjection","ModelLineProjection","_projectionData","_isVisible","modelLineNumber","_assertVisible","startOffsetInInputWithInjections","endOffsetInInputWithInjections","idx","getValueInRange","spaces","_modelLineNumber","getViewLinesData","outputLineIdx","globalStartIndex","needed","lineWithInjections","inlineDecorationsPerOutputLine","currentInjectedOffset","lineStartOffsetInInputWithInjections","lineEndOffsetInInputWithInjections","withInserted","globalIndex","_getViewLineData","deltaStartIndex","sliceAndInflate","getViewLineCount","outputColumn","translateToInputOffset","deltaLineNumber","inputColumn","translateToOutputPosition","toPosition","outputPosition","baseViewLineNumber","normalizeOutputPosition","getInjectedText","_outputLineIndex","inflate","_fromOuputLineIndex","_toOutputLineIndex","getViewLineData","_inputColumn","_outputColumn","_globalStartIndex","_needed","_result","_deltaLineNumber","_spaces","_makeSpaces","ViewModelLinesFromProjectedModel","domLineBreaksComputerFactory","monospaceLineBreaksComputerFactory","wrappingStrategy","_editorId","_validModelVersionId","_domLineBreaksComputerFactory","_monospaceLineBreaksComputerFactory","_constructLines","hiddenAreasDecorationIds","deltaDecorations","CoordinatesConverter","resetHiddenAreas","previousLineBreaks","modelLineProjections","linesContent","getLinesContent","injectedTextDecorations","getInjectedTextDecorations","lineBreaksComputer","createLineBreaksComputer","injectedTextQueue","lineInjectedText","takeWhile","linesBreaks","values","hiddenAreas","areaId","getDecorationRange","hiddenAreaStart","hiddenAreaEnd","hiddenAreaIdx","nextLineNumberToUpdateHiddenArea","isInHiddenArea","line","getVersionId","projectedModelLineLineCounts","ConstantTimePrefixSumComputer","decId","_ranges","newRanges","sortedRanges","currentRangeStart","currentRangeEnd","normalizeLineRanges","validateRange","oldRanges","hasDifference","newDecorations","ModelDecorationOptions","hasVisibleLine","lineChanged","setVisible","newOutputLineCount","setValue","setHiddenAreas","_modelColumn","newTabSize","equalFontInfo","equalWrappingStrategy","equalWrappingColumn","equalWrappingIndent","onlyWrappingColumnChanged","getProjectionData","outputFromLineNumber","getPrefixSum","outputToLineNumber","removeValues","_toLineNumber","lineBreaks","totalOutputLineCount","insertLines","insertPrefixSumValues","outputLineCount","insertValues","oldOutputLineCount","lineMappingChanged","changeFrom","changeTo","insertFrom","insertTo","deleteFrom","deleteTo","getTotalSum","viewLineNumber","viewLineCount","_toValidViewLineNumber","modelPosition","convertViewPositionToModelPosition","getViewLineMinColumn","modelMinPosition","modelMaxPosition","guides","getActiveIndentGuide","viewStartPosition","viewEndPosition","indent","getIndexOf","remainder","ViewLineInfo","viewLineInfo","modelLineWrappedLineIdx","minViewColumn","getModelColumnOfViewPosition","maxViewColumn","getViewLineMaxColumn","viewStartLineNumber","viewEndLineNumber","startViewLine","getViewLineInfo","endViewLine","lastVisibleModelPos","getModelStartPositionOfViewLine","viewLines","curModelLine","lastVisibleModelPos2","ViewLineInfoGroupedByModelRange","getModelEndPositionOfViewLine","activeViewPosition","modelActivePosition","resultPerViewLine","getViewLineInfosGroupedByModelRanges","group","modelRangeStartLineNumber","bracketGuidesPerModelLine","getLinesBracketGuides","isWrappedLineContinuation","getMinColumnOfViewLine","bracketGuides","modelStart","modelEnd","resultRepeatCount","resultRepeatOption","modelStartLineIndex","modelEndLineIndex","reqStart","modelLineIndex","viewLineStartIndex","getViewLineNumberOfModelPosition","viewLineEndIndex","option","getLinesIndentGuides","viewIndents","currIndex","blockAtIndex","getViewLineContent","getViewLineLength","startModelLineIndex","startRemainder","getLineCount","fromViewLineIndex","remainingViewLineCount","lastLine","viewColumn","expectedModelPosition","computedModelColumn","validatePosition","expectedModelRange","validViewStart","validateViewPosition","getStartPosition","validViewEnd","getEndPosition","validPosition","inputLineNumber","lineIndexChanged","getViewPositionOfModelPosition","modelColumn","filterOutValidation","res","finalResult","finalResultLen","prevDecId","getInjectedTextAt","normalizePosition","getLineIndentColumn","lines","_lines","viewPosition","convertViewRangeToModelRange","validateViewRange","modelPositionIsVisible","getModelLineViewLineCount","ViewModelLinesFromModelAsIs","IdentityCoordinatesConverter","_newTabSize","_fontInfo","_wrappingStrategy","_wrappingColumn","_wrappingIndent","_versionId","_minLineNumber","_maxLineNumber","activePosition","fill","pos","_validPosition","_validRange","_viewPosition","_viewRange","ViewModel","languageConfigurationService","_eventDispatcher","cursorConfig","CursorConfiguration","getOptions","_tokenizeViewportSoon","RunOnceScheduler","tokenizeViewport","_updateConfigurationViewLineCount","_updateConfigurationViewLineCountNow","_hasFocus","_viewportStartLine","_viewportStartLineTrackedRange","_viewportStartLineDelta","isTooLargeForTokenization","createCoordinatesConverter","_cursor","CursorsController","schedule","emitSingleViewEvent","emitOutgoingEvent","_decorations","_registerModelEvents","onDidChangeFast","eventsCollector","_onConfigurationChanged","invalidateMinimapColorCache","_setTrackedRange","setViewLineCount","linesViewportData","viewVisibleRange","modelVisibleRanges","_toModelVisibleRanges","modelVisibleRange","setHasFocus","previousViewportStartModelPosition","previousViewportStartViewPosition","restorePreviousViewportStart","setWrappingSettings","getCurrentScrollTop","reset","viewPositionTop","setScrollPosition","updateConfiguration","onDidChangeContentOrInjectedText","hadOtherModelChange","hadModelLineChangeThatChangedLineMapping","textModelEvents","lineIdx","filter","element","lineBreakQueue","ArrayQueue","onModelFlushed","linesDeletedEvent","onModelLinesDeleted","insertedLineBreaks","takeCount","linesInsertedEvent","onModelLinesInserted","changedLineBreakData","dequeue","onModelLineChanged","linesChangedEvent","acceptVersionId","setModelLineCount","getAttachedEditorCount","_getTrackedRange","onModelContentChanged","onDidChangeTokens","viewRanges","lenJ","tokenizationSupportChanged","onDidChangeLanguageConfiguration","onDidChangeLanguage","onDidChangeOptions","setTabSize","onDidChangeDecorations","onModelDecorationsChanged","linesAround","startViewLineNumber","endViewLineNumber","visibleViewRange","getCompletelyVisibleViewRange","getHiddenAreas","hiddenStartLineNumber","hiddenEndLineNumber","getLinesViewportDataAtScrollTop","compatViewState","saveState","firstViewLineNumber","getLineNumberAtVerticalOffset","firstPosition","firstPositionDeltaTop","state","_reduceRestoreStateCompatibility","viewportStartLineTop","getViewLinesIndentGuides","getViewLinesBracketGuides","getDecorationsViewportData","getTabSize","lineData","toInlineDecoration","getOverviewRulerDecorations","OverviewRulerDecorations","opts","overviewRuler","lane","accept","asArray","invalidateCachedColor","getAllDecorations","viewAnchorPosition","lineFeedCnt","modelAnchor","getEOL","resultOffset","getOffsetAt","getPositionAt","modelRanges","emptySelectionClipboard","forceCRLF","newLineCharacter","hasEmptyRange","hasNonEmptyRange","modelLineNumbers","prevModelLineNumber","PLAINTEXT_LANGUAGE_ID","fontFamily","_getColorMap","test","EDITOR_FONT_DEFAULTS","replace","mode","fontWeight","fontSize","_getHTMLToCopy","tokenizeLineToHTML","platform","Color","pushStackElement","getPrimaryCursorState","getLastAddedCursorIndex","getCursorStates","states","_withViewEventsCollector","setStates","getCursorColumnSelectData","getAutoClosedCharacters","columnSelectData","setCursorColumnSelectData","getPrevEditOperationType","setPrevEditOperationType","getSelection","getSelections","modelState","setSelections","restoreState","context","readOnly","edits","cursorStateComputer","_executeCursorEdit","executeEdits","setIsDoingComposition","startComposition","endComposition","replacePrevCharCnt","replaceNextCharCnt","positionDelta","compositionType","pasteOnNewLine","multicursorText","paste","cut","command","executeCommand","commands","executeCommands","revealPrimary","getTopMostViewPosition","getBottomMostViewPosition","newScrollTop","deltaScrollNow","setMaxLineWidth","_asMap","prevGroup","prevData","prevLane","prevEndLineNumber"],"sourceRoot":""}