{"version":3,"file":"static/js/monaco-editor-vendor.df546ea5.ca5fbc3e.js","mappings":"mOAQaA,EAAb,WACI,WAAYC,IAAe,eACvB,IAAMC,GAAeC,EAAAA,EAAAA,GAAQF,GAC7BG,KAAKH,cAAgBC,EACrBE,KAAKC,UAAYL,EAAoBM,gBAAgBJ,GACrDE,KAAKG,KAAO,IAAIC,GACnB,CANL,kCAcI,SAAIC,EAAUC,GACV,IAAMC,GAAQR,EAAAA,EAAAA,GAAQO,GAClBD,GAAY,GAAKA,EAAW,IAC5BL,KAAKC,UAAUI,GAAYE,EAG3BP,KAAKG,KAAKK,IAAIH,EAAUE,EAE/B,GAtBL,iBAuBI,SAAIF,GACA,OAAIA,GAAY,GAAKA,EAAW,IACrBL,KAAKC,UAAUI,GAGdL,KAAKG,KAAKM,IAAIJ,IAAaL,KAAKH,aAE/C,IA9BL,8BAOI,SAAuBC,GAEnB,IADA,IAAMY,EAAW,IAAIC,WAAW,KACvBC,EAAI,EAAGA,EAAI,IAAKA,IACrBF,EAASE,GAAKd,EAElB,OAAOY,CACV,KAbL,KAgCaG,EAAb,WACI,cAAc,eACVb,KAAKc,QAAU,IAAIlB,EAAoB,EAC1C,CAHL,kCAII,SAAIS,GACAL,KAAKc,QAAQN,IAAIH,EAAU,EAC9B,GANL,iBAOI,SAAIA,GACA,OAAuC,IAA/BL,KAAKc,QAAQL,IAAIJ,EAC5B,KATL,I,6FCnBaU,EAAb,8FACI,SAA0BC,EAAWC,EAAeC,GAChD,OAAkB,IAAdF,EACOD,EAAcI,kBAAkBF,EAAeC,GAEtDE,EAAAA,GAA6BJ,IAAcI,EAAAA,GAAyBJ,GAC7DC,EAAgB,EAEpBA,EAAgB,CAC1B,GATL,qCAcI,SAA+BI,EAAaC,EAAQJ,GAKhD,IAJA,IAAMK,EAAUC,KAAKC,IAAIH,EAAS,EAAGD,EAAYK,QAC3CC,EAAON,EAAYO,UAAU,EAAGL,GAChCM,EAAW,IAAIT,EAAAA,GAAyBO,GAC1CG,EAAS,GACLD,EAASE,OAAO,CACpB,IAAMf,EAAYI,EAAAA,GAAyBO,EAAMJ,EAASM,EAASG,QACnEH,EAASI,qBACTH,EAAS9B,KAAKkC,mBAAmBlB,EAAWc,EAAQZ,EACvD,CACD,OAAOY,CACV,GAzBL,qCA8BI,SAA+BT,EAAaJ,EAAeC,GACvD,GAAID,GAAiB,EACjB,OAAO,EAMX,IAJA,IAAMkB,EAAoBd,EAAYK,OAChCG,EAAW,IAAIT,EAAAA,GAAyBC,GAC1Ce,EAAsB,EACtBC,EAAe,GACXR,EAASE,OAAO,CACpB,IAAMf,EAAYI,EAAAA,GAAyBC,EAAac,EAAmBN,EAASG,QACpFH,EAASI,qBACT,IAAMK,EAAqBtC,KAAKkC,mBAAmBlB,EAAWoB,EAAqBlB,GAC7EqB,EAAcV,EAASG,OAAS,EACtC,GAAIM,GAAsBrB,EAGtB,OADmBqB,EAAqBrB,EADpBA,EAAgBmB,EAGzBG,EAGAF,EAGfD,EAAsBE,EACtBD,EAAeE,CAClB,CAED,OAAOJ,EAAoB,CAC9B,GA1DL,+BA+DI,SAAyBlB,EAAeC,GACpC,OAAOD,EAAgBC,EAAUD,EAAgBC,CACpD,GAjEL,+BAsEI,SAAyBD,EAAeuB,GACpC,OAAOvB,EAAgBuB,EAAavB,EAAgBuB,CACvD,GAxEL,+BA6EI,SAAyBlB,EAAQJ,GAC7B,OAAOM,KAAKiB,IAAI,EAAGnB,EAAS,GAAKA,EAAS,GAAKJ,EAClD,GA/EL,+BAoFI,SAAyBI,EAAQkB,GAC7B,OAAOhB,KAAKiB,IAAI,EAAGnB,EAAS,GAAKA,EAAS,GAAKkB,EAClD,KAtFL,I,6FChBaE,EAAb,kFACI,SAAcC,EAAUhB,GACpB,MAAO,CACHiB,MAAO,IAAIC,EAAAA,EAAMF,EAASG,WAAYH,EAASrB,OAAQqB,EAASG,WAAYH,EAASrB,QACrFK,KAAMA,EACNoB,kBAAkB,EAEzB,GAPL,oBAQI,SAAcH,GACV,MAAO,CACHA,MAAOA,EACPjB,KAAM,KAEb,GAbL,qBAcI,SAAeiB,EAAOjB,GAClB,MAAO,CACHiB,MAAOA,EACPjB,KAAMA,EAEb,GAnBL,yBAoBI,SAAmBiB,EAAOjB,GACtB,MAAO,CACHiB,MAAOA,EACPjB,KAAMA,EACNoB,kBAAkB,EAEzB,KA1BL,I,wiCCMaC,GAAsBC,EAAAA,EAAAA,KAAc,iCAAkC,CAAEC,KAAM,KAAMC,MAAO,KAAMC,GAAI,MAAQC,EAAAA,EAAa,gBAAiB,uEAC3IC,GAA4BL,EAAAA,EAAAA,KAAc,6BAA8B,CAAEC,KAAM,UAAWC,MAAO,UAAWC,GAAI,WAAaC,EAAAA,EAAa,yBAA0B,4EACrKE,GAAuBN,EAAAA,EAAAA,KAAc,kCAAmC,CAAEC,KAAM,YAAaC,MAAO,YAAaC,GAAI,MAAQC,EAAAA,EAAa,iBAAkB,yJAAyJ,GACrTG,GAA6BP,EAAAA,EAAAA,KAAc,8BAA+B,CAAEC,KAAM,KAAMC,MAAO,KAAMC,GAAIK,EAAAA,KAAwBJ,EAAAA,EAAa,uBAAwB,8DAA8D,GACpOK,GAAwBT,EAAAA,EAAAA,KAAc,mCAAoC,CAAEC,KAAMS,EAAAA,IAA0BR,MAAOQ,EAAAA,IAA0BP,GAAI,MAAQC,EAAAA,EAAa,kBAAmB,yKAAyK,GAClWO,GAA8BX,EAAAA,EAAAA,KAAc,+BAAgC,CAAEC,KAAM,KAAMC,MAAO,KAAMC,GAAIK,EAAAA,KAAwBJ,EAAAA,EAAa,wBAAyB,+DAA+D,GACxOQ,GAAyBZ,EAAAA,EAAAA,KAAc,0BAA2B,CAAEC,KAAM,UAAWC,MAAOW,EAAAA,GAAAA,MAAaV,GAAIU,EAAAA,GAAAA,OAAeT,EAAAA,EAAa,QAAS,gCAClJU,GAAyBd,EAAAA,EAAAA,KAAc,0BAA2B,KAAMI,EAAAA,EAAa,yBAA0B,yHAC/GW,GAAoBf,EAAAA,EAAAA,KAAc,8BAA+B,CAAEC,KAAM,YAAaC,MAAO,YAAaC,GAAI,aAAeC,EAAAA,EAAa,oBAAqB,kDAC/JY,GAAqBhB,EAAAA,EAAAA,KAAc,+BAAgC,CAAEC,KAAMc,EAAmBb,MAAOa,EAAmBZ,GAAIY,GAAqBX,EAAAA,EAAa,qBAAsB,4CACpLa,GAA2BjB,EAAAA,EAAAA,KAAc,qCAAsC,CAAEC,KAAMc,EAAmBb,MAAOa,EAAmBZ,GAAIY,GAAqBX,EAAAA,EAAa,0BAA2B,mDACrMc,GAAoBlB,EAAAA,EAAAA,KAAc,8BAA+B,CAAEC,KAAM,UAAWC,MAAO,UAAWC,GAAIU,EAAAA,GAAAA,OAAeT,EAAAA,EAAa,oBAAqB,kCAClKe,GAAmCnB,EAAAA,EAAAA,KAAc,oCAAqC,CAAEC,KAAM,UAAWC,MAAO,UAAWC,GAAIK,EAAAA,KAAwBJ,EAAAA,EAAa,yBAA0B,uCAAuC,EAAOA,EAAAA,EAAa,mCAAoC,uEACtRgB,GAAyBpB,EAAAA,EAAAA,KAAc,oCAAqC,CAAEC,KAAMkB,EAAkCjB,MAAOiB,EAAkChB,GAAIgB,GAAoCf,EAAAA,EAAa,yBAA0B,uCAC9OiB,GAAcrB,EAAAA,EAAAA,KAAc,yBAA0B,CAAEC,KAAM,UAAWC,MAAOW,EAAAA,GAAAA,UAAiBV,GAAIU,EAAAA,GAAAA,OAAeT,EAAAA,EAAa,cAAe,gCAEhJkB,IAD2BtB,EAAAA,EAAAA,KAAc,4BAA6B,CAAEC,KAAM,UAAWC,MAAO,UAAWC,GAAI,WAAaC,EAAAA,EAAa,2BAA4B,yCACtIJ,EAAAA,EAAAA,KAAc,gCAAiC,CAAEC,KAAM,YAAaC,MAAO,YAAaC,GAAI,aAAeC,EAAAA,EAAa,+BAAgC,+CACvLmB,GAA2BvB,EAAAA,EAAAA,KAAc,4BAA6B,CAAEC,KAAM,OAAQC,MAAO,UAAWC,GAAIqB,EAAAA,KAAkBpB,EAAAA,EAAa,2BAA4B,sCACvKqB,GAA4BzB,EAAAA,EAAAA,KAAc,6BAA8B,CAAEC,KAAM,YAAaC,MAAO,YAAaC,GAAI,aAAeC,EAAAA,EAAa,4BAA6B,wCAC9KsB,GAAgC1B,EAAAA,EAAAA,KAAc,iCAAkC,KAAMI,EAAAA,EAAa,gCAAiC,qIACpIuB,GAAe3B,EAAAA,EAAAA,KAAc,0BAA2B,CAAEC,KAAM2B,EAAAA,IAAkB1B,MAAO0B,EAAAA,IAAkBzB,GAAIyB,EAAAA,KAAoBxB,EAAAA,EAAa,eAAgB,uGAChKyB,GAA8B7B,EAAAA,EAAAA,KAAc,+BAAgC,CAAEC,KAAM,KAAMC,MAAO,KAAMC,GAAIU,EAAAA,GAAAA,QAAc,QAAQiB,YAAY,KAAQ1B,EAAAA,EAAa,wBAAyB,oEAC3L2B,GAA+B/B,EAAAA,EAAAA,KAAc,gCAAiC,CAAEC,KAAMY,EAAAA,GAAAA,QAAc,SAAUX,MAAOW,EAAAA,GAAAA,QAAc,SAAUV,GAAI,MAAQC,EAAAA,EAAa,yBAA0B,uQAChM4B,GAAkBhC,EAAAA,EAAAA,KAAc,yBAA0B,CAAEC,KAAM,KAAMC,MAAO,KAAMC,GAAIU,EAAAA,GAAAA,QAAc,QAAQiB,YAAY,KAAQ1B,EAAAA,EAAa,wBAAyB,8CACzK6B,GAAsBjC,EAAAA,EAAAA,KAAc,6BAA8B,CAAEC,KAAMY,EAAAA,GAAAA,QAAc,aAAcX,MAAOW,EAAAA,GAAAA,QAAc,SAAUV,GAAI,MAAQC,EAAAA,EAAa,4BAA6B,sDAC3L8B,GAAsBlC,EAAAA,EAAAA,KAAc,6BAA8B,CAAEC,KAAM,KAAMC,MAAO,KAAMC,GAAI,MAAQC,EAAAA,EAAa,4BAA6B,sDAC1J+B,EAAoB,IAAItB,EAAAA,GAAM,IAAIuB,EAAAA,GAAK,EAAG,IAAK,IAAK,KAC7CC,GAA8BrC,EAAAA,EAAAA,KAAc,+CAAgD,CAAEC,KAAMkC,EAAmBjC,MAAOiC,EAAmBhC,GAAIgC,GAAqB/B,EAAAA,EAAa,8BAA+B,6HAA6H,GACnVkC,GAAqBtC,EAAAA,EAAAA,KAAc,sCAAuC,CAAEC,KAAM,IAAIY,EAAAA,GAAM,IAAIuB,EAAAA,GAAK,IAAK,GAAI,GAAI,KAAOlC,MAAO,IAAIW,EAAAA,GAAM,IAAIuB,EAAAA,GAAK,IAAK,GAAI,GAAI,KAAOjC,GAAI,IAAIU,EAAAA,GAAM,IAAIuB,EAAAA,GAAK,IAAK,GAAI,GAAI,KAAOhC,EAAAA,EAAa,oBAAqB,4CACpPmC,GAAuBvC,EAAAA,EAAAA,KAAc,wCAAyC,CAAEC,KAAMuC,EAAAA,IAAyBtC,MAAOsC,EAAAA,IAAyBrC,GAAIsC,EAAAA,KAAuBrC,EAAAA,EAAa,sBAAuB,8CAC9MsC,GAAoB1C,EAAAA,EAAAA,KAAc,qCAAsC,CAAEC,KAAM0C,EAAAA,IAAsBzC,MAAOyC,EAAAA,IAAsBxC,GAAIyC,EAAAA,KAAoBxC,EAAAA,EAAa,mBAAoB,2CAC5LyC,GAAuC7C,EAAAA,EAAAA,KAAc,qCAAsC,CAAEC,KAAM,UAAWC,MAAO,YAAaC,GAAI,WAAaC,EAAAA,EAAa,oCAAqC,mFACrM0C,GAAuC9C,EAAAA,EAAAA,KAAc,qCAAsC,CAAEC,KAAM,UAAWC,MAAO,YAAaC,GAAI,WAAaC,EAAAA,EAAa,oCAAqC,mFACrM2C,GAAuC/C,EAAAA,EAAAA,KAAc,qCAAsC,CAAEC,KAAM,UAAWC,MAAO,YAAaC,GAAI,WAAaC,EAAAA,EAAa,oCAAqC,mFACrM4C,GAAuChD,EAAAA,EAAAA,KAAc,qCAAsC,CAAEC,KAAM,YAAaC,MAAO,YAAaC,GAAI,aAAeC,EAAAA,EAAa,oCAAqC,mFACzM6C,GAAuCjD,EAAAA,EAAAA,KAAc,qCAAsC,CAAEC,KAAM,YAAaC,MAAO,YAAaC,GAAI,aAAeC,EAAAA,EAAa,oCAAqC,mFACzM8C,GAAuClD,EAAAA,EAAAA,KAAc,qCAAsC,CAAEC,KAAM,YAAaC,MAAO,YAAaC,GAAI,aAAeC,EAAAA,EAAa,oCAAqC,mFACzM+C,GAAuDnD,EAAAA,EAAAA,KAAc,sDAAuD,CAAEC,KAAM,IAAIY,EAAAA,GAAM,IAAIuB,EAAAA,GAAK,IAAK,GAAI,GAAI,KAAOlC,MAAO,IAAIW,EAAAA,GAAM,IAAIuB,EAAAA,GAAK,IAAK,GAAI,GAAI,KAAOjC,GAAI,IAAIU,EAAAA,GAAM,IAAIuB,EAAAA,GAAK,IAAK,GAAI,GAAI,KAAOhC,EAAAA,EAAa,oDAAqD,6CACtUgD,GAAoCpD,EAAAA,EAAAA,KAAc,qCAAsC,CAAEC,KAAM,YAAaC,MAAO,YAAaC,GAAI,aAAeC,EAAAA,EAAa,qCAAsC,iGACvMiD,GAAoCrD,EAAAA,EAAAA,KAAc,qCAAsC,CAAEC,KAAM,YAAaC,MAAO,YAAaC,GAAI,aAAeC,EAAAA,EAAa,qCAAsC,iGACvMkD,GAAoCtD,EAAAA,EAAAA,KAAc,qCAAsC,CAAEC,KAAM,YAAaC,MAAO,YAAaC,GAAI,aAAeC,EAAAA,EAAa,qCAAsC,iGACvMmD,GAAoCvD,EAAAA,EAAAA,KAAc,qCAAsC,CAAEC,KAAM,YAAaC,MAAO,YAAaC,GAAI,aAAeC,EAAAA,EAAa,qCAAsC,iGACvMoD,GAAoCxD,EAAAA,EAAAA,KAAc,qCAAsC,CAAEC,KAAM,YAAaC,MAAO,YAAaC,GAAI,aAAeC,EAAAA,EAAa,qCAAsC,iGACvMqD,GAAoCzD,EAAAA,EAAAA,KAAc,qCAAsC,CAAEC,KAAM,YAAaC,MAAO,YAAaC,GAAI,aAAeC,EAAAA,EAAa,qCAAsC,iGACvMsD,GAA0C1D,EAAAA,EAAAA,KAAc,2CAA4C,CAAEC,KAAM,YAAaC,MAAO,YAAaC,GAAI,aAAeC,EAAAA,EAAa,2CAA4C,+FACzNuD,GAA0C3D,EAAAA,EAAAA,KAAc,2CAA4C,CAAEC,KAAM,YAAaC,MAAO,YAAaC,GAAI,aAAeC,EAAAA,EAAa,2CAA4C,+FACzNwD,GAA0C5D,EAAAA,EAAAA,KAAc,2CAA4C,CAAEC,KAAM,YAAaC,MAAO,YAAaC,GAAI,aAAeC,EAAAA,EAAa,2CAA4C,+FACzNyD,GAA0C7D,EAAAA,EAAAA,KAAc,2CAA4C,CAAEC,KAAM,YAAaC,MAAO,YAAaC,GAAI,aAAeC,EAAAA,EAAa,2CAA4C,+FACzN0D,IAA0C9D,EAAAA,EAAAA,KAAc,2CAA4C,CAAEC,KAAM,YAAaC,MAAO,YAAaC,GAAI,aAAeC,EAAAA,EAAa,2CAA4C,+FACzN2D,IAA0C/D,EAAAA,EAAAA,KAAc,2CAA4C,CAAEC,KAAM,YAAaC,MAAO,YAAaC,GAAI,aAAeC,EAAAA,EAAa,2CAA4C,gGAC1LJ,EAAAA,EAAAA,KAAc,gCAAiC,CAAEC,KAAM,UAAWC,MAAO,UAAWC,GAAI,WAAaC,EAAAA,EAAa,gCAAiC,wDAE/L4D,EAAAA,EAAAA,KAA2B,SAACC,EAAOC,GAC/B,IAAMC,EAAaF,EAAMG,SAASxC,EAAAA,KAC9BuC,GACAD,EAAUG,QAAV,6GAAwHF,EAAxH,QAEJ,IAAMG,EAAaL,EAAMG,SAASG,EAAAA,KAC9BD,GACAJ,EAAUG,QAAV,uEAAkFC,EAAlF,QAEJ,IAAME,EAASP,EAAMG,SAASzC,GAC1B6C,GACAN,EAAUG,QAAV,qDAAgEG,EAAhE,QAEJ,IAAMC,EAAiBR,EAAMG,SAAS9D,GAClCmE,GACAP,EAAUG,QAAV,6DAAwEI,EAAxE,QAEJ,IAAMC,EAAuBT,EAAMG,SAAS7D,GACxCmE,GACAR,EAAUG,QAAV,uDAAiF,OAAfJ,EAAMU,KAAgB,SAAW,QAAnG,YAA8GD,EAA9G,QAEJ,IAAME,EAAkBX,EAAMG,SAAS3D,GACnCmE,GACAV,EAAUG,QAAV,8DAAyEO,EAAzE,QAEJ,IAAMC,EAAwBZ,EAAMG,SAASzD,GACzCkE,GACAX,EAAUG,QAAV,wDAAkF,OAAfJ,EAAMU,KAAgB,SAAW,QAApG,YAA+GE,EAA/G,QAEJ,IAAMC,EAAab,EAAMG,SAASrD,GAC9B+D,IACAZ,EAAUG,QAAV,wCAAmDS,EAAnD,mBACAZ,EAAUG,QAAV,wCAAmDS,EAAnD,mBAEP,G,wBC7FM,SAASC,EAASrG,GAKrB,IAJA,IAAIsG,EAAW,EACXC,EAAkB,EAClBC,EAAgB,EAChBpG,EAAM,EACDnB,EAAI,EAAGwH,EAAMzG,EAAKD,OAAQd,EAAIwH,EAAKxH,IAAK,CAC7C,IAAMyH,EAAM1G,EAAK2G,WAAW1H,GAChB,KAARyH,GACiB,IAAbJ,IACAC,EAAkBtH,GAEtBqH,IACIrH,EAAI,EAAIwH,GAAkC,KAA3BzG,EAAK2G,WAAW1H,EAAI,IAEnCmB,GAAO,EACPnB,KAIAmB,GAAO,EAEXoG,EAAgBvH,EAAI,GAEP,KAARyH,IAELtG,GAAO,EACU,IAAbkG,IACAC,EAAkBtH,GAEtBqH,IACAE,EAAgBvH,EAAI,EAE3B,CAID,OAHiB,IAAbqH,IACAC,EAAkBvG,EAAKD,QAEpB,CAACuG,EAAUC,EAAiBvG,EAAKD,OAASyG,EAAepG,EACnE,C,sGCbM,SAASwG,EAAqBC,EAAKhG,EAAYiG,GAClD,IAAIC,EAA0BtH,EAAAA,GAAgCoH,GAI9D,OAHiC,IAA7BE,IACAA,EAA0BF,EAAI9G,QA1BtC,SAA6C8G,EAAKhG,EAAYiG,GAE1D,IADA,IAAIE,EAAY,EACP/H,EAAI,EAAGA,EAAI4H,EAAI9G,OAAQd,IACN,OAAlB4H,EAAII,OAAOhI,GACX+H,GAAanG,EAGbmG,IAGR,IAAI7G,EAAS,GACb,IAAK2G,EAAc,CACf,IAAMI,EAAUrH,KAAKsH,MAAMH,EAAYnG,GACvCmG,GAAwBnG,EACxB,IAAK,IAAI5B,EAAI,EAAGA,EAAIiI,EAASjI,IACzBkB,GAAU,IAEjB,CACD,IAAK,IAAIlB,EAAI,EAAGA,EAAI+H,EAAW/H,IAC3BkB,GAAU,IAEd,OAAOA,CACV,CAMUiH,CAAoCP,EAAI5G,UAAU,EAAG8G,GAA0BlG,EAAYiG,GAAgBD,EAAI5G,UAAU8G,EACnI,C,kFC3BYM,EAAb,WACI,WAAYlG,EAAYxB,IAAQ,eAC5BtB,KAAK8C,WAAaA,EAClB9C,KAAKsB,OAASA,CACjB,CAJL,mCAWI,WAA+D,IAA1D2H,EAA0D,uDAA1CjJ,KAAK8C,WAAYoG,EAAyB,uDAAblJ,KAAKsB,OACnD,OAAI2H,IAAkBjJ,KAAK8C,YAAcoG,IAAclJ,KAAKsB,OACjDtB,KAGA,IAAIgJ,EAASC,EAAeC,EAE1C,GAlBL,mBAyBI,WAA4C,IAAtCC,EAAsC,uDAApB,EAAGC,EAAiB,uDAAH,EACrC,OAAOpJ,KAAKqJ,KAAKrJ,KAAK8C,WAAaqG,EAAiBnJ,KAAKsB,OAAS8H,EACrE,GA3BL,oBA+BI,SAAOE,GACH,OAAON,EAASO,OAAOvJ,KAAMsJ,EAChC,GAjCL,sBAkDI,SAASA,GACL,OAAON,EAASQ,SAASxJ,KAAMsJ,EAClC,GApDL,6BAsEI,SAAgBA,GACZ,OAAON,EAASS,gBAAgBzJ,KAAMsJ,EACzC,GAxEL,mBAsGI,WACI,OAAO,IAAIN,EAAShJ,KAAK8C,WAAY9C,KAAKsB,OAC7C,GAxGL,sBA4GI,WACI,MAAO,IAAMtB,KAAK8C,WAAa,IAAM9C,KAAKsB,OAAS,GACtD,IA9GL,qBAqCI,SAAcoI,EAAGC,GACb,OAAKD,IAAMC,KAGDD,KACJC,GACFD,EAAE5G,aAAe6G,EAAE7G,YACnB4G,EAAEpI,SAAWqI,EAAErI,MACtB,GA7CL,sBAyDI,SAAgBoI,EAAGC,GACf,OAAID,EAAE5G,WAAa6G,EAAE7G,cAGjB6G,EAAE7G,WAAa4G,EAAE5G,aAGd4G,EAAEpI,OAASqI,EAAErI,MACvB,GAjEL,6BA6EI,SAAuBoI,EAAGC,GACtB,OAAID,EAAE5G,WAAa6G,EAAE7G,cAGjB6G,EAAE7G,WAAa4G,EAAE5G,aAGd4G,EAAEpI,QAAUqI,EAAErI,MACxB,GArFL,qBAyFI,SAAeoI,EAAGC,GACd,IAAMC,EAA6B,EAAfF,EAAE5G,WAChB+G,EAA6B,EAAfF,EAAE7G,WACtB,OAAI8G,IAAgBC,GACW,EAAXH,EAAEpI,SACS,EAAXqI,EAAErI,QAGfsI,EAAcC,CACxB,GAlGL,kBAmHI,SAAYC,GACR,OAAO,IAAId,EAASc,EAAIhH,WAAYgH,EAAIxI,OAC3C,GArHL,yBAyHI,SAAmByI,GACf,OAAQA,GAC0B,kBAAnBA,EAAIjH,YACW,kBAAfiH,EAAIzI,MACtB,KA7HL,I,6FCCauB,EAAb,WACI,WAAYmH,EAAiBC,EAAaC,EAAeC,IAAW,eAC3DH,EAAkBE,GAAmBF,IAAoBE,GAAiBD,EAAcE,GACzFnK,KAAKgK,gBAAkBE,EACvBlK,KAAKiK,YAAcE,EACnBnK,KAAKkK,cAAgBF,EACrBhK,KAAKmK,UAAYF,IAGjBjK,KAAKgK,gBAAkBA,EACvBhK,KAAKiK,YAAcA,EACnBjK,KAAKkK,cAAgBA,EACrBlK,KAAKmK,UAAYA,EAExB,CAdL,sCAkBI,WACI,OAAOtH,EAAMuH,QAAQpK,KACxB,GApBL,8BA8BI,SAAiB2C,GACb,OAAOE,EAAMwH,iBAAiBrK,KAAM2C,EACvC,GAhCL,2BAmEI,SAAcC,GACV,OAAOC,EAAMyH,cAActK,KAAM4C,EACpC,GArEL,iCA2FI,SAAoBA,GAChB,OAAOC,EAAM0H,oBAAoBvK,KAAM4C,EAC1C,GA7FL,uBAoHI,SAAUA,GACN,OAAOC,EAAM2H,UAAUxK,KAAM4C,EAChC,GAtHL,6BA6JI,SAAgBA,GACZ,OAAOC,EAAM4H,gBAAgBzK,KAAM4C,EACtC,GA/JL,yBAsMI,SAAY0G,GACR,OAAOzG,EAAM6H,YAAY1K,KAAMsJ,EAClC,GAxML,4BAuNI,WACI,OAAOzG,EAAM8H,eAAe3K,KAC/B,GAzNL,8BAmOI,WACI,OAAO6C,EAAM+H,iBAAiB5K,KACjC,GArOL,sBA+OI,WACI,MAAO,IAAMA,KAAKgK,gBAAkB,IAAMhK,KAAKiK,YAAc,OAASjK,KAAKkK,cAAgB,IAAMlK,KAAKmK,UAAY,GACrH,GAjPL,4BAqPI,SAAeD,EAAeC,GAC1B,OAAO,IAAItH,EAAM7C,KAAKgK,gBAAiBhK,KAAKiK,YAAaC,EAAeC,EAC3E,GAvPL,8BA2PI,SAAiBH,EAAiBC,GAC9B,OAAO,IAAIpH,EAAMmH,EAAiBC,EAAajK,KAAKkK,cAAelK,KAAKmK,UAC3E,GA7PL,6BAiQI,WACI,OAAOtH,EAAMgI,gBAAgB7K,KAChC,GAnQL,oBA+WI,WACI,OAAOA,IACV,IAjXL,sBAwBI,SAAe4C,GACX,OAAQA,EAAMoH,kBAAoBpH,EAAMsH,eAAiBtH,EAAMqH,cAAgBrH,EAAMuH,SACxF,GA1BL,8BAoCI,SAAwBvH,EAAOD,GAC3B,QAAIA,EAASG,WAAaF,EAAMoH,iBAAmBrH,EAASG,WAAaF,EAAMsH,mBAG3EvH,EAASG,aAAeF,EAAMoH,iBAAmBrH,EAASrB,OAASsB,EAAMqH,gBAGzEtH,EAASG,aAAeF,EAAMsH,eAAiBvH,EAASrB,OAASsB,EAAMuH,WAI9E,GA/CL,oCAoDI,SAA8BvH,EAAOD,GACjC,QAAIA,EAASG,WAAaF,EAAMoH,iBAAmBrH,EAASG,WAAaF,EAAMsH,mBAG3EvH,EAASG,aAAeF,EAAMoH,iBAAmBrH,EAASrB,QAAUsB,EAAMqH,gBAG1EtH,EAASG,aAAeF,EAAMsH,eAAiBvH,EAASrB,QAAUsB,EAAMuH,WAI/E,GA/DL,2BAyEI,SAAqBvH,EAAOkI,GACxB,QAAIA,EAAWd,gBAAkBpH,EAAMoH,iBAAmBc,EAAWZ,cAAgBtH,EAAMoH,qBAGvFc,EAAWd,gBAAkBpH,EAAMsH,eAAiBY,EAAWZ,cAAgBtH,EAAMsH,mBAGrFY,EAAWd,kBAAoBpH,EAAMoH,iBAAmBc,EAAWb,YAAcrH,EAAMqH,gBAGvFa,EAAWZ,gBAAkBtH,EAAMsH,eAAiBY,EAAWX,UAAYvH,EAAMuH,YAIxF,GAvFL,iCAiGI,SAA2BvH,EAAOkI,GAC9B,QAAIA,EAAWd,gBAAkBpH,EAAMoH,iBAAmBc,EAAWZ,cAAgBtH,EAAMoH,qBAGvFc,EAAWd,gBAAkBpH,EAAMsH,eAAiBY,EAAWZ,cAAgBtH,EAAMsH,mBAGrFY,EAAWd,kBAAoBpH,EAAMoH,iBAAmBc,EAAWb,aAAerH,EAAMqH,gBAGxFa,EAAWZ,gBAAkBtH,EAAMsH,eAAiBY,EAAWX,WAAavH,EAAMuH,YAIzF,GA/GL,uBA2HI,SAAiBT,EAAGC,GAChB,IAAIK,EACAC,EACAC,EACAC,EAyBJ,OAxBIR,EAAEK,gBAAkBN,EAAEM,iBACtBA,EAAkBL,EAAEK,gBACpBC,EAAcN,EAAEM,aAEXN,EAAEK,kBAAoBN,EAAEM,iBAC7BA,EAAkBL,EAAEK,gBACpBC,EAAczI,KAAKC,IAAIkI,EAAEM,YAAaP,EAAEO,eAGxCD,EAAkBN,EAAEM,gBACpBC,EAAcP,EAAEO,aAEhBN,EAAEO,cAAgBR,EAAEQ,eACpBA,EAAgBP,EAAEO,cAClBC,EAAYR,EAAEQ,WAETR,EAAEO,gBAAkBR,EAAEQ,eAC3BA,EAAgBP,EAAEO,cAClBC,EAAY3I,KAAKiB,IAAIkH,EAAEQ,UAAWT,EAAES,aAGpCD,EAAgBR,EAAEQ,cAClBC,EAAYT,EAAES,WAEX,IAAItH,EAAMmH,EAAiBC,EAAaC,EAAeC,EACjE,GAzJL,6BAmKI,SAAuBT,EAAGC,GACtB,IAAIoB,EAAwBrB,EAAEM,gBAC1BgB,EAAoBtB,EAAEO,YACtBgB,EAAsBvB,EAAEQ,cACxBgB,EAAkBxB,EAAES,UACpBgB,EAAuBxB,EAAEK,gBACzBoB,EAAmBzB,EAAEM,YACrBoB,EAAqB1B,EAAEO,cACvBoB,EAAiB3B,EAAEQ,UAgBvB,OAfIY,EAAwBI,GACxBJ,EAAwBI,EACxBH,EAAoBI,GAEfL,IAA0BI,IAC/BH,EAAoBxJ,KAAKiB,IAAIuI,EAAmBI,IAEhDH,EAAsBI,GACtBJ,EAAsBI,EACtBH,EAAkBI,GAEbL,IAAwBI,IAC7BH,EAAkB1J,KAAKC,IAAIyJ,EAAiBI,IAG5CP,EAAwBE,GAGxBF,IAA0BE,GAAuBD,EAAoBE,EAF9D,KAKJ,IAAIrI,EAAMkI,EAAuBC,EAAmBC,EAAqBC,EACnF,GAlML,yBA4MI,SAAmBxB,EAAGC,GAClB,QAAUD,KACJC,GACFD,EAAEM,kBAAoBL,EAAEK,iBACxBN,EAAEO,cAAgBN,EAAEM,aACpBP,EAAEQ,gBAAkBP,EAAEO,eACtBR,EAAES,YAAcR,EAAEQ,SACzB,GAnNL,4BA6NI,SAAsBvH,GAClB,OAAO,IAAIoG,EAAAA,EAASpG,EAAMsH,cAAetH,EAAMuH,UAClD,GA/NL,8BAyOI,SAAwBvH,GACpB,OAAO,IAAIoG,EAAAA,EAASpG,EAAMoH,gBAAiBpH,EAAMqH,YACpD,GA3OL,6BAuQI,SAAuBrH,GACnB,OAAO,IAAIC,EAAMD,EAAMoH,gBAAiBpH,EAAMqH,YAAarH,EAAMoH,gBAAiBpH,EAAMqH,YAC3F,GAzQL,2BA2QI,SAAqBsB,GAAoB,IAAbC,EAAa,uDAAPD,EAC9B,OAAO,IAAI1I,EAAM0I,EAAMzI,WAAYyI,EAAMjK,OAAQkK,EAAI1I,WAAY0I,EAAIlK,OACxE,GA7QL,kBA8QI,SAAYsB,GACR,OAAKA,EAGE,IAAIC,EAAMD,EAAMoH,gBAAiBpH,EAAMqH,YAAarH,EAAMsH,cAAetH,EAAMuH,WAF3E,IAGd,GAnRL,sBAuRI,SAAgBJ,GACZ,OAAQA,GAC+B,kBAAxBA,EAAIC,iBACgB,kBAApBD,EAAIE,aACkB,kBAAtBF,EAAIG,eACc,kBAAlBH,EAAII,SACtB,GA7RL,uCAiSI,SAAiCT,EAAGC,GAEhC,QAAID,EAAEQ,cAAgBP,EAAEK,iBAAoBN,EAAEQ,gBAAkBP,EAAEK,iBAAmBN,EAAES,UAAYR,EAAEM,gBAIjGN,EAAEO,cAAgBR,EAAEM,iBAAoBL,EAAEO,gBAAkBR,EAAEM,iBAAmBL,EAAEQ,UAAYT,EAAEO,YAKxG,GA5SL,6BAgTI,SAAuBP,EAAGC,GAEtB,QAAID,EAAEQ,cAAgBP,EAAEK,iBAAoBN,EAAEQ,gBAAkBP,EAAEK,iBAAmBN,EAAES,WAAaR,EAAEM,gBAIlGN,EAAEO,cAAgBR,EAAEM,iBAAoBL,EAAEO,gBAAkBR,EAAEM,iBAAmBL,EAAEQ,WAAaT,EAAEO,YAKzG,GA3TL,sCAgUI,SAAgCP,EAAGC,GAC/B,GAAID,GAAKC,EAAG,CACR,IAAM8B,EAAuC,EAApB/B,EAAEM,gBACrB0B,EAAuC,EAApB/B,EAAEK,gBAC3B,GAAIyB,IAAqBC,EAAkB,CACvC,IAAMC,EAA+B,EAAhBjC,EAAEO,YACjB2B,EAA+B,EAAhBjC,EAAEM,YACvB,GAAI0B,IAAiBC,EAAc,CAC/B,IAAMC,EAAmC,EAAlBnC,EAAEQ,cACnB4B,EAAmC,EAAlBnC,EAAEO,cACzB,OAAI2B,IAAmBC,GACc,EAAdpC,EAAES,YACY,EAAdR,EAAEQ,WAGlB0B,EAAiBC,CAC3B,CACD,OAAOH,EAAeC,CACzB,CACD,OAAOH,EAAmBC,CAC7B,CAGD,OAFiBhC,EAAI,EAAI,IACRC,EAAI,EAAI,EAE5B,GAxVL,oCA6VI,SAA8BD,EAAGC,GAC7B,OAAID,EAAEQ,gBAAkBP,EAAEO,cAClBR,EAAES,YAAcR,EAAEQ,UACdT,EAAEM,kBAAoBL,EAAEK,gBACjBN,EAAEO,YAAcN,EAAEM,YAEtBP,EAAEM,gBAAkBL,EAAEK,gBAE1BN,EAAES,UAAYR,EAAEQ,UAEpBT,EAAEQ,cAAgBP,EAAEO,aAC9B,GAxWL,gCA4WI,SAA0BtH,GACtB,OAAOA,EAAMsH,cAAgBtH,EAAMoH,eACtC,KA9WL,I,kFCAa+B,EAAb,WACI,WAAYC,EAAGC,EAAGtC,EAAGD,IAAG,eACpB1J,KAAKkM,iBAAcC,EACnBnM,KAAKgM,EAAID,EAAMK,OAAOJ,GACtBhM,KAAKiM,EAAIF,EAAMK,OAAOH,GACtBjM,KAAK2J,EAAIoC,EAAMK,OAAOzC,GACtB3J,KAAK0J,EAAIqC,EAAMK,OAAO1C,EACzB,CAPL,qCAQI,SAAOJ,GACH,OAAQtJ,KAAKgM,IAAM1C,EAAM0C,GAClBhM,KAAKiM,IAAM3C,EAAM2C,GACjBjM,KAAK2J,IAAML,EAAMK,GACjB3J,KAAK0J,IAAMJ,EAAMI,CAC3B,IAbL,qBAcI,SAAc2C,GACV,OAAIA,EAAI,EACG,EAEPA,EAAI,IACG,IAEA,EAAJA,CACV,KAtBL,KAwBAN,EAAMO,MAAQ,IAAIP,EAAM,EAAG,EAAG,EAAG,E,mHCtBpBQ,EAAb,0CACI,WAAYC,EAA0BC,EAAsBC,EAAoBC,GAAgB,6BAC5F,cAAMH,EAA0BC,EAAsBC,EAAoBC,IACrEH,yBAA2BA,EAChC,EAAKC,qBAAuBA,EAC5B,EAAKC,mBAAqBA,EAC1B,EAAKC,eAAiBA,EALsE,CAM/F,CAPL,uCAWI,WACI,MAAO,IAAM3M,KAAKwM,yBAA2B,IAAMxM,KAAKyM,qBAAuB,OAASzM,KAAK0M,mBAAqB,IAAM1M,KAAK2M,eAAiB,GACjJ,GAbL,6BAiBI,SAAgBrD,GACZ,OAAQiD,EAAUK,gBAAgB5M,KAAMsJ,EAC3C,GAnBL,0BAgCI,WACI,OAAItJ,KAAKwM,2BAA6BxM,KAAKgK,iBAAmBhK,KAAKyM,uBAAyBzM,KAAKiK,YACtF,EAEJ,CACV,GArCL,4BAyCI,SAAeC,EAAeC,GAC1B,OAA4B,IAAxBnK,KAAK6M,eACE,IAAIN,EAAUvM,KAAKgK,gBAAiBhK,KAAKiK,YAAaC,EAAeC,GAEzE,IAAIoC,EAAUrC,EAAeC,EAAWnK,KAAKgK,gBAAiBhK,KAAKiK,YAC7E,GA9CL,yBAkDI,WACI,OAAO,IAAIjB,EAAAA,EAAShJ,KAAK0M,mBAAoB1M,KAAK2M,eACrD,GApDL,+BAwDI,WACI,OAAO,IAAI3D,EAAAA,EAAShJ,KAAKwM,yBAA0BxM,KAAKyM,qBAC3D,GA1DL,8BA8DI,SAAiBzC,EAAiBC,GAC9B,OAA4B,IAAxBjK,KAAK6M,eACE,IAAIN,EAAUvC,EAAiBC,EAAajK,KAAKkK,cAAelK,KAAKmK,WAEzE,IAAIoC,EAAUvM,KAAKkK,cAAelK,KAAKmK,UAAWH,EAAiBC,EAC7E,IAnEL,8BAuBI,SAAuBP,EAAGC,GACtB,OAAQD,EAAE8C,2BAA6B7C,EAAE6C,0BACrC9C,EAAE+C,uBAAyB9C,EAAE8C,sBAC7B/C,EAAEgD,qBAAuB/C,EAAE+C,oBAC3BhD,EAAEiD,iBAAmBhD,EAAEgD,cAC9B,GA5BL,2BAwEI,SAAqBpB,GAAoB,IAAbC,EAAa,uDAAPD,EAC9B,OAAO,IAAIgB,EAAUhB,EAAMzI,WAAYyI,EAAMjK,OAAQkK,EAAI1I,WAAY0I,EAAIlK,OAC5E,GA1EL,uBA8EI,SAAiBsB,EAAOkK,GACpB,OAAkB,IAAdA,EACO,IAAIP,EAAU3J,EAAMoH,gBAAiBpH,EAAMqH,YAAarH,EAAMsH,cAAetH,EAAMuH,WAGnF,IAAIoC,EAAU3J,EAAMsH,cAAetH,EAAMuH,UAAWvH,EAAMoH,gBAAiBpH,EAAMqH,YAE/F,GArFL,2BAyFI,SAAqB8C,GACjB,OAAO,IAAIR,EAAUQ,EAAIP,yBAA0BO,EAAIN,qBAAsBM,EAAIL,mBAAoBK,EAAIJ,eAC5G,GA3FL,gCA+FI,SAA0BjD,EAAGC,GACzB,GAAID,IAAMC,IAAMD,GAAKC,EACjB,OAAO,EAEX,IAAKD,IAAMC,EACP,OAAO,EAEX,GAAID,EAAEhI,SAAWiI,EAAEjI,OACf,OAAO,EAEX,IAAK,IAAId,EAAI,EAAGwH,EAAMsB,EAAEhI,OAAQd,EAAIwH,EAAKxH,IACrC,IAAKZ,KAAK4M,gBAAgBlD,EAAE9I,GAAI+I,EAAE/I,IAC9B,OAAO,EAGf,OAAO,CACV,GA/GL,0BAmHI,SAAoBmJ,GAChB,OAAQA,GACwC,kBAAjCA,EAAIyC,0BACyB,kBAA7BzC,EAAI0C,sBACuB,kBAA3B1C,EAAI2C,oBACmB,kBAAvB3C,EAAI4C,cACtB,GAzHL,iCA6HI,SAA2B3C,EAAiBC,EAAaC,EAAeC,EAAW2C,GAC/E,OAAkB,IAAdA,EACO,IAAIP,EAAUvC,EAAiBC,EAAaC,EAAeC,GAE/D,IAAIoC,EAAUrC,EAAeC,EAAWH,EAAiBC,EACnE,KAlIL,G,SAA+BpH,E,qICH3BmK,EAOAC,EAOAC,E,sDAbJ,SAASC,IAIL,OAHKH,IACDA,EAAuB,IAAII,YAAY,aAEpCJ,CACV,CASM,SAASK,IAIZ,OAHKH,IACDA,EAAuBI,EAAAA,IAA4BH,KARlDF,IACDA,EAAuB,IAAIG,YAAY,aAEpCH,IAOAC,CACV,CACM,IACIK,EACAC,EAFEC,EAAyC,qBAAhBL,YAsBtC,SAASM,EAAoBC,EAAQ3L,EAAQoG,GAGzC,IAFA,IAAMtG,EAAS,GACX8L,EAAY,EACPhN,EAAI,EAAGA,EAAIwH,EAAKxH,IAAK,CAC1B,IAAMP,EAAWwN,EAAAA,GAAoBF,EAAQ3L,GAC7CA,GAAU,EACVF,EAAO8L,KAAeE,OAAOC,aAAa1N,EAC7C,CACD,OAAOyB,EAAOkM,KAAK,GACtB,CA5BGP,GACAF,EAAsB,SAACU,GAAD,OAAc,IAAIC,EAAcD,EAAhC,EACtBT,EAMJ,SAA+BG,EAAQ3L,EAAQoG,GAC3C,IAAM+F,EAAO,IAAIC,YAAYT,EAAOE,OAAQ7L,EAAQoG,GACpD,GAAIA,EAAM,IAAkB,QAAZ+F,EAAK,IAA6B,QAAZA,EAAK,IAKvC,OAAOT,EAAoBC,EAAQ3L,EAAQoG,GAE/C,OAAO+E,IAAyBkB,OAAOF,EAC1C,IAbGZ,EAAsB,SAACU,GAAD,OAAc,IAAIK,CAAlB,EACtBd,EAAgBE,G,IAuBdQ,EAAAA,WACF,WAAYD,IAAU,eAClBjO,KAAKuO,UAAuB,EAAXN,EACjBjO,KAAKwO,QAAU,IAAIJ,YAAYpO,KAAKuO,WACpCvO,KAAKyO,kBAAoB,KACzBzO,KAAK0O,cAAgB,CACxB,C,oCACD,WACI1O,KAAKyO,kBAAoB,KACzBzO,KAAK0O,cAAgB,CACxB,G,mBACD,WACI,OAA+B,OAA3B1O,KAAKyO,mBACLzO,KAAK2O,eACE3O,KAAKyO,kBAAkBT,KAAK,KAEhChO,KAAK4O,cACf,G,0BACD,WACI,GAA2B,IAAvB5O,KAAK0O,cACL,MAAO,GAEX,IAAMP,EAAO,IAAIC,YAAYpO,KAAKwO,QAAQX,OAAQ,EAAG7N,KAAK0O,eAC1D,OAAOrB,IAAyBgB,OAAOF,EAC1C,G,0BACD,WACI,IAAMU,EAAe7O,KAAK4O,eAC1B5O,KAAK0O,cAAgB,EACU,OAA3B1O,KAAKyO,kBACLzO,KAAKyO,kBAAoB,CAACI,GAG1B7O,KAAKyO,kBAAkBzO,KAAKyO,kBAAkB/M,QAAUmN,CAE/D,G,oBACD,SAAOxO,GACH,IAAMyO,EAAiB9O,KAAKuO,UAAYvO,KAAK0O,cACzCI,GAAkB,IACK,IAAnBA,GAAwB1N,EAAAA,GAAwBf,KAChDL,KAAK2O,eAGb3O,KAAKwO,QAAQxO,KAAK0O,iBAAmBrO,CACxC,G,yBACD,SAAYA,GACJL,KAAK0O,gBAAkB1O,KAAKuO,WAE5BvO,KAAK2O,eAET3O,KAAKwO,QAAQxO,KAAK0O,iBAAmBrO,CACxC,G,+BACD,SAAkBmI,GACd,IAAMuG,EAASvG,EAAI9G,OACnB,GAAI1B,KAAK0O,cAAgBK,GAAU/O,KAAKuO,UAIpC,OAFAvO,KAAK2O,oBACL3O,KAAKyO,kBAAkBzO,KAAKyO,kBAAkB/M,QAAU8G,GAG5D,IAAK,IAAI5H,EAAI,EAAGA,EAAImO,EAAQnO,IACxBZ,KAAKwO,QAAQxO,KAAK0O,iBAAmBlG,EAAIF,WAAW1H,EAE3D,K,EA9DCsN,GAgEAI,EAAAA,WACF,cAAc,eACVtO,KAAKgP,QAAU,GACfhP,KAAKiP,WAAa,CACrB,C,oCACD,WACIjP,KAAKgP,QAAU,GACfhP,KAAKiP,WAAa,CACrB,G,mBACD,WACI,OAAOjP,KAAKgP,QAAQhB,KAAK,GAC5B,G,oBACD,SAAO3N,GACHL,KAAKgP,QAAQhP,KAAKiP,cAAgBnB,OAAOC,aAAa1N,EACzD,G,yBACD,SAAYA,GACRL,KAAKgP,QAAQhP,KAAKiP,cAAgBnB,OAAOC,aAAa1N,EACzD,G,+BACD,SAAkBmI,GACdxI,KAAKgP,QAAQhP,KAAKiP,cAAgBzG,CACrC,K,EApBC8F,E,0ICtHN,SAASY,EAAc1G,GACnB,OAAQA,EACH2G,QAAQ,MAAO,OACfA,QAAQ,MAAO,MACvB,CACM,IAAMC,EAAb,WACI,WAAYC,EAAaC,EAASC,EAAaC,IAAS,eACpDxP,KAAKqP,YAAcA,EACnBrP,KAAKsP,QAAUA,EACftP,KAAKuP,YAAcA,EACnBvP,KAAKwP,QAAUA,CAClB,CANL,sCAOI,WACI,OAAOxP,KAAKsP,QAAQ5N,MACvB,GATL,kBAUI,WACI,OAAO1B,KAAKqP,YAAcrP,KAAKsP,QAAQ5N,MAC1C,GAZL,qBAaI,WACI,OAAO1B,KAAKwP,QAAQ9N,MACvB,GAfL,kBAgBI,WACI,OAAO1B,KAAKuP,YAAcvP,KAAKwP,QAAQ9N,MAC1C,GAlBL,sBAmBI,WACI,OAA4B,IAAxB1B,KAAKsP,QAAQ5N,OACN,WAAP,OAAkB1B,KAAKqP,YAAvB,aAAuCH,EAAclP,KAAKwP,SAA1D,MAEwB,IAAxBxP,KAAKwP,QAAQ9N,OACN,WAAP,OAAkB1B,KAAKqP,YAAvB,aAAuCH,EAAclP,KAAKsP,SAA1D,MAEG,YAAP,OAAmBtP,KAAKqP,YAAxB,aAAwCH,EAAclP,KAAKsP,SAA3D,mBAA8EJ,EAAclP,KAAKwP,SAAjG,KACH,GA3BL,uBA8CI,WACI,OAAQ,EAEFJ,EAAWK,iBAAiBzP,KAAKsP,SACjCF,EAAWK,iBAAiBzP,KAAKwP,QAC1C,GAnDL,mBAoDI,SAAM7F,EAAG3H,GAOL,OANA6L,EAAAA,GAAqBlE,EAAG3J,KAAKqP,YAAarN,GAC1CA,GAAU,EACV6L,EAAAA,GAAqBlE,EAAG3J,KAAKuP,YAAavN,GAC1CA,GAAU,EACVA,EAASoN,EAAWM,aAAa/F,EAAG3J,KAAKsP,QAAStN,GAClDA,EAASoN,EAAWM,aAAa/F,EAAG3J,KAAKwP,QAASxN,EAErD,IA5DL,+BA4BI,SAAwBwG,GACpB,OAAQ,EAAI,EAAIA,EAAI9G,MACvB,GA9BL,0BA+BI,SAAoBiI,EAAGnB,EAAKxG,GACxB,IAAMoG,EAAMI,EAAI9G,OAChBmM,EAAAA,GAAqBlE,EAAGvB,EAAKpG,GAC7BA,GAAU,EACV,IAAK,IAAIpB,EAAI,EAAGA,EAAIwH,EAAKxH,IACrBiN,EAAAA,GAAqBlE,EAAGnB,EAAIF,WAAW1H,GAAIoB,GAC3CA,GAAU,EAEd,OAAOA,CACV,GAxCL,yBAyCI,SAAmB2H,EAAG3H,GAClB,IAAMoG,EAAMyF,EAAAA,GAAoBlE,EAAG3H,GAEnC,OADAA,GAAU,GACHwL,EAAAA,EAAAA,IAAc7D,EAAG3H,EAAQoG,EACnC,GA7CL,kBA6DI,SAAYuB,EAAG3H,EAAQ2N,GACnB,IAAMN,EAAcxB,EAAAA,GAAoBlE,EAAG3H,GAC3CA,GAAU,EACV,IAAMuN,EAAc1B,EAAAA,GAAoBlE,EAAG3H,GAC3CA,GAAU,EACV,IAAMsN,EAAUF,EAAWQ,YAAYjG,EAAG3H,GAC1CA,GAAUoN,EAAWK,iBAAiBH,GACtC,IAAME,EAAUJ,EAAWQ,YAAYjG,EAAG3H,GAG1C,OAFAA,GAAUoN,EAAWK,iBAAiBD,GACtCG,EAAKE,KAAK,IAAIT,EAAWC,EAAaC,EAASC,EAAaC,IACrDxN,CACV,KAxEL,KA0EO,SAAS8N,EAA+BC,EAAWC,GACtD,OAAkB,OAAdD,GAA2C,IAArBA,EAAUrO,OACzBsO,EAEQ,IAAIC,EAAqBF,EAAWC,GACrCE,UACrB,C,IACKD,EAAAA,WACF,WAAYF,EAAWC,IAAW,eAC9BhQ,KAAKmQ,WAAaJ,EAClB/P,KAAKoQ,WAAaJ,EAClBhQ,KAAKqQ,QAAU,GACfrQ,KAAKsQ,WAAa,EAClBtQ,KAAKuQ,SAAWvQ,KAAKmQ,WAAWzO,OAChC1B,KAAKwQ,iBAAmB,EACxBxQ,KAAKyQ,SAAWzQ,KAAKoQ,WAAW1O,OAChC1B,KAAK0Q,iBAAmB,CAC3B,C,uCACD,WAKI,IAJA,IAAIC,EAAY,EACZC,EAAY,EACZC,EAAW7Q,KAAK8Q,SAASH,GACzBI,EAAW/Q,KAAKgR,SAASJ,GACtBD,EAAY3Q,KAAKuQ,UAAYK,EAAY5Q,KAAKyQ,UACjD,GAAiB,OAAbI,EAKJ,GAAiB,OAAbE,EAKJ,GAAIA,EAASE,QAAUJ,EAAStB,YAC5BvP,KAAKkR,YAAYH,GACjBA,EAAW/Q,KAAKgR,WAAWJ,QAG/B,GAAIC,EAASM,QAAUJ,EAAS1B,YAC5BrP,KAAKoR,YAAYP,GACjBA,EAAW7Q,KAAK8Q,WAAWH,QAG/B,GAAII,EAAS1B,YAAcwB,EAAStB,YAApC,CACI,MAAiBU,EAAqBoB,WAAWN,EAAUF,EAAStB,YAAcwB,EAAS1B,aAA3F,eAAOiC,EAAP,KAAWC,EAAX,KACAvR,KAAKkR,YAAYI,GACjBP,EAAWQ,CAEd,MACD,GAAIV,EAAStB,YAAcwB,EAAS1B,YAApC,CACI,MAAiBY,EAAqBuB,WAAWX,EAAUE,EAAS1B,YAAcwB,EAAStB,aAA3F,eAAO+B,EAAP,KAAWC,EAAX,KACAvR,KAAKoR,YAAYE,GACjBT,EAAWU,CAEd,KALD,CAOA,IAAIE,OAAS,EACTC,OAAS,EACb,GAAIX,EAASE,SAAWJ,EAASM,OAC7BM,EAAYZ,EACZa,EAAYX,EACZF,EAAW7Q,KAAK8Q,WAAWH,GAC3BI,EAAW/Q,KAAKgR,WAAWJ,QAE1B,GAAIG,EAASE,OAASJ,EAASM,OAAQ,CACxC,MAAiBlB,EAAqBuB,WAAWX,EAAUE,EAASY,WAApE,eACAF,EADA,KAEAC,EAAYX,EACZF,EAHA,KAIAE,EAAW/Q,KAAKgR,WAAWJ,EAC9B,KACI,CACD,MAAiBX,EAAqBoB,WAAWN,EAAUF,EAASe,WAApE,eAAON,EAAP,KAAWC,EAAX,KACAE,EAAYZ,EACZa,EAAYJ,EACZT,EAAW7Q,KAAK8Q,WAAWH,GAC3BI,EAAWQ,CACd,CACDvR,KAAKqQ,QAAQrQ,KAAKsQ,cAAgB,IAAIlB,EAAWqC,EAAUpC,YAAaoC,EAAUnC,QAASoC,EAAUnC,YAAamC,EAAUlC,SAC5HxP,KAAKwQ,kBAAoBiB,EAAUG,UAAYH,EAAUE,UACzD3R,KAAK0Q,kBAAoBgB,EAAUE,UAAYF,EAAUC,SA1BxD,MAzBG3R,KAAKoR,YAAYP,GACjBA,EAAW7Q,KAAK8Q,WAAWH,QAN3B3Q,KAAKkR,YAAYH,GACjBA,EAAW/Q,KAAKgR,WAAWJ,GAyDnC,IAAMiB,EAAS5B,EAAqB6B,OAAO9R,KAAKqQ,SAEhD,OADgBJ,EAAqB8B,aAAaF,EAErD,G,yBACD,SAAYd,GACR/Q,KAAKqQ,QAAQrQ,KAAKsQ,cAAgBL,EAAqB+B,YAAYhS,KAAKwQ,iBAAkBO,GAC1F/Q,KAAK0Q,kBAAoBK,EAASa,UAAYb,EAASY,SAC1D,G,sBACD,SAASf,GACL,OAAQA,EAAY5Q,KAAKyQ,SAAWzQ,KAAKoQ,WAAWQ,GAAa,IACpE,G,yBACD,SAAYC,GACR7Q,KAAKqQ,QAAQrQ,KAAKsQ,cAAgBL,EAAqBgC,YAAYjS,KAAK0Q,iBAAkBG,GAC1F7Q,KAAKwQ,kBAAoBK,EAASe,UAAYf,EAASc,SAC1D,G,sBACD,SAAShB,GACL,OAAQA,EAAY3Q,KAAKuQ,SAAWvQ,KAAKmQ,WAAWQ,GAAa,IACpE,I,0BACD,SAAmBuB,EAAiBnB,GAChC,OAAO,IAAI3B,EAAW2B,EAAS1B,YAAc6C,EAAiBnB,EAASzB,QAASyB,EAASxB,YAAawB,EAASvB,QAClH,G,yBACD,SAAmB2C,EAAiBtB,GAChC,OAAO,IAAIzB,EAAWyB,EAASxB,YAAawB,EAASvB,QAASuB,EAAStB,YAAc4C,EAAiBtB,EAASrB,QAClH,G,wBACD,SAAkB4C,EAAMpQ,GACpB,IAAMqQ,EAAUD,EAAK5C,QAAQ8C,OAAO,EAAGtQ,GACjCuQ,EAAWH,EAAK5C,QAAQ8C,OAAOtQ,GACrC,MAAO,CACH,IAAIoN,EAAWgD,EAAK/C,YAAa+C,EAAK9C,QAAS8C,EAAK7C,YAAa8C,GACjE,IAAIjD,EAAWgD,EAAKnB,OAAQ,GAAImB,EAAK7C,YAAcvN,EAAQuQ,GAElE,G,wBACD,SAAkBH,EAAMpQ,GACpB,IAAMqQ,EAAUD,EAAK9C,QAAQgD,OAAO,EAAGtQ,GACjCuQ,EAAWH,EAAK9C,QAAQgD,OAAOtQ,GACrC,MAAO,CACH,IAAIoN,EAAWgD,EAAK/C,YAAagD,EAASD,EAAK7C,YAAa6C,EAAK5C,SACjE,IAAIJ,EAAWgD,EAAK/C,YAAcrN,EAAQuQ,EAAUH,EAAKjB,OAAQ,IAExE,G,oBACD,SAAcqB,GACV,GAAqB,IAAjBA,EAAM9Q,OACN,OAAO8Q,EAKX,IAHA,IAAM1Q,EAAS,GACX8L,EAAY,EACZ6E,EAAOD,EAAM,GACR5R,EAAI,EAAGA,EAAI4R,EAAM9Q,OAAQd,IAAK,CACnC,IAAM8R,EAAOF,EAAM5R,GACf6R,EAAKxB,SAAWyB,EAAKrD,YAErBoD,EAAO,IAAIrD,EAAWqD,EAAKpD,YAAaoD,EAAKnD,QAAUoD,EAAKpD,QAASmD,EAAKlD,YAAakD,EAAKjD,QAAUkD,EAAKlD,UAG3G1N,EAAO8L,KAAe6E,EACtBA,EAAOC,EAEd,CAED,OADA5Q,EAAO8L,KAAe6E,EACf3Q,CACV,G,0BACD,SAAoB0Q,GAChB,GAAqB,IAAjBA,EAAM9Q,OACN,OAAO8Q,EAIX,IAFA,IAAM1Q,EAAS,GACX8L,EAAY,EACPhN,EAAI,EAAGA,EAAI4R,EAAM9Q,OAAQd,IAAK,CACnC,IAAMwR,EAAOI,EAAM5R,GACfwR,EAAK9C,UAAY8C,EAAK5C,UAG1B1N,EAAO8L,KAAewE,EACzB,CACD,OAAOtQ,CACV,K,EAvJCmO,E,wDCxFC,IAAM0C,EAAwB,CACjCzR,QAAS,EACTsB,WAAY,EACZiG,cAAc,EACdmK,mBAAmB,EACnBC,oBAAoB,EACpBC,wBAAwB,EACxBC,+BAAgC,CAAEC,SAAS,G,uGCNlCC,EAAb,0CACI,WAAYC,GAAgB,sBACxB,cAAM,GACN,IAAK,IAAItS,EAAI,EAAGwH,EAAM8K,EAAexR,OAAQd,EAAIwH,EAAKxH,IAClD,EAAKJ,IAAI0S,EAAe5K,WAAW1H,GAAI,GAHnB,OAKxB,EAAKJ,IAAI,GAAgB,GACzB,EAAKA,IAAI,EAAa,GANE,CAO3B,CARL,kB,SAA6CZ,GAmBtC,IAAMuT,EATb,SAAcC,GACV,IAAMC,EAAQ,CAAC,EACf,OAAO,SAACC,GAIJ,OAHKD,EAAME,eAAeD,KACtBD,EAAMC,GAASF,EAAUE,IAEtBD,EAAMC,EAChB,CACJ,CACsCE,EAAK,SAACF,GAAD,OAAW,IAAIL,EAAwBK,EAAvC,G,gJCpB/BG,EAAwB,oCAoB9B,IAAMC,EAZb,WAA6C,MAAnBC,EAAmB,uDAAJ,GACjChG,EAAS,yBAD4B,UAEvB8F,GAFuB,IAEzC,IAAK,EAAL,qBAAyC,KAA9BG,EAA8B,QACjCD,EAAaE,QAAQD,IAAQ,IAGjCjG,GAAU,KAAOiG,EACpB,CAPwC,+BASzC,OADAjG,GAAU,SACH,IAAImG,OAAOnG,EAAQ,IAC7B,CAEkCoG,GAC5B,SAASC,EAA0BC,GACtC,IAAInS,EAAS4R,EACb,GAAIO,GAAmBA,aAA0BH,OAC7C,GAAKG,EAAeC,OAchBpS,EAASmS,MAde,CACxB,IAAIE,EAAQ,IACRF,EAAeG,aACfD,GAAS,KAETF,EAAeI,YACfF,GAAS,KAETF,EAAeK,UACfH,GAAS,KAEbrS,EAAS,IAAIgS,OAAOG,EAAetG,OAAQwG,EAC9C,CAML,OADArS,EAAOyS,UAAY,EACZzS,CACV,CACD,IAAM0S,EAAiB,CACnBC,OAAQ,IACRC,WAAY,GACZC,WAAY,KAET,SAASC,EAActT,EAAQ2S,EAAgBtS,EAAMkT,GAAqC,IAAzBC,EAAyB,uDAAhBN,EAC7E,GAAI7S,EAAKD,OAASoT,EAAOL,OAAQ,CAG7B,IAAIlJ,EAAQjK,EAASwT,EAAOL,OAAS,EAQrC,OAPIlJ,EAAQ,EACRA,EAAQ,EAGRsJ,GAActJ,EAGXqJ,EAActT,EAAQ2S,EAD7BtS,EAAOA,EAAKC,UAAU2J,EAAOjK,EAASwT,EAAOL,OAAS,GACHI,EAAYC,EAClE,CAKD,IAJA,IAAMC,EAAKC,KAAKC,MACVnL,EAAMxI,EAAS,EAAIuT,EACrBK,GAAkB,EAClBC,EAAQ,KACHvU,EAAI,IAELoU,KAAKC,MAAQF,GAAMD,EAAOH,YAFjB/T,IAAK,CAOlB,IAAMwU,EAAatL,EAAMgL,EAAOJ,WAAa9T,EAC7CqT,EAAeM,UAAY/S,KAAKiB,IAAI,EAAG2S,GACvC,IAAMC,EAAYC,EAAiCrB,EAAgBtS,EAAMmI,EAAKoL,GAC9E,IAAKG,GAAaF,EAEd,MAIJ,GAFAA,EAAQE,EAEJD,GAAc,EACd,MAEJF,EAAiBE,CACpB,CACD,GAAID,EAAO,CACP,IAAMrT,EAAS,CACXyT,KAAMJ,EAAM,GACZlL,YAAa4K,EAAa,EAAIM,EAAMK,MACpCrL,UAAW0K,EAAa,EAAIM,EAAMK,MAAQL,EAAM,GAAGzT,QAGvD,OADAuS,EAAeM,UAAY,EACpBzS,CACV,CACD,OAAO,IACV,CACD,SAASwT,EAAiCrB,EAAgBtS,EAAMmI,EAAK2L,GAEjE,IADA,IAAIN,EACGA,EAAQlB,EAAeyB,KAAK/T,IAAO,CACtC,IAAMgU,EAAaR,EAAMK,OAAS,EAClC,GAAIG,GAAc7L,GAAOmK,EAAeM,WAAazK,EACjD,OAAOqL,EAEN,GAAIM,EAAU,GAAKE,EAAaF,EACjC,OAAO,IAEd,CACD,OAAO,IACV,C,iOCxGYG,EAAb,WACI,WAAYC,IAAS,eACjB7V,KAAK8V,iBAAmB,KACxB9V,KAAK+V,iBAAkB,EACvB/V,KAAKgW,UAAUH,EAAS,IAAII,EAAAA,GAAkB,IAAIpT,EAAAA,EAAM,EAAG,EAAG,EAAG,GAAI,EAAG,IAAImG,EAAAA,EAAS,EAAG,GAAI,GAAI,IAAIiN,EAAAA,GAAkB,IAAIpT,EAAAA,EAAM,EAAG,EAAG,EAAG,GAAI,EAAG,IAAImG,EAAAA,EAAS,EAAG,GAAI,GACvK,CALL,sCAMI,SAAQ6M,GACJ7V,KAAKkW,oBAAoBL,EAC5B,GARL,oCASI,SAAuBA,GACnB7V,KAAK+V,iBAAkB,EACvB/V,KAAKmW,oBAAoBN,EAC5B,GAZL,mCAaI,SAAsBA,GAClB7V,KAAK+V,iBAAkB,EACvB/V,KAAKkW,oBAAoBL,EAC5B,GAhBL,iCAiBI,SAAoBA,GACX7V,KAAK+V,kBAIV/V,KAAK8V,iBAAmBD,EAAQO,MAAMC,iBAAiBrW,KAAK8V,iBAAkB9V,KAAKsW,WAAWC,UAAW,GAC5G,GAvBL,iCAwBI,SAAoBV,GAChB7V,KAAK8V,iBAAmBD,EAAQO,MAAMC,iBAAiBrW,KAAK8V,iBAAkB,KAAM,EACvF,GA1BL,2BA2BI,WACI,OAAO,IAAIU,EAAAA,GAAYxW,KAAKsW,WAAYtW,KAAKyW,UAChD,GA7BL,sCA8BI,SAAyBZ,GACrB,IAAMjT,EAAQiT,EAAQO,MAAMM,iBAAiB1W,KAAK8V,kBAClD,OAAOvJ,EAAAA,EAAAA,UAAoB3J,EAAO5C,KAAKsW,WAAWC,UAAU1J,eAC/D,GAjCL,8BAkCI,SAAiBgJ,GACb7V,KAAKgW,UAAUH,EAAS7V,KAAKsW,WAAYtW,KAAKyW,UACjD,GApCL,sBAqCI,SAASZ,EAASS,EAAYG,GAC1BzW,KAAKgW,UAAUH,EAASS,EAAYG,EACvC,GAvCL,uBA2DI,SAAUZ,EAASS,EAAYG,GAI3B,GAHIA,IACAA,EAAYb,EAAOe,mBAAmBd,EAAQe,UAAWH,IAExDH,EASA,CAED,IAAMO,EAAiBhB,EAAQO,MAAMU,cAAcR,EAAWO,gBACxDE,EAAuCT,EAAWO,eAAenM,YAAYmM,GAAkBP,EAAWS,qCAAuC,EACjJpU,EAAWkT,EAAQO,MAAMY,iBAAiBV,EAAW3T,UACrDsU,EAAyBX,EAAW3T,SAAS4G,OAAO5G,GAAY2T,EAAWW,uBAAyB,EAC1GX,EAAa,IAAIL,EAAAA,GAAkBY,EAAgBE,EAAsCpU,EAAUsU,EACtG,KAhBgB,CACb,IAAKR,EACD,OAGJ,IAAMI,EAAiBhB,EAAQO,MAAMU,cAAcjB,EAAQqB,qBAAqBC,6BAA6BV,EAAUI,iBACjHlU,EAAWkT,EAAQO,MAAMY,iBAAiBnB,EAAQqB,qBAAqBE,mCAAmCX,EAAU9T,WAC1H2T,EAAa,IAAIL,EAAAA,GAAkBY,EAAgBJ,EAAUM,qCAAsCpU,EAAU8T,EAAUQ,uBAC1H,CASD,GAAKR,EAQA,CAED,IAAMY,EAAqBxB,EAAQqB,qBAAqBI,kBAAkBb,EAAUI,eAAgBP,EAAWO,gBACzGU,EAAe1B,EAAQqB,qBAAqBM,qBAAqBf,EAAU9T,SAAU2T,EAAW3T,UACtG8T,EAAY,IAAIR,EAAAA,GAAkBoB,EAAoBf,EAAWS,qCAAsCQ,EAAcjB,EAAWW,uBACnI,KAbe,CAEZ,IAAMQ,EAAsB5B,EAAQqB,qBAAqBQ,mCAAmC,IAAI1O,EAAAA,EAASsN,EAAWO,eAAe7M,gBAAiBsM,EAAWO,eAAe5M,cACxK0N,EAAsB9B,EAAQqB,qBAAqBQ,mCAAmC,IAAI1O,EAAAA,EAASsN,EAAWO,eAAe3M,cAAeoM,EAAWO,eAAe1M,YACtKkN,EAAqB,IAAIxU,EAAAA,EAAM4U,EAAoB3U,WAAY2U,EAAoBnW,OAAQqW,EAAoB7U,WAAY6U,EAAoBrW,QAC/IiW,EAAe1B,EAAQqB,qBAAqBQ,mCAAmCpB,EAAW3T,UAChG8T,EAAY,IAAIR,EAAAA,GAAkBoB,EAAoBf,EAAWS,qCAAsCQ,EAAcjB,EAAWW,uBACnI,CAODjX,KAAKsW,WAAaA,EAClBtW,KAAKyW,UAAYA,EACjBzW,KAAKmW,oBAAoBN,EAC5B,IAjGL,yCAwCI,SAAkCe,EAAWjU,EAAUiV,EAAYC,GAC/D,OAAIlV,EAAS4G,OAAOqO,GACTC,EAEJjB,EAAUkB,kBAAkBnV,EAAU,EAChD,GA7CL,gCA8CI,SAA0BiU,EAAWH,GACjC,IAAM9T,EAAW8T,EAAU9T,SACrBoV,EAAiBtB,EAAUI,eAAejM,mBAC1CoN,EAAevB,EAAUI,eAAelM,iBACxCsN,EAAgBrB,EAAUkB,kBAAkBnV,EAAU,GACtDuV,EAAsBlY,KAAKmY,2BAA2BvB,EAAWmB,EAAgBpV,EAAUsV,GAC3FG,EAAoBpY,KAAKmY,2BAA2BvB,EAAWoB,EAAcD,EAAgBG,GACnG,OAAIvV,EAAS4G,OAAO0O,IAAkBF,EAAexO,OAAO2O,IAAwBF,EAAazO,OAAO6O,GAE7F3B,EAEJ,IAAIR,EAAAA,GAAkBpT,EAAAA,EAAAA,cAAoBqV,EAAqBE,GAAoB3B,EAAUM,qCAAuCgB,EAAezW,OAAS4W,EAAoB5W,OAAQ2W,EAAexB,EAAUQ,uBAAyBtU,EAASrB,OAAS2W,EAAc3W,OACpR,KA1DL,KCDa+W,EAAb,WACI,WAAYxC,IAAS,eACjB7V,KAAK6V,QAAUA,EACf7V,KAAKsY,QAAU,CAAC,IAAI1C,EAAOC,IAC3B7V,KAAKuY,qBAAuB,CAC/B,CALL,sCAMI,WAAU,gBACevY,KAAKsY,SADpB,IACN,IAAK,EAAL,qBAAmC,SACxBE,QAAQxY,KAAK6V,QACvB,CAHK,+BAIT,GAVL,qCAWI,WAA0B,gBACD7V,KAAKsY,SADJ,IACtB,IAAK,EAAL,qBAAmC,SACxBG,uBAAuBzY,KAAK6V,QACtC,CAHqB,+BAIzB,GAfL,oCAgBI,WAAyB,gBACA7V,KAAKsY,SADL,IACrB,IAAK,EAAL,qBAAmC,SACxBI,sBAAsB1Y,KAAK6V,QACrC,CAHoB,+BAIxB,GApBL,2BAqBI,SAAcA,GACV7V,KAAK6V,QAAUA,CAClB,GAvBL,8BAwBI,WAAmB,gBACM7V,KAAKsY,SADX,IACf,IAAK,EAAL,qBAAmC,SACxBK,iBAAiB3Y,KAAK6V,QAChC,CAHc,+BAIlB,GA5BL,sCA6BI,WAA2B,WACvB,OAAO7V,KAAKsY,QAAQM,KAAI,SAAAvM,GAAC,OAAIA,EAAEwM,yBAAyB,EAAKhD,QAApC,GAC5B,GA/BL,oBAgCI,WACI,OAAO7V,KAAKsY,QAAQM,KAAI,SAAAvM,GAAC,OAAIA,EAAEyM,eAAN,GAC5B,GAlCL,8BAmCI,WACI,OAAO9Y,KAAKsY,QAAQM,KAAI,SAAAvM,GAAC,OAAIA,EAAEoK,UAAU9T,QAAhB,GAC5B,GArCL,oCAsCI,WACI,OAAOoW,EAAAA,EAAAA,IAAU/Y,KAAKsY,SAASU,EAAAA,EAAAA,KAAU,SAAA3M,GAAC,OAAIA,EAAEoK,UAAU9T,QAAhB,GAA0BqG,EAAAA,EAAAA,UAAmByN,UAAU9T,QACpG,GAxCL,uCAyCI,WACI,OAAOsW,EAAAA,EAAAA,IAAcjZ,KAAKsY,SAASU,EAAAA,EAAAA,KAAU,SAAA3M,GAAC,OAAIA,EAAEoK,UAAU9T,QAAhB,GAA0BqG,EAAAA,EAAAA,UAAmByN,UAAU9T,QACxG,GA3CL,2BA4CI,WACI,OAAO3C,KAAKsY,QAAQM,KAAI,SAAAvM,GAAC,OAAIA,EAAEiK,WAAWC,SAAjB,GAC5B,GA9CL,+BA+CI,WACI,OAAOvW,KAAKsY,QAAQM,KAAI,SAAAvM,GAAC,OAAIA,EAAEoK,UAAUF,SAAhB,GAC5B,GAjDL,2BAkDI,SAAc2C,GACVlZ,KAAKmZ,UAAU3C,EAAAA,GAAAA,oBAAgC0C,GAClD,GApDL,8BAqDI,WACI,OAAOlZ,KAAKsY,QAAQ,GAAGQ,eAC1B,GAvDL,uBAwDI,SAAUM,GACS,OAAXA,IAGJpZ,KAAKsY,QAAQ,GAAGe,SAASrZ,KAAK6V,QAASuD,EAAO,GAAG9C,WAAY8C,EAAO,GAAG3C,WACvEzW,KAAKsZ,oBAAoBF,EAAOG,MAAM,IACzC,GA9DL,iCAkEI,SAAoBC,GAChB,IAAMC,EAAyBzZ,KAAKsY,QAAQ5W,OAAS,EAC/CgY,EAAwBF,EAAgB9X,OAC9C,GAAI+X,EAAyBC,EAEzB,IADA,IAAMC,EAAYD,EAAwBD,EACjC7Y,EAAI,EAAGA,EAAI+Y,EAAW/Y,IAC3BZ,KAAK4Z,2BAGR,GAAIH,EAAyBC,EAE9B,IADA,IAAMG,EAAYJ,EAAyBC,EAClC9Y,EAAI,EAAGA,EAAIiZ,EAAWjZ,IAC3BZ,KAAK8Z,uBAAuB9Z,KAAKsY,QAAQ5W,OAAS,GAG1D,IAAK,IAAId,EAAI,EAAGA,EAAI8Y,EAAuB9Y,IACvCZ,KAAKsY,QAAQ1X,EAAI,GAAGyY,SAASrZ,KAAK6V,QAAS2D,EAAgB5Y,GAAG0V,WAAYkD,EAAgB5Y,GAAG6V,UAEpG,GApFL,kCAqFI,WACIzW,KAAKsZ,oBAAoB,GAC5B,GAvFL,iCAwFI,WACItZ,KAAKsY,QAAQzI,KAAK,IAAI+F,EAAO5V,KAAK6V,UAClC7V,KAAKuY,qBAAuBvY,KAAKsY,QAAQ5W,OAAS,CACrD,GA3FL,qCA4FI,WACI,OAA4B,IAAxB1B,KAAKsY,QAAQ5W,QAA8C,IAA9B1B,KAAKuY,qBAC3B,EAEJvY,KAAKuY,oBACf,GAjGL,oCAkGI,SAAuBwB,GACf/Z,KAAKuY,sBAAwBwB,EAAc,GAC3C/Z,KAAKuY,uBAETvY,KAAKsY,QAAQyB,EAAc,GAAGvB,QAAQxY,KAAK6V,SAC3C7V,KAAKsY,QAAQ0B,OAAOD,EAAc,EAAG,EACxC,GAxGL,uBAyGI,WACI,GAA4B,IAAxB/Z,KAAKsY,QAAQ5W,OAAjB,CAKA,IAFA,IAAM4W,EAAUtY,KAAKsY,QAAQiB,MAAM,GAC7BU,EAAgB,GACbrZ,EAAI,EAAGwH,EAAMkQ,EAAQ5W,OAAQd,EAAIwH,EAAKxH,IAC3CqZ,EAAcpK,KAAK,CACf2F,MAAO5U,EACP2V,UAAW+B,EAAQ1X,GAAG0V,WAAWC,YAGzC0D,EAAcC,MAAKlB,EAAAA,EAAAA,KAAU,SAAAmB,GAAC,OAAIA,EAAE5D,SAAN,GAAiB1T,EAAAA,EAAAA,2BAC/C,IAAK,IAAIuX,EAAoB,EAAGA,EAAoBH,EAAcvY,OAAS,EAAG0Y,IAAqB,CAC/F,IAAMC,EAAUJ,EAAcG,GACxBE,EAAOL,EAAcG,EAAoB,GACzCG,EAAmBF,EAAQ9D,UAC3BiE,EAAgBF,EAAK/D,UAC3B,GAAKvW,KAAK6V,QAAQ4E,aAAaC,4BAA/B,CAYA,GARIF,EAAcpQ,WAAamQ,EAAiBnQ,UAEvBoQ,EAAc5P,mBAAmBnB,gBAAgB8Q,EAAiB5P,kBAIlE6P,EAAc5P,mBAAmBpB,SAAS+Q,EAAiB5P,kBAE5D,CACpB,IAAMgQ,EAA0BN,EAAQ7E,MAAQ8E,EAAK9E,MAAQ4E,EAAoBA,EAAoB,EAC/FQ,EAA0BP,EAAQ7E,MAAQ8E,EAAK9E,MAAQ4E,EAAoB,EAAIA,EAC/ES,EAAcZ,EAAcW,GAAyBpF,MACrDsF,EAAcb,EAAcU,GAAyBnF,MACrDuF,EAAkBd,EAAcW,GAAyBrE,UACzDyE,EAAkBf,EAAcU,GAAyBpE,UAC/D,IAAKwE,EAAgBE,gBAAgBD,GAAkB,CACnD,IAAME,EAAiBH,EAAgBvQ,UAAUwQ,GAC3CG,EAAwBJ,EAAgBvO,2BAA6BuO,EAAgB/Q,iBAAmB+Q,EAAgBtO,uBAAyBsO,EAAgB9Q,YACjKmR,EAAwBJ,EAAgBxO,2BAA6BwO,EAAgBhR,iBAAmBgR,EAAgBvO,uBAAyBuO,EAAgB/Q,YAEnKoR,OAAuB,EACvBR,IAAgB7a,KAAKuY,sBACrB8C,EAA0BF,EAC1Bnb,KAAKuY,qBAAuBuC,GAI5BO,EAA0BD,EAE9B,IAAIE,OAAkB,EAElBA,EADAD,EACqB,IAAI9O,EAAAA,EAAU2O,EAAelR,gBAAiBkR,EAAejR,YAAaiR,EAAehR,cAAegR,EAAe/Q,WAGvH,IAAIoC,EAAAA,EAAU2O,EAAehR,cAAegR,EAAe/Q,UAAW+Q,EAAelR,gBAAiBkR,EAAejR,aAE9IgQ,EAAcU,GAAyBpE,UAAY+E,EACnD,IAAMC,EAAiB/E,EAAAA,GAAAA,mBAA+B8E,GACtDhD,EAAQwC,GAAazB,SAASrZ,KAAK6V,QAAS0F,EAAejF,WAAYiF,EAAe9E,UACzF,CA/BmB,gBAgCOwD,GAhCP,IAgCpB,IAAK,EAAL,qBAA0C,KAA/BuB,EAA+B,QAClCA,EAAahG,MAAQqF,GACrBW,EAAahG,OAEpB,CApCmB,+BAqCpB8C,EAAQ0B,OAAOa,EAAa,GAC5BZ,EAAcD,OAAOY,EAAyB,GAC9C5a,KAAK8Z,uBAAuBe,EAAc,GAC1CT,GACH,CAnDA,CAoDJ,CArEA,CAsEJ,KAlLL,KCNaqB,GAAb,QACI,WAAYrF,EAAOQ,EAAWM,EAAsBuD,IAAc,eAC9Dza,KAAK0b,yBAAsBvP,EAC3BnM,KAAKoW,MAAQA,EACbpW,KAAK4W,UAAYA,EACjB5W,KAAKkX,qBAAuBA,EAC5BlX,KAAKya,aAAeA,CACvB,I,kECMQkB,EAAb,0CACI,WAAYvF,EAAOQ,EAAWM,EAAsBuD,GAAc,6BAC9D,gBACKmB,OAASxF,EACd,EAAKyF,qBAAuB,EAAKD,OAAOE,eACxC,EAAKC,WAAanF,EAClB,EAAKoF,sBAAwB9E,EAC7B,EAAKrB,QAAU,IAAI4F,EAAc,EAAKG,OAAQ,EAAKG,WAAY,EAAKC,sBAAuBvB,GAC3F,EAAKwB,SAAW,IAAI5D,EAAiB,EAAKxC,SAC1C,EAAKqG,WAAY,EACjB,EAAKC,aAAc,EACnB,EAAKC,qBAAsB,EAC3B,EAAKC,kCAAoC,KACzC,EAAKC,kBAAoB,KACzB,EAAKC,mBAAqB,GAC1B,EAAKC,uBAAyB,EAdgC,CAejE,CAhBL,sCAiBI,WACIxc,KAAKic,SAASzD,UACdxY,KAAKuc,oBAAqB/D,EAAAA,EAAAA,IAAQxY,KAAKuc,qBACvC,sDACH,GArBL,iCAsBI,SAAoB9B,GAChBza,KAAK6V,QAAU,IAAI4F,EAAczb,KAAK4b,OAAQ5b,KAAK+b,WAAY/b,KAAKgc,sBAAuBvB,GAC3Fza,KAAKic,SAASQ,cAAczc,KAAK6V,QACpC,GAzBL,kCA0BI,SAAqB6G,GACb1c,KAAK6b,uBAAyB7b,KAAK4b,OAAOE,gBAW9C9b,KAAKmZ,UAAUuD,EAAiB,YAAa,EAAgB1c,KAAK2c,kBACrE,GAvCL,yBAwCI,SAAYC,GACR5c,KAAKkc,UAAYU,CACpB,GA1CL,wCA2CI,WACI,GAAI5c,KAAKuc,mBAAmB7a,OAAS,EAEjC,IADA,IAAMwX,EAAalZ,KAAKic,SAASY,gBACxBjc,EAAI,EAAGA,EAAIZ,KAAKuc,mBAAmB7a,OAAQd,IAAK,CACrD,IAAMkc,EAAmB9c,KAAKuc,mBAAmB3b,GAC5Ckc,EAAiBC,QAAQ7D,KAC1B4D,EAAiBtE,UACjBxY,KAAKuc,mBAAmBvC,OAAOpZ,EAAG,GAClCA,IAEP,CAER,GAvDL,mCAyDI,WACI,OAAOZ,KAAKic,SAASe,kBACxB,GA3DL,qCA4DI,WACI,OAAOhd,KAAKic,SAASgB,yBACxB,GA9DL,6BA+DI,WACI,OAAOjd,KAAKic,SAASiB,QACxB,GAjEL,uBAkEI,SAAUR,EAAiB/O,EAAQwP,EAAQ/D,GACvC,IAAIgE,GAAwB,EACb,OAAXhE,GAAmBA,EAAO1X,OAASia,EAAkB0B,mBACrDjE,EAASA,EAAOG,MAAM,EAAGoC,EAAkB0B,kBAC3CD,GAAwB,GAE5B,IAAME,EAAWC,EAAiBC,KAAKxd,KAAK4b,OAAQ5b,MAKpD,OAJAA,KAAKic,SAAS9C,UAAUC,GACxBpZ,KAAKic,SAASwB,YACdzd,KAAKsc,kBAAoB,KACzBtc,KAAK0d,6BACE1d,KAAK2d,6BAA6BjB,EAAiB/O,EAAQwP,EAAQG,EAAUF,EACvF,GA9EL,uCA+EI,SAA0BQ,GACtB5d,KAAKsc,kBAAoBsB,CAC5B,GAjFL,2BAkFI,SAAclB,EAAiB/O,EAAQkQ,EAAeC,EAAcC,EAAkBC,GAClF,IAAMC,EAAgBje,KAAKic,SAASiC,mBAChCC,EAAkB,KAClBC,EAAuB,KACvBH,EAAcvc,OAAS,EACvB0c,EAAuBpe,KAAKic,SAASoC,oBAGrCF,EAAkBtb,EAAAA,EAAAA,cAAoBob,EAAc,GAAIA,EAAc,IAE1EvB,EAAgB4B,cAAc,IAAIC,EAAAA,GAA4B5Q,EAAQkQ,EAAeM,EAAiBC,EAAsBN,EAAcC,EAAkBC,GAC/J,GA7FL,uBA8FI,WAGI,IAFA,IAAMlc,EAAS,GACToX,EAAalZ,KAAKic,SAASY,gBACxBjc,EAAI,EAAGwH,EAAM8Q,EAAWxX,OAAQd,EAAIwH,EAAKxH,IAAK,CACnD,IAAM2V,EAAY2C,EAAWtY,GAC7BkB,EAAO+N,KAAK,CACR2O,iBAAkBjI,EAAUnM,UAC5ByM,eAAgB,CACZ/T,WAAYyT,EAAU/J,yBACtBlL,OAAQiV,EAAU9J,sBAEtB9J,SAAU,CACNG,WAAYyT,EAAU7J,mBACtBpL,OAAQiV,EAAU5J,iBAG7B,CACD,OAAO7K,CACV,GAhHL,0BAiHI,SAAa4a,EAAiBtD,GAE1B,IADA,IAAMqF,EAAoB,GACjB7d,EAAI,EAAGwH,EAAMgR,EAAO1X,OAAQd,EAAIwH,EAAKxH,IAAK,CAC/C,IAAM8d,EAAQtF,EAAOxY,GACjB8L,EAAqB,EACrBC,EAAiB,EAEjB+R,EAAM/b,UAAY+b,EAAM/b,SAASG,aACjC4J,EAAqBgS,EAAM/b,SAASG,YAEpC4b,EAAM/b,UAAY+b,EAAM/b,SAASrB,SACjCqL,EAAiB+R,EAAM/b,SAASrB,QAEpC,IAAIkL,EAA2BE,EAC3BD,EAAuBE,EAEvB+R,EAAM7H,gBAAkB6H,EAAM7H,eAAe/T,aAC7C0J,EAA2BkS,EAAM7H,eAAe/T,YAEhD4b,EAAM7H,gBAAkB6H,EAAM7H,eAAevV,SAC7CmL,EAAuBiS,EAAM7H,eAAevV,QAEhDmd,EAAkB5O,KAAK,CACnBrD,yBAA0BA,EAC1BC,qBAAsBA,EACtBC,mBAAoBA,EACpBC,eAAgBA,GAEvB,CACD3M,KAAKmZ,UAAUuD,EAAiB,eAAgB,EAAgBlG,EAAAA,GAAAA,oBAAgCiI,IAChGze,KAAK2e,cAAcjC,EAAiB,gBAAgB,EAAO,GAAgB,EAAM,EACpF,GAhJL,mCAiJI,SAAsBA,EAAiBkC,GACnC,GAAIA,aAAaC,EAAAA,GAA+B,CAE5C,GAAI7e,KAAKmc,YAEL,OAMJnc,KAAKmc,aAAc,EACnB,IACInc,KAAKmZ,UAAUuD,EAAiB,cAAe,EAAgB1c,KAAK2c,kBAIvE,CALD,QAII3c,KAAKmc,aAAc,CACtB,CACJ,KACI,CAED,GADAnc,KAAK6b,qBAAuB+C,EAAEE,UAC1B9e,KAAKmc,YACL,OAEJ,IAAM4C,EAAgBH,EAAEI,cAAc,GAEtC,GADAhf,KAAKwc,uBAAyB,EAC1BuC,EAEA/e,KAAKic,SAASzD,UACdxY,KAAKic,SAAW,IAAI5D,EAAiBrY,KAAK6V,SAC1C7V,KAAK0d,6BACL1d,KAAK2d,6BAA6BjB,EAAiB,QAAS,EAAsB,MAAM,QAGxF,GAAI1c,KAAKkc,WAAa0C,EAAEtD,oBAAsBsD,EAAEtD,mBAAmB5Z,OAAS,EAAG,CAC3E,IAAMud,EAAczI,EAAAA,GAAAA,oBAAgCoI,EAAEtD,oBAClDtb,KAAKmZ,UAAUuD,EAAiB,cAAekC,EAAEM,UAAY,EAAeN,EAAEO,UAAY,EAAe,EAA4BF,IACrIjf,KAAK2e,cAAcjC,EAAiB,eAAe,EAAO,GAAgB,EAAM,EAEvF,KACI,CACD,IAAM0C,EAAwBpf,KAAKic,SAASpD,2BAC5C7Y,KAAKmZ,UAAUuD,EAAiB,cAAe,EAA4BlG,EAAAA,GAAAA,oBAAgC4I,GAC9G,CAER,CACJ,GA/LL,0BAgMI,WACI,OAAOpf,KAAKic,SAASe,mBAAmB1G,WAAWC,SACtD,GAlML,oCAmMI,WACI,OAAOvW,KAAKic,SAASoD,wBACxB,GArML,uCAsMI,WACI,OAAOrf,KAAKic,SAASqD,2BACxB,GAxML,uCAyMI,WACI,GAAItf,KAAKsc,kBACL,OAAOtc,KAAKsc,kBAEhB,IAAMiD,EAAgBvf,KAAKic,SAASe,mBAC9B3F,EAAqBkI,EAAc9I,UAAUI,eAAejM,mBAC5D2M,EAAegI,EAAc9I,UAAU9T,SAC7C,MAAO,CACH6c,QAAQ,EACRC,mBAAoBpI,EAAmBvU,WACvC4c,qBAAsB1f,KAAK6V,QAAQ4E,aAAakF,wBAAwB3f,KAAK+b,WAAY1E,GACzFuI,iBAAkBrI,EAAazU,WAC/B+c,mBAAoB7f,KAAK6V,QAAQ4E,aAAakF,wBAAwB3f,KAAK+b,WAAYxE,GAE9F,GAvNL,2BAwNI,WACI,OAAOvX,KAAKic,SAASY,eACxB,GA1NL,2BA2NI,SAAcH,EAAiB/O,EAAQuL,EAAYiE,GAC/Cnd,KAAKmZ,UAAUuD,EAAiB/O,EAAQwP,EAAQ3G,EAAAA,GAAAA,oBAAgC0C,GACnF,GA7NL,sCA8NI,WACI,OAAOlZ,KAAKwc,sBACf,GAhOL,sCAiOI,SAAyB5U,GACrB5H,KAAKwc,uBAAyB5U,CACjC,GAnOL,mCAqOI,SAAsBkY,EAA4BC,GAG9C,IAFA,IAAMC,EAAuC,GACvCC,EAAsC,GACnCrf,EAAI,EAAGwH,EAAM0X,EAA2Bpe,OAAQd,EAAIwH,EAAKxH,IAC9Dof,EAAqCnQ,KAAK,CACtCjN,MAAOkd,EAA2Blf,GAClCsf,QAAS,CACLC,YAAa,wBACbC,gBAAiB,wBACjBC,WAAY,KAGpBJ,EAAoCpQ,KAAK,CACrCjN,MAAOmd,EAA0Bnf,GACjCsf,QAAS,CACLC,YAAa,wBACbE,WAAY,KAIxB,IAAMC,EAAkCtgB,KAAK4b,OAAO2E,iBAAiB,GAAIP,GACnEQ,EAAiCxgB,KAAK4b,OAAO2E,iBAAiB,GAAIN,GACxEjgB,KAAKuc,mBAAmB1M,KAAK,IAAI4Q,EAAiBzgB,KAAK4b,OAAQ0E,EAAiCE,GACnG,GA5PL,mCA6PI,SAAsBE,GAClB,GAAKA,EAAL,CAIIA,EAASC,8BACT3gB,KAAK4b,OAAOgF,mBAEhB,IAAM9e,EAAS+e,EAAgBC,gBAAgB9gB,KAAK4b,OAAQ5b,KAAKic,SAASY,gBAAiB6D,EAASK,UACpG,GAAIjf,EAAQ,CAER9B,KAAKghB,wBAAwBlf,GAI7B,IAFA,IAAMge,EAA6B,GAC7BC,EAA4B,GACzBnf,EAAI,EAAGA,EAAI8f,EAASK,SAASrf,OAAQd,IAAK,CAC/C,IAAMqgB,EAAUP,EAASK,SAASngB,GAC9BqgB,aAAmBC,EAAAA,GAA8BD,EAAQE,gBAAkBF,EAAQG,sBACnFtB,EAA2BjQ,KAAKoR,EAAQG,qBACxCrB,EAA0BlQ,KAAKoR,EAAQE,gBAE9C,CACGrB,EAA2Bpe,OAAS,GACpC1B,KAAKqhB,sBAAsBvB,EAA4BC,GAE3D/f,KAAKwc,uBAAyBkE,EAAS9Y,IAC1C,CACG8Y,EAASY,6BACTthB,KAAK4b,OAAOgF,kBAxBf,CA0BJ,GA3RL,qCA4RI,SAAwB3B,GACfA,GAAsC,IAAvBA,EAAYvd,SAC5Bud,EAAcjf,KAAKic,SAASpD,4BAEhC7Y,KAAKsc,kBAAoB,KACzBtc,KAAKic,SAASsF,cAActC,GAC5Bjf,KAAKic,SAASwB,WACjB,GAnSL,0CAsSI,SAA6Bf,EAAiB/O,EAAQwP,EAAQG,EAAUF,GACpE,IAAMoE,EAAWjE,EAAiBC,KAAKxd,KAAK4b,OAAQ5b,MACpD,GAAIwhB,EAASjY,OAAO+T,GAChB,OAAO,EAEX,IAAMpE,EAAalZ,KAAKic,SAASY,gBAC3B4E,EAAiBzhB,KAAKic,SAASoC,oBAIrC,GAFA3B,EAAgB4B,cAAc,IAAIoD,EAAAA,GAA4BD,EAAgBvI,KAEzEoE,GACEA,EAAS2B,YAAYvd,SAAW8f,EAASvC,YAAYvd,QACrD8f,EAASvC,YAAY0C,MAAK,SAACC,EAAgBhhB,GAAjB,OAAwBghB,EAAetL,WAAW/M,OAAO+T,EAAS2B,YAAYre,GAAG0V,WAAjF,IAA+F,CAC5H,IAAMuL,EAAgBvE,EAAWA,EAAS2B,YAAYrG,KAAI,SAAAuB,GAAC,OAAIA,EAAE7D,WAAWC,SAAjB,IAA8B,KACnFuL,EAAoBxE,EAAWA,EAASyE,eAAiB,EAC/DrF,EAAgBsF,kBAAkB,IAAIC,EAAAA,GAAwBJ,EAAe3I,EAAY4I,EAAmBN,EAASO,eAAgBpU,GAAU,WAAYwP,EAAQC,GACtK,CACD,OAAO,CACV,GAxTL,mCA2TI,SAAsB5K,GAClB,IAAKA,EAAM9Q,OACP,OAAO,KAGX,IADA,IAAMwgB,EAAU,GACPthB,EAAI,EAAGwH,EAAMoK,EAAM9Q,OAAQd,EAAIwH,EAAKxH,IAAK,CAC9C,IAAMwR,EAAOI,EAAM5R,GACnB,IAAKwR,EAAKzQ,MAAQyQ,EAAKzQ,KAAKkS,QAAQ,OAAS,EACzC,OAAO,KAEX,IAAMsO,EAAI/P,EAAKzQ,KAAKwT,MAAM,+BAC1B,IAAKgN,EACD,OAAO,KAEX,IAAMC,EAAYD,EAAE,GACdE,EAA6BriB,KAAK6V,QAAQ4E,aAAa6H,iBAAiBC,gCAAgC9hB,IAAI2hB,GAClH,IAAKC,GAAoE,IAAtCA,EAA2B3gB,OAC1D,OAAO,KAEX,IAAM8gB,EAAWH,EAA2B,GAAGI,KACzCC,EAAiBtQ,EAAKzQ,KAAKD,OAASygB,EAAE,GAAGzgB,OAAS,EAClDihB,EAAgBvQ,EAAKzQ,KAAKihB,YAAYJ,EAAUE,EAAiB,GACvE,IAAuB,IAAnBC,EACA,OAAO,KAEXT,EAAQrS,KAAK,CAAC8S,EAAeD,GAChC,CACD,OAAOR,CACV,GAvVL,0BAwVI,SAAaxF,EAAiB/O,EAAQ6E,EAAOqQ,GAAqB,WAC1DC,EAAqB,KACV,YAAXnV,IACAmV,EAAqB9iB,KAAK+iB,sBAAsBvQ,IAEhDsQ,IACAtQ,EAAM,GAAGwQ,YAAa,GAE1B,IAAMlD,EAA6B,GAC7BC,EAA4B,GAC5B7G,EAAalZ,KAAK4b,OAAOqH,mBAAmBjjB,KAAK6c,gBAAiBrK,GAAO,SAAC0Q,GAC5E,GAAIJ,EACA,IAAK,IAAIliB,EAAI,EAAGwH,EAAM0a,EAAmBphB,OAAQd,EAAIwH,EAAKxH,IAAK,CAC3D,cAAkDkiB,EAAmBliB,GAArE,GAAOuiB,EAAP,KAA2BC,EAA3B,KACMC,EAAWH,EAAUtiB,GACrBkC,EAAaugB,EAASzgB,MAAMoH,gBAC5B2Y,EAAgBU,EAASzgB,MAAMqH,YAAc,EAAIkZ,EACjDT,EAAiBW,EAASzgB,MAAMqH,YAAc,EAAImZ,EACxDtD,EAA2BjQ,KAAK,IAAIhN,EAAAA,EAAMC,EAAY4f,EAAiB,EAAG5f,EAAY4f,EAAiB,IACvG3C,EAA0BlQ,KAAK,IAAIhN,EAAAA,EAAMC,EAAY6f,EAAgB,EAAG7f,EAAY4f,EAAiB,GACxG,CAEL,IAAMxJ,EAAa2J,EAAoBK,GAMvC,OALIhK,IAGA,EAAKiD,aAAc,GAEhBjD,CACV,IACGA,IACAlZ,KAAKmc,aAAc,EACnBnc,KAAKuhB,cAAc7E,EAAiB/O,EAAQuL,EAAY,IAExD4G,EAA2Bpe,OAAS,GACpC1B,KAAKqhB,sBAAsBvB,EAA4BC,EAE9D,GA7XL,0BA8XI,SAAauD,EAAU5G,EAAiB/O,GAA6C,IAArC4V,EAAqC,uDAAhB,EACjE,IAAIvjB,KAAK6V,QAAQ4E,aAAa+I,SAA9B,CAIA,IAAMlG,EAAWC,EAAiBC,KAAKxd,KAAK4b,OAAQ5b,MACpDA,KAAKic,SAASwH,yBACdzjB,KAAKmc,aAAc,EACnB,IACInc,KAAKic,SAAStD,mBACd2K,GAIH,CAFD,MAAOI,IACHC,EAAAA,EAAAA,IAAkBD,EACrB,CACD1jB,KAAKmc,aAAc,EACnBnc,KAAKic,SAAS2H,0BACd5jB,KAAK0d,6BACD1d,KAAK2d,6BAA6BjB,EAAiB/O,EAAQ4V,EAAoBjG,GAAU,IACzFtd,KAAK2e,cAAcjC,EAAiB/O,GAAQ,EAAO,GAAgB,EAAM,EAf5E,CAiBJ,GAnZL,mCAoZI,SAAsBkW,GAClB7jB,KAAKoc,oBAAsByH,CAC9B,GAtZL,qCAuZI,WACI,OAAOpD,EAAiBqD,2BAA2B9jB,KAAKuc,mBAC3D,GAzZL,8BA0ZI,SAAiBG,GACb1c,KAAKqc,kCAAoCrc,KAAK6c,gBAAgBtD,MAAM,EACvE,GA5ZL,4BA6ZI,SAAemD,EAAiB/O,GAAQ,WACpC3N,KAAK+jB,cAAa,WACC,aAAXpW,IAEA,EAAKqW,sBAAsBC,EAAAA,EAAAA,+BAA8C,EAAKzH,uBAAwB,EAAK3G,QAAQ4E,aAAc,EAAKmB,OAAQ,EAAKS,kCAAmC,EAAKQ,gBAAiB,EAAKqH,4BACjN,EAAK7H,kCAAoC,KAEhD,GAAEK,EAAiB/O,EACvB,GAraL,kBAsaI,SAAK+O,EAAiB/a,EAAMgM,GAAQ,WAChC3N,KAAK+jB,cAAa,WACd,GAAe,aAAXpW,EAIA,IAFA,IAAMvF,EAAMzG,EAAKD,OACbM,EAAS,EACNA,EAASoG,GAAK,CACjB,IAAM+b,EAAa/iB,EAAAA,GAAuBO,EAAMK,GAC1CqG,EAAM1G,EAAK2Q,OAAOtQ,EAAQmiB,GAEhC,EAAKH,sBAAsBC,EAAAA,EAAAA,qBAAoC,EAAK7H,oBAAqB,EAAKI,uBAAwB,EAAK3G,QAAQ4E,aAAc,EAAKmB,OAAQ,EAAKiB,gBAAiB,EAAKqH,0BAA2B7b,IACpNrG,GAAUmiB,CACb,MAGD,EAAKH,sBAAsBC,EAAAA,EAAAA,wBAAuC,EAAKzH,uBAAwB,EAAK3G,QAAQ4E,aAAc,EAAKmB,OAAQ,EAAKiB,gBAAiBlb,GAEpK,GAAE+a,EAAiB/O,EACvB,GAxbL,6BAybI,SAAgB+O,EAAiB/a,EAAMyiB,EAAoBC,EAAoBC,EAAe3W,GAAQ,WAClG,GAAoB,IAAhBhM,EAAKD,QAAuC,IAAvB0iB,GAAmD,IAAvBC,EAYrDrkB,KAAK+jB,cAAa,WACd,EAAKC,sBAAsBC,EAAAA,EAAAA,gBAA+B,EAAKzH,uBAAwB,EAAK3G,QAAQ4E,aAAc,EAAKmB,OAAQ,EAAKiB,gBAAiBlb,EAAMyiB,EAAoBC,EAAoBC,GACtM,GAAE5H,EAAiB/O,QAZhB,GAAsB,IAAlB2W,EAAqB,CAErB,IAAMC,EAAgBvkB,KAAK6c,gBAAgBjE,KAAI,SAAArC,GAC3C,IAAM5T,EAAW4T,EAAUiO,cAC3B,OAAO,IAAIjY,EAAAA,EAAU5J,EAASG,WAAYH,EAASrB,OAASgjB,EAAe3hB,EAASG,WAAYH,EAASrB,OAASgjB,EACrH,IACDtkB,KAAKuhB,cAAc7E,EAAiB/O,EAAQ4W,EAAe,EAC9D,CAMR,GAzcL,mBA0cI,SAAM7H,EAAiB/a,EAAM8iB,EAAgBC,EAAiB/W,GAAQ,WAClE3N,KAAK+jB,cAAa,WACd,EAAKC,sBAAsBC,EAAAA,EAAAA,MAAqB,EAAKpO,QAAQ4E,aAAc,EAAKmB,OAAQ,EAAKiB,gBAAiBlb,EAAM8iB,EAAgBC,GAAmB,IAC1J,GAAEhI,EAAiB/O,EAAQ,EAC/B,GA9cL,iBA+cI,SAAI+O,EAAiB/O,GAAQ,WACzB3N,KAAK+jB,cAAa,WACd,EAAKC,sBAAsBW,EAAAA,EAAAA,IAAqB,EAAK9O,QAAQ4E,aAAc,EAAKmB,OAAQ,EAAKiB,iBAChG,GAAEH,EAAiB/O,EACvB,GAndL,4BAodI,SAAe+O,EAAiBuE,EAAStT,GAAQ,WAC7C3N,KAAK+jB,cAAa,WACd,EAAK9H,SAAS2I,uBACd,EAAKZ,sBAAsB,IAAIa,EAAAA,GAAoB,EAAe,CAAC5D,GAAU,CACzEN,8BAA8B,EAC9BW,6BAA6B,IAEpC,GAAE5E,EAAiB/O,EACvB,GA5dL,6BA6dI,SAAgB+O,EAAiBqE,EAAUpT,GAAQ,WAC/C3N,KAAK+jB,cAAa,WACd,EAAKC,sBAAsB,IAAIa,EAAAA,GAAoB,EAAe9D,EAAU,CACxEJ,8BAA8B,EAC9BW,6BAA6B,IAEpC,GAAE5E,EAAiB/O,EACvB,KApeL,GAAuCmX,EAAAA,IAsevCnJ,EAAkB0B,iBAAmB,I,IAI/BE,EAAAA,WACF,WAAYwE,EAAgB9C,IAAa,eACrCjf,KAAK+hB,eAAiBA,EACtB/hB,KAAKif,YAAcA,CACtB,C,qCAID,SAAO3V,GACH,IAAKA,EACD,OAAO,EAEX,GAAItJ,KAAK+hB,iBAAmBzY,EAAMyY,eAC9B,OAAO,EAEX,GAAI/hB,KAAKif,YAAYvd,SAAW4H,EAAM2V,YAAYvd,OAC9C,OAAO,EAEX,IAAK,IAAId,EAAI,EAAGwH,EAAMpI,KAAKif,YAAYvd,OAAQd,EAAIwH,EAAKxH,IACpD,IAAKZ,KAAKif,YAAYre,GAAG2I,OAAOD,EAAM2V,YAAYre,IAC9C,OAAO,EAGf,OAAO,CACV,I,mBAnBD,SAAYwV,EAAO2O,GACf,OAAO,IAAIxH,EAAiBnH,EAAM0F,eAAgBiJ,EAAOpI,kBAC5D,K,EAPCY,GA0BAkD,EAAAA,WACF,WAAYrK,EAAOkK,EAAiCE,IAAgC,eAChFxgB,KAAK4b,OAASxF,EACdpW,KAAKglB,iCAAmC1E,EACxCtgB,KAAKilB,gCAAkCzE,CAC1C,C,sCAQD,WACIxgB,KAAKglB,iCAAmChlB,KAAK4b,OAAO2E,iBAAiBvgB,KAAKglB,iCAAkC,IAC5GhlB,KAAKilB,gCAAkCjlB,KAAK4b,OAAO2E,iBAAiBvgB,KAAKilB,gCAAiC,GAC7G,G,2CACD,WAEI,IADA,IAAMnjB,EAAS,GACNlB,EAAI,EAAGA,EAAIZ,KAAKglB,iCAAiCtjB,OAAQd,IAAK,CACnE,IAAMskB,EAAkBllB,KAAK4b,OAAOuJ,mBAAmBnlB,KAAKglB,iCAAiCpkB,IACzFskB,GACApjB,EAAO+N,KAAKqV,EAEnB,CACD,OAAOpjB,CACV,G,qBACD,SAAQoX,GAEJ,IADA,IAAMkM,EAAkB,GACfxkB,EAAI,EAAGA,EAAIZ,KAAKilB,gCAAgCvjB,OAAQd,IAAK,CAClE,IAAMskB,EAAkBllB,KAAK4b,OAAOuJ,mBAAmBnlB,KAAKilB,gCAAgCrkB,IAC5F,GAAIskB,IACAE,EAAgBvV,KAAKqV,GACjBA,EAAgBlb,kBAAoBkb,EAAgBhb,eAEpD,OAAO,CAGlB,CACDkb,EAAgBlL,KAAKrX,EAAAA,EAAAA,0BACrBqW,EAAWgB,KAAKrX,EAAAA,EAAAA,0BAChB,IAAK,IAAIjC,EAAI,EAAGA,EAAIsY,EAAWxX,OAAQd,IAAK,CACxC,GAAIA,GAAKwkB,EAAgB1jB,OACrB,OAAO,EAEX,IAAK0jB,EAAgBxkB,GAAG2J,oBAAoB2O,EAAWtY,IACnD,OAAO,CAEd,CACD,OAAO,CACV,I,yCA5CD,SAAkCykB,GAC9B,IADiD,EAC7CC,EAAuB,GADsB,UAElBD,GAFkB,IAEjD,IAAK,EAAL,qBAAkD,KAAvCvI,EAAuC,QAC9CwI,EAAuBA,EAAqBC,OAAOzI,EAAiB0I,gCACvE,CAJgD,+BAKjD,OAAOF,CACV,K,EAZC7E,GAoDAI,EAAAA,W,gFACF,SAAuBzK,EAAOqP,EAAkB1E,GAQ5C,IAPA,IAAM2E,EAAM,CACRtP,MAAOA,EACPqP,iBAAkBA,EAClBE,cAAe,GACfC,uBAAwB,IAEtB9jB,EAAS9B,KAAK6lB,sBAAsBH,EAAK3E,GACtCngB,EAAI,EAAGwH,EAAMsd,EAAIC,cAAcjkB,OAAQd,EAAIwH,EAAKxH,IACrD8kB,EAAItP,MAAMC,iBAAiBqP,EAAIC,cAAc/kB,GAAI,KAAM,GAE3D,OAAOkB,CACV,G,mCACD,SAA6B4jB,EAAK3E,GAC9B,GAAI/gB,KAAK8lB,cAAc/E,GACnB,OAAO,KAEX,IAAMgF,EAAe/lB,KAAKgmB,mBAAmBN,EAAK3E,GAClD,GAAuC,IAAnCgF,EAAaE,WAAWvkB,OACxB,OAAO,KAEX,IAAMwkB,EAAgBH,EAAaE,WAC7BE,EAAkBnmB,KAAKomB,mBAAmBF,GAChD,GAAIC,EAAgB5S,eAAe,KAG/B,OADA8S,QAAQC,KAAK,qBACN,KAIX,IADA,IAAMC,EAAqB,GAClB3lB,EAAI,EAAGwH,EAAM8d,EAAcxkB,OAAQd,EAAIwH,EAAKxH,IAC5CulB,EAAgB5S,eAAe2S,EAActlB,GAAG4lB,WAAWC,MAAMC,aAClEH,EAAmB1W,KAAKqW,EAActlB,IAK1CmlB,EAAaY,yBAA2BJ,EAAmB7kB,OAAS,IACpE6kB,EAAmB,GAAGvD,YAAa,GAEvC,IAAI4D,EAAkBlB,EAAItP,MAAM6M,mBAAmByC,EAAID,iBAAkBc,GAAoB,SAACM,GAE1F,IADA,IAAMC,EAA+B,GAC5BlmB,EAAI,EAAGA,EAAI8kB,EAAID,iBAAiB/jB,OAAQd,IAC7CkmB,EAA6BlmB,GAAK,GAH8E,gBAKnGimB,GALmG,IAKpH,IAAK,EAAL,qBAAwC,KAA7BE,EAA6B,QAC/BA,EAAGP,YAIRM,EAA6BC,EAAGP,WAAWC,OAAO5W,KAAKkX,EAC1D,CAXmH,+BAgBpH,IAJA,IAAMC,EAAmB,SAACtd,EAAGC,GACzB,OAAOD,EAAE8c,WAAWS,MAAQtd,EAAE6c,WAAWS,KAC5C,EACKC,EAAmB,GAf2F,WAgB3GtmB,GACDkmB,EAA6BlmB,GAAGc,OAAS,GACzColB,EAA6BlmB,GAAGsZ,KAAK8M,GACrCE,EAAiBtmB,GAAKmgB,EAASngB,GAAGumB,mBAAmBzB,EAAItP,MAAO,CAC5DgR,yBAA0B,WACtB,OAAON,EAA6BlmB,EACvC,EACDymB,oBAAqB,SAACC,GAClB,IAAMC,EAAMC,SAASF,EAAI,IACnB1kB,EAAQ8iB,EAAItP,MAAMM,iBAAiBgP,EAAIC,cAAc4B,IAC3D,OAAwC,IAApC7B,EAAIE,uBAAuB2B,GACpB,IAAIhb,EAAAA,EAAU3J,EAAMoH,gBAAiBpH,EAAMqH,YAAarH,EAAMsH,cAAetH,EAAMuH,WAEvF,IAAIoC,EAAAA,EAAU3J,EAAMsH,cAAetH,EAAMuH,UAAWvH,EAAMoH,gBAAiBpH,EAAMqH,YAC3F,KAILid,EAAiBtmB,GAAK8kB,EAAID,iBAAiB7kB,EAlCiE,EAgB3GA,EAAI,EAAGA,EAAI8kB,EAAID,iBAAiB/jB,OAAQd,IAAK,EAA7CA,GAqBT,OAAOsmB,CACV,IACIN,IACDA,EAAkBlB,EAAID,kBAG1B,IAAMgC,EAAgB,GACtB,IAAK,IAAIC,KAAqBvB,EACtBA,EAAgB5S,eAAemU,IAC/BD,EAAc5X,KAAK2X,SAASE,EAAmB,KAIvDD,EAAcvN,MAAK,SAACxQ,EAAGC,GACnB,OAAOA,EAAID,CACd,IAED,IAAK,IAAL,MAA2B+d,EAA3B,eAA0C,CAArC,IAAME,EAAY,KACnBf,EAAgB5M,OAAO2N,EAAc,EACxC,CACD,OAAOf,CACV,G,2BACD,SAAqB7F,GACjB,IAAK,IAAIngB,EAAI,EAAGwH,EAAM2Y,EAASrf,OAAQd,EAAIwH,EAAKxH,IAC5C,GAAImgB,EAASngB,GACT,OAAO,EAGf,OAAO,CACV,G,gCACD,SAA0B8kB,EAAK3E,GAG3B,IAFA,IAAIkF,EAAa,GACbU,GAA0B,EACrB/lB,EAAI,EAAGwH,EAAM2Y,EAASrf,OAAQd,EAAIwH,EAAKxH,IAAK,CACjD,IAAMqgB,EAAUF,EAASngB,GACzB,GAAIqgB,EAAS,CACT,IAAMjV,EAAIhM,KAAK4nB,8BAA8BlC,EAAK9kB,EAAGqgB,GACrDgF,EAAaA,EAAWV,OAAOvZ,EAAEia,YACjCU,EAA0BA,GAA2B3a,EAAE2a,uBAC1D,CACJ,CACD,MAAO,CACHV,WAAYA,EACZU,wBAAyBA,EAEhC,G,2CACD,SAAqCjB,EAAKmC,EAAiB5G,GAGvD,IAAMgF,EAAa,GACf6B,EAAiB,EACfC,EAAmB,SAACnlB,EAAOjB,GAAmC,IAA7BoB,EAA6B,wDAC5DF,EAAAA,EAAAA,QAAcD,IAAmB,KAATjB,GAI5BskB,EAAWpW,KAAK,CACZ2W,WAAY,CACRC,MAAOoB,EACPZ,MAAOa,KAEXllB,MAAOA,EACPjB,KAAMA,EACNoB,iBAAkBA,EAClBilB,qBAAsB/G,EAAQgH,uBAErC,EACGtB,GAA0B,EAqCxBuB,EAAuB,CACzBH,iBAAkBA,EAClBI,wBAtC4B,SAAC5R,EAAW5U,EAAMoB,GAC9C4jB,GAA0B,EAC1BoB,EAAiBxR,EAAW5U,EAAMoB,EACrC,EAoCGqlB,eAnCmB,SAACC,EAAYC,GAChC,IACIjI,EADE9J,EAAYhK,EAAAA,EAAAA,cAAwB8b,GAE1C,GAAI9R,EAAUnM,UACV,GAAoC,mBAAzBke,EAEHjI,EADAiI,EACa,EAGA,MAGhB,CAED,IAAMC,EAAgB7C,EAAItP,MAAMoS,iBAAiBjS,EAAUvM,iBAEvDqW,EADA9J,EAAUtM,cAAgBse,EACb,EAGA,CAEpB,MAGDlI,EAAa,EAEjB,IAAMoI,EAAI/C,EAAIC,cAAcjkB,OACtB4lB,EAAK5B,EAAItP,MAAMC,iBAAiB,KAAME,EAAW8J,GAGvD,OAFAqF,EAAIC,cAAc8C,GAAKnB,EACvB5B,EAAIE,uBAAuB6C,GAAKlS,EAAU1J,eACnC4b,EAAE/B,UACZ,GAMD,IACIzF,EAAQyH,kBAAkBhD,EAAItP,MAAO8R,EAUxC,CARD,MAAOtJ,GAIH,OADA+E,EAAAA,EAAAA,IAAkB/E,GACX,CACHqH,WAAY,GACZU,yBAAyB,EAEhC,CACD,MAAO,CACHV,WAAYA,EACZU,wBAAyBA,EAEhC,G,gCACD,SAA0BV,IAEtBA,EAAaA,EAAW1M,MAAM,IAEnBW,MAAK,SAACxQ,EAAGC,GAEhB,OAAS9G,EAAAA,EAAAA,uBAA6B6G,EAAE9G,MAAO+G,EAAE/G,MACpD,IAGD,IADA,IAAMujB,EAAkB,CAAC,EAChBvlB,EAAI,EAAGA,EAAIqlB,EAAWvkB,OAAQd,IAAK,CACxC,IAAM+nB,EAAa1C,EAAWrlB,EAAI,GAC5BgoB,EAAY3C,EAAWrlB,GAC7B,GAAIiC,EAAAA,EAAAA,iBAAuB8lB,EAAW/lB,OAAO4G,SAAS3G,EAAAA,EAAAA,eAAqB+lB,EAAUhmB,QAAS,CAC1F,IAAIimB,OAAU,EAQd1C,GALI0C,EAFAF,EAAWnC,WAAWC,MAAQmC,EAAUpC,WAAWC,MAEtCkC,EAAWnC,WAAWC,MAGtBmC,EAAUpC,WAAWC,OAEXC,aAAc,EACzC,IAAK,IAAIoC,EAAI,EAAGA,EAAI7C,EAAWvkB,OAAQonB,IAC/B7C,EAAW6C,GAAGtC,WAAWC,QAAUoC,IACnC5C,EAAWjM,OAAO8O,EAAG,GACjBA,EAAIloB,GACJA,IAEJkoB,KAGJloB,EAAI,GACJA,GAEP,CACJ,CACD,OAAOulB,CACV,K,EAlPCtF,E,wGCpkBOkI,EAAb,mGAOI,SAA+B1nB,EAAasB,EAAUzB,GAKlD,IAJA,IAAM8nB,EAAa3nB,EAAYK,OAC3BT,EAAgB,EAChBgoB,GAAuB,EACvBC,GAA4B,EACvBtoB,EAAI,EAAGA,EAAIooB,EAAYpoB,IAAK,CACjC,GAAIA,IAAM+B,EACN,MAAO,CAACsmB,EAAqBC,EAA0BjoB,GAO3D,OALIA,EAAgBC,IAAY,IAC5B+nB,EAAsBroB,EACtBsoB,EAA2BjoB,GAEhBI,EAAYiH,WAAW1H,IAElC,KAAK,GACDK,GAAiB,EACjB,MACJ,KAAK,EAEDA,EAAgBF,EAAAA,EAAAA,kBAAgCE,EAAeC,GAC/D,MACJ,QACI,MAAO,EAAE,GAAI,GAAI,GAE5B,CACD,OAAIyB,IAAaqmB,EACN,CAACC,EAAqBC,EAA0BjoB,GAEpD,EAAE,GAAI,GAAI,EACpB,GArCL,4BA+CI,SAAsBI,EAAasB,EAAUzB,EAAS4L,GAClD,IASIqc,EATEH,EAAa3nB,EAAYK,OAG/B,EAAuEqnB,EAAwBK,wBAAwB/nB,EAAasB,EAAUzB,GAA9I,eAAO+nB,EAAP,KAA4BC,EAA5B,KAAsDjoB,EAAtD,KACA,IAAuB,IAAnBA,EACA,OAAQ,EAKZ,OAAQ6L,GACJ,KAAK,EACDqc,GAAO,EACP,MACJ,KAAK,EACDA,GAAO,EACP,MACJ,KAAK,EAGD,GAAIloB,EAAgBC,IAAY,EAC5B,OAAOyB,EAGXwmB,EAAOloB,EAAgBC,GAAYA,EAAU,EAKrD,GAAIioB,EAAM,CACN,IAA6B,IAAzBF,EACA,OAAQ,EAQZ,IADA,IAAII,EAAuBH,EAClBtoB,EAAIqoB,EAAqBroB,EAAIooB,IAAcpoB,EAAG,CACnD,GAAIyoB,IAAyBH,EAA2BhoB,EAEpD,OAAO+nB,EAGX,OADe5nB,EAAYiH,WAAW1H,IAElC,KAAK,GACDyoB,GAAwB,EACxB,MACJ,KAAK,EACDA,EAAuBtoB,EAAAA,EAAAA,kBAAgCsoB,EAAsBnoB,GAC7E,MACJ,QACI,OAAQ,EAEnB,CACD,OAAImoB,IAAyBH,EAA2BhoB,EAC7C+nB,GAGH,CACX,CAKD,IAHA,IAAMK,EAAsBvoB,EAAAA,EAAAA,kBAAgCE,EAAeC,GAEvEmoB,EAAuBpoB,EAClBL,EAAI+B,EAAU/B,EAAIooB,EAAYpoB,IAAK,CACxC,GAAIyoB,IAAyBC,EACzB,OAAO1oB,EAGX,OADeS,EAAYiH,WAAW1H,IAElC,KAAK,GACDyoB,GAAwB,EACxB,MACJ,KAAK,EACDA,EAAuBtoB,EAAAA,EAAAA,kBAAgCsoB,EAAsBnoB,GAC7E,MACJ,QACI,OAAQ,EAEnB,CAED,OAAImoB,IAAyBC,EAClBN,GAEH,CACX,KAvIL,I,mHCEaO,EAAb,wFACI,SAAoBzU,EAAQsB,EAAOoT,EAAgBC,EAAmBC,EAAcC,GAOhF,IANA,IAAMC,EAAYpoB,KAAKqoB,IAAIH,EAAeF,GAAkB,EACtDM,EAAYN,EAAiBE,EAC7BK,EAASN,EAAoBE,EAC7BK,EAASP,EAAoBE,EAC7B7nB,EAAS,GAENlB,EAAI,EAAGA,EAAIgpB,EAAWhpB,IAAK,CAChC,IAAMkC,EAAa0mB,GAAkBM,GAAYlpB,EAAIA,GAC/CqJ,EAAc6K,EAAOmV,wBAAwB7T,EAAOtT,EAAY2mB,GAChEtf,EAAY2K,EAAOmV,wBAAwB7T,EAAOtT,EAAY6mB,GAC9DO,EAAqBpV,EAAO6K,wBAAwBvJ,EAAO,IAAIpN,EAAAA,EAASlG,EAAYmH,IACpFkgB,EAAmBrV,EAAO6K,wBAAwBvJ,EAAO,IAAIpN,EAAAA,EAASlG,EAAYqH,IAExF,GAAI6f,EAAO,CACP,GAAIE,EAAqBP,EACrB,SAEJ,GAAIQ,EAAmBV,EACnB,QAEP,CACD,GAAIM,EAAO,CACP,GAAII,EAAmBV,EACnB,SAEJ,GAAIS,EAAqBP,EACrB,QAEP,CACD7nB,EAAO+N,KAAK,IAAIoG,EAAAA,GAAkB,IAAIpT,EAAAA,EAAMC,EAAYmH,EAAanH,EAAYmH,GAAc,EAAG,IAAIjB,EAAAA,EAASlG,EAAYqH,GAAY,GAC1I,CACD,GAAsB,IAAlBrI,EAAOJ,OAEP,IAAK,IAAId,EAAI,EAAGA,EAAIgpB,EAAWhpB,IAAK,CAChC,IAAMkC,EAAa0mB,GAAkBM,GAAYlpB,EAAIA,GAC/CwpB,EAAYhU,EAAMoS,iBAAiB1lB,GACzChB,EAAO+N,KAAK,IAAIoG,EAAAA,GAAkB,IAAIpT,EAAAA,EAAMC,EAAYsnB,EAAWtnB,EAAYsnB,GAAY,EAAG,IAAIphB,EAAAA,EAASlG,EAAYsnB,GAAY,GACtI,CAEL,MAAO,CACHC,WAAYvoB,EACZgoB,SAAUA,EACVN,eAAgBA,EAChBc,iBAAkBb,EAClBC,aAAcA,EACda,eAAgBZ,EAEvB,GAjDL,8BAkDI,SAAwB7U,EAAQsB,EAAOoU,GACnC,IAAI3K,EAAqB2K,EAAqB3K,mBAI9C,OAHIA,EAAqB,GACrBA,IAEG0J,EAAgBkB,aAAa3V,EAAQsB,EAAOoU,EAAqB/K,mBAAoB+K,EAAqB9K,qBAAsB8K,EAAqB5K,iBAAkBC,EACjL,GAxDL,+BAyDI,SAAyB/K,EAAQsB,EAAOoU,GAIpC,IAHA,IAAIE,EAAsB,EACpBC,EAAoBnpB,KAAKC,IAAI+oB,EAAqB/K,mBAAoB+K,EAAqB5K,kBAC3FgL,EAAoBppB,KAAKiB,IAAI+nB,EAAqB/K,mBAAoB+K,EAAqB5K,kBACxF9c,EAAa6nB,EAAmB7nB,GAAc8nB,EAAmB9nB,IAAc,CACpF,IAAM+nB,EAAoBzU,EAAMoS,iBAAiB1lB,GAC3CgoB,EAA0BhW,EAAO6K,wBAAwBvJ,EAAO,IAAIpN,EAAAA,EAASlG,EAAY+nB,IAC/FH,EAAsBlpB,KAAKiB,IAAIioB,EAAqBI,EACvD,CACD,IAAIjL,EAAqB2K,EAAqB3K,mBAI9C,OAHIA,EAAqB6K,GACrB7K,IAEG7f,KAAKyqB,aAAa3V,EAAQsB,EAAOoU,EAAqB/K,mBAAoB+K,EAAqB9K,qBAAsB8K,EAAqB5K,iBAAkBC,EACtK,GAvEL,4BAwEI,SAAsB/K,EAAQsB,EAAOoU,EAAsBO,GACvD,IAAMC,EAAaD,EAAUjW,EAAOmW,SAAW,EACzCrL,EAAmBpe,KAAKiB,IAAI,EAAG+nB,EAAqB5K,iBAAmBoL,GAC7E,OAAOhrB,KAAKyqB,aAAa3V,EAAQsB,EAAOoU,EAAqB/K,mBAAoB+K,EAAqB9K,qBAAsBE,EAAkB4K,EAAqB3K,mBACtK,GA5EL,8BA6EI,SAAwB/K,EAAQsB,EAAOoU,EAAsBO,GACzD,IAAMC,EAAaD,EAAUjW,EAAOmW,SAAW,EACzCrL,EAAmBpe,KAAKC,IAAI2U,EAAM8U,eAAgBV,EAAqB5K,iBAAmBoL,GAChG,OAAOhrB,KAAKyqB,aAAa3V,EAAQsB,EAAOoU,EAAqB/K,mBAAoB+K,EAAqB9K,qBAAsBE,EAAkB4K,EAAqB3K,mBACtK,KAjFL,I,0KCIa8E,EAAb,uFACI,SAAmBwG,EAAuBrW,EAAQsB,EAAO8C,GAGrD,IAFA,IAAM6H,EAAW,GACbJ,EAA0D,IAA1BwK,EAC3BvqB,EAAI,EAAGwH,EAAM8Q,EAAWxX,OAAQd,EAAIwH,EAAKxH,IAAK,CACnD,IAAM2V,EAAY2C,EAAWtY,GACzBwqB,EAAkB7U,EACtB,GAAI6U,EAAgBhhB,UAAW,CAC3B,IAAMzH,EAAW4T,EAAUiO,cACrB6G,EAAkBC,EAAAA,EAAAA,MAAqBxW,EAAQsB,EAAOzT,GAC5DyoB,EAAkB,IAAIvoB,EAAAA,EAAMwoB,EAAgBvoB,WAAYuoB,EAAgB/pB,OAAQqB,EAASG,WAAYH,EAASrB,OACjH,CACG8pB,EAAgBhhB,UAEhB2W,EAASngB,GAAK,MAGdwqB,EAAgBphB,kBAAoBohB,EAAgBlhB,gBACpDyW,GAA+B,GAEnCI,EAASngB,GAAK,IAAI2qB,EAAAA,GAAeH,EAAiB,IACrD,CACD,MAAO,CAACzK,EAA8BI,EACzC,GAvBL,qCAwBI,SAA+ByK,EAAmBC,EAAqBC,EAAmBC,EAAsBvV,EAAO8C,EAAYoM,GAC/H,GAA4B,UAAxBmG,GAAyD,UAAtBC,EACnC,OAAO,EAEX,GAA0B,UAAtBF,EACA,OAAO,EAEX,IAAK,IAAI5qB,EAAI,EAAGwH,EAAM8Q,EAAWxX,OAAQd,EAAIwH,EAAKxH,IAAK,CACnD,IAAM2V,EAAY2C,EAAWtY,GACvB+B,EAAW4T,EAAUiO,cAC3B,IAAKjO,EAAUnM,UACX,OAAO,EAEX,IAAMwhB,EAAWxV,EAAMyV,eAAelpB,EAASG,YAC/C,GAAIH,EAASrB,OAAS,GAAKqB,EAASrB,QAAUsqB,EAASlqB,OAAS,EAC5D,OAAO,EAEX,IAAMoqB,EAAYF,EAAShjB,OAAOjG,EAASrB,OAAS,GAC9CyqB,EAA4BJ,EAAqBlrB,IAAIqrB,GAC3D,IAAKC,EACD,OAAO,EAEX,IAAIC,EAAAA,EAAAA,IAAQF,IACR,GAA0B,UAAtBJ,EACA,OAAO,OAIX,GAA4B,UAAxBD,EACA,OAAO,EAGf,IAzBmD,EAyB7CQ,EAAiBL,EAAShjB,OAAOjG,EAASrB,OAAS,GACrD4qB,GAAuB,EA1BwB,UA2BZH,GA3BY,IA2BnD,IAAK,EAAL,qBAAkE,KAAvDI,EAAuD,QAC1DA,EAAyB1J,OAASqJ,GAAaK,EAAyBC,QAAUH,IAClFC,GAAuB,EAE9B,CA/BkD,+BAgCnD,IAAKA,EACD,OAAO,EAGX,GAA0B,SAAtBV,EAA8B,CAE9B,IADA,IAAIa,GAAQ,EACHvD,EAAI,EAAGwD,EAAOhH,EAAqB5jB,OAAQonB,EAAIwD,EAAMxD,IAAK,CAC/D,IAAMyD,EAAsBjH,EAAqBwD,GACjD,GAAInmB,EAASG,aAAeypB,EAAoBviB,iBAAmBrH,EAASrB,SAAWirB,EAAoBtiB,YAAa,CACpHoiB,GAAQ,EACR,KACH,CACJ,CACD,IAAKA,EACD,OAAO,CAEd,CACJ,CACD,OAAO,CACV,GAlFL,uCAmFI,SAAiCvX,EAAQsB,EAAO8C,GAE5C,IADA,IAAM6H,EAAW,GACRngB,EAAI,EAAGwH,EAAM8Q,EAAWxX,OAAQd,EAAIwH,EAAKxH,IAAK,CACnD,IAAM+B,EAAWuW,EAAWtY,GAAG4jB,cACzB4G,EAAkB,IAAIvoB,EAAAA,EAAMF,EAASG,WAAYH,EAASrB,OAAS,EAAGqB,EAASG,WAAYH,EAASrB,OAAS,GACnHyf,EAASngB,GAAK,IAAI2qB,EAAAA,GAAeH,EAAiB,GACrD,CACD,MAAO,EAAC,EAAMrK,EACjB,GA3FL,wBA4FI,SAAkBoK,EAAuBrW,EAAQsB,EAAO8C,EAAYoM,GAChE,GAAItlB,KAAKwsB,wBAAwB1X,EAAO0W,kBAAmB1W,EAAO2W,oBAAqB3W,EAAO4W,kBAAmB5W,EAAOwN,iBAAiBmK,0BAA2BrW,EAAO8C,EAAYoM,GACnL,OAAOtlB,KAAK0sB,0BAA0B5X,EAAQsB,EAAO8C,GAIzD,IAFA,IAAM6H,EAAW,GACbJ,EAA0D,IAA1BwK,EAC3BvqB,EAAI,EAAGwH,EAAM8Q,EAAWxX,OAAQd,EAAIwH,EAAKxH,IAAK,CACnD,IAAM+rB,EAAchI,EAAiBiI,eAAe1T,EAAWtY,GAAIwV,EAAOtB,GAGtE6X,EAAYviB,UACZ2W,EAASngB,GAAK,MAGd+rB,EAAY3iB,kBAAoB2iB,EAAYziB,gBAC5CyW,GAA+B,GAEnCI,EAASngB,GAAK,IAAI2qB,EAAAA,GAAeoB,EAAa,IACjD,CACD,MAAO,CAAChM,EAA8BI,EACzC,GAhHL,4BAiHI,SAAsBxK,EAAWH,EAAOtB,GACpC,IAAKyB,EAAUnM,UACX,OAAOmM,EAEX,IAAM5T,EAAW4T,EAAUiO,cAE3B,GAAI1P,EAAO+X,aAAelqB,EAASrB,OAAS,EAAG,CAC3C,IAAMD,EAAc+U,EAAMyV,eAAelpB,EAASG,YAC5C4F,EAA0BtH,EAAAA,GAAgCC,GAC1DyrB,GAAsD,IAA7BpkB,EACSrH,EAAYK,OAAS,EACvDgH,EAA0B,EAChC,GAAI/F,EAASrB,QAAUwrB,EAAuB,CAC1C,IAAMrD,EAAoB3U,EAAO6K,wBAAwBvJ,EAAOzT,GAC1DgnB,EAAkB5oB,EAAAA,EAAAA,kBAAgC0oB,EAAmB3U,EAAOtS,YAC5EuqB,EAAWjY,EAAOmV,wBAAwB7T,EAAOzT,EAASG,WAAY6mB,GAC5E,OAAO,IAAI9mB,EAAAA,EAAMF,EAASG,WAAYiqB,EAAUpqB,EAASG,WAAYH,EAASrB,OACjF,CACJ,CACD,OAAOuB,EAAAA,EAAAA,cAAoB8hB,EAAiBqI,2BAA2BrqB,EAAUyT,GAAQzT,EAC5F,GArIL,wCAsII,SAAkCA,EAAUyT,GACxC,GAAIzT,EAASrB,OAAS,EAAG,CAErB,IAAMimB,EAAMnmB,EAAAA,GAA4BuB,EAASrB,OAAS,EAAG8U,EAAMyV,eAAelpB,EAASG,aAC3F,OAAOH,EAAS0G,UAAK8C,EAAWob,EAAM,EACzC,CACI,GAAI5kB,EAASG,WAAa,EAAG,CAC9B,IAAMmqB,EAAUtqB,EAASG,WAAa,EACtC,OAAO,IAAIkG,EAAAA,EAASikB,EAAS7W,EAAMoS,iBAAiByE,GACvD,CAEG,OAAOtqB,CAEd,GAnJL,iBAoJI,SAAWmS,EAAQsB,EAAO8C,GACtB,IAAM6H,EAAW,GACbmM,EAAe,KACnBhU,EAAWgB,MAAK,SAACxQ,EAAGC,GAAJ,OAAUX,EAAAA,EAAAA,QAAiBU,EAAEkB,mBAAoBjB,EAAEgB,iBAAnD,IAChB,IAAK,IAAI/J,EAAI,EAAGwH,EAAM8Q,EAAWxX,OAAQd,EAAIwH,EAAKxH,IAAK,CACnD,IAAM2V,EAAY2C,EAAWtY,GAC7B,GAAI2V,EAAUnM,UACV,GAAI0K,EAAOqY,wBAAyB,CAEhC,IAAMxqB,EAAW4T,EAAUiO,cACvBxa,OAAe,EAAEC,OAAW,EAAEC,OAAa,EAAEC,OAAS,EACtDxH,EAASG,WAAasT,EAAM8U,gBAE5BlhB,EAAkBrH,EAASG,WAC3BmH,EAAc,EACdC,EAAgBvH,EAASG,WAAa,EACtCqH,EAAY,GAEPxH,EAASG,WAAa,IAAuB,OAAjBoqB,QAA0C,IAAjBA,OAA0B,EAASA,EAAahjB,iBAAmBvH,EAASG,YAEtIkH,EAAkBrH,EAASG,WAAa,EACxCmH,EAAcmM,EAAMoS,iBAAiB7lB,EAASG,WAAa,GAC3DoH,EAAgBvH,EAASG,WACzBqH,EAAYiM,EAAMoS,iBAAiB7lB,EAASG,cAI5CkH,EAAkBrH,EAASG,WAC3BmH,EAAc,EACdC,EAAgBvH,EAASG,WACzBqH,EAAYiM,EAAMoS,iBAAiB7lB,EAASG,aAEhD,IAAMsoB,EAAkB,IAAIvoB,EAAAA,EAAMmH,EAAiBC,EAAaC,EAAeC,GAC/E+iB,EAAe9B,EACVA,EAAgBhhB,UAIjB2W,EAASngB,GAAK,KAHdmgB,EAASngB,GAAK,IAAI2qB,EAAAA,GAAeH,EAAiB,GAKzD,MAGGrK,EAASngB,GAAK,UAIlBmgB,EAASngB,GAAK,IAAI2qB,EAAAA,GAAehV,EAAW,GAEnD,CACD,OAAO,IAAIsO,EAAAA,GAAoB,EAAe9D,EAAU,CACpDJ,8BAA8B,EAC9BW,6BAA6B,GAEpC,KA1ML,I,kFCwcW8L,E,wFAzcEC,EAAb,yFACI,SAAqBzW,EAAW0B,EAASgV,GAGrC,IAFA,IAAMxrB,EAAS,GACX8L,EAAY,EACPhN,EAAI,EAAGwH,EAAMkQ,EAAQ5W,OAAQd,EAAIwH,EAAKxH,IAAK,CAChD,IAAMmkB,EAASzM,EAAQ1X,GACvBkB,EAAO8L,KAAe,IAAI4I,EAAAA,GAAYuO,EAAOzO,WAAYyO,EAAOtO,WAE5D3U,EAAO8L,KADP0f,EACsB9W,EAAAA,GAAAA,eAA2B8U,EAAAA,EAAAA,cAA6B1U,EAAU6D,aAAc7D,EAAUR,MAAO2O,EAAOzO,aAGxGE,EAAAA,GAAAA,cAA0B8U,EAAAA,EAAAA,cAA6B1U,EAAU6D,aAAc7D,EAAWmO,EAAOtO,WAE9H,CACD,OAAO3U,CACV,GAfL,yBAgBI,SAAmB8U,EAAW0B,EAASgV,GAGnC,IAFA,IAAMxrB,EAAS,GACX8L,EAAY,EACPhN,EAAI,EAAGwH,EAAMkQ,EAAQ5W,OAAQd,EAAIwH,EAAKxH,IAAK,CAChD,IAAMmkB,EAASzM,EAAQ1X,GACvBkB,EAAO8L,KAAe,IAAI4I,EAAAA,GAAYuO,EAAOzO,WAAYyO,EAAOtO,WAE5D3U,EAAO8L,KADP0f,EACsB9W,EAAAA,GAAAA,eAA2B8U,EAAAA,EAAAA,YAA2B1U,EAAU6D,aAAc7D,EAAUR,MAAO2O,EAAOzO,aAGtGE,EAAAA,GAAAA,cAA0B8U,EAAAA,EAAAA,YAA2B1U,EAAU6D,aAAc7D,EAAWmO,EAAOtO,WAE5H,CACD,OAAO3U,CACV,GA9BL,mCA+BI,SAA6B8U,EAAW0B,EAASkG,GAE7C,IADA,IAAI1c,EAAS,GACJlB,EAAI,EAAGwH,EAAMkQ,EAAQ5W,OAAQd,EAAIwH,EAAKxH,IAAK,CAChD,IAAMmkB,EAASzM,EAAQ1X,GACvBkB,EAAOlB,GAAKZ,KAAKutB,iBAAiB3W,EAAWmO,EAAQvG,EACxD,CACD,OAAO1c,CACV,GAtCL,8BAuCI,SAAwB8U,EAAWmO,EAAQvG,GACvC,IAAMgP,EAAyBzI,EAAOtO,UAAU9T,SAASrB,OAEnDmsB,EAA2BD,IADDzI,EAAOzO,WAAW3T,SAASrB,OAErDosB,EAA6B3I,EAAOtO,UAAU9T,SAASG,WACvD6qB,EAAsB/W,EAAUgX,gCAAgCF,GAEtE,OAAKD,GADyBD,IAA2BG,EAK9C3tB,KAAK6tB,wBAAwBjX,EAAWmO,EAAQvG,GAHhDxe,KAAK8tB,uBAAuBlX,EAAWmO,EAAQvG,EAK7D,GApDL,oCAqDI,SAA8B5H,EAAWmO,EAAQvG,GAC7C,OAAOhI,EAAAA,GAAAA,cAA0B8U,EAAAA,EAAAA,sBAAqC1U,EAAU6D,aAAc7D,EAAWmO,EAAOtO,UAAW+H,GAC9H,GAvDL,qCAwDI,SAA+B5H,EAAWmO,EAAQvG,GAC9C,OAAOhI,EAAAA,GAAAA,eAA2B8U,EAAAA,EAAAA,sBAAqC1U,EAAU6D,aAAc7D,EAAUR,MAAO2O,EAAOzO,WAAYkI,GACtI,GA1DL,6BA2DI,SAAuB5H,EAAW0B,EAASkG,EAAiBuP,GAExD,IADA,IAAMjsB,EAAS,GACNlB,EAAI,EAAGwH,EAAMkQ,EAAQ5W,OAAQd,EAAIwH,EAAKxH,IAAK,CAChD,IAAMmkB,EAASzM,EAAQ1X,GACvBkB,EAAOlB,GAAKZ,KAAKguB,eAAepX,EAAWmO,EAAQvG,EAAiBuP,EACvE,CACD,OAAOjsB,CACV,GAlEL,4BAmEI,SAAsB8U,EAAWmO,EAAQvG,EAAiBuP,GACtD,IAAME,EAAoBlJ,EAAOtO,UAAU9T,SACrCurB,EAAqBtX,EAAU4R,iBAAiByF,EAAkBnrB,YAClEqrB,EAAkBF,EAAkB3sB,SAAW4sB,EAC/CE,EAAqBrJ,EAAOzO,WAAW3T,SACvC0rB,EAAiBzX,EAAUR,MAAMoS,iBAAiB4F,EAAmBtrB,YACrEwrB,EAAyBJ,EAAqBD,EAAkB3sB,SAAW+sB,EAAiBD,EAAmB9sB,OACrH,OAAI6sB,GAAmBG,EACZtuB,KAAKuuB,sBAAsB3X,EAAWmO,EAAQvG,EAAiBuP,GAG/D/tB,KAAKwuB,qBAAqB5X,EAAWmO,EAAQvG,EAAiBuP,EAE5E,GAhFL,kCAiFI,SAA4BnX,EAAWmO,EAAQvG,EAAiBuP,GAC5D,OAAOvX,EAAAA,GAAAA,cAA0B8U,EAAAA,EAAAA,gBAA+B1U,EAAU6D,aAAc7D,EAAWmO,EAAOtO,UAAW+H,EAAiBuP,GACzI,GAnFL,mCAoFI,SAA6BnX,EAAWmO,EAAQvG,EAAiBuP,GAC7D,OAAOvX,EAAAA,GAAAA,eAA2B8U,EAAAA,EAAAA,gBAA+B1U,EAAU6D,aAAc7D,EAAUR,MAAO2O,EAAOzO,WAAYkI,EAAiBuP,GACjJ,GAtFL,iCAuFI,SAA2BnX,EAAW0B,GAElC,IADA,IAAMxW,EAAS,GACNlB,EAAI,EAAGwH,EAAMkQ,EAAQ5W,OAAQd,EAAIwH,EAAKxH,IAAK,CAChD,IAAMmkB,EAASzM,EAAQ1X,GACjBoJ,EAAkB+a,EAAOzO,WAAWC,UAAUvM,gBAC9C4f,EAAYhT,EAAUR,MAAM8U,eAC9BhhB,EAAgB6a,EAAOzO,WAAWC,UAAUrM,cAC5CC,OAAS,EACTD,IAAkB0f,EAClBzf,EAAYyM,EAAUR,MAAMoS,iBAAiBoB,IAG7C1f,IACAC,EAAY,GAEhBrI,EAAOlB,GAAK4V,EAAAA,GAAAA,eAA2B,IAAIP,EAAAA,GAAkB,IAAIpT,EAAAA,EAAMmH,EAAiB,EAAGA,EAAiB,GAAI,EAAG,IAAIhB,EAAAA,EAASkB,EAAeC,GAAY,GAC9J,CACD,OAAOrI,CACV,GAzGL,qCA0GI,SAA+B8U,EAAW0B,EAASkG,GAE/C,IADA,IAAM1c,EAAS,GACNlB,EAAI,EAAGwH,EAAMkQ,EAAQ5W,OAAQd,EAAIwH,EAAKxH,IAAK,CAChD,IAAMmkB,EAASzM,EAAQ1X,GACvBkB,EAAOlB,GAAK4V,EAAAA,GAAAA,eAA2B8U,EAAAA,EAAAA,wBAAuC1U,EAAU6D,aAAc7D,EAAUR,MAAO2O,EAAOzO,WAAYkI,GAC7I,CACD,OAAO1c,CACV,GAjHL,+BAkHI,SAAyB8U,EAAW0B,EAASkG,GAEzC,IADA,IAAM1c,EAAS,GACNlB,EAAI,EAAGwH,EAAMkQ,EAAQ5W,OAAQd,EAAIwH,EAAKxH,IAAK,CAChD,IAAMmkB,EAASzM,EAAQ1X,GACvBkB,EAAOlB,GAAK4V,EAAAA,GAAAA,eAA2B8U,EAAAA,EAAAA,kBAAiC1U,EAAU6D,aAAc7D,EAAUR,MAAO2O,EAAOzO,WAAYkI,GACvI,CACD,OAAO1c,CACV,GAzHL,uBA0HI,SAAiB8U,EAAWmO,GACxB,IAAM6E,EAAYhT,EAAUR,MAAM8U,eAC5Bd,EAAYxT,EAAUR,MAAMoS,iBAAiBoB,GACnD,OAAOpT,EAAAA,GAAAA,eAA2B,IAAIP,EAAAA,GAAkB,IAAIpT,EAAAA,EAAM,EAAG,EAAG,EAAG,GAAI,EAAG,IAAImG,EAAAA,EAAS4gB,EAAWQ,GAAY,GACzH,GA9HL,kBA+HI,SAAYxT,EAAWmO,EAAQvG,EAAiBiQ,EAAWC,GACvD,IAAM/rB,EAAWiU,EAAUR,MAAMY,iBAAiByX,GAC5ClX,EAAgBmX,EAChB9X,EAAUM,qBAAqBM,qBAAqB,IAAIxO,EAAAA,EAAS0lB,EAAc5rB,WAAY4rB,EAAcptB,QAASqB,GAClHiU,EAAUM,qBAAqBQ,mCAAmC/U,GACxE,IAAK6b,IAAoBuG,EAAOzO,WAAWqY,eAAgB,CAEvD,IAAM/E,EAAYhT,EAAUR,MAAM8U,eAC9B0D,EAAqBjsB,EAASG,WAAa,EAC3C+rB,EAAiB,EAKrB,OAJID,EAAqBhF,IACrBgF,EAAqBhF,EACrBiF,EAAiBjY,EAAUR,MAAMoS,iBAAiBoG,IAE/CpY,EAAAA,GAAAA,eAA2B,IAAIP,EAAAA,GAAkB,IAAIpT,EAAAA,EAAMF,EAASG,WAAY,EAAG8rB,EAAoBC,GAAiB,EAAG,IAAI7lB,EAAAA,EAAS4lB,EAAoBC,GAAiB,GACvL,CAED,IAAMC,EAAqB/J,EAAOzO,WAAWO,eAAejM,mBAAmB9H,WAC/E,GAAIH,EAASG,WAAagsB,EACtB,OAAOtY,EAAAA,GAAAA,cAA0BuO,EAAOtO,UAAUsY,KAAKhK,EAAOzO,WAAWqY,eAAgBpX,EAAazU,WAAY,EAAG,IAEpH,GAAIH,EAASG,WAAagsB,EAAoB,CAC/C,IAAMlF,EAAYhT,EAAUsU,eACxB8D,EAAyBzX,EAAazU,WAAa,EACnDmsB,EAAqB,EAKzB,OAJID,EAAyBpF,IACzBoF,EAAyBpF,EACzBqF,EAAqBrY,EAAU4R,iBAAiBwG,IAE7CxY,EAAAA,GAAAA,cAA0BuO,EAAOtO,UAAUsY,KAAKhK,EAAOzO,WAAWqY,eAAgBK,EAAwBC,EAAoB,GACxI,CAEG,IAAMC,EAA8BnK,EAAOzO,WAAWO,eAAelM,iBACrE,OAAO6L,EAAAA,GAAAA,eAA2BuO,EAAOzO,WAAWyY,KAAKhK,EAAOzO,WAAWqY,eAAgBO,EAA4BpsB,WAAYosB,EAA4B5tB,OAAQ,GAE9K,GAlKL,kBAmKI,SAAYsV,EAAWmO,EAAQvG,EAAiBiQ,GAC5C,IAAM9rB,EAAWiU,EAAUR,MAAMY,iBAAiByX,GAClD,OAAOjY,EAAAA,GAAAA,eAA2B2Y,EAAAA,EAAAA,KAAoBvY,EAAU6D,aAAc7D,EAAUR,MAAO2O,EAAOzO,WAAYkI,EAAiB7b,GACtI,GAtKL,6BAuKI,SAAuBiU,EAAWmO,GAC9B,IAAKA,EAAOzO,WAAWqY,eACnB,OAAO,IAAInY,EAAAA,GAAYuO,EAAOzO,WAAYyO,EAAOtO,WAErD,IAAM3T,EAAaiiB,EAAOtO,UAAU9T,SAASG,WACvCxB,EAASyjB,EAAOtO,UAAU9T,SAASrB,OACzC,OAAOkV,EAAAA,GAAAA,cAA0B,IAAIP,EAAAA,GAAkB,IAAIpT,EAAAA,EAAMC,EAAYxB,EAAQwB,EAAYxB,GAAS,EAAG,IAAI0H,EAAAA,EAASlG,EAAYxB,GAAS,GAClJ,GA9KL,oBA+KI,SAAcsV,EAAWmO,EAAQvG,EAAiBiQ,EAAWC,GACzD,IAAM/rB,EAAWiU,EAAUR,MAAMY,iBAAiByX,GAC5ClX,EAAgBmX,EAChB9X,EAAUM,qBAAqBM,qBAAqB,IAAIxO,EAAAA,EAAS0lB,EAAc5rB,WAAY4rB,EAAcptB,QAASqB,GAClHiU,EAAUM,qBAAqBQ,mCAAmC/U,GACxE,OAAO6T,EAAAA,GAAAA,cAA0BuO,EAAOtO,UAAUsY,KAAKvQ,EAAiBjH,EAAazU,WAAYyU,EAAajW,OAAQ,GACzH,GArLL,wBAsLI,SAAkBsV,EAAW0B,EAASxL,EAAW0R,EAAiBje,EAAO6uB,GACrE,OAAQtiB,GACJ,KAAK,EACD,OAAa,IAATsiB,EAEOpvB,KAAKqvB,kBAAkBzY,EAAW0B,EAASkG,GAI3Cxe,KAAKsvB,UAAU1Y,EAAW0B,EAASkG,EAAiBje,GAGnE,KAAK,EACD,OAAa,IAAT6uB,EAEOpvB,KAAKuvB,mBAAmB3Y,EAAW0B,EAASkG,GAI5Cxe,KAAKwvB,WAAW5Y,EAAW0B,EAASkG,EAAiBje,GAGpE,KAAK,EACD,OAAa,IAAT6uB,EAEOpvB,KAAKyvB,mBAAmB7Y,EAAW0B,EAASkG,EAAiBje,GAI7DP,KAAK0vB,oBAAoB9Y,EAAW0B,EAASkG,EAAiBje,GAG7E,KAAK,EACD,OAAa,IAAT6uB,EAEOpvB,KAAK2vB,qBAAqB/Y,EAAW0B,EAASkG,EAAiBje,GAI/DP,KAAK4vB,sBAAsBhZ,EAAW0B,EAASkG,EAAiBje,GAG/E,KAAK,EACD,OAAa,IAAT6uB,EACO9W,EAAQM,KAAI,SAAAmM,GAAM,OAAIvO,EAAAA,GAAAA,cAA0B8U,EAAAA,EAAAA,oBAAmC1U,EAAU6D,aAAc7D,EAAWmO,EAAOtO,UAAW+H,GAAtH,IAGlBlG,EAAQM,KAAI,SAAAmM,GAAM,OAAIvO,EAAAA,GAAAA,eAA2B8U,EAAAA,EAAAA,oBAAmC1U,EAAU6D,aAAc7D,EAAUR,MAAO2O,EAAOzO,WAAYkI,GAA9H,IAGjC,KAAK,EACD,OAAa,IAAT4Q,EACO9W,EAAQM,KAAI,SAAAmM,GAAM,OAAIvO,EAAAA,GAAAA,cAA0B8U,EAAAA,EAAAA,oBAAmC1U,EAAU6D,aAAc7D,EAAWmO,EAAOtO,UAAW+H,GAAtH,IAGlBlG,EAAQM,KAAI,SAAAmM,GAAM,OAAIvO,EAAAA,GAAAA,eAA2B8U,EAAAA,EAAAA,oBAAmC1U,EAAU6D,aAAc7D,EAAUR,MAAO2O,EAAOzO,WAAYkI,GAA9H,IAGjC,KAAK,EAED,OAAOxe,KAAK6vB,qBAAqBjZ,EAAW0B,EAASkG,GAEzD,KAAK,EAED,OAAOxe,KAAK8vB,oCAAoClZ,EAAW0B,EAASkG,GAExE,KAAK,EAED,OAAOxe,KAAK+vB,wBAAwBnZ,EAAW0B,EAASkG,GAE5D,KAAK,EAED,OAAOxe,KAAKgwB,qBAAqBpZ,EAAW0B,EAASkG,GAEzD,KAAK,GAED,OAAOxe,KAAKiwB,mCAAmCrZ,EAAW0B,EAASkG,GAEvE,QACI,OAAO,KAElB,GAvQL,0BAwQI,SAAoB5H,EAAW0B,EAASxL,EAAW0R,EAAiBje,GAChE,IAAM2vB,EAAmBtZ,EAAUuZ,gCAC7BC,EAAoBxZ,EAAUM,qBAAqBC,6BAA6B+Y,GACtF,OAAQpjB,GACJ,KAAK,GAED,IAAMujB,EAAkBrwB,KAAKswB,wBAAwB1Z,EAAUR,MAAOga,EAAmB7vB,GACnFgwB,EAAc3Z,EAAUR,MAAMwX,gCAAgCyC,GACpE,MAAO,CAACrwB,KAAKwwB,qBAAqB5Z,EAAW0B,EAAQ,GAAIkG,EAAiB6R,EAAiBE,IAE/F,KAAK,GAED,IAAMF,EAAkBrwB,KAAKywB,uBAAuB7Z,EAAUR,MAAOga,EAAmB7vB,GAClFgwB,EAAc3Z,EAAUR,MAAMwX,gCAAgCyC,GACpE,MAAO,CAACrwB,KAAKwwB,qBAAqB5Z,EAAW0B,EAAQ,GAAIkG,EAAiB6R,EAAiBE,IAE/F,KAAK,GAED,IAAMF,EAAkB7uB,KAAKkvB,OAAON,EAAkBpmB,gBAAkBomB,EAAkBlmB,eAAiB,GACrGqmB,EAAc3Z,EAAUR,MAAMwX,gCAAgCyC,GACpE,MAAO,CAACrwB,KAAKwwB,qBAAqB5Z,EAAW0B,EAAQ,GAAIkG,EAAiB6R,EAAiBE,IAE/F,KAAK,GAGD,IADA,IAAMzuB,EAAS,GACNlB,EAAI,EAAGwH,EAAMkQ,EAAQ5W,OAAQd,EAAIwH,EAAKxH,IAAK,CAChD,IAAMmkB,EAASzM,EAAQ1X,GACvBkB,EAAOlB,GAAKZ,KAAK2wB,gCAAgC/Z,EAAWmO,EAAQmL,EAAkB1R,EACzF,CACD,OAAO1c,EAEX,QACI,OAAO,KAElB,GA1SL,6CA2SI,SAAuC8U,EAAWmO,EAAQmL,EAAkB1R,GACxE,IAMQoS,EANFC,EAAiB9L,EAAOtO,UAAU9T,SAASG,WACjD,GAAIotB,EAAiBlmB,iBAAmB6mB,GAAkBA,GAAkBX,EAAiBhmB,cAAgB,EAEzG,OAAO,IAAIsM,EAAAA,GAAYuO,EAAOzO,WAAYyO,EAAOtO,WAK7Cma,EADAC,EAAiBX,EAAiBhmB,cAAgB,EAC9BgmB,EAAiBhmB,cAAgB,EAEhD2mB,EAAiBX,EAAiBlmB,gBACnBkmB,EAAiBlmB,gBAGjB6mB,EAExB,IAAMluB,EAAW2oB,EAAAA,EAAAA,SAAwB1U,EAAU6D,aAAc7D,EAAWia,EAAgB9L,EAAOtO,UAAU9T,SAASrB,OAAQyjB,EAAOtO,UAAUQ,uBAAwB2Z,GAAmB,GAC1L,OAAOpa,EAAAA,GAAAA,cAA0BuO,EAAOtO,UAAUsY,KAAKvQ,EAAiB7b,EAASG,WAAYH,EAASrB,OAAQqB,EAASsU,wBAE9H,GA/TL,qCAmUI,SAA+Bb,EAAOxT,EAAOkuB,GACzC,IAAI9mB,EAAkBpH,EAAMoH,gBAK5B,OAJIpH,EAAMqH,cAAgBmM,EAAM2a,iBAAiB/mB,IAE7CA,IAEGxI,KAAKC,IAAImB,EAAMsH,cAAeF,EAAkB8mB,EAAQ,EAClE,GA1UL,oCA8UI,SAA8B1a,EAAOxT,EAAOkuB,GACxC,IAAI9mB,EAAkBpH,EAAMoH,gBAK5B,OAJIpH,EAAMqH,cAAgBmM,EAAM2a,iBAAiB/mB,IAE7CA,IAEGxI,KAAKiB,IAAIuH,EAAiBpH,EAAMsH,cAAgB4mB,EAAQ,EAClE,GArVL,uBAsVI,SAAiBla,EAAW0B,EAASkG,EAAiBwS,GAClD,OAAO1Y,EAAQM,KAAI,SAAAmM,GAAM,OAAIvO,EAAAA,GAAAA,cAA0B8U,EAAAA,EAAAA,SAAwB1U,EAAU6D,aAAc7D,EAAWmO,EAAOtO,UAAW+H,EAAiBwS,GAA5H,GAC5B,GAxVL,+BAyVI,SAAyBpa,EAAW0B,EAASkG,GAEzC,IADA,IAAM1c,EAAS,GACNlB,EAAI,EAAGwH,EAAMkQ,EAAQ5W,OAAQd,EAAIwH,EAAKxH,IAAK,CAChD,IAAMmkB,EAASzM,EAAQ1X,GACjBiwB,EAAiB9L,EAAOtO,UAAU9T,SAASG,WAC3CmuB,EAAWzvB,KAAKkvB,MAAM9Z,EAAUiV,eAAegF,GAAgBnvB,OAAS,GAC9EI,EAAOlB,GAAK4V,EAAAA,GAAAA,cAA0B8U,EAAAA,EAAAA,SAAwB1U,EAAU6D,aAAc7D,EAAWmO,EAAOtO,UAAW+H,EAAiByS,GACvI,CACD,OAAOnvB,CACV,GAlWL,wBAmWI,SAAkB8U,EAAW0B,EAASkG,EAAiBwS,GACnD,OAAO1Y,EAAQM,KAAI,SAAAmM,GAAM,OAAIvO,EAAAA,GAAAA,cAA0B8U,EAAAA,EAAAA,UAAyB1U,EAAU6D,aAAc7D,EAAWmO,EAAOtO,UAAW+H,EAAiBwS,GAA7H,GAC5B,GArWL,gCAsWI,SAA0Bpa,EAAW0B,EAASkG,GAE1C,IADA,IAAM1c,EAAS,GACNlB,EAAI,EAAGwH,EAAMkQ,EAAQ5W,OAAQd,EAAIwH,EAAKxH,IAAK,CAChD,IAAMmkB,EAASzM,EAAQ1X,GACjBiwB,EAAiB9L,EAAOtO,UAAU9T,SAASG,WAC3CmuB,EAAWzvB,KAAKkvB,MAAM9Z,EAAUiV,eAAegF,GAAgBnvB,OAAS,GAC9EI,EAAOlB,GAAK4V,EAAAA,GAAAA,cAA0B8U,EAAAA,EAAAA,UAAyB1U,EAAU6D,aAAc7D,EAAWmO,EAAOtO,UAAW+H,EAAiByS,GACxI,CACD,OAAOnvB,CACV,GA/WL,kCAgXI,SAA4B8U,EAAW0B,EAASkG,EAAiBwM,GAE7D,IADA,IAAMlpB,EAAS,GACNlB,EAAI,EAAGwH,EAAMkQ,EAAQ5W,OAAQd,EAAIwH,EAAKxH,IAAK,CAChD,IAAMmkB,EAASzM,EAAQ1X,GACvBkB,EAAOlB,GAAK4V,EAAAA,GAAAA,cAA0B8U,EAAAA,EAAAA,SAAwB1U,EAAU6D,aAAc7D,EAAWmO,EAAOtO,UAAW+H,EAAiBwM,GACvI,CACD,OAAOlpB,CACV,GAvXL,mCAwXI,SAA6B8U,EAAW0B,EAASkG,EAAiBwM,GAE9D,IADA,IAAMlpB,EAAS,GACNlB,EAAI,EAAGwH,EAAMkQ,EAAQ5W,OAAQd,EAAIwH,EAAKxH,IAAK,CAChD,IAAMmkB,EAASzM,EAAQ1X,GACvBkB,EAAOlB,GAAK4V,EAAAA,GAAAA,eAA2B8U,EAAAA,EAAAA,SAAwB1U,EAAU6D,aAAc7D,EAAUR,MAAO2O,EAAOzO,WAAYkI,EAAiBwM,GAC/I,CACD,OAAOlpB,CACV,GA/XL,gCAgYI,SAA0B8U,EAAW0B,EAASkG,EAAiBwM,GAE3D,IADA,IAAMlpB,EAAS,GACNlB,EAAI,EAAGwH,EAAMkQ,EAAQ5W,OAAQd,EAAIwH,EAAKxH,IAAK,CAChD,IAAMmkB,EAASzM,EAAQ1X,GACvBkB,EAAOlB,GAAK4V,EAAAA,GAAAA,cAA0B8U,EAAAA,EAAAA,OAAsB1U,EAAU6D,aAAc7D,EAAWmO,EAAOtO,UAAW+H,EAAiBwM,GACrI,CACD,OAAOlpB,CACV,GAvYL,iCAwYI,SAA2B8U,EAAW0B,EAASkG,EAAiBwM,GAE5D,IADA,IAAMlpB,EAAS,GACNlB,EAAI,EAAGwH,EAAMkQ,EAAQ5W,OAAQd,EAAIwH,EAAKxH,IAAK,CAChD,IAAMmkB,EAASzM,EAAQ1X,GACvBkB,EAAOlB,GAAK4V,EAAAA,GAAAA,eAA2B8U,EAAAA,EAAAA,OAAsB1U,EAAU6D,aAAc7D,EAAUR,MAAO2O,EAAOzO,WAAYkI,EAAiBwM,GAC7I,CACD,OAAOlpB,CACV,GA/YL,iCAgZI,SAA2B8U,EAAWmO,EAAQvG,EAAiBoB,EAAkBsR,GAC7E,OAAO1a,EAAAA,GAAAA,cAA0BuO,EAAOtO,UAAUsY,KAAKvQ,EAAiBoB,EAAkBsR,EAAc,GAC3G,GAlZL,kCAmZI,SAA4Bta,EAAWmO,EAAQvG,EAAiB2S,EAAmBC,GAC/E,OAAO5a,EAAAA,GAAAA,eAA2BuO,EAAOzO,WAAWyY,KAAKvQ,EAAiB2S,EAAmBC,EAAe,GAC/G,GArZL,kCAsZI,SAA4Bxa,EAAW0B,EAASkG,GAE5C,IADA,IAAM1c,EAAS,GACNlB,EAAI,EAAGwH,EAAMkQ,EAAQ5W,OAAQd,EAAIwH,EAAKxH,IAAK,CAChD,IAAMmkB,EAASzM,EAAQ1X,GACjBiwB,EAAiB9L,EAAOtO,UAAU9T,SAASG,WAC3CuuB,EAAaza,EAAUma,iBAAiBF,GAC9C/uB,EAAOlB,GAAKZ,KAAKsxB,oBAAoB1a,EAAWmO,EAAQvG,EAAiBqS,EAAgBQ,EAC5F,CACD,OAAOvvB,CACV,GA/ZL,iDAgaI,SAA2C8U,EAAW0B,EAASkG,GAE3D,IADA,IAAM1c,EAAS,GACNlB,EAAI,EAAGwH,EAAMkQ,EAAQ5W,OAAQd,EAAIwH,EAAKxH,IAAK,CAChD,IAAMmkB,EAASzM,EAAQ1X,GACjBiwB,EAAiB9L,EAAOtO,UAAU9T,SAASG,WAC3CuuB,EAAaza,EAAUgX,gCAAgCiD,GAC7D/uB,EAAOlB,GAAKZ,KAAKsxB,oBAAoB1a,EAAWmO,EAAQvG,EAAiBqS,EAAgBQ,EAC5F,CACD,OAAOvvB,CACV,GAzaL,qCA0aI,SAA+B8U,EAAW0B,EAASkG,GAE/C,IADA,IAAM1c,EAAS,GACNlB,EAAI,EAAGwH,EAAMkQ,EAAQ5W,OAAQd,EAAIwH,EAAKxH,IAAK,CAChD,IAAMmkB,EAASzM,EAAQ1X,GACjBiwB,EAAiB9L,EAAOtO,UAAU9T,SAASG,WAC3CuuB,EAAa7vB,KAAKkvB,OAAO9Z,EAAU4R,iBAAiBqI,GAAkBja,EAAUma,iBAAiBF,IAAmB,GAC1H/uB,EAAOlB,GAAKZ,KAAKsxB,oBAAoB1a,EAAWmO,EAAQvG,EAAiBqS,EAAgBQ,EAC5F,CACD,OAAOvvB,CACV,GAnbL,kCAobI,SAA4B8U,EAAW0B,EAASkG,GAE5C,IADA,IAAM1c,EAAS,GACNlB,EAAI,EAAGwH,EAAMkQ,EAAQ5W,OAAQd,EAAIwH,EAAKxH,IAAK,CAChD,IAAMmkB,EAASzM,EAAQ1X,GACjBiwB,EAAiB9L,EAAOtO,UAAU9T,SAASG,WAC3CuuB,EAAaza,EAAU4R,iBAAiBqI,GAC9C/uB,EAAOlB,GAAKZ,KAAKsxB,oBAAoB1a,EAAWmO,EAAQvG,EAAiBqS,EAAgBQ,EAC5F,CACD,OAAOvvB,CACV,GA7bL,gDA8bI,SAA0C8U,EAAW0B,EAASkG,GAE1D,IADA,IAAM1c,EAAS,GACNlB,EAAI,EAAGwH,EAAMkQ,EAAQ5W,OAAQd,EAAIwH,EAAKxH,IAAK,CAChD,IAAMmkB,EAASzM,EAAQ1X,GACjBiwB,EAAiB9L,EAAOtO,UAAU9T,SAASG,WAC3CuuB,EAAaza,EAAU2a,+BAA+BV,GAC5D/uB,EAAOlB,GAAKZ,KAAKsxB,oBAAoB1a,EAAWmO,EAAQvG,EAAiBqS,EAAgBQ,EAC5F,CACD,OAAOvvB,CACV,KAvcL,MA0cA,SAAWsrB,GAoBPA,EAAWjN,YAAc,CACrBA,YAAa,gDACbqR,KAAM,CACF,CACIC,KAAM,8BACNtR,YAAa,s0BAebuR,WAvCa,SAAUC,GAC/B,IAAKC,EAAAA,GAAeD,GAChB,OAAO,EAEX,IAAME,EAAgBF,EACtB,QAAKC,EAAAA,GAAeC,EAAcC,SAG7BF,EAAAA,GAAkBC,EAAcE,UAAYH,EAAAA,GAAgBC,EAAcE,cAG1EH,EAAAA,GAAkBC,EAAcG,MAAQJ,EAAAA,GAAeC,EAAcG,SAGrEJ,EAAAA,GAAkBC,EAActxB,SAAWqxB,EAAAA,GAAeC,EAActxB,SAIhF,EAsBW0xB,OAAQ,CACJ,KAAQ,SACR,SAAY,CAAC,MACb,WAAc,CACV,GAAM,CACF,KAAQ,SACR,KAAQ,CAAC,OAAQ,QAAS,KAAM,OAAQ,gBAAiB,gBAAiB,mBAAoB,iBAAkB,0BAA2B,yCAA0C,wCAAyC,cAAe,iBAAkB,iBAAkB,sBAErR,GAAM,CACF,KAAQ,SACR,KAAQ,CAAC,OAAQ,cAAe,YAAa,aAEjD,MAAS,CACL,KAAQ,SACR,QAAW,GAEf,OAAU,CACN,KAAQ,UACR,SAAW,QAUnC7E,EAAW8E,aAAe,CACtBC,KAAM,OACNC,MAAO,QACPC,GAAI,KACJC,KAAM,OACNC,cAAe,gBACfC,cAAe,gBACfC,iBAAkB,mBAClBC,uCAAwC,yCACxCC,wBAAyB,0BACzBC,eAAgB,iBAChBC,sCAAuC,wCACvCC,YAAa,cACbC,eAAgB,iBAChBC,eAAgB,iBAChBC,kBAAmB,qBAKvB7F,EAAW8F,QAAU,CACjBC,KAAM,OACNC,YAAa,cACbC,UAAW,YACXC,SAAU,YAgFdlG,EAAWmG,MA9EX,SAAe/B,GACX,IAAKA,EAAKM,GAEN,OAAO,KAEX,IAAIhlB,EACJ,OAAQ0kB,EAAKM,IACT,KAAK1E,EAAW8E,aAAaC,KACzBrlB,EAAY,EACZ,MACJ,KAAKsgB,EAAW8E,aAAaE,MACzBtlB,EAAY,EACZ,MACJ,KAAKsgB,EAAW8E,aAAaG,GACzBvlB,EAAY,EACZ,MACJ,KAAKsgB,EAAW8E,aAAaI,KACzBxlB,EAAY,EACZ,MACJ,KAAKsgB,EAAW8E,aAAaK,cACzBzlB,EAAY,EACZ,MACJ,KAAKsgB,EAAW8E,aAAaM,cACzB1lB,EAAY,EACZ,MACJ,KAAKsgB,EAAW8E,aAAaO,iBACzB3lB,EAAY,EACZ,MACJ,KAAKsgB,EAAW8E,aAAaQ,uCACzB5lB,EAAY,EACZ,MACJ,KAAKsgB,EAAW8E,aAAaS,wBACzB7lB,EAAY,EACZ,MACJ,KAAKsgB,EAAW8E,aAAaU,eACzB9lB,EAAY,EACZ,MACJ,KAAKsgB,EAAW8E,aAAaW,sCACzB/lB,EAAY,GACZ,MACJ,KAAKsgB,EAAW8E,aAAaY,YACzBhmB,EAAY,GACZ,MACJ,KAAKsgB,EAAW8E,aAAac,eACzBlmB,EAAY,GACZ,MACJ,KAAKsgB,EAAW8E,aAAaa,eACzBjmB,EAAY,GACZ,MACJ,KAAKsgB,EAAW8E,aAAae,kBACzBnmB,EAAY,GACZ,MACJ,QAEI,OAAO,KAEf,IAAIsiB,EAAO,EACX,OAAQoC,EAAKQ,IACT,KAAK5E,EAAW8F,QAAQC,KACpB/D,EAAO,EACP,MACJ,KAAKhC,EAAW8F,QAAQE,YACpBhE,EAAO,EACP,MACJ,KAAKhC,EAAW8F,QAAQG,UACpBjE,EAAO,EACP,MACJ,KAAKhC,EAAW8F,QAAQI,SACpBlE,EAAO,EAGf,MAAO,CACHtiB,UAAWA,EACXsiB,KAAMA,EACN2C,SAAWP,EAAKO,OAChBxxB,MAAQixB,EAAKjxB,OAAS,EAE7B,CA5KL,EA8KG6sB,IAAeA,EAAa,CAAC,G,oJCxnBnBoG,GAAb,QACI,WAAY1wB,EAAYxB,EAAQ2V,IAAwB,eACpDjX,KAAKyzB,0BAAuBtnB,EAC5BnM,KAAK8C,WAAaA,EAClB9C,KAAKsB,OAASA,EACdtB,KAAKiX,uBAAyBA,CACjC,IAEQqU,EAAb,wFACI,SAAoBlV,EAAOzT,GACvB,GAAIA,EAASrB,OAAS8U,EAAM2a,iBAAiBpuB,EAASG,YAClD,OAAOH,EAAS+wB,WAAMvnB,GAAY/K,EAAAA,GAAuBgV,EAAMyV,eAAelpB,EAASG,YAAaH,EAASrB,OAAS,IAErH,GAAIqB,EAASG,WAAa,EAAG,CAC9B,IAAMmG,EAAgBtG,EAASG,WAAa,EAC5C,OAAO,IAAIkG,EAAAA,EAASC,EAAemN,EAAMoS,iBAAiBvf,GAC7D,CAEG,OAAOtG,CAEd,GAZL,wCAaI,SAAkCyT,EAAOzT,EAAUzB,GAC/C,GAAIyB,EAASrB,QAAU8U,EAAMud,oBAAoBhxB,EAASG,YAAa,CACnE,IAAM8wB,EAAYxd,EAAM2a,iBAAiBpuB,EAASG,YAC5CzB,EAAc+U,EAAMyV,eAAelpB,EAASG,YAC5CyM,EAAcwZ,EAAAA,EAAAA,eAAuC1nB,EAAasB,EAASrB,OAAS,EAAGJ,EAAS,GACtG,IAAqB,IAAjBqO,GAAsBA,EAAc,GAAKqkB,EACzC,OAAO,IAAI5qB,EAAAA,EAASrG,EAASG,WAAYyM,EAAc,EAE9D,CACD,OAAOvP,KAAK6zB,aAAazd,EAAOzT,EACnC,GAvBL,kBAwBI,SAAYmS,EAAQsB,EAAOzT,GACvB,IAAMmH,EAAMgL,EAAOgf,eACbxI,EAAeyI,2BAA2B3d,EAAOzT,EAAUmS,EAAO5T,SAClEoqB,EAAeuI,aAAazd,EAAOzT,GACzC,OAAO,IAAI6wB,EAAe1pB,EAAIhH,WAAYgH,EAAIxI,OAAQ,EACzD,GA7BL,sBAkCI,SAAgBwT,EAAQsB,EAAO2O,EAAQvG,EAAiBwS,GACpD,IAAIluB,EAAYxB,EAChB,GAAIyjB,EAAO4J,iBAAmBnQ,EAG1B1b,EAAaiiB,EAAOxO,UAAUvM,gBAC9B1I,EAASyjB,EAAOxO,UAAUtM,gBAEzB,CAGD,IAAMH,EAAMib,EAAOpiB,SAAS+wB,WAAMvnB,IAAa6kB,EAAc,IAGvDgD,EAAgB5d,EAAM0B,kBAAkBwT,EAAe2I,mBAAmBnqB,EAAKsM,GAAQ,GACvF8d,EAAI5I,EAAenC,KAAKrU,EAAQsB,EAAO4d,GAC7ClxB,EAAaoxB,EAAEpxB,WACfxB,EAAS4yB,EAAE5yB,MACd,CACD,OAAOyjB,EAAOgK,KAAKvQ,EAAiB1b,EAAYxB,EAAQ,EAC3D,GAtDL,gCA0DI,SAA0BqB,EAAUyT,GAChC,OAAO,IAAIpN,EAAAA,EAASrG,EAASG,WAAYwoB,EAAe6I,UAAUxxB,EAASrB,OAAQ8U,EAAM2a,iBAAiBpuB,EAASG,YAAasT,EAAMoS,iBAAiB7lB,EAASG,aACnK,GA5DL,uBA6DI,SAAiBvC,EAAOkB,EAAKgB,GACzB,OAAIlC,EAAQkB,EACDA,EAEPlB,EAAQkC,EACDA,EAEJlC,CACV,GArEL,2BAsEI,SAAqB6V,EAAOtT,EAAYxB,GAQpC,OAPIA,EAAS8U,EAAMoS,iBAAiB1lB,GAChCxB,GAAkBF,EAAAA,GAAuBgV,EAAMyV,eAAe/oB,GAAaxB,EAAS,GAE/EwB,EAAasT,EAAM8U,iBACxBpoB,GAA0B,EAC1BxB,EAAS8U,EAAM2a,iBAAiBjuB,IAE7B,IAAIkG,EAAAA,EAASlG,EAAYxB,EACnC,GA/EL,yCAgFI,SAAmC8U,EAAOtT,EAAYxB,EAAQJ,EAASsB,GACnE,GAAIlB,EAAS8U,EAAMud,oBAAoB7wB,GAAa,CAChD,IAAMzB,EAAc+U,EAAMyV,eAAe/oB,GACnCyM,EAAcwZ,EAAAA,EAAAA,eAAuC1nB,EAAaC,EAAS,EAAGJ,EAAS,GAC7F,IAAqB,IAAjBqO,EACA,OAAO,IAAIvG,EAAAA,EAASlG,EAAYyM,EAAc,EAErD,CACD,OAAOvP,KAAKo0B,cAAche,EAAOtT,EAAYxB,EAChD,GAzFL,mBA0FI,SAAawT,EAAQsB,EAAOzT,GACxB,IAAMmH,EAAMgL,EAAOgf,eACbxI,EAAe+I,4BAA4Bje,EAAOzT,EAASG,WAAYH,EAASrB,OAAQwT,EAAO5T,QAAS4T,EAAOtS,YAC/G8oB,EAAe8I,cAAche,EAAOzT,EAASG,WAAYH,EAASrB,QACxE,OAAO,IAAIkyB,EAAe1pB,EAAIhH,WAAYgH,EAAIxI,OAAQ,EACzD,GA/FL,uBAgGI,SAAiBwT,EAAQsB,EAAO2O,EAAQvG,EAAiBwS,GACrD,IAAIluB,EAAYxB,EAChB,GAAIyjB,EAAO4J,iBAAmBnQ,EAE1B1b,EAAaiiB,EAAOxO,UAAUrM,cAC9B5I,EAASyjB,EAAOxO,UAAUpM,cAEzB,CACD,IAAML,EAAMib,EAAOpiB,SAAS+wB,WAAMvnB,EAAW6kB,EAAc,GACrDgD,EAAgB5d,EAAM0B,kBAAkBwT,EAAe2I,mBAAmBnqB,EAAKsM,GAAQ,GACvFpK,EAAIsf,EAAegJ,MAAMxf,EAAQsB,EAAO4d,GAC9ClxB,EAAakJ,EAAElJ,WACfxB,EAAS0K,EAAE1K,MACd,CACD,OAAOyjB,EAAOgK,KAAKvQ,EAAiB1b,EAAYxB,EAAQ,EAC3D,GA/GL,sBAgHI,SAAgBwT,EAAQsB,EAAOtT,EAAYxB,EAAQ2V,EAAwBhO,EAAesrB,EAAqBC,GAC3G,IAAMnL,EAAuBtoB,EAAAA,EAAAA,wBAAsCqV,EAAMyV,eAAe/oB,GAAaxB,EAAQwT,EAAO5T,SAAW+V,EACzH2S,EAAYxT,EAAM8U,eAClBuJ,EAAqC,IAAf3xB,GAA+B,IAAXxB,EAC1CozB,EAAqB5xB,IAAe8mB,GAAatoB,IAAW8U,EAAMoS,iBAAiB1lB,GACnF6xB,EAAqB1rB,EAAgBnG,EAAa2xB,EAAqBC,EA6B7E,IA5BA5xB,EAAamG,GACI,GACbnG,EAAa,EAETxB,EADAizB,EACSne,EAAM2a,iBAAiBjuB,GAGvBtB,KAAKC,IAAI2U,EAAMoS,iBAAiB1lB,GAAaxB,IAGrDwB,EAAa8mB,GAClB9mB,EAAa8mB,EAETtoB,EADAizB,EACSne,EAAMoS,iBAAiB1lB,GAGvBtB,KAAKC,IAAI2U,EAAMoS,iBAAiB1lB,GAAaxB,IAI1DA,EAASwT,EAAOmV,wBAAwB7T,EAAOtT,EAAYumB,GAG3DpS,EADA0d,EACyB,EAGAtL,EAAuBtoB,EAAAA,EAAAA,wBAAsCqV,EAAMyV,eAAe/oB,GAAaxB,EAAQwT,EAAO5T,cAE7GiL,IAA1BqoB,EAAqC,CACrC,IAAM7xB,EAAW,IAAIqG,EAAAA,EAASlG,EAAYxB,GACpCiO,EAAc6G,EAAM0B,kBAAkBnV,EAAU6xB,GACtDvd,GAAmD3V,EAASiO,EAAYjO,OACxEwB,EAAayM,EAAYzM,WACzBxB,EAASiO,EAAYjO,MACxB,CACD,OAAO,IAAIkyB,EAAe1wB,EAAYxB,EAAQ2V,EACjD,GA1JL,kBA2JI,SAAYnC,EAAQsB,EAAOtT,EAAYxB,EAAQ2V,EAAwB6Z,EAAO8D,GAC1E,OAAO50B,KAAK60B,SAAS/f,EAAQsB,EAAOtT,EAAYxB,EAAQ2V,EAAwBnU,EAAaguB,EAAO8D,EAAqB,EAC5H,GA7JL,sBA8JI,SAAgB9f,EAAQsB,EAAO2O,EAAQvG,EAAiBwM,GACpD,IAAIloB,EAAYxB,EACZyjB,EAAO4J,iBAAmBnQ,GAE1B1b,EAAaiiB,EAAOxO,UAAUrM,cAC9B5I,EAASyjB,EAAOxO,UAAUpM,YAG1BrH,EAAaiiB,EAAOpiB,SAASG,WAC7BxB,EAASyjB,EAAOpiB,SAASrB,QAE7B,IAAM0K,EAAIsf,EAAewJ,KAAKhgB,EAAQsB,EAAOtT,EAAYxB,EAAQyjB,EAAO9N,uBAAwB+T,GAAY,GAC5G,OAAOjG,EAAOgK,KAAKvQ,EAAiBxS,EAAElJ,WAAYkJ,EAAE1K,OAAQ0K,EAAEiL,uBACjE,GA3KL,2BA4KI,SAAqBnC,EAAQsB,EAAO2O,GAChC,IAAMxO,EAAYwO,EAAOxO,UACnBM,EAAiByU,EAAewJ,KAAKhgB,EAAQsB,EAAOG,EAAU/J,yBAA0B+J,EAAU9J,qBAAsBsY,EAAOhO,qCAAsC,GAAG,GACxKpU,EAAW2oB,EAAewJ,KAAKhgB,EAAQsB,EAAOG,EAAU7J,mBAAoB6J,EAAU5J,eAAgBoY,EAAO9N,uBAAwB,GAAG,GAC9I,OAAO,IAAIhB,EAAAA,GAAkB,IAAIpT,EAAAA,EAAMgU,EAAe/T,WAAY+T,EAAevV,OAAQuV,EAAe/T,WAAY+T,EAAevV,QAASuV,EAAeI,uBAAwB,IAAIjO,EAAAA,EAASrG,EAASG,WAAYH,EAASrB,QAASqB,EAASsU,uBACnP,GAjLL,gBAkLI,SAAUnC,EAAQsB,EAAOtT,EAAYxB,EAAQ2V,EAAwB6Z,EAAOiE,GACxE,OAAO/0B,KAAK60B,SAAS/f,EAAQsB,EAAOtT,EAAYxB,EAAQ2V,EAAwBnU,EAAaguB,EAAOiE,EAAsB,EAC7H,GApLL,oBAqLI,SAAcjgB,EAAQsB,EAAO2O,EAAQvG,EAAiBwM,GAClD,IAAIloB,EAAYxB,EACZyjB,EAAO4J,iBAAmBnQ,GAE1B1b,EAAaiiB,EAAOxO,UAAUvM,gBAC9B1I,EAASyjB,EAAOxO,UAAUtM,cAG1BnH,EAAaiiB,EAAOpiB,SAASG,WAC7BxB,EAASyjB,EAAOpiB,SAASrB,QAE7B,IAAM0K,EAAIsf,EAAe0J,GAAGlgB,EAAQsB,EAAOtT,EAAYxB,EAAQyjB,EAAO9N,uBAAwB+T,GAAY,GAC1G,OAAOjG,EAAOgK,KAAKvQ,EAAiBxS,EAAElJ,WAAYkJ,EAAE1K,OAAQ0K,EAAEiL,uBACjE,GAlML,yBAmMI,SAAmBnC,EAAQsB,EAAO2O,GAC9B,IAAMxO,EAAYwO,EAAOxO,UACnBM,EAAiByU,EAAe0J,GAAGlgB,EAAQsB,EAAOG,EAAU/J,yBAA0B+J,EAAU9J,qBAAsBsY,EAAOhO,qCAAsC,GAAG,GACtKpU,EAAW2oB,EAAe0J,GAAGlgB,EAAQsB,EAAOG,EAAU7J,mBAAoB6J,EAAU5J,eAAgBoY,EAAO9N,uBAAwB,GAAG,GAC5I,OAAO,IAAIhB,EAAAA,GAAkB,IAAIpT,EAAAA,EAAMgU,EAAe/T,WAAY+T,EAAevV,OAAQuV,EAAe/T,WAAY+T,EAAevV,QAASuV,EAAeI,uBAAwB,IAAIjO,EAAAA,EAASrG,EAASG,WAAYH,EAASrB,QAASqB,EAASsU,uBACnP,GAxML,0BAyMI,SAAoBb,EAAOtT,GACvB,OAA0D,IAAtDsT,EAAMwX,gCAAgC9qB,EAK7C,GA/ML,iCAgNI,SAA2BgS,EAAQsB,EAAO2O,EAAQvG,GAG9C,IAFA,IAAI1b,EAAaiiB,EAAOpiB,SAASG,WAE1BA,EAAa,GAAK9C,KAAKi1B,aAAa7e,EAAOtT,IAC9CA,IAGJ,KAAOA,EAAa,IAAM9C,KAAKi1B,aAAa7e,EAAOtT,IAC/CA,IAEJ,OAAOiiB,EAAOgK,KAAKvQ,EAAiB1b,EAAYsT,EAAM2a,iBAAiBjuB,GAAa,EACvF,GA3NL,iCA4NI,SAA2BgS,EAAQsB,EAAO2O,EAAQvG,GAI9C,IAHA,IAAMoL,EAAYxT,EAAM8U,eACpBpoB,EAAaiiB,EAAOpiB,SAASG,WAE1BA,EAAa8mB,GAAa5pB,KAAKi1B,aAAa7e,EAAOtT,IACtDA,IAGJ,KAAOA,EAAa8mB,IAAc5pB,KAAKi1B,aAAa7e,EAAOtT,IACvDA,IAEJ,OAAOiiB,EAAOgK,KAAKvQ,EAAiB1b,EAAYsT,EAAM2a,iBAAiBjuB,GAAa,EACvF,GAxOL,mCAyOI,SAA6BgS,EAAQsB,EAAO2O,EAAQvG,GAChD,IAGIld,EAHEwB,EAAaiiB,EAAOpiB,SAASG,WAC7B8wB,EAAYxd,EAAM2a,iBAAiBjuB,GACnC6qB,EAAsBvX,EAAMwX,gCAAgC9qB,IAAe8wB,EASjF,OALItyB,EAFyByjB,EAAOpiB,SAASrB,SAChBqsB,EAChBiG,EAGAjG,EAEN5I,EAAOgK,KAAKvQ,EAAiB1b,EAAYxB,EAAQ,EAC3D,GAtPL,6BAuPI,SAAuBwT,EAAQsB,EAAO2O,EAAQvG,EAAiBuP,GAC3D,IAAMjrB,EAAaiiB,EAAOpiB,SAASG,WAC7BsnB,EAAYhU,EAAMoS,iBAAiB1lB,GACzC,OAAOiiB,EAAOgK,KAAKvQ,EAAiB1b,EAAYsnB,EAAW2D,EAAS,WAA0C3D,EAAY,EAC7H,GA3PL,qCA4PI,SAA+BtV,EAAQsB,EAAO2O,EAAQvG,GAClD,OAAOuG,EAAOgK,KAAKvQ,EAAiB,EAAG,EAAG,EAC7C,GA9PL,+BA+PI,SAAyB1J,EAAQsB,EAAO2O,EAAQvG,GAC5C,IAAM0W,EAAiB9e,EAAM8U,eACvBiK,EAAa/e,EAAMoS,iBAAiB0M,GAC1C,OAAOnQ,EAAOgK,KAAKvQ,EAAiB0W,EAAgBC,EAAY,EACnE,KAnQL,I,8SCDalR,EAAb,kFACI,SAAcnP,EAAQsB,EAAO8C,GACzB,GAAc,OAAV9C,GAAiC,OAAf8C,EAClB,MAAO,GAGX,IADA,IAAM6H,EAAW,GACRngB,EAAI,EAAGwH,EAAM8Q,EAAWxX,OAAQd,EAAIwH,EAAKxH,IAC9CmgB,EAASngB,GAAK,IAAIw0B,EAAAA,EAAalc,EAAWtY,GAAI,CAC1Cy0B,WAAW,EACXn0B,QAAS4T,EAAO5T,QAChBsB,WAAYsS,EAAOtS,WACnBiG,aAAcqM,EAAOrM,aACrBokB,YAAa/X,EAAO+X,YACpByI,WAAYxgB,EAAOwgB,aAG3B,OAAOvU,CACV,GAjBL,qBAkBI,SAAejM,EAAQsB,EAAO8C,GAE1B,IADA,IAAM6H,EAAW,GACRngB,EAAI,EAAGwH,EAAM8Q,EAAWxX,OAAQd,EAAIwH,EAAKxH,IAC9CmgB,EAASngB,GAAK,IAAIw0B,EAAAA,EAAalc,EAAWtY,GAAI,CAC1Cy0B,WAAW,EACXn0B,QAAS4T,EAAO5T,QAChBsB,WAAYsS,EAAOtS,WACnBiG,aAAcqM,EAAOrM,aACrBokB,YAAa/X,EAAO+X,YACpByI,WAAYxgB,EAAOwgB,aAG3B,OAAOvU,CACV,GA/BL,yBAgCI,SAAmBjM,EAAQygB,EAAazE,GAEpC,OADAA,EAAQA,GAAS,EACVsE,EAAAA,EAAAA,YAAyBG,EAAaA,EAAY7zB,OAASovB,EAAOhc,EAAO5T,QAAS4T,EAAOtS,WAAYsS,EAAOrM,aACtH,GAnCL,2BAoCI,SAAqBqM,EAAQygB,EAAazE,GAEtC,OADAA,EAAQA,GAAS,EACVsE,EAAAA,EAAAA,cAA2BG,EAAaA,EAAY7zB,OAASovB,EAAOhc,EAAO5T,QAAS4T,EAAOtS,WAAYsS,EAAOrM,aACxH,GAvCL,+BAwCI,SAAyBqM,EAAQsB,EAAO8C,EAAYvX,GAEhD,IADA,IAAMof,EAAW,GACRngB,EAAI,EAAGwH,EAAM8Q,EAAWxX,OAAQd,EAAIwH,EAAKxH,IAC9CmgB,EAASngB,GAAK,IAAI2qB,EAAAA,GAAerS,EAAWtY,GAAIe,EAAKf,IAEzD,OAAO,IAAIikB,EAAAA,GAAoB,EAAe9D,EAAU,CACpDJ,8BAA8B,EAC9BW,6BAA6B,GAEpC,GAjDL,0BAkDI,SAAoBxM,EAAQsB,EAAO8C,EAAYvX,EAAM8iB,GAEjD,IADA,IAAM1D,EAAW,GACRngB,EAAI,EAAGwH,EAAM8Q,EAAWxX,OAAQd,EAAIwH,EAAKxH,IAAK,CACnD,IAAM2V,EAAY2C,EAAWtY,GACvB+B,EAAW4T,EAAUiO,cAO3B,GANIC,IAAmBlO,EAAUnM,YAC7Bqa,GAAiB,GAEjBA,GAAkB9iB,EAAKkS,QAAQ,QAAUlS,EAAKD,OAAS,IACvD+iB,GAAiB,GAEjBA,EAAgB,CAEhB,IAAM+Q,EAAgB,IAAI3yB,EAAAA,EAAMF,EAASG,WAAY,EAAGH,EAASG,WAAY,GAC7Eie,EAASngB,GAAK,IAAI60B,EAAAA,GAAqCD,EAAe7zB,EAAM4U,GAAW,EAC1F,MAEGwK,EAASngB,GAAK,IAAI2qB,EAAAA,GAAehV,EAAW5U,EAEnD,CACD,OAAO,IAAIkjB,EAAAA,GAAoB,EAAe9D,EAAU,CACpDJ,8BAA8B,EAC9BW,6BAA6B,GAEpC,GA1EL,uCA2EI,SAAiCxM,EAAQoE,EAAYvX,EAAM8iB,EAAgBC,GACvE,GAAID,EACA,OAAO,KAEX,GAA0B,IAAtBvL,EAAWxX,OACX,OAAO,KAEX,GAAIgjB,GAAmBA,EAAgBhjB,SAAWwX,EAAWxX,OACzD,OAAOgjB,EAEX,GAAgC,WAA5B5P,EAAO4gB,iBAA+B,CAGG,KAArC/zB,EAAK2G,WAAW3G,EAAKD,OAAS,KAC9BC,EAAOA,EAAK2Q,OAAO,EAAG3Q,EAAKD,OAAS,IAGC,KAArCC,EAAK2G,WAAW3G,EAAKD,OAAS,KAC9BC,EAAOA,EAAK2Q,OAAO,EAAG3Q,EAAKD,OAAS,IAExC,IAAMi0B,EAAQv0B,EAAAA,GAAmBO,GACjC,GAAIg0B,EAAMj0B,SAAWwX,EAAWxX,OAC5B,OAAOi0B,CAEd,CACD,OAAO,IACV,GArGL,mBAsGI,SAAa7gB,EAAQsB,EAAO8C,EAAYvX,EAAM8iB,EAAgBC,GAC1D,IAAMkR,EAAmB51B,KAAK61B,0BAA0B/gB,EAAQoE,EAAYvX,EAAM8iB,EAAgBC,GAClG,OAAIkR,GACA1c,EAAaA,EAAWgB,KAAKrX,EAAAA,EAAAA,0BACtB7C,KAAK81B,kBAAkBhhB,EAAQsB,EAAO8C,EAAY0c,IAGlD51B,KAAK+1B,aAAajhB,EAAQsB,EAAO8C,EAAYvX,EAAM8iB,EAEjE,GA/GL,gCAgHI,SAA0B3P,EAAQsB,EAAOtT,GACrC,IAAIkzB,EAAS,KACTT,EAAc,GACZU,EAAuBC,EAAAA,GAAAA,wBAAsDphB,EAAOwgB,WAAYlf,EAAOtT,GAAY,GACzH,GAAImzB,EACAD,EAASC,EAAqBD,OAC9BT,EAAcU,EAAqBV,iBAElC,GAAIzyB,EAAa,EAAG,CACrB,IAAIoyB,EACJ,IAAKA,EAAiBpyB,EAAa,EAAGoyB,GAAkB,EAAGA,IAAkB,CACzE,IAAMtJ,EAAWxV,EAAMyV,eAAeqJ,GAEtC,GADyB9zB,EAAAA,GAA+BwqB,IAChC,EACpB,KAEP,CACD,GAAIsJ,EAAiB,EAEjB,OAAO,KAEX,IAAM9K,EAAYhU,EAAMoS,iBAAiB0M,GACnCiB,EAAsBD,EAAAA,GAAAA,eAA6CphB,EAAOwgB,WAAYlf,EAAO,IAAIvT,EAAAA,EAAMqyB,EAAgB9K,EAAW8K,EAAgB9K,IACpJ+L,IACAZ,EAAcY,EAAoBZ,YAAcY,EAAoBC,WAE3E,CAUD,OATIJ,IACIA,IAAWK,EAAAA,GAAAA,SACXd,EAActR,EAAeqS,YAAYxhB,EAAQygB,IAEjDS,IAAWK,EAAAA,GAAAA,UACXd,EAActR,EAAesS,cAAczhB,EAAQygB,IAEvDA,EAAczgB,EAAOvM,qBAAqBgtB,IAEzCA,GACM,IAGd,GAxJL,sCAyJI,SAAgCzgB,EAAQsB,EAAOG,EAAW0R,GACtD,IAAIuO,EAAW,GACT7zB,EAAW4T,EAAU3L,mBAC3B,GAAIkK,EAAOrM,aAIP,IAHA,IAAMkX,EAA0B7K,EAAO6K,wBAAwBvJ,EAAOzT,GAChEH,EAAasS,EAAOtS,WACpBmG,EAAYnG,EAAcmd,EAA0Bnd,EACjD5B,EAAI,EAAGA,EAAI+H,EAAW/H,IAC3B41B,GAAY,SAIhBA,EAAW,KAEf,OAAO,IAAIjL,EAAAA,GAAehV,EAAWigB,EAAUvO,EAClD,GAxKL,iBAyKI,SAAWnT,EAAQsB,EAAO8C,GAEtB,IADA,IAAM6H,EAAW,GACRngB,EAAI,EAAGwH,EAAM8Q,EAAWxX,OAAQd,EAAIwH,EAAKxH,IAAK,CACnD,IAAM2V,EAAY2C,EAAWtY,GAC7B,GAAI2V,EAAUnM,UAAW,CACrB,IAAMwhB,EAAWxV,EAAMyV,eAAetV,EAAUvM,iBAChD,GAAI,QAAQysB,KAAK7K,IAAaxV,EAAMsgB,kBAAkBngB,EAAUvM,iBAAkB,CAC9E,IAAI2sB,EAAa32B,KAAK42B,mBAAmB9hB,EAAQsB,EAAOG,EAAUvM,iBAClE2sB,EAAaA,GAAc,KAC3B,IAAME,EAAmB/hB,EAAOvM,qBAAqBouB,GACrD,IAAK/K,EAASkL,WAAWD,GAAmB,CACxC9V,EAASngB,GAAK,IAAI2qB,EAAAA,GAAe,IAAI1oB,EAAAA,EAAM0T,EAAUvM,gBAAiB,EAAGuM,EAAUvM,gBAAiB4hB,EAASlqB,OAAS,GAAIm1B,GAAkB,GAC5I,QACH,CACJ,CACD9V,EAASngB,GAAKZ,KAAK+2B,yBAAyBjiB,EAAQsB,EAAOG,GAAW,EACzE,KACI,CACD,GAAIA,EAAUvM,kBAAoBuM,EAAUrM,cAAe,CACvD,IAAM8sB,EAAgB5gB,EAAMoS,iBAAiBjS,EAAUvM,iBACvD,GAA8B,IAA1BuM,EAAUtM,aAAqBsM,EAAUpM,YAAc6sB,EAAe,CAEtEjW,EAASngB,GAAKZ,KAAK+2B,yBAAyBjiB,EAAQsB,EAAOG,GAAW,GACtE,QACH,CACJ,CACDwK,EAASngB,GAAK,IAAIw0B,EAAAA,EAAa7e,EAAW,CACtC8e,WAAW,EACXn0B,QAAS4T,EAAO5T,QAChBsB,WAAYsS,EAAOtS,WACnBiG,aAAcqM,EAAOrM,aACrBokB,YAAa/X,EAAO+X,YACpByI,WAAYxgB,EAAOwgB,YAE1B,CACJ,CACD,OAAOvU,CACV,GA9ML,6BA+MI,SAAuBoK,EAAuBrW,EAAQsB,EAAO8C,EAAYvX,EAAMyiB,EAAoBC,EAAoBC,GAAe,WAC5HvD,EAAW7H,EAAWN,KAAI,SAAArC,GAAS,OAAI,EAAK0gB,iBAAiB7gB,EAAOG,EAAW5U,EAAMyiB,EAAoBC,EAAoBC,EAA1F,IACzC,OAAO,IAAIO,EAAAA,GAAoB,EAAqB9D,EAAU,CAC1DJ,6BAA8BuW,EAA8B/L,EAAuB,GACnF7J,6BAA6B,GAEpC,GArNL,8BAsNI,SAAwBlL,EAAOG,EAAW5U,EAAMyiB,EAAoBC,EAAoBC,GACpF,IAAK/N,EAAUnM,UAIX,OAAO,KAEX,IAAMN,EAAMyM,EAAUiO,cAChBva,EAAczI,KAAKiB,IAAI,EAAGqH,EAAIxI,OAAS8iB,GACvCja,EAAY3I,KAAKC,IAAI2U,EAAMoS,iBAAiB1e,EAAIhH,YAAagH,EAAIxI,OAAS+iB,GAC1EzhB,EAAQ,IAAIC,EAAAA,EAAMiH,EAAIhH,WAAYmH,EAAaH,EAAIhH,WAAYqH,GAErE,OADgBiM,EAAM+gB,gBAAgBv0B,KACtBjB,GAA0B,IAAlB2iB,EAEb,KAEJ,IAAI8S,EAAAA,GAAoCx0B,EAAOjB,EAAM,EAAG2iB,EAClE,GAvOL,0BAwOI,SAAoB1hB,EAAOjB,EAAM01B,GAC7B,OAAIA,EACO,IAAIC,EAAAA,GAAsC10B,EAAOjB,GAAM,GAGvD,IAAI4pB,EAAAA,GAAe3oB,EAAOjB,GAAM,EAE9C,GA/OL,oBAgPI,SAAcmT,EAAQsB,EAAOihB,EAAcz0B,GACvC,GAA0B,IAAtBkS,EAAOwgB,WACP,OAAOrR,EAAesT,aAAa30B,EAAO,KAAMy0B,GAEpD,IAAKjhB,EAAMsgB,kBAAkB9zB,EAAMgI,mBAAmB9H,aAAqC,IAAtBgS,EAAOwgB,WAA6B,CACrG,IAAM1J,EAAWxV,EAAMyV,eAAejpB,EAAMoH,iBACtCurB,EAAcn0B,EAAAA,GAA6BwqB,GAAUhqB,UAAU,EAAGgB,EAAMqH,YAAc,GAC5F,OAAOga,EAAesT,aAAa30B,EAAO,KAAOkS,EAAOvM,qBAAqBgtB,GAAc8B,EAC9F,CACD,IAAMrrB,EAAIkqB,EAAAA,GAAAA,eAA6CphB,EAAOwgB,WAAYlf,EAAOxT,GACjF,GAAIoJ,EAAG,CACH,GAAIA,EAAEwrB,eAAiBnB,EAAAA,GAAAA,KAEnB,OAAOpS,EAAesT,aAAa30B,EAAO,KAAOkS,EAAOvM,qBAAqByD,EAAEupB,YAAcvpB,EAAEoqB,YAAaiB,GAE3G,GAAIrrB,EAAEwrB,eAAiBnB,EAAAA,GAAAA,OAExB,OAAOpS,EAAesT,aAAa30B,EAAO,KAAOkS,EAAOvM,qBAAqByD,EAAEupB,YAAcvpB,EAAEoqB,YAAaiB,GAE3G,GAAIrrB,EAAEwrB,eAAiBnB,EAAAA,GAAAA,cAA4B,CAEpD,IAAMoB,EAAe3iB,EAAOvM,qBAAqByD,EAAEupB,aAC7CmC,EAAkB5iB,EAAOvM,qBAAqByD,EAAEupB,YAAcvpB,EAAEoqB,YAChEI,EAAW,KAAOkB,EAAkB,KAAOD,EACjD,OAAIJ,EACO,IAAIC,EAAAA,GAAsC10B,EAAO4zB,GAAU,GAG3D,IAAIY,EAAAA,GAAoCx0B,EAAO4zB,GAAW,EAAGkB,EAAgBh2B,OAAS+1B,EAAa/1B,QAAQ,EAEzH,CACI,GAAIsK,EAAEwrB,eAAiBnB,EAAAA,GAAAA,QAAsB,CAC9C,IAAMsB,EAAoB1T,EAAesS,cAAczhB,EAAQ9I,EAAEupB,aACjE,OAAOtR,EAAesT,aAAa30B,EAAO,KAAOkS,EAAOvM,qBAAqBovB,EAAoB3rB,EAAEoqB,YAAaiB,EACnH,CACJ,CACD,IAAMzL,EAAWxV,EAAMyV,eAAejpB,EAAMoH,iBACtCurB,EAAcn0B,EAAAA,GAA6BwqB,GAAUhqB,UAAU,EAAGgB,EAAMqH,YAAc,GAC5F,GAAI6K,EAAOwgB,YAAc,EAAc,CACnC,IAAMsC,EAAK1B,EAAAA,GAAAA,kBAAgDphB,EAAOwgB,WAAYlf,EAAOxT,EAAO,CACxF2zB,cAAe,SAACsB,GACZ,OAAO5T,EAAesS,cAAczhB,EAAQ+iB,EAC/C,EACDvB,YAAa,SAACuB,GACV,OAAO5T,EAAeqS,YAAYxhB,EAAQ+iB,EAC7C,EACDtvB,qBAAsB,SAACsvB,GACnB,OAAO/iB,EAAOvM,qBAAqBsvB,EACtC,IAEL,GAAID,EAAI,CACJ,IAAIE,EAAmBhjB,EAAO6K,wBAAwBvJ,EAAOxT,EAAM+H,kBAC7DotB,EAAen1B,EAAMuH,UACrB6tB,EAAiB5hB,EAAMyV,eAAejpB,EAAMsH,eAC5C+tB,EAAqB72B,EAAAA,GAAgC42B,GAO3D,GALIp1B,EADAq1B,GAAsB,EACdr1B,EAAMs1B,eAAet1B,EAAMsH,cAAe1I,KAAKiB,IAAIG,EAAMuH,UAAW8tB,EAAqB,IAGzFr1B,EAAMs1B,eAAet1B,EAAMsH,cAAekM,EAAMoS,iBAAiB5lB,EAAMsH,gBAE/EmtB,EACA,OAAO,IAAIC,EAAAA,GAAsC10B,EAAO,KAAOkS,EAAOvM,qBAAqBqvB,EAAGO,aAAa,GAG3G,IAAIn2B,EAAS,EAOb,OANI+1B,GAAgBE,EAAqB,IAChCnjB,EAAOrM,eACRqvB,EAAmBt2B,KAAK42B,KAAKN,EAAmBhjB,EAAOtS,aAE3DR,EAASR,KAAKC,IAAIq2B,EAAmB,EAAIhjB,EAAOvM,qBAAqBqvB,EAAGO,YAAYz2B,OAAS,EAAG,IAE7F,IAAI01B,EAAAA,GAAoCx0B,EAAO,KAAOkS,EAAOvM,qBAAqBqvB,EAAGO,YAAa,EAAGn2B,GAAQ,EAE3H,CACJ,CACD,OAAOiiB,EAAesT,aAAa30B,EAAO,KAAOkS,EAAOvM,qBAAqBgtB,GAAc8B,EAC9F,GA7TL,+BA8TI,SAAyBviB,EAAQsB,EAAO8C,GACpC,GAAIpE,EAAOwgB,WAAa,EACpB,OAAO,EAEX,IAAK,IAAI10B,EAAI,EAAGwH,EAAM8Q,EAAWxX,OAAQd,EAAIwH,EAAKxH,IAC9C,IAAKwV,EAAMsgB,kBAAkBxd,EAAWtY,GAAG+J,iBAAiB7H,YACxD,OAAO,EAGf,OAAO,CACV,GAxUL,gCAyUI,SAA0BgS,EAAQsB,EAAOxT,EAAOy1B,GAC5C,IAAMC,EAAqBpC,EAAAA,GAAAA,yBAAuD9f,EAAOxT,EAAMoH,gBAAiBpH,EAAMqH,aAChH0tB,EAAoBzB,EAAAA,GAAAA,uBAAqDphB,EAAOwgB,WAAYlf,EAAOxT,EAAOy1B,EAAI,CAChH/B,YAAa,SAACf,GACV,OAAOtR,EAAeqS,YAAYxhB,EAAQygB,EAC7C,EACDgB,cAAe,SAAChB,GACZ,OAAOtR,EAAesS,cAAczhB,EAAQygB,EAC/C,IAEL,GAA0B,OAAtBoC,EACA,OAAO,KAEX,GAAIA,IAAsB7iB,EAAOvM,qBAAqB+vB,GAAqB,CACvE,IAAML,EAAqB7hB,EAAMwX,gCAAgChrB,EAAMoH,iBACvE,OAA2B,IAAvBiuB,EACOhU,EAAesT,aAAa,IAAI10B,EAAAA,EAAMD,EAAMoH,gBAAiB,EAAGpH,EAAMsH,cAAetH,EAAMuH,WAAY2K,EAAOvM,qBAAqBovB,GAAqBU,GAAI,GAG5JpU,EAAesT,aAAa,IAAI10B,EAAAA,EAAMD,EAAMoH,gBAAiB,EAAGpH,EAAMsH,cAAetH,EAAMuH,WAAY2K,EAAOvM,qBAAqBovB,GACtIvhB,EAAMyV,eAAejpB,EAAMoH,iBAAiBpI,UAAUq2B,EAAqB,EAAGr1B,EAAMqH,YAAc,GAAKouB,GAAI,EAEtH,CACD,OAAO,IACV,GAjWL,oCAkWI,SAA8BvjB,EAAQsB,EAAO8C,EAAYoM,EAAsB+S,GAC3E,GAAmC,UAA/BvjB,EAAOyjB,oBACP,OAAO,EAEX,IAAKzjB,EAAOwN,iBAAiBC,gCAAgCiW,IAAIH,GAC7D,OAAO,EAEX,IAAK,IAAIz3B,EAAI,EAAGwH,EAAM8Q,EAAWxX,OAAQd,EAAIwH,EAAKxH,IAAK,CACnD,IAAM2V,EAAY2C,EAAWtY,GAC7B,IAAK2V,EAAUnM,UACX,OAAO,EAEX,IAAMzH,EAAW4T,EAAUiO,cACrBoH,EAAWxV,EAAMyV,eAAelpB,EAASG,YAE/C,GADuB8oB,EAAShjB,OAAOjG,EAASrB,OAAS,KAClC+2B,EACnB,OAAO,EAGX,IAAMI,GAAYzM,EAAAA,EAAAA,IAAQqM,GAE1B,GAAwB,MADA11B,EAASrB,OAAS,EAAIsqB,EAAStjB,WAAW3F,EAASrB,OAAS,GAAK,IAC3Cm3B,EAC1C,OAAO,EAGX,GAAmC,SAA/B3jB,EAAOyjB,oBAAgC,CAEvC,IADA,IAAIlM,GAAQ,EACHvD,EAAI,EAAGwD,EAAOhH,EAAqB5jB,OAAQonB,EAAIwD,EAAMxD,IAAK,CAC/D,IAAMyD,EAAsBjH,EAAqBwD,GACjD,GAAInmB,EAASG,aAAeypB,EAAoBviB,iBAAmBrH,EAASrB,SAAWirB,EAAoBtiB,YAAa,CACpHoiB,GAAQ,EACR,KACH,CACJ,CACD,IAAKA,EACD,OAAO,CAEd,CACJ,CACD,OAAO,CACV,GA1YL,qCA2YI,SAA+BlB,EAAuBrW,EAAQsB,EAAO8C,EAAYmf,GAE7E,IADA,IAAMtX,EAAW,GACRngB,EAAI,EAAGwH,EAAM8Q,EAAWxX,OAAQd,EAAIwH,EAAKxH,IAAK,CACnD,IACM+B,EADYuW,EAAWtY,GACF4jB,cACrBgR,EAAgB,IAAI3yB,EAAAA,EAAMF,EAASG,WAAYH,EAASrB,OAAQqB,EAASG,WAAYH,EAASrB,OAAS,GAC7Gyf,EAASngB,GAAK,IAAI2qB,EAAAA,GAAeiK,EAAe6C,EACnD,CACD,OAAO,IAAIxT,EAAAA,GAAoB,EAAqB9D,EAAU,CAC1DJ,6BAA8BuW,EAA8B/L,EAAuB,GACnF7J,6BAA6B,GAEpC,GAvZL,mCAwZI,SAA6BxM,EAAQ4jB,GAEjC,IAAMC,EAAWD,EAAU9vB,OAAO,GAC5BgwB,EAA0B9jB,EAAOwN,iBAAiBuW,4BAA4Bp4B,IAAIk4B,IAAa,GAC/FG,EAAyBhkB,EAAOwN,iBAAiByW,6BAA6Bt4B,IAAIk4B,IAAa,GAC/FK,EAAwBJ,EAAwBjX,MAAK,SAAAsX,GAAC,OAAIP,EAAU5B,WAAWmC,EAAExW,KAA3B,IACtDyW,EAAuBJ,EAAuBnX,MAAK,SAAAsX,GAAC,OAAIP,EAAU5B,WAAWmC,EAAE7M,MAA3B,IAC1D,OAAQ4M,GAAyBE,CACpC,GAhaL,sCAyaI,SAAgCpkB,EAAQsB,EAAO+iB,EAAWd,GACtD,IAAMe,EAAatkB,EAAOwN,iBAAiBmK,0BAA0BhsB,IAAI43B,GACzE,IAAKe,EACD,OAAO,KAGX,IAN0D,EAMtDt3B,EAAS,KAN6C,UAOlCs3B,GAPkC,IAO1D,IAAK,EAAL,qBAAoC,KAAzBC,EAAyB,QAChC,GAAe,OAAXv3B,GAAmBu3B,EAAU5W,KAAK/gB,OAASI,EAAO2gB,KAAK/gB,OAAQ,CAC/D,IAD+D,EAC3D43B,GAAmB,EADwC,UAExCH,GAFwC,IAE/D,IAAK,EAAL,qBAAkC,KAAvBx2B,EAAuB,QAE9B,GADqByT,EAAM+gB,gBAAgB,IAAIt0B,EAAAA,EAAMF,EAASG,WAAYH,EAASrB,OAAS+3B,EAAU5W,KAAK/gB,OAAS,EAAGiB,EAASG,WAAYH,EAASrB,SAClI+2B,IAAOgB,EAAU5W,KAAM,CACtC6W,GAAmB,EACnB,KACH,CACJ,CAR8D,+BAS3DA,IACAx3B,EAASu3B,EAEhB,CACJ,CArByD,+BAsB1D,OAAOv3B,CACV,GAhcL,2CAucI,SAAqCgT,EAAQykB,GACzC,GAAIA,EAAK9W,KAAK/gB,QAAU,EACpB,OAAO,KAEX,IAJ+C,EAIzC83B,EAAWD,EAAKnN,MAAMxjB,OAAO2wB,EAAKnN,MAAM1qB,OAAS,GAEjD03B,EAAatkB,EAAOwN,iBAAiBmX,2BAA2Bh5B,IAAI+4B,IAAa,GACnF13B,EAAS,KAPkC,UAQvBs3B,GARuB,IAQ/C,IAAK,EAAL,qBAAoC,KAAzBC,EAAyB,QAC5BA,EAAU5W,OAAS8W,EAAK9W,MAAQ8W,EAAK9W,KAAKiX,SAASL,EAAU5W,OAAS8W,EAAKnN,MAAMuN,SAASN,EAAUjN,UAC/FtqB,GAAUu3B,EAAU5W,KAAK/gB,OAASI,EAAO2gB,KAAK/gB,UAC/CI,EAASu3B,EAGpB,CAd8C,+BAe/C,OAAOv3B,CACV,GAvdL,sCAwdI,SAAgCgT,EAAQsB,EAAO8C,EAAYmf,EAAIuB,GAC3D,IAAMnB,GAAYzM,EAAAA,EAAAA,IAAQqM,GACpBwB,EAAmBpB,EAAY3jB,EAAO4W,kBAAoB5W,EAAO2W,oBACjEqO,EAAyBrB,EAAY3jB,EAAOglB,sBAAsBC,MAAQjlB,EAAOglB,sBAAsBE,QAC7G,GAAwB,UAApBH,EACA,OAAO,KALkE,gBAOrD3gB,GAPqD,IAO7E,IAAK,EAAL,qBAAoC,CAChC,IADgC,QACjB9O,UACX,OAAO,IAEd,CAX4E,+BAmB7E,IAAM+uB,EAAYjgB,EAAWN,KAAI,SAACuB,GAC9B,IAAMxX,EAAWwX,EAAEqK,cACnB,OAAIoV,EACO,CAAE92B,WAAYH,EAASG,WAAYT,aAAcM,EAASrB,OAAS+2B,EAAG32B,OAAQa,YAAaI,EAASrB,QAGpG,CAAEwB,WAAYH,EAASG,WAAYT,aAAcM,EAASrB,OAAQiB,YAAaI,EAASrB,OAEtG,IAGKi4B,EAAOv5B,KAAKi6B,yBAAyBnlB,EAAQsB,EAAO+iB,EAAUvgB,KAAI,SAAAsb,GAAC,OAAI,IAAIlrB,EAAAA,EAASkrB,EAAEpxB,WAAYoxB,EAAE7xB,aAAjC,IAAiDg2B,GAC1H,IAAKkB,EACD,OAAO,KAMX,IAtC6E,EAsCvEW,EAAgBl6B,KAAKm6B,8BAA8BrlB,EAAQykB,GAC3Da,EAAqBF,EAAgBA,EAAc9N,MAAQ,GAC7DiO,GAAyB,EAxCgD,UAyCtDlB,GAzCsD,IAyC7E,IAAK,EAAL,qBAAkC,KAAvBx2B,EAAuB,QACtBG,EAA0CH,EAA1CG,WAAYT,EAA8BM,EAA9BN,aAAcE,EAAgBI,EAAhBJ,YAC5BqpB,EAAWxV,EAAMyV,eAAe/oB,GAChCw3B,EAAa1O,EAAShqB,UAAU,EAAGS,EAAe,GAClDq2B,EAAY9M,EAAShqB,UAAUW,EAAc,GAKnD,GAJKm2B,EAAU5B,WAAWsD,KACtBC,GAAyB,GAGzB3B,EAAUh3B,OAAS,EAAG,CACtB,IAAM64B,EAAiB7B,EAAU9vB,OAAO,GAExC,IAD2Bqb,EAAeuW,sBAAsB1lB,EAAQ4jB,KAC5CoB,EAAsBS,GAC9C,OAAO,IAEd,CAED,GAAyB,IAArBhB,EAAK9W,KAAK/gB,SAAwB,MAAP22B,GAAsB,MAAPA,IAAmC,WAApBwB,EAA8B,CACvF,IAAM3mB,GAAiBC,EAAAA,EAAAA,GAAwB2B,EAAO5B,gBACtD,GAAIonB,EAAW54B,OAAS,EAAG,CACvB,IAAM+4B,EAAkBH,EAAWhyB,WAAWgyB,EAAW54B,OAAS,GAClE,GAA4C,IAAxCwR,EAAezS,IAAIg6B,GACnB,OAAO,IAEd,CACJ,CACD,IAAKrkB,EAAMsgB,kBAAkB5zB,GAEzB,OAAO,KAEXsT,EAAMskB,kBAAkB53B,GACxB,IAAM63B,EAAavkB,EAAMwkB,cAAc93B,GACjC+3B,GAAmBC,EAAAA,EAAAA,IAAuBH,EAAYt4B,EAAe,GAC3E,IAAKk3B,EAAKwB,gBAAgBF,EAAkBx4B,EAAew4B,EAAiBG,iBACxE,OAAO,KAUX,IAAMC,EAAmB1B,EAAK2B,uBAC9B,GAAID,EAAkB,CAClB,IAAME,EAAY/kB,EAAMglB,iCAAiCt4B,EAAYT,EAAc44B,GACnF,IAAK1B,EAAK8B,KAAKF,GACX,OAAO,IAEd,CACJ,CA5F4E,+BA6F7E,OAAId,EACOd,EAAKnN,MAAMxqB,UAAU,EAAG23B,EAAKnN,MAAM1qB,OAAS04B,EAAmB14B,QAG/D63B,EAAKnN,KAEnB,GA3jBL,yCA4jBI,SAAmCjB,EAAuBrW,EAAQsB,EAAO8C,EAAYmf,EAAIuB,EAAkB0B,GAEvG,IADA,IAAMva,EAAW,GACRngB,EAAI,EAAGwH,EAAM8Q,EAAWxX,OAAQd,EAAIwH,EAAKxH,IAAK,CACnD,IAAM2V,EAAY2C,EAAWtY,GAC7BmgB,EAASngB,GAAK,IAAIsgB,EAA2B3K,EAAW8hB,GAAKuB,EAAkB0B,EAClF,CACD,OAAO,IAAIzW,EAAAA,GAAoB,EAAqB9D,EAAU,CAC1DJ,8BAA8B,EAC9BW,6BAA6B,GAEpC,GAtkBL,iCAukBI,SAA2BxM,EAAQujB,GAC/B,OAAIrM,EAAAA,EAAAA,IAAQqM,GACwB,WAAxBvjB,EAAOymB,cAAqD,oBAAxBzmB,EAAOymB,aAInB,aAAxBzmB,EAAOymB,cAAuD,oBAAxBzmB,EAAOymB,YAE5D,GA/kBL,sCAglBI,SAAgCzmB,EAAQsB,EAAO8C,EAAYmf,GACvD,IAAKpU,EAAeuX,oBAAoB1mB,EAAQujB,KAAQvjB,EAAO2mB,iBAAiBloB,eAAe8kB,GAC3F,OAAO,EAGX,IADA,IAAMqD,GAA0B1P,EAAAA,EAAAA,IAAQqM,GAC/Bz3B,EAAI,EAAGwH,EAAM8Q,EAAWxX,OAAQd,EAAIwH,EAAKxH,IAAK,CACnD,IAAM2V,EAAY2C,EAAWtY,GAC7B,GAAI2V,EAAUnM,UACV,OAAO,EAGX,IADA,IAAIuxB,GAAkC,EAC7B74B,EAAayT,EAAUvM,gBAAiBlH,GAAcyT,EAAUrM,cAAepH,IAAc,CAClG,IAAM8oB,EAAWxV,EAAMyV,eAAe/oB,GAChC84B,EAAc94B,IAAeyT,EAAUvM,gBAAkBuM,EAAUtM,YAAc,EAAI,EACrF4xB,EAAY/4B,IAAeyT,EAAUrM,cAAgBqM,EAAUpM,UAAY,EAAIyhB,EAASlqB,OACxFo6B,EAAelQ,EAAShqB,UAAUg6B,EAAYC,GACpD,GAAI,SAASpF,KAAKqF,GAAe,CAE7BH,GAAkC,EAClC,KACH,CACJ,CACD,GAAIA,EACA,OAAO,EAEX,GAAID,GAA2BnlB,EAAUvM,kBAAoBuM,EAAUrM,eAAiBqM,EAAUtM,YAAc,IAAMsM,EAAUpM,UAAW,CACvI,IAAM4xB,EAAgB3lB,EAAM+gB,gBAAgB5gB,GAC5C,IAAIyV,EAAAA,EAAAA,IAAQ+P,GAGR,OAAO,CAEd,CACJ,CACD,OAAO,CACV,GAnnBL,uCAonBI,SAAiC5Q,EAAuBrW,EAAQsB,EAAO8C,EAAYmf,GAE/E,IADA,IAAMtX,EAAW,GACRngB,EAAI,EAAGwH,EAAM8Q,EAAWxX,OAAQd,EAAIwH,EAAKxH,IAAK,CACnD,IAAM2V,EAAY2C,EAAWtY,GACvBo7B,EAAiBlnB,EAAO2mB,iBAAiBpD,GAC/CtX,EAASngB,GAAK,IAAIq7B,EAAAA,EAAyB1lB,EAAW8hB,EAAI2D,EAC7D,CACD,OAAO,IAAInX,EAAAA,GAAoB,EAAe9D,EAAU,CACpDJ,8BAA8B,EAC9BW,6BAA6B,GAEpC,GA/nBL,4CAgoBI,SAAsCxM,EAAQsB,EAAO8C,GACjD,QAA0B,IAAtBA,EAAWxX,SAAgB0U,EAAMsgB,kBAAkBxd,EAAW,GAAGvO,iBAAiB7H,YAIzF,GAroBL,0CAsoBI,SAAoCqoB,EAAuBrW,EAAQsB,EAAOG,EAAW8hB,GACjF,IAAKvjB,EAAOonB,cAAc3oB,eAAe8kB,KAAQ9hB,EAAUnM,UACvD,OAAO,KAEX,IAAMzH,EAAW4T,EAAUiO,cAC3BpO,EAAMskB,kBAAkB/3B,EAASG,YACjC,IACIq5B,EADExB,EAAavkB,EAAMwkB,cAAcj4B,EAASG,YAEhD,IACIq5B,EAAiBrnB,EAAOsnB,oBAAoB/D,EAAIsC,EAAYh4B,EAASrB,OAKxE,CAHD,MAAOsd,GAEH,OADA+E,EAAAA,EAAAA,IAAkB/E,GACX,IACV,CACD,IAAKud,EACD,OAAO,KAEX,GAAIA,EAAeE,iBAAkB,CACjC,IAAMlyB,GAAawwB,EAAW9O,iBAAmBwM,GAAIzV,YAAYuZ,EAAeE,kBAAoB,EAC9FlnB,EAAQiB,EAAMkmB,aAAaC,sBAAsBJ,EAAeE,iBAAkB,CACpFv5B,WAAYH,EAASG,WACrBxB,OAAQ6I,GACT,KACH,GAAIgL,EAAO,CACP,GAAIA,EAAMnL,kBAAoBrH,EAASG,WAEnC,OAAO,KAEX,IAAM05B,EAAYpmB,EAAMyV,eAAe1W,EAAMnL,iBACvCyyB,EAAuBr7B,EAAAA,GAA6Bo7B,GACpDE,EAAiB5nB,EAAOvM,qBAAqBk0B,GAC7C7Q,EAAWxV,EAAMyV,eAAelpB,EAASG,YACzC65B,EAA0BvmB,EAAMwX,gCAAgCjrB,EAASG,aAAeH,EAASrB,OAEjGk1B,EAAWkG,EADF9Q,EAAShqB,UAAU+6B,EAA0B,EAAGh6B,EAASrB,OAAS,GACtC+2B,EACrC7C,EAAgB,IAAI3yB,EAAAA,EAAMF,EAASG,WAAY,EAAGH,EAASG,WAAYH,EAASrB,QAChF2f,EAAU,IAAIsK,EAAAA,GAAeiK,EAAegB,GAClD,OAAO,IAAI3R,EAAAA,GAAoB+X,EAAmBpG,EAAUrL,GAAwB,CAAClK,GAAU,CAC3FN,8BAA8B,EAC9BW,6BAA6B,GAEpC,CACJ,CACD,OAAO,IACV,GAnrBL,4CAurBI,SAAsC6J,EAAuBrW,EAAQsB,EAAOymB,EAAkC3jB,EAAYoM,GACtH,IAAKuX,GAAoCtwB,EAAAA,EAAAA,mBAA6BswB,EAAkC3jB,GAEpG,OAAO,KAEX,IAL4I,EAKxImf,EAAK,KALmI,UAOpHnf,GAPoH,IAO5I,IAAK,EAAL,qBAAoC,KAAzB3C,EAAyB,QAChC,IAAKA,EAAUnM,UACX,OAAO,KAEX,IAAMzH,EAAW4T,EAAUiO,cACrBsY,EAAc1mB,EAAM+gB,gBAAgB,IAAIt0B,EAAAA,EAAMF,EAASG,WAAYH,EAASrB,OAAS,EAAGqB,EAASG,WAAYH,EAASrB,SAC5H,GAAW,OAAP+2B,EACAA,EAAKyE,OAEJ,GAAIzE,IAAOyE,EACZ,OAAO,IAEd,CAnB2I,+BAoB5I,IAAKzE,EACD,OAAO,KAEX,GAAIr4B,KAAK+8B,uBAAuBjoB,EAAQsB,EAAO8C,EAAYoM,EAAsB+S,GAAK,CAElF,IAAMtX,EAAW7H,EAAWN,KAAI,SAAAuB,GAAC,OAAI,IAAIoR,EAAAA,GAAe,IAAI1oB,EAAAA,EAAMsX,EAAEzN,mBAAoByN,EAAExN,eAAgBwN,EAAEzN,mBAAoByN,EAAExN,eAAiB,GAAI,IAAI,EAA1H,IACjC,OAAO,IAAIkY,EAAAA,GAAoB,EAAqB9D,EAAU,CAC1DJ,8BAA8B,EAC9BW,6BAA6B,GAEpC,CACD,IAAMga,EAAuBt7B,KAAKg9B,yBAAyBloB,EAAQsB,EAAO8C,EAAYmf,GAAI,GAC1F,OAA6B,OAAzBiD,EACOt7B,KAAKi9B,4BAA4B9R,EAAuBrW,EAAQsB,EAAO8C,EAAYmf,GAAI,EAAMiD,GAEjG,IACV,GA3tBL,kCA4tBI,SAA4BzX,EAAoBsH,EAAuBrW,EAAQsB,EAAO8C,EAAYoM,EAAsB+S,GACpH,IAAKxU,GAA6B,OAAPwU,EAAa,CAEpC,IADA,IAAMtX,EAAW,GACRngB,EAAI,EAAGwH,EAAM8Q,EAAWxX,OAAQd,EAAIwH,EAAKxH,IAC9CmgB,EAASngB,GAAKqjB,EAAeiZ,OAAOpoB,EAAQsB,GAAO,EAAO8C,EAAWtY,IAEzE,OAAO,IAAIikB,EAAAA,GAAoB,EAAqB9D,EAAU,CAC1DJ,8BAA8B,EAC9BW,6BAA6B,GAEpC,CACD,IAAKuC,GAAsB7jB,KAAKm9B,kBAAkBroB,EAAQsB,EAAO8C,GAAa,CAG1E,IAFA,IAAM6H,EAAW,GACbqc,GAAkB,EACbx8B,EAAI,EAAGwH,EAAM8Q,EAAWxX,OAAQd,EAAIwH,EAAKxH,IAE9C,GADAmgB,EAASngB,GAAKZ,KAAKq9B,mBAAmBvoB,EAAQsB,EAAO8C,EAAWtY,GAAIy3B,IAC/DtX,EAASngB,GAAI,CACdw8B,GAAkB,EAClB,KACH,CAEL,IAAKA,EACD,OAAO,IAAIvY,EAAAA,GAAoB,EAAqB9D,EAAU,CAC1DJ,8BAA8B,EAC9BW,6BAA6B,GAGxC,CACD,IAAKuC,GAAsB7jB,KAAK+8B,uBAAuBjoB,EAAQsB,EAAO8C,EAAYoM,EAAsB+S,GACpG,OAAOr4B,KAAKs9B,wBAAwBnS,EAAuBrW,EAAQsB,EAAO8C,EAAYmf,GAE1F,IAAKxU,EAAoB,CACrB,IAAMyX,EAAuBt7B,KAAKg9B,yBAAyBloB,EAAQsB,EAAO8C,EAAYmf,GAAI,GAC1F,GAAIiD,EACA,OAAOt7B,KAAKi9B,4BAA4B9R,EAAuBrW,EAAQsB,EAAO8C,EAAYmf,GAAI,EAAOiD,EAE5G,CACD,GAAIt7B,KAAKu9B,yBAAyBzoB,EAAQsB,EAAO8C,EAAYmf,GACzD,OAAOr4B,KAAKw9B,0BAA0BrS,EAAuBrW,EAAQsB,EAAO8C,EAAYmf,GAI5F,IAAKxU,GAAsB7jB,KAAKy9B,+BAA+B3oB,EAAQsB,EAAO8C,GAAa,CACvF,IAAMlN,EAAIhM,KAAK09B,6BAA6BvS,EAAuBrW,EAAQsB,EAAO8C,EAAW,GAAImf,GACjG,GAAIrsB,EACA,OAAOA,CAEd,CAGD,IADA,IAAM+U,EAAW,GACRngB,EAAI,EAAGwH,EAAM8Q,EAAWxX,OAAQd,EAAIwH,EAAKxH,IAC9CmgB,EAASngB,GAAK,IAAI2qB,EAAAA,GAAerS,EAAWtY,GAAIy3B,GAEpD,IAAMsF,EAASf,EAAmBvE,EAAIlN,GACtC,OAAO,IAAItG,EAAAA,GAAoB8Y,EAAQ5c,EAAU,CAC7CJ,6BAA8BuW,EAA8B/L,EAAuBwS,GACnFrc,6BAA6B,GAEpC,GAtxBL,qCAuxBI,SAA+B6J,EAAuBrW,EAAQsB,EAAO8C,EAAY1Q,GAE7E,IADA,IAAMuY,EAAW,GACRngB,EAAI,EAAGwH,EAAM8Q,EAAWxX,OAAQd,EAAIwH,EAAKxH,IAC9CmgB,EAASngB,GAAK,IAAI2qB,EAAAA,GAAerS,EAAWtY,GAAI4H,GAEpD,IAAMm1B,EAASf,EAAmBp0B,EAAK2iB,GACvC,OAAO,IAAItG,EAAAA,GAAoB8Y,EAAQ5c,EAAU,CAC7CJ,6BAA8BuW,EAA8B/L,EAAuBwS,GACnFrc,6BAA6B,GAEpC,GAjyBL,8BAkyBI,SAAwBxM,EAAQsB,EAAO8C,GACnC,GAAc,OAAV9C,GAAiC,OAAf8C,EAClB,MAAO,GAGX,IADA,IAAM6H,EAAW,GACRngB,EAAI,EAAGwH,EAAM8Q,EAAWxX,OAAQd,EAAIwH,EAAKxH,IAAK,CACnD,IAAIkC,EAAaoW,EAAWtY,GAAG8L,mBAC/B,GAAmB,IAAf5J,EACAie,EAASngB,GAAK,IAAI02B,EAAAA,GAAsC,IAAIz0B,EAAAA,EAAM,EAAG,EAAG,EAAG,GAAI,UAE9E,CACDC,IACA,IAAMxB,EAAS8U,EAAMoS,iBAAiB1lB,GACtCie,EAASngB,GAAKZ,KAAKk9B,OAAOpoB,EAAQsB,GAAO,EAAO,IAAIvT,EAAAA,EAAMC,EAAYxB,EAAQwB,EAAYxB,GAC7F,CACJ,CACD,OAAOyf,CACV,GAnzBL,6BAozBI,SAAuBjM,EAAQsB,EAAO8C,GAClC,GAAc,OAAV9C,GAAiC,OAAf8C,EAClB,MAAO,GAGX,IADA,IAAM6H,EAAW,GACRngB,EAAI,EAAGwH,EAAM8Q,EAAWxX,OAAQd,EAAIwH,EAAKxH,IAAK,CACnD,IAAMkC,EAAaoW,EAAWtY,GAAG8L,mBAC3BpL,EAAS8U,EAAMoS,iBAAiB1lB,GACtCie,EAASngB,GAAKZ,KAAKk9B,OAAOpoB,EAAQsB,GAAO,EAAO,IAAIvT,EAAAA,EAAMC,EAAYxB,EAAQwB,EAAYxB,GAC7F,CACD,OAAOyf,CACV,GA/zBL,6BAg0BI,SAAuBjM,EAAQsB,EAAO8C,GAElC,IADA,IAAM6H,EAAW,GACRngB,EAAI,EAAGwH,EAAM8Q,EAAWxX,OAAQd,EAAIwH,EAAKxH,IAC9CmgB,EAASngB,GAAKZ,KAAKk9B,OAAOpoB,EAAQsB,GAAO,EAAM8C,EAAWtY,IAE9D,OAAOmgB,CACV,KAt0BL,KAw0BaG,EAAb,0CACI,WAAY3K,EAAWqnB,EAAeC,EAAqB7B,GAAgB,6BACvE,cAAMzlB,GAAYsnB,EAAsBD,EAAgB,IAAM5B,EAAgB,GAAIA,EAAet6B,SAC5Fo8B,eAAiBF,EACtB,EAAKG,gBAAkB/B,EACvB,EAAK5a,oBAAsB,KAC3B,EAAKD,eAAiB,KALiD,CAM1E,CAPL,iDAQI,SAAmB/K,EAAO4nB,GACtB,IACMp7B,EADwBo7B,EAAO5W,2BACD,GAAGxkB,MAGvC,OAFA5C,KAAKohB,oBAAsB,IAAIve,EAAAA,EAAMD,EAAMoH,gBAAiBpH,EAAMuH,UAAYnK,KAAK+9B,gBAAgBr8B,OAAQkB,EAAMsH,cAAetH,EAAMuH,WACtInK,KAAKmhB,eAAiB,IAAIte,EAAAA,EAAMD,EAAMoH,gBAAiBpH,EAAMuH,UAAYnK,KAAK89B,eAAep8B,OAAS1B,KAAK+9B,gBAAgBr8B,OAAQkB,EAAMsH,cAAetH,EAAMuH,YACvJ,iEAAyBiM,EAAO4nB,EAC1C,KAdL,GAAgD5G,EAAAA,IAgBhD,SAASwF,EAAmBqB,EAAWC,GACnC,MAAkB,MAAdD,EACmC,IAA5BC,GAC4B,IAA5BA,EACD,EACA,EAEH,CACV,CACD,SAAShH,EAA8BgH,EAAyBC,GAC5D,SAAIC,EAAkBF,IAA6BE,EAAkBD,KAIrC,IAA5BD,GAMGG,EAAuBH,KAA6BG,EAAuBF,EACrF,CACD,SAASE,EAAuBz2B,GAC5B,OAAiB,IAATA,GAAoD,IAATA,EAC7C,QACAA,CACT,CACD,SAASw2B,EAAkBx2B,GACvB,OAAgB,IAATA,GACS,IAATA,GACS,IAATA,CACV,C,gMC93BYunB,EAAb,uFACI,SAAmB9tB,EAAai9B,EAAUC,EAAehzB,EAAOC,GAE5D,MAAO,CAAED,MAAOA,EAAOC,IAAKA,EAAK8yB,SAAUA,EAAUC,cAAeA,EACvE,GAJL,qCAKI,SAA+BrrB,EAAgBkD,EAAOzT,GAClD,IAAMtB,EAAc+U,EAAMyV,eAAelpB,EAASG,YAClD,OAAO9C,KAAKw+B,0BAA0Bn9B,EAAa6R,EAAgBvQ,EACtE,GARL,uCASI,SAAiCtB,EAAa6R,EAAgBvQ,GAE1D,IADA,IAAI27B,EAAW,EACNG,EAAU97B,EAASrB,OAAS,EAAGm9B,GAAW,EAAGA,IAAW,CAC7D,IAAMC,EAASr9B,EAAYiH,WAAWm2B,GAChCE,EAAUzrB,EAAezS,IAAIi+B,GACnC,GAAgB,IAAZC,EAA6B,CAC7B,GAAiB,IAAbL,EACA,OAAOt+B,KAAK4+B,YAAYv9B,EAAai9B,EAAUK,EAASF,EAAU,EAAGz+B,KAAK6+B,eAAex9B,EAAa6R,EAAgBorB,EAAUG,EAAU,IAE9IH,EAAW,CACd,MACI,GAAgB,IAAZK,EAAmC,CACxC,GAAiB,IAAbL,EACA,OAAOt+B,KAAK4+B,YAAYv9B,EAAai9B,EAAUK,EAASF,EAAU,EAAGz+B,KAAK6+B,eAAex9B,EAAa6R,EAAgBorB,EAAUG,EAAU,IAE9IH,EAAW,CACd,MACI,GAAgB,IAAZK,GACY,IAAbL,EACA,OAAOt+B,KAAK4+B,YAAYv9B,EAAai9B,EAAUK,EAASF,EAAU,EAAGz+B,KAAK6+B,eAAex9B,EAAa6R,EAAgBorB,EAAUG,EAAU,GAGrJ,CACD,OAAiB,IAAbH,EACOt+B,KAAK4+B,YAAYv9B,EAAai9B,EAAU,EAAoB,EAAGt+B,KAAK6+B,eAAex9B,EAAa6R,EAAgBorB,EAAU,IAE9H,IACV,GApCL,4BAqCI,SAAsBj9B,EAAa6R,EAAgBorB,EAAU1C,GAEzD,IADA,IAAMxzB,EAAM/G,EAAYK,OACf+8B,EAAU7C,EAAY6C,EAAUr2B,EAAKq2B,IAAW,CACrD,IAAMC,EAASr9B,EAAYiH,WAAWm2B,GAChCE,EAAUzrB,EAAezS,IAAIi+B,GACnC,GAAgB,IAAZC,EACA,OAAOF,EAEX,GAAiB,IAAbH,GAA4C,IAAZK,EAChC,OAAOF,EAEX,GAAiB,IAAbH,GAA8C,IAAZK,EAClC,OAAOF,CAEd,CACD,OAAOr2B,CACV,GArDL,iCAsDI,SAA2B8K,EAAgBkD,EAAOzT,GAC9C,IAAMtB,EAAc+U,EAAMyV,eAAelpB,EAASG,YAClD,OAAO9C,KAAK8+B,sBAAsBz9B,EAAa6R,EAAgBvQ,EAClE,GAzDL,mCA0DI,SAA6BtB,EAAa6R,EAAgBvQ,GAGtD,IAFA,IAAI27B,EAAW,EACTl2B,EAAM/G,EAAYK,OACf+8B,EAAU97B,EAASrB,OAAS,EAAGm9B,EAAUr2B,EAAKq2B,IAAW,CAC9D,IAAMC,EAASr9B,EAAYiH,WAAWm2B,GAChCE,EAAUzrB,EAAezS,IAAIi+B,GACnC,GAAgB,IAAZC,EAA6B,CAC7B,GAAiB,IAAbL,EACA,OAAOt+B,KAAK4+B,YAAYv9B,EAAai9B,EAAUK,EAAS3+B,KAAK++B,iBAAiB19B,EAAa6R,EAAgBorB,EAAUG,EAAU,GAAIA,GAEvIH,EAAW,CACd,MACI,GAAgB,IAAZK,EAAmC,CACxC,GAAiB,IAAbL,EACA,OAAOt+B,KAAK4+B,YAAYv9B,EAAai9B,EAAUK,EAAS3+B,KAAK++B,iBAAiB19B,EAAa6R,EAAgBorB,EAAUG,EAAU,GAAIA,GAEvIH,EAAW,CACd,MACI,GAAgB,IAAZK,GACY,IAAbL,EACA,OAAOt+B,KAAK4+B,YAAYv9B,EAAai9B,EAAUK,EAAS3+B,KAAK++B,iBAAiB19B,EAAa6R,EAAgBorB,EAAUG,EAAU,GAAIA,EAG9I,CACD,OAAiB,IAAbH,EACOt+B,KAAK4+B,YAAYv9B,EAAai9B,EAAU,EAAoBt+B,KAAK++B,iBAAiB19B,EAAa6R,EAAgBorB,EAAUl2B,EAAM,GAAIA,GAEvI,IACV,GAtFL,8BAuFI,SAAwB/G,EAAa6R,EAAgBorB,EAAU1C,GAC3D,IAAK,IAAI6C,EAAU7C,EAAY6C,GAAW,EAAGA,IAAW,CACpD,IAAMC,EAASr9B,EAAYiH,WAAWm2B,GAChCE,EAAUzrB,EAAezS,IAAIi+B,GACnC,GAAgB,IAAZC,EACA,OAAOF,EAAU,EAErB,GAAiB,IAAbH,GAA4C,IAAZK,EAChC,OAAOF,EAAU,EAErB,GAAiB,IAAbH,GAA8C,IAAZK,EAClC,OAAOF,EAAU,CAExB,CACD,OAAO,CACV,GAtGL,0BAuGI,SAAoBvrB,EAAgBkD,EAAOzT,EAAUq8B,GACjD,IAAIl8B,EAAaH,EAASG,WACtBxB,EAASqB,EAASrB,OACP,IAAXA,GACIwB,EAAa,IACbA,GAA0B,EAC1BxB,EAAS8U,EAAMoS,iBAAiB1lB,IAGxC,IAAIm8B,EAAiB9P,EAAe+P,wBAAwBhsB,EAAgBkD,EAAO,IAAIpN,EAAAA,EAASlG,EAAYxB,IAC5G,GAA2B,IAAvB09B,EACA,OAAO,IAAIh2B,EAAAA,EAASlG,EAAYm8B,EAAiBA,EAAe1zB,MAAQ,EAAI,GAEhF,GAA2B,IAAvByzB,EAQA,OAPIC,GAC+B,IAA5BA,EAAeX,UACfW,EAAezzB,IAAMyzB,EAAe1zB,QAAU,GACb,IAAjC0zB,EAAeV,gBAElBU,EAAiB9P,EAAe+P,wBAAwBhsB,EAAgBkD,EAAO,IAAIpN,EAAAA,EAASlG,EAAYm8B,EAAe1zB,MAAQ,KAE5H,IAAIvC,EAAAA,EAASlG,EAAYm8B,EAAiBA,EAAe1zB,MAAQ,EAAI,GAEhF,GAA2B,IAAvByzB,EAAkD,CAClD,KAAOC,GAC4B,IAA5BA,EAAeX,UAElBW,EAAiB9P,EAAe+P,wBAAwBhsB,EAAgBkD,EAAO,IAAIpN,EAAAA,EAASlG,EAAYm8B,EAAe1zB,MAAQ,IAEnI,OAAO,IAAIvC,EAAAA,EAASlG,EAAYm8B,EAAiBA,EAAe1zB,MAAQ,EAAI,EAC/E,CAKD,OAHI0zB,GAAkB39B,GAAU29B,EAAezzB,IAAM,IACjDyzB,EAAiB9P,EAAe+P,wBAAwBhsB,EAAgBkD,EAAO,IAAIpN,EAAAA,EAASlG,EAAYm8B,EAAe1zB,MAAQ,KAE5H,IAAIvC,EAAAA,EAASlG,EAAYm8B,EAAiBA,EAAezzB,IAAM,EAAI,EAC7E,GA3IL,+BA4II,SAAyB4K,EAAOzT,GAC5B,IAAMG,EAAaH,EAASG,WACtBsnB,EAAYhU,EAAMoS,iBAAiB1lB,GACzC,GAAwB,IAApBH,EAASrB,OACT,OAAQwB,EAAa,EAAI,IAAIkG,EAAAA,EAASlG,EAAa,EAAGsT,EAAMoS,iBAAiB1lB,EAAa,IAAMH,EAGpG,IADA,IAAMtB,EAAc+U,EAAMyV,eAAe/oB,GAChCxB,EAASqB,EAASrB,OAAS,EAAGA,EAAS,EAAGA,IAAU,CACzD,IAAM6nB,EAAO9nB,EAAYiH,WAAWhH,EAAS,GACvCgzB,EAAQjzB,EAAYiH,WAAWhH,EAAS,GAC9C,GAAa,KAAT6nB,GAAyC,KAAVmL,EAE/B,OAAO,IAAItrB,EAAAA,EAASlG,EAAYxB,GAEpC,GAAIF,EAAAA,GAA2B+nB,IAAS/nB,EAAAA,GAA2BkzB,GAE/D,OAAO,IAAItrB,EAAAA,EAASlG,EAAYxB,GAEpC,GAAIF,EAAAA,GAA2B+nB,IAAS/nB,EAAAA,GAA2BkzB,IAE3DhzB,EAAS,EAAI8oB,EAAW,CACxB,IAAM+U,EAAa99B,EAAYiH,WAAWhH,GAC1C,GAAIF,EAAAA,GAA2B+9B,GAC3B,OAAO,IAAIn2B,EAAAA,EAASlG,EAAYxB,EAEvC,CAER,CACD,OAAO,IAAI0H,EAAAA,EAASlG,EAAY,EACnC,GAzKL,2BA0KI,SAAqBoQ,EAAgBkD,EAAOzT,EAAUq8B,GAClD,IAAIl8B,EAAaH,EAASG,WACtBxB,EAASqB,EAASrB,OAClB89B,GAAY,EACZ99B,IAAW8U,EAAMoS,iBAAiB1lB,IAC9BA,EAAasT,EAAM8U,iBACnBkU,GAAY,EACZt8B,GAA0B,EAC1BxB,EAAS,GAGjB,IAAI+9B,EAAiBlQ,EAAemQ,oBAAoBpsB,EAAgBkD,EAAO,IAAIpN,EAAAA,EAASlG,EAAYxB,IACxG,GAA2B,IAAvB09B,EACIK,GAA8C,IAA5BA,EAAef,UAC7Be,EAAe7zB,IAAM6zB,EAAe9zB,QAAU,GAAsC,IAAjC8zB,EAAed,gBAElEc,EAAiBlQ,EAAemQ,oBAAoBpsB,EAAgBkD,EAAO,IAAIpN,EAAAA,EAASlG,EAAYu8B,EAAe7zB,IAAM,KAI7HlK,EADA+9B,EACSA,EAAe7zB,IAAM,EAGrB4K,EAAMoS,iBAAiB1lB,QAGnC,GAA2B,IAAvBk8B,EAAkD,CAOvD,IANII,IAIA99B,EAAS,GAEN+9B,IAC6B,IAA5BA,EAAef,UACZe,EAAe9zB,MAAQ,GAAKjK,IAGnC+9B,EAAiBlQ,EAAemQ,oBAAoBpsB,EAAgBkD,EAAO,IAAIpN,EAAAA,EAASlG,EAAYu8B,EAAe7zB,IAAM,IAGzHlK,EADA+9B,EACSA,EAAe9zB,MAAQ,EAGvB6K,EAAMoS,iBAAiB1lB,EAEvC,MAEOu8B,IAAmBD,GAAa99B,GAAU+9B,EAAe9zB,MAAQ,IACjE8zB,EAAiBlQ,EAAemQ,oBAAoBpsB,EAAgBkD,EAAO,IAAIpN,EAAAA,EAASlG,EAAYu8B,EAAe7zB,IAAM,KAGzHlK,EADA+9B,EACSA,EAAe9zB,MAAQ,EAGvB6K,EAAMoS,iBAAiB1lB,GAGxC,OAAO,IAAIkG,EAAAA,EAASlG,EAAYxB,EACnC,GArOL,gCAsOI,SAA0B8U,EAAOzT,GAC7B,IAAMG,EAAaH,EAASG,WACtBsnB,EAAYhU,EAAMoS,iBAAiB1lB,GACzC,GAAIH,EAASrB,SAAW8oB,EACpB,OAAQtnB,EAAasT,EAAM8U,eAAiB,IAAIliB,EAAAA,EAASlG,EAAa,EAAG,GAAKH,EAGlF,IADA,IAAMtB,EAAc+U,EAAMyV,eAAe/oB,GAChCxB,EAASqB,EAASrB,OAAS,EAAGA,EAAS8oB,EAAW9oB,IAAU,CACjE,IAAM6nB,EAAO9nB,EAAYiH,WAAWhH,EAAS,GACvCgzB,EAAQjzB,EAAYiH,WAAWhH,EAAS,GAC9C,GAAa,KAAT6nB,GAAyC,KAAVmL,EAE/B,OAAO,IAAItrB,EAAAA,EAASlG,EAAYxB,GAEpC,GAAIF,EAAAA,GAA2B+nB,IAAS/nB,EAAAA,GAA2BkzB,GAE/D,OAAO,IAAItrB,EAAAA,EAASlG,EAAYxB,GAEpC,GAAIF,EAAAA,GAA2B+nB,IAAS/nB,EAAAA,GAA2BkzB,IAE3DhzB,EAAS,EAAI8oB,EAAW,CACxB,IAAM+U,EAAa99B,EAAYiH,WAAWhH,GAC1C,GAAIF,EAAAA,GAA2B+9B,GAC3B,OAAO,IAAIn2B,EAAAA,EAASlG,EAAYxB,EAEvC,CAER,CACD,OAAO,IAAI0H,EAAAA,EAASlG,EAAYsnB,EACnC,GAnQL,uCAoQI,SAAiChU,EAAOzT,GACpC,IAAMtB,EAAc+U,EAAMyV,eAAelpB,EAASG,YAC5C84B,EAAaj5B,EAASrB,OAAS,EAC/Bi+B,EAAoBn+B,EAAAA,GAA+BC,EAAau6B,GACtE,OAAI2D,EAAoB,EAAI3D,EACjB,IAAI/4B,EAAAA,EAAMF,EAASG,WAAYy8B,EAAoB,EAAG58B,EAASG,WAAYH,EAASrB,QAExF,IACV,GA5QL,4BA6QI,SAAsBokB,EAAKsZ,GACvB,IAAM9rB,EAAiBwS,EAAIxS,eACrBkD,EAAQsP,EAAItP,MACZG,EAAYmP,EAAInP,UAChBipB,EAAuB9Z,EAAI8Z,qBACjC,IAAKjpB,EAAUnM,UACX,OAAOmM,EAEX,GAAIoO,EAAAA,EAAAA,wBAAyCe,EAAI8F,kBAAmB9F,EAAI+F,oBAAqB/F,EAAIgG,kBAAmBhG,EAAIpD,iBAAiBmK,0BAA2B/G,EAAItP,MAAO,CAACsP,EAAInP,WAAYmP,EAAIJ,sBAAuB,CACvN,IAAM3iB,EAAW+iB,EAAInP,UAAUiO,cAC/B,OAAO,IAAI3hB,EAAAA,EAAMF,EAASG,WAAYH,EAASrB,OAAS,EAAGqB,EAASG,WAAYH,EAASrB,OAAS,EACrG,CACD,IAAMqB,EAAW,IAAIqG,EAAAA,EAASuN,EAAU7J,mBAAoB6J,EAAU5J,gBAClE7J,EAAaH,EAASG,WACtBxB,EAASqB,EAASrB,OACtB,GAAmB,IAAfwB,GAA+B,IAAXxB,EAEpB,OAAO,KAEX,GAAIk+B,EAAsB,CACtB,IAAMxzB,EAAIhM,KAAKy/B,0BAA0BrpB,EAAOzT,GAChD,GAAIqJ,EACA,OAAOA,CAEd,CACD,IAAIizB,EAAiB9P,EAAe+P,wBAAwBhsB,EAAgBkD,EAAOzT,GAgCnF,OA/B2B,IAAvBq8B,EACIC,EACA39B,EAAS29B,EAAe1zB,MAAQ,EAG5BjK,EAAS,EACTA,EAAS,GAGTwB,IACAxB,EAAS8U,EAAMoS,iBAAiB1lB,KAKpCm8B,GAAkB39B,GAAU29B,EAAezzB,IAAM,IACjDyzB,EAAiB9P,EAAe+P,wBAAwBhsB,EAAgBkD,EAAO,IAAIpN,EAAAA,EAASlG,EAAYm8B,EAAe1zB,MAAQ,KAE/H0zB,EACA39B,EAAS29B,EAAezzB,IAAM,EAG1BlK,EAAS,EACTA,EAAS,GAGTwB,IACAxB,EAAS8U,EAAMoS,iBAAiB1lB,KAIrC,IAAID,EAAAA,EAAMC,EAAYxB,EAAQqB,EAASG,WAAYH,EAASrB,OACtE,GAvUL,8BAwUI,SAAwB4R,EAAgBkD,EAAOG,GAC3C,IAAKA,EAAUnM,UACX,OAAOmM,EAEX,IAAM5T,EAAW,IAAIqG,EAAAA,EAASuN,EAAU7J,mBAAoB6J,EAAU5J,gBAChEX,EAAIhM,KAAK0/B,4BAA4BtpB,EAAOzT,GAClD,OAAIqJ,GAGGhM,KAAK2/B,sCAAsCzsB,EAAgBkD,EAAOzT,EAC5E,GAlVL,iCAmVI,SAA2B6F,EAAKgN,GAC5B,IAAMnV,EAAWmI,EAAIF,WAAWkN,GAChC,OAAqB,KAAbnV,GAA4C,IAAbA,CAC1C,GAtVL,yCAuVI,SAAmC+V,EAAOzT,GACtC,IAAMtB,EAAc+U,EAAMyV,eAAelpB,EAASG,YAC5CX,EAAoBd,EAAYK,OACtC,GAA0B,IAAtBS,EAEA,OAAO,KAEX,IAAIy9B,EAAYp+B,KAAKiB,IAAIE,EAASrB,OAAS,EAAG,GAC9C,IAAKtB,KAAK6/B,oBAAoBx+B,EAAau+B,GAEvC,OAAO,KAEX,IAAIE,EAAat+B,KAAKC,IAAIkB,EAASrB,OAAS,EAAGa,EAAoB,GACnE,IAAKnC,KAAK6/B,oBAAoBx+B,EAAay+B,GAEvC,OAAO,KAGX,KAAOF,EAAY,GAAK5/B,KAAK6/B,oBAAoBx+B,EAAau+B,EAAY,IACtEA,IAGJ,KAAOE,EAAa,EAAI39B,GAAqBnC,KAAK6/B,oBAAoBx+B,EAAay+B,EAAa,IAC5FA,IAEJ,OAAO,IAAIj9B,EAAAA,EAAMF,EAASG,WAAY88B,EAAY,EAAGj9B,EAASG,WAAYg9B,EAAa,EAC1F,GAjXL,mDAkXI,SAA6C5sB,EAAgBkD,EAAOzT,GAAU,WACpEtB,EAAc+U,EAAMyV,eAAelpB,EAASG,YAC5CkmB,EAAa3nB,EAAYK,OAC/B,GAAmB,IAAfsnB,EAEA,OAAIrmB,EAASG,WAAa,EACf,IAAID,EAAAA,EAAMF,EAASG,WAAa,EAAGsT,EAAMoS,iBAAiB7lB,EAASG,WAAa,GAAIH,EAASG,WAAY,GAG5GH,EAASG,WAAasT,EAAM8U,eACrB,IAAIroB,EAAAA,EAAMF,EAASG,WAAY,EAAGH,EAASG,WAAa,EAAG,GAI3D,IAAID,EAAAA,EAAMF,EAASG,WAAY,EAAGH,EAASG,WAAY,GAI1E,IAAMi9B,EAAc,SAACxqB,GACjB,OAAQA,EAAKhK,MAAQ,GAAK5I,EAASrB,QAAUqB,EAASrB,QAAUiU,EAAK/J,IAAM,CAC9E,EACKw0B,EAA0B,SAAC/1B,EAAaE,GAG1C,OAFAF,EAAczI,KAAKC,IAAIwI,EAAatH,EAASrB,QAC7C6I,EAAY3I,KAAKiB,IAAI0H,EAAWxH,EAASrB,QAClC,IAAIuB,EAAAA,EAAMF,EAASG,WAAYmH,EAAatH,EAASG,WAAYqH,EAC3E,EACK81B,EAAkC,SAAC1qB,GAIrC,IAHA,IAAItL,EAAcsL,EAAKhK,MAAQ,EAC3BpB,EAAYoL,EAAK/J,IAAM,EACvB00B,GAAqB,EAClB/1B,EAAY,EAAI6e,GAAc,EAAK6W,oBAAoBx+B,EAAa8I,EAAY,IACnF+1B,GAAqB,EACrB/1B,IAEJ,IAAK+1B,EACD,KAAOj2B,EAAc,GAAK,EAAK41B,oBAAoBx+B,EAAa4I,EAAc,IAC1EA,IAGR,OAAO+1B,EAAwB/1B,EAAaE,EAC/C,EACK80B,EAAiB9P,EAAe+P,wBAAwBhsB,EAAgBkD,EAAOzT,GACrF,GAAIs8B,GAAkBc,EAAYd,GAC9B,OAAOgB,EAAgChB,GAE3C,IAAMI,EAAiBlQ,EAAemQ,oBAAoBpsB,EAAgBkD,EAAOzT,GACjF,OAAI08B,GAAkBU,EAAYV,GACvBY,EAAgCZ,GAEvCJ,GAAkBI,EACXW,EAAwBf,EAAezzB,IAAM,EAAG6zB,EAAe9zB,MAAQ,GAE9E0zB,EACOe,EAAwBf,EAAe1zB,MAAQ,EAAG0zB,EAAezzB,IAAM,GAE9E6zB,EACOW,EAAwBX,EAAe9zB,MAAQ,EAAG8zB,EAAe7zB,IAAM,GAE3Ew0B,EAAwB,EAAGhX,EAAa,EAClD,GA7aL,iCA8aI,SAA2B5S,EAAOG,GAC9B,IAAKA,EAAUnM,UACX,OAAOmM,EAEX,IAAMzM,EAAMyM,EAAUiO,cAChB2b,EAAahR,EAAeiR,kBAAkBhqB,EAAOtM,GAC3D,OAAO,IAAIjH,EAAAA,EAAMiH,EAAIhH,WAAYgH,EAAIxI,OAAQ6+B,EAAWr9B,WAAYq9B,EAAW7+B,OAClF,GArbL,yCAsbI,SAAmCkH,EAAKozB,GAEpC,IADA,IAAMxzB,EAAMI,EAAI9G,OACP+8B,EAAU7C,EAAY6C,EAAUr2B,EAAKq2B,IAAW,CACrD,IAAMpG,EAAK7vB,EAAII,OAAO61B,GACtB,GAAW,MAAPpG,GAAqB,OAAPA,EACd,OAAOoG,CAEd,CACD,OAAOr2B,CACV,GA/bL,wCAgcI,SAAkCgO,EAAOzT,GACrC,IAAMtB,EAAc+U,EAAMyV,eAAelpB,EAASG,YAC5C84B,EAAaj5B,EAASrB,OAAS,EAC/B22B,EAAqBj4B,KAAKqgC,4BAA4Bh/B,EAAau6B,GACzE,OAAIA,EAAa,EAAI3D,EAEV,IAAIp1B,EAAAA,EAAMF,EAASG,WAAYH,EAASrB,OAAQqB,EAASG,WAAYm1B,EAAqB,GAE9F,IACV,GAzcL,6BA0cI,SAAuBvS,EAAKsZ,GACxB,IAAM9rB,EAAiBwS,EAAIxS,eACrBkD,EAAQsP,EAAItP,MACZG,EAAYmP,EAAInP,UAChBipB,EAAuB9Z,EAAI8Z,qBACjC,IAAKjpB,EAAUnM,UACX,OAAOmM,EAEX,IAAM5T,EAAW,IAAIqG,EAAAA,EAASuN,EAAU7J,mBAAoB6J,EAAU5J,gBAClE7J,EAAaH,EAASG,WACtBxB,EAASqB,EAASrB,OAChBsoB,EAAYxT,EAAM8U,eAClBd,EAAYhU,EAAMoS,iBAAiB1lB,GACzC,GAAIA,IAAe8mB,GAAatoB,IAAW8oB,EAEvC,OAAO,KAEX,GAAIoV,EAAsB,CACtB,IAAMxzB,EAAIhM,KAAKsgC,2BAA2BlqB,EAAOzT,GACjD,GAAIqJ,EACA,OAAOA,CAEd,CACD,IAAIqzB,EAAiBlQ,EAAemQ,oBAAoBpsB,EAAgBkD,EAAOzT,GA4C/E,OA3C2B,IAAvBq8B,EACIK,EACA/9B,EAAS+9B,EAAe7zB,IAAM,EAG1BlK,EAAS8oB,GAAatnB,IAAe8mB,EACrCtoB,EAAS8oB,GAGTtnB,IAGIxB,GAFJ+9B,EAAiBlQ,EAAemQ,oBAAoBpsB,EAAgBkD,EAAO,IAAIpN,EAAAA,EAASlG,EAAY,KAEvFu8B,EAAe9zB,MAAQ,EAGvB6K,EAAMoS,iBAAiB1lB,KAMxCu8B,GAAkB/9B,GAAU+9B,EAAe9zB,MAAQ,IACnD8zB,EAAiBlQ,EAAemQ,oBAAoBpsB,EAAgBkD,EAAO,IAAIpN,EAAAA,EAASlG,EAAYu8B,EAAe7zB,IAAM,KAEzH6zB,EACA/9B,EAAS+9B,EAAe9zB,MAAQ,EAG5BjK,EAAS8oB,GAAatnB,IAAe8mB,EACrCtoB,EAAS8oB,GAGTtnB,IAGIxB,GAFJ+9B,EAAiBlQ,EAAemQ,oBAAoBpsB,EAAgBkD,EAAO,IAAIpN,EAAAA,EAASlG,EAAY,KAEvFu8B,EAAe9zB,MAAQ,EAGvB6K,EAAMoS,iBAAiB1lB,KAKzC,IAAID,EAAAA,EAAMC,EAAYxB,EAAQqB,EAASG,WAAYH,EAASrB,OACtE,GA9gBL,kCA+gBI,SAA4B8U,EAAOG,GAC/B,IAAKA,EAAUnM,UACX,OAAOmM,EAEX,IAAMzM,EAAMyM,EAAUiO,cAChB2b,EAAahR,EAAeoR,mBAAmBnqB,EAAOtM,GAC5D,OAAO,IAAIjH,EAAAA,EAAMiH,EAAIhH,WAAYgH,EAAIxI,OAAQ6+B,EAAWr9B,WAAYq9B,EAAW7+B,OAClF,GAthBL,mCAuhBI,SAA6B8U,EAAOtT,EAAYyS,GAC5C,IAAM3S,EAAQ,IAAIC,EAAAA,EAAMC,EAAYyS,EAAKhK,MAAQ,EAAGzI,EAAYyS,EAAK/J,IAAM,GAC3E,MAAO,CACH+J,KAAMa,EAAM+gB,gBAAgBv0B,GAC5BqH,YAAarH,EAAMqH,YACnBE,UAAWvH,EAAMuH,UAExB,GA9hBL,+BA+hBI,SAAyBiM,EAAOoqB,EAAiB79B,GAC7C,IAAMuQ,GAAiBC,EAAAA,EAAAA,GAAwBqtB,GACzCC,EAAWtR,EAAe+P,wBAAwBhsB,EAAgBkD,EAAOzT,GAC/E,GAAI89B,GAAkC,IAAtBA,EAASnC,UAAgCmC,EAASl1B,OAAS5I,EAASrB,OAAS,GAAKqB,EAASrB,OAAS,GAAKm/B,EAASj1B,IAC9H,OAAO2jB,EAAeuR,sBAAsBtqB,EAAOzT,EAASG,WAAY29B,GAE5E,IAAME,EAAWxR,EAAemQ,oBAAoBpsB,EAAgBkD,EAAOzT,GAC3E,OAAIg+B,GAAkC,IAAtBA,EAASrC,UAAgCqC,EAASp1B,OAAS5I,EAASrB,OAAS,GAAKqB,EAASrB,OAAS,GAAKq/B,EAASn1B,IACvH2jB,EAAeuR,sBAAsBtqB,EAAOzT,EAASG,WAAY69B,GAErE,IACV,GA1iBL,kBA2iBI,SAAY7rB,EAAQsB,EAAO2O,EAAQvG,EAAiB7b,GAChD,IAKQsH,EACAE,EA2BJF,EACAE,EAlCE+I,GAAiBC,EAAAA,EAAAA,GAAwB2B,EAAO5B,gBAChDutB,EAAWtR,EAAe+P,wBAAwBhsB,EAAgBkD,EAAOzT,GACzEg+B,EAAWxR,EAAemQ,oBAAoBpsB,EAAgBkD,EAAOzT,GAC3E,IAAK6b,EA4BD,OAxBIiiB,GAAkC,IAAtBA,EAASnC,UAAgCmC,EAASl1B,OAAS5I,EAASrB,OAAS,GAAKqB,EAASrB,OAAS,GAAKm/B,EAASj1B,KAE9HvB,EAAcw2B,EAASl1B,MAAQ,EAC/BpB,EAAYs2B,EAASj1B,IAAM,GAEtBm1B,GAAkC,IAAtBA,EAASrC,UAAgCqC,EAASp1B,OAAS5I,EAASrB,OAAS,GAAKqB,EAASrB,OAAS,GAAKq/B,EAASn1B,KAEnIvB,EAAc02B,EAASp1B,MAAQ,EAC/BpB,EAAYw2B,EAASn1B,IAAM,IAIvBvB,EADAw2B,EACcA,EAASj1B,IAAM,EAGf,EAGdrB,EADAw2B,EACYA,EAASp1B,MAAQ,EAGjB6K,EAAMoS,iBAAiB7lB,EAASG,aAG7C,IAAImT,EAAAA,GAAkB,IAAIpT,EAAAA,EAAMF,EAASG,WAAYmH,EAAatH,EAASG,WAAYqH,GAAY,EAAG,IAAInB,EAAAA,EAASrG,EAASG,WAAYqH,GAAY,GAI3Js2B,GAAkC,IAAtBA,EAASnC,UAAgCmC,EAASl1B,MAAQ5I,EAASrB,OAAS,GAAKqB,EAASrB,OAAS,EAAIm/B,EAASj1B,KAE5HvB,EAAcw2B,EAASl1B,MAAQ,EAC/BpB,EAAYs2B,EAASj1B,IAAM,GAEtBm1B,GAAkC,IAAtBA,EAASrC,UAAgCqC,EAASp1B,MAAQ5I,EAASrB,OAAS,GAAKqB,EAASrB,OAAS,EAAIq/B,EAASn1B,KAEjIvB,EAAc02B,EAASp1B,MAAQ,EAC/BpB,EAAYw2B,EAASn1B,IAAM,IAG3BvB,EAActH,EAASrB,OACvB6I,EAAYxH,EAASrB,QAEzB,IACIA,EADEwB,EAAaH,EAASG,WAE5B,GAAIiiB,EAAOlO,eAAexM,iBAAiB1H,GACvCrB,EAASyjB,EAAOlO,eAAe1M,eAE9B,GAAIxH,EAAS8G,gBAAgBsb,EAAOlO,eAAejM,oBAAqB,CACzEtJ,EAAS2I,EACT,IAAM22B,EAAmB,IAAI53B,EAAAA,EAASlG,EAAYxB,GAC9CyjB,EAAOlO,eAAexM,iBAAiBu2B,KACvCt/B,EAASyjB,EAAOlO,eAAe1M,UAEtC,KACI,CACD7I,EAAS6I,EACT,IAAMy2B,EAAmB,IAAI53B,EAAAA,EAASlG,EAAYxB,GAC9CyjB,EAAOlO,eAAexM,iBAAiBu2B,KACvCt/B,EAASyjB,EAAOlO,eAAe5M,YAEtC,CACD,OAAO8a,EAAOgK,MAAK,EAAMjsB,EAAYxB,EAAQ,EAChD,KAjnBL,KAmnBau/B,EAAb,2JACI,SAA0Bnb,GACtB,IAAM0T,EAAa0H,EAAe,CAC9B3R,EAAe4R,eAAerb,EAAK,GACnCyJ,EAAe4R,eAAerb,EAAK,GACnCyJ,EAAe6R,oBAAoBtb,EAAItP,MAAOsP,EAAInP,aAGtD,OADA6iB,EAAWlf,KAAKrX,EAAAA,EAAAA,wBACTu2B,EAAW,EACrB,GATL,iCAUI,SAA2B1T,GACvB,IAAM0T,EAAa0H,EAAe,CAC9B3R,EAAe8R,gBAAgBvb,EAAK,GACpCyJ,EAAe8R,gBAAgBvb,EAAK,GACpCyJ,EAAe+R,qBAAqBxb,EAAItP,MAAOsP,EAAInP,aAGvD,OADA6iB,EAAWlf,KAAKrX,EAAAA,EAAAA,0BACTu2B,EAAW,EACrB,GAlBL,8BAmBI,SAAwBlmB,EAAgBkD,EAAOzT,GAC3C,IAAMy2B,EAAa0H,EAAe,CAC9B3R,EAAegS,aAAajuB,EAAgBkD,EAAOzT,EAAU,GAC7DwsB,EAAegS,aAAajuB,EAAgBkD,EAAOzT,EAAU,GAC7DwsB,EAAeiR,kBAAkBhqB,EAAOzT,KAG5C,OADAy2B,EAAWlf,KAAKlR,EAAAA,EAAAA,SACTowB,EAAW,EACrB,GA3BL,+BA4BI,SAAyBlmB,EAAgBkD,EAAOzT,GAC5C,IAAMy2B,EAAa0H,EAAe,CAC9B3R,EAAeiS,cAAcluB,EAAgBkD,EAAOzT,EAAU,GAC9DwsB,EAAeiS,cAAcluB,EAAgBkD,EAAOzT,EAAU,GAC9DwsB,EAAeoR,mBAAmBnqB,EAAOzT,KAG7C,OADAy2B,EAAWlf,KAAKlR,EAAAA,EAAAA,SACTowB,EAAW,EACrB,KApCL,GAAwCjK,GAsCxC,SAAS2R,EAAeO,GACpB,OAAOA,EAAIC,QAAO,SAAAC,GAAE,OAAIC,QAAQD,EAAZ,GACvB,C,gQC3pBKE,EAAkB,kBAAM,CAAN,EAClBC,EAAiB,kBAAM,CAAN,EACjBC,EAA4B,SAACt5B,GAAD,MAAkB,MAARA,GAAuB,OAARA,CAAzB,EACrBu5B,EAAb,WACI,WAAYC,EAAYC,EAAcC,EAAeC,IAA8B,eAC/EhiC,KAAKgiC,6BAA+BA,EACpChiC,KAAKiiC,mCAAgC91B,EACrCnM,KAAKkiC,YAAcL,EACnB,IAAM3hB,EAAU6hB,EAAc7hB,QACxBiiB,EAAajiB,EAAQzf,IAAI,KAC/BT,KAAKwjB,SAAWtD,EAAQzf,IAAI,IAC5BT,KAAKkB,QAAU4gC,EAAa5gC,QAC5BlB,KAAKwC,WAAas/B,EAAat/B,WAC/BxC,KAAKyI,aAAeq5B,EAAar5B,aACjCzI,KAAK8zB,eAAiB5T,EAAQzf,IAAI,KAClCT,KAAKoiC,WAAaliB,EAAQzf,IAAI,IAC9BT,KAAKirB,SAAWzpB,KAAKiB,IAAI,EAAGjB,KAAKsH,MAAMq5B,EAAWE,OAASriC,KAAKoiC,YAAc,GAC9EpiC,KAAK6sB,YAAc3M,EAAQzf,IAAI,KAC/BT,KAAKkT,eAAiBgN,EAAQzf,IAAI,KAClCT,KAAKmtB,wBAA0BjN,EAAQzf,IAAI,IAC3CT,KAAKsiC,2BAA6BpiB,EAAQzf,IAAI,IAC9CT,KAAK0a,4BAA8BwF,EAAQzf,IAAI,IAC/CT,KAAK01B,iBAAmBxV,EAAQzf,IAAI,IACpCT,KAAKyrB,oBAAsBvL,EAAQzf,IAAI,GACvCT,KAAK0rB,kBAAoBxL,EAAQzf,IAAI,GACrCT,KAAKwrB,kBAAoBtL,EAAQzf,IAAI,GACrCT,KAAKu4B,oBAAsBrY,EAAQzf,IAAI,GACvCT,KAAKu7B,aAAerb,EAAQzf,IAAI,IAChCT,KAAKs1B,WAAapV,EAAQzf,IAAI,GAC9BT,KAAKy7B,iBAAmB,CAAC,EACzBz7B,KAAKuiC,eAAiB,KACtBviC,KAAK85B,sBAAwB,CACzBC,MAAO/5B,KAAKwiC,oBAAoBX,EAAY7hC,KAAK0rB,mBACjDsO,QAASh6B,KAAKwiC,oBAAoBX,EAAY7hC,KAAKyrB,sBAEvDzrB,KAAKsiB,iBAAmBtiB,KAAKgiC,6BAA6BS,yBAAyBZ,GAAYa,sBAC/F,IAAMjH,EAAmBz7B,KAAKgiC,6BAA6BS,yBAAyBZ,GAAYc,sBAChG,GAAIlH,EAAkB,iBACCA,GADD,IAClB,IAAK,EAAL,qBAAqC,KAA1BlC,EAA0B,QACjCv5B,KAAKy7B,iBAAiBlC,EAAK9W,MAAQ8W,EAAKnN,KAC3C,CAHiB,+BAIrB,CACJ,CAvCL,0CAuDI,WACI,IAAIwW,EACJ,IAAK5iC,KAAKuiC,eAAgB,CACtBviC,KAAKuiC,eAAiB,CAAC,EACvB,IAAMrG,EAA0H,QAAzG0G,EAAK5iC,KAAKgiC,6BAA6BS,yBAAyBziC,KAAKkiC,aAAaW,yBAAsC,IAAPD,OAAgB,EAASA,EAAGE,wBACpK,GAAI5G,EAAe,iBACIA,GADJ,IACf,IAAK,EAAL,qBAAkC,KAAvB6G,EAAuB,QAC9B/iC,KAAKuiC,eAAeQ,IAAQ,CAC/B,CAHc,+BAIlB,CACJ,CACD,OAAO/iC,KAAKuiC,cACf,GAnEL,iCAuEI,SAAoBzW,EAAWjW,EAASvU,GACpC,IAAMu5B,GAAmBC,EAAAA,EAAAA,IAAuBjlB,EAASvU,EAAS,GAC5D0hC,EAA2BhjC,KAAKgiC,6BAA6BS,yBAAyB5H,EAAiBgH,YAAYgB,kBACzH,OAAKG,EAGEA,EAAyB5G,oBAAoBtQ,EAAW+O,EAAkBv5B,EAASu5B,EAAiBG,iBAFhG,IAGd,GA9EL,kCA+EI,SAAqBxyB,GACjB,OAAOD,EAAAA,EAAAA,GAAqBC,EAAKxI,KAAKwC,WAAYxC,KAAKyI,aAC1D,GAjFL,iCAkFI,SAAoBo5B,EAAYhI,GAC5B,OAAQA,GACJ,IAAK,mBACD,OAAO8H,EACX,IAAK,kBACD,OAAO3hC,KAAKijC,mCAAmCpB,GACnD,IAAK,SACD,OAAOJ,EACX,IAAK,QACD,OAAOC,EAElB,GA7FL,gDA8FI,SAAmCG,GAC/B,IAAMqB,EAAqBljC,KAAKgiC,6BAA6BS,yBAAyBZ,GAAYsB,wBAClG,OAAO,SAAA92B,GAAC,OAAuC,IAAnC62B,EAAmBrvB,QAAQxH,EAA/B,CACX,GAjGL,qCAsGI,SAAwB+J,EAAOzT,GAC3B,OAAO5B,EAAAA,EAAAA,wBAAsCqV,EAAMyV,eAAelpB,EAASG,YAAaH,EAASrB,OAAQtB,KAAKkB,QACjH,GAxGL,qCA6GI,SAAwBkV,EAAOtT,EAAY7B,GACvC,IAAMa,EAASf,EAAAA,EAAAA,wBAAsCqV,EAAMyV,eAAe/oB,GAAa7B,EAAejB,KAAKkB,SACrG0yB,EAAYxd,EAAM2a,iBAAiBjuB,GACzC,GAAIhB,EAAS8xB,EACT,OAAOA,EAEX,IAAMxJ,EAAYhU,EAAMoS,iBAAiB1lB,GACzC,OAAIhB,EAASsoB,EACFA,EAEJtoB,CACV,IAxHL,6BAwCI,SAAsB8c,GAClB,OAAQA,EAAEwkB,WAAW,MACdxkB,EAAEwkB,WAAW,MACbxkB,EAAEwkB,WAAW,KACbxkB,EAAEwkB,WAAW,KACbxkB,EAAEwkB,WAAW,KACbxkB,EAAEwkB,WAAW,IACbxkB,EAAEwkB,WAAW,IACbxkB,EAAEwkB,WAAW,IACbxkB,EAAEwkB,WAAW,IACbxkB,EAAEwkB,WAAW,KACbxkB,EAAEwkB,WAAW,MACbxkB,EAAEwkB,WAAW,KACbxkB,EAAEwkB,WAAW,GACvB,KAtDL,KA0Ha5sB,EAAb,WACI,WAAYF,EAAYG,IAAW,eAC/BzW,KAAKqjC,uBAAoBl3B,EACzBnM,KAAKsW,WAAaA,EAClBtW,KAAKyW,UAAYA,CACpB,CALL,qCAwBI,SAAOnN,GACH,OAAQtJ,KAAKyW,UAAUlN,OAAOD,EAAMmN,YAAczW,KAAKsW,WAAW/M,OAAOD,EAAMgN,WAClF,IA1BL,6BAMI,SAAsBA,GAClB,OAAO,IAAIgtB,EAAwBhtB,EACtC,GARL,2BASI,SAAqBG,GACjB,OAAO,IAAI8sB,EAAuB9sB,EACrC,GAXL,gCAYI,SAA0B+sB,GACtB,IAAMjtB,EAAYhK,EAAAA,EAAAA,cAAwBi3B,GACpCltB,EAAa,IAAIL,EAAkBpT,EAAAA,EAAAA,cAAoB0T,EAAUktB,qBAAsB,EAAGltB,EAAUiO,cAAe,GACzH,OAAOhO,EAAYktB,eAAeptB,EACrC,GAhBL,iCAiBI,SAA2BqtB,GAEvB,IADA,IAAMvqB,EAAS,GACNxY,EAAI,EAAGwH,EAAMu7B,EAAgBjiC,OAAQd,EAAIwH,EAAKxH,IACnDwY,EAAOxY,GAAKZ,KAAK4jC,mBAAmBD,EAAgB/iC,IAExD,OAAOwY,CACV,KAvBL,KA4BakqB,GAAb,QACI,WAAYhtB,IAAY,eACpBtW,KAAKsW,WAAaA,EAClBtW,KAAKyW,UAAY,IACpB,IAEQ8sB,GAAb,QACI,WAAY9sB,IAAW,eACnBzW,KAAKsW,WAAa,KAClBtW,KAAKyW,UAAYA,CACpB,IAKQR,EAAb,WACI,WAAYY,EAAgBE,EAAsCpU,EAAUsU,IAAwB,eAChGjX,KAAK6jC,6BAA0B13B,EAC/BnM,KAAK6W,eAAiBA,EACtB7W,KAAK+W,qCAAuCA,EAC5C/W,KAAK2C,SAAWA,EAChB3C,KAAKiX,uBAAyBA,EAC9BjX,KAAKuW,UAAYN,EAAkB6tB,kBAAkB9jC,KAAK6W,eAAgB7W,KAAK2C,SAClF,CARL,qCASI,SAAO2G,GACH,OAAQtJ,KAAK+W,uCAAyCzN,EAAMyN,sCACrD/W,KAAKiX,yBAA2B3N,EAAM2N,wBACtCjX,KAAK2C,SAAS4G,OAAOD,EAAM3G,WAC3B3C,KAAK6W,eAAenM,YAAYpB,EAAMuN,eAChD,GAdL,0BAeI,WACI,OAAS7W,KAAKuW,UAAUnM,YAAcpK,KAAK6W,eAAezM,SAC7D,GAjBL,kBAkBI,SAAKoU,EAAiB1b,EAAYxB,EAAQ2V,GACtC,OAAIuH,EAEO,IAAIvI,EAAkBjW,KAAK6W,eAAgB7W,KAAK+W,qCAAsC,IAAI/N,EAAAA,EAASlG,EAAYxB,GAAS2V,GAIxH,IAAIhB,EAAkB,IAAIpT,EAAAA,EAAMC,EAAYxB,EAAQwB,EAAYxB,GAAS2V,EAAwB,IAAIjO,EAAAA,EAASlG,EAAYxB,GAAS2V,EAEjJ,IA3BL,gCA4BI,SAAyBJ,EAAgBlU,GACrC,OAAIkU,EAAezM,YAAczH,EAAS8G,gBAAgBoN,EAAejM,oBAC9D2B,EAAAA,EAAAA,cAAwBsK,EAAejM,mBAAoBjI,GAG3D4J,EAAAA,EAAAA,cAAwBsK,EAAelM,iBAAkBhI,EAEvE,KAnCL,KAqCakiB,GAAb,QACI,WAAYjd,EAAMmZ,EAAUgjB,IAAM,eAC9B/jC,KAAKgkC,+BAA4B73B,EACjCnM,KAAK4H,KAAOA,EACZ5H,KAAK+gB,SAAWA,EAChB/gB,KAAK2gB,6BAA+BojB,EAAKpjB,6BACzC3gB,KAAKshB,4BAA8ByiB,EAAKziB,2BAC3C,IAEE,SAAS0K,EAAQqM,GACpB,MAAe,MAAPA,GAAsB,MAAPA,GAAqB,MAAPA,CACxC,C,wGC3ND,SAAS4L,EAAYC,EAAkBC,EAAkBC,EAA6BC,GAElF,OADiB,IAAIC,EAAAA,GAAQJ,EAAkBC,EAAkBC,GACjDG,YAAYF,EAC/B,C,IACKG,EAAAA,WACF,WAAY7O,IAAO,eAGf,IAFA,IAAM8O,EAAe,GACfC,EAAa,GACV9jC,EAAI,EAAGc,EAASi0B,EAAMj0B,OAAQd,EAAIc,EAAQd,IAC/C6jC,EAAa7jC,GAAK+jC,EAAuBhP,EAAM/0B,GAAI,GACnD8jC,EAAW9jC,GAAKgkC,EAAsBjP,EAAM/0B,GAAI,GAEpDZ,KAAK21B,MAAQA,EACb31B,KAAK6kC,cAAgBJ,EACrBzkC,KAAK8kC,YAAcJ,CACtB,C,0CACD,WAEI,IADA,IAAMK,EAAW,GACRnkC,EAAI,EAAGwH,EAAMpI,KAAK21B,MAAMj0B,OAAQd,EAAIwH,EAAKxH,IAC9CmkC,EAASnkC,GAAKZ,KAAK21B,MAAM/0B,GAAGgB,UAAU5B,KAAK6kC,cAAcjkC,GAAK,EAAGZ,KAAK8kC,YAAYlkC,GAAK,GAE3F,OAAOmkC,CACV,G,8BACD,SAAiBvvB,GACb,OAAOxV,KAAK21B,MAAMngB,EACrB,G,gCACD,SAAmB5U,GACf,OAAOA,EAAI,CACd,G,8BACD,SAAiBA,GACb,OAAOA,EAAI,CACd,G,gCACD,SAAmBokC,EAA4BpJ,EAAYC,GAKvD,IAJA,IAAMoJ,EAAY,GACZC,EAAc,GACdC,EAAU,GACZ/8B,EAAM,EACDoN,EAAQomB,EAAYpmB,GAASqmB,EAAUrmB,IAI5C,IAHA,IAAMnU,EAAcrB,KAAK21B,MAAMngB,GACzBvL,EAAe+6B,EAA6BhlC,KAAK6kC,cAAcrvB,GAAS,EACxErL,EAAa66B,EAA6BhlC,KAAK8kC,YAAYtvB,GAASnU,EAAYK,OAAS,EACtF0jC,EAAMn7B,EAAam7B,EAAMj7B,EAAWi7B,IACzCH,EAAU78B,GAAO/G,EAAYiH,WAAW88B,EAAM,GAC9CF,EAAY98B,GAAOoN,EAAQ,EAC3B2vB,EAAQ/8B,GAAOg9B,EACfh9B,IAGR,OAAO,IAAIi9B,EAAaJ,EAAWC,EAAaC,EACnD,K,EA7CCX,GA+CAa,EAAAA,WACF,WAAYJ,EAAWC,EAAaC,IAAS,eACzCnlC,KAAKslC,WAAaL,EAClBjlC,KAAKulC,aAAeL,EACpBllC,KAAKwlC,SAAWL,CACnB,C,0CACD,WACI,OAAOnlC,KAAKslC,UACf,G,gCACD,SAAmB1kC,GACf,OAAOZ,KAAKulC,aAAa3kC,EAC5B,G,4BACD,SAAeA,GACX,OAAOZ,KAAKwlC,SAAS5kC,EACxB,G,8BACD,SAAiBA,GACb,OAAOZ,KAAKulC,aAAa3kC,EAC5B,G,0BACD,SAAaA,GACT,OAAOZ,KAAKwlC,SAAS5kC,GAAK,CAC7B,K,EApBCykC,GAsBAI,EAAAA,WACF,WAAYC,EAAyBC,EAAqBC,EAAuBC,EAAmBC,EAAyBC,EAAqBC,EAAuBC,IAAmB,eACxLjmC,KAAK0lC,wBAA0BA,EAC/B1lC,KAAK2lC,oBAAsBA,EAC3B3lC,KAAK4lC,sBAAwBA,EAC7B5lC,KAAK6lC,kBAAoBA,EACzB7lC,KAAK8lC,wBAA0BA,EAC/B9lC,KAAK+lC,oBAAsBA,EAC3B/lC,KAAKgmC,sBAAwBA,EAC7BhmC,KAAKimC,kBAAoBA,CAC5B,C,wDACD,SAA4BC,EAAYC,EAAsBC,GAC1D,IAAIV,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAyBJ,OAxBkC,IAA9BC,EAAWG,gBACXX,EAA0B,EAC1BC,EAAsB,EACtBC,EAAwB,EACxBC,EAAoB,IAGpBH,EAA0BS,EAAqBG,mBAAmBJ,EAAWK,eAC7EZ,EAAsBQ,EAAqBK,eAAeN,EAAWK,eACrEX,EAAwBO,EAAqBM,iBAAiBP,EAAWK,cAAgBL,EAAWG,eAAiB,GACrHR,EAAoBM,EAAqBO,aAAaR,EAAWK,cAAgBL,EAAWG,eAAiB,IAE/E,IAA9BH,EAAWS,gBACXb,EAA0B,EAC1BC,EAAsB,EACtBC,EAAwB,EACxBC,EAAoB,IAGpBH,EAA0BM,EAAqBE,mBAAmBJ,EAAWU,eAC7Eb,EAAsBK,EAAqBI,eAAeN,EAAWU,eACrEZ,EAAwBI,EAAqBK,iBAAiBP,EAAWU,cAAgBV,EAAWS,eAAiB,GACrHV,EAAoBG,EAAqBM,aAAaR,EAAWU,cAAgBV,EAAWS,eAAiB,IAE1G,IAAIlB,EAAWC,EAAyBC,EAAqBC,EAAuBC,EAAmBC,EAAyBC,EAAqBC,EAAuBC,EACtL,K,EA7CCR,G,IAwEAoB,EAAAA,WACF,WAAYnB,EAAyBE,EAAuBE,EAAyBE,EAAuBc,IAAa,eACrH9mC,KAAK0lC,wBAA0BA,EAC/B1lC,KAAK4lC,sBAAwBA,EAC7B5lC,KAAK8lC,wBAA0BA,EAC/B9lC,KAAKgmC,sBAAwBA,EAC7BhmC,KAAK8mC,YAAcA,CACtB,C,wDACD,SAA4B9B,EAA4BkB,EAAYa,EAAsBC,EAAsBC,EAAkBC,EAA0BC,GACxJ,IAAIzB,EACAE,EACAE,EACAE,EACAc,OAAc36B,EAiBlB,GAhBkC,IAA9B+5B,EAAWG,gBACXX,EAA0BqB,EAAqBT,mBAAmBJ,EAAWK,eAAiB,EAC9FX,EAAwB,IAGxBF,EAA0BqB,EAAqBT,mBAAmBJ,EAAWK,eAC7EX,EAAwBmB,EAAqBN,iBAAiBP,EAAWK,cAAgBL,EAAWG,eAAiB,IAEvF,IAA9BH,EAAWS,gBACXb,EAA0BkB,EAAqBV,mBAAmBJ,EAAWU,eAAiB,EAC9FZ,EAAwB,IAGxBF,EAA0BkB,EAAqBV,mBAAmBJ,EAAWU,eAC7EZ,EAAwBgB,EAAqBP,iBAAiBP,EAAWU,cAAgBV,EAAWS,eAAiB,IAErHO,GAA4BhB,EAAWG,eAAiB,GAAKH,EAAWG,eAAiB,IAAMH,EAAWS,eAAiB,GAAKT,EAAWS,eAAiB,IAAMM,IAAoB,CAEtL,IAAMd,EAAuBY,EAAqBK,mBAAmBpC,EAA4BkB,EAAWK,cAAeL,EAAWK,cAAgBL,EAAWG,eAAiB,GAC5KD,EAAuBY,EAAqBI,mBAAmBpC,EAA4BkB,EAAWU,cAAeV,EAAWU,cAAgBV,EAAWS,eAAiB,GAC9KU,EAAapD,EAAYkC,EAAsBC,EAAsBa,GAAkB,GAAMK,QAC7FH,IACAE,EA7DhB,SAAgCA,GAC5B,GAAIA,EAAW3lC,QAAU,EACrB,OAAO2lC,EAIX,IAFA,IAAMvlC,EAAS,CAACulC,EAAW,IACvBE,EAAazlC,EAAO,GACflB,EAAI,EAAGwH,EAAMi/B,EAAW3lC,OAAQd,EAAIwH,EAAKxH,IAAK,CACnD,IAAM4mC,EAAaH,EAAWzmC,GACxB6mC,EAAyBD,EAAWjB,eAAiBgB,EAAWhB,cAAgBgB,EAAWlB,gBAC3FqB,EAAyBF,EAAWZ,eAAiBW,EAAWX,cAAgBW,EAAWZ,gBAE1EnlC,KAAKC,IAAIgmC,EAAwBC,GApItB,GAuI9BH,EAAWlB,eAAkBmB,EAAWjB,cAAgBiB,EAAWnB,eAAkBkB,EAAWhB,cAChGgB,EAAWZ,eAAkBa,EAAWZ,cAAgBY,EAAWb,eAAkBY,EAAWX,gBAIhG9kC,EAAO+N,KAAK23B,GACZD,EAAaC,EAEpB,CACD,OAAO1lC,CACV,CAqC4B6lC,CAAuBN,IAExCP,EAAc,GACd,IAAK,IAAIlmC,EAAI,EAAGc,EAAS2lC,EAAW3lC,OAAQd,EAAIc,EAAQd,IACpDkmC,EAAYj3B,KAAK41B,EAAWmC,qBAAqBP,EAAWzmC,GAAIulC,EAAsBC,GAE7F,CACD,OAAO,IAAIS,EAAWnB,EAAyBE,EAAuBE,EAAyBE,EAAuBc,EACzH,K,EA5CCD,GA8COgB,EAAb,WACI,WAAYC,EAAeC,EAAehE,IAAM,eAC5C/jC,KAAKknC,yBAA2BnD,EAAKmD,yBACrClnC,KAAKmnC,6BAA+BpD,EAAKoD,6BACzCnnC,KAAKglC,2BAA6BjB,EAAKiB,2BACvChlC,KAAKgoC,qBAAuBjE,EAAKiE,qBACjChoC,KAAK8nC,cAAgBA,EACrB9nC,KAAK+nC,cAAgBA,EACrB/nC,KAAKioC,SAAW,IAAIzD,EAAasD,GACjC9nC,KAAKkoC,SAAW,IAAI1D,EAAauD,GACjC/nC,KAAKmoC,iBAAmBC,EAAkCrE,EAAKsE,oBAC/DroC,KAAKinC,iBAAmBmB,EAA8D,IAA5BrE,EAAKsE,mBAA2B,EAAI7mC,KAAKC,IAAIsiC,EAAKsE,mBAAoB,KACnI,CAZL,0CAaI,WACI,GAAmC,IAA/BroC,KAAKioC,SAAStS,MAAMj0B,QAAkD,IAAlC1B,KAAKioC,SAAStS,MAAM,GAAGj0B,OAE3D,OAAmC,IAA/B1B,KAAKkoC,SAASvS,MAAMj0B,QAAkD,IAAlC1B,KAAKkoC,SAASvS,MAAM,GAAGj0B,OACpD,CACH4mC,WAAW,EACXhB,QAAS,IAGV,CACHgB,WAAW,EACXhB,QAAS,CAAC,CACF5B,wBAAyB,EACzBE,sBAAuB,EACvBE,wBAAyB,EACzBE,sBAAuBhmC,KAAKkoC,SAASvS,MAAMj0B,OAC3ColC,YAAa,CAAC,CACNb,kBAAmB,EACnBD,sBAAuB,EACvBD,oBAAqB,EACrBD,wBAAyB,EACzBD,kBAAmB,EACnBD,sBAAuB,EACvBD,oBAAqB,EACrBD,wBAAyB,OAKjD,GAAmC,IAA/B1lC,KAAKkoC,SAASvS,MAAMj0B,QAAkD,IAAlC1B,KAAKkoC,SAASvS,MAAM,GAAGj0B,OAE3D,MAAO,CACH4mC,WAAW,EACXhB,QAAS,CAAC,CACF5B,wBAAyB,EACzBE,sBAAuB5lC,KAAKioC,SAAStS,MAAMj0B,OAC3CokC,wBAAyB,EACzBE,sBAAuB,EACvBc,YAAa,CAAC,CACNb,kBAAmB,EACnBD,sBAAuB,EACvBD,oBAAqB,EACrBD,wBAAyB,EACzBD,kBAAmB,EACnBD,sBAAuB,EACvBD,oBAAqB,EACrBD,wBAAyB,OAKjD,IAAM6C,EAAatE,EAAYjkC,KAAKioC,SAAUjoC,KAAKkoC,SAAUloC,KAAKmoC,iBAAkBnoC,KAAKgoC,sBACnFX,EAAakB,EAAWjB,QACxBgB,EAAYC,EAAWD,UAG7B,GAAItoC,KAAKglC,2BAA4B,CAEjC,IADA,IAAMwD,EAAc,GACX5nC,EAAI,EAAGc,EAAS2lC,EAAW3lC,OAAQd,EAAIc,EAAQd,IACpD4nC,EAAY34B,KAAKg3B,EAAW4B,qBAAqBzoC,KAAKglC,2BAA4BqC,EAAWzmC,GAAIZ,KAAKioC,SAAUjoC,KAAKkoC,SAAUloC,KAAKinC,iBAAkBjnC,KAAKknC,yBAA0BlnC,KAAKmnC,+BAE9L,MAAO,CACHmB,UAAWA,EACXhB,QAASkB,EAEhB,CAMD,IAHA,IAAM1mC,EAAS,GACX4mC,EAAoB,EACpBC,EAAoB,EACf/nC,GAAK,EAAcwH,EAAMi/B,EAAW3lC,OAAQd,EAAIwH,EAAKxH,IAAK,CAI/D,IAHA,IAAMgoC,EAAchoC,EAAI,EAAIwH,EAAMi/B,EAAWzmC,EAAI,GAAK,KAChDioC,EAAgBD,EAAaA,EAAWrC,cAAgBvmC,KAAK8nC,cAAcpmC,OAC3EonC,EAAgBF,EAAaA,EAAWhC,cAAgB5mC,KAAK+nC,cAAcrmC,OAC1EgnC,EAAoBG,GAAgBF,EAAoBG,GAAc,CACzE,IAAMC,EAAe/oC,KAAK8nC,cAAcY,GAClCM,EAAehpC,KAAK+nC,cAAcY,GACxC,GAAII,IAAiBC,EAAc,CAM3B,IAFA,IAAIrD,EAAsBhB,EAAuBoE,EAAc,GAC3DhD,EAAsBpB,EAAuBqE,EAAc,GACxDrD,EAAsB,GAAKI,EAAsB,GAAG,CAGvD,GAFqBgD,EAAazgC,WAAWq9B,EAAsB,KAC9CqD,EAAa1gC,WAAWy9B,EAAsB,GAE/D,MAEJJ,IACAI,GACH,EACGJ,EAAsB,GAAKI,EAAsB,IACjD/lC,KAAKipC,8BAA8BnnC,EAAQ4mC,EAAoB,EAAG,EAAG/C,EAAqBgD,EAAoB,EAAG,EAAG5C,GASxH,IAJA,IAAIF,EAAoBjB,EAAsBmE,EAAc,GACxD9C,EAAoBrB,EAAsBoE,EAAc,GACtDE,EAAoBH,EAAarnC,OAAS,EAC1CynC,EAAoBH,EAAatnC,OAAS,EACzCmkC,EAAoBqD,GAAqBjD,EAAoBkD,GAAmB,CAGnF,GAFqBJ,EAAazgC,WAAWu9B,EAAoB,KAC5CkD,EAAazgC,WAAW29B,EAAoB,GAE7D,MAEJJ,IACAI,GACH,EACGJ,EAAoBqD,GAAqBjD,EAAoBkD,IAC7DnpC,KAAKipC,8BAA8BnnC,EAAQ4mC,EAAoB,EAAG7C,EAAmBqD,EAAmBP,EAAoB,EAAG1C,EAAmBkD,EAG7J,CACDT,IACAC,GACH,CACGC,IAEA9mC,EAAO+N,KAAKg3B,EAAW4B,qBAAqBzoC,KAAKglC,2BAA4B4D,EAAY5oC,KAAKioC,SAAUjoC,KAAKkoC,SAAUloC,KAAKinC,iBAAkBjnC,KAAKknC,yBAA0BlnC,KAAKmnC,+BAClLuB,GAAqBE,EAAWvC,eAChCsC,GAAqBC,EAAWjC,eAEvC,CACD,MAAO,CACH2B,UAAWA,EACXhB,QAASxlC,EAEhB,GAhJL,2CAiJI,SAA8BA,EAAQsnC,EAAoBzD,EAAqBE,EAAmBwD,EAAoBtD,EAAqBE,GACvI,IAAIjmC,KAAKspC,+BAA+BxnC,EAAQsnC,EAAoBzD,EAAqBE,EAAmBwD,EAAoBtD,EAAqBE,GAArJ,CAIA,IAAIa,OAAc36B,EACdnM,KAAKknC,2BACLJ,EAAc,CAAC,IAAIrB,EAAW2D,EAAoBzD,EAAqByD,EAAoBvD,EAAmBwD,EAAoBtD,EAAqBsD,EAAoBpD,KAE/KnkC,EAAO+N,KAAK,IAAIg3B,EAAWuC,EAAoBA,EAAoBC,EAAoBA,EAAoBvC,GAL1G,CAMJ,GA3JL,4CA4JI,SAA+BhlC,EAAQsnC,EAAoBzD,EAAqBE,EAAmBwD,EAAoBtD,EAAqBE,GACxI,IAAM79B,EAAMtG,EAAOJ,OACnB,GAAY,IAAR0G,EACA,OAAO,EAEX,IAAMm/B,EAAazlC,EAAOsG,EAAM,GAChC,OAAyC,IAArCm/B,EAAW3B,uBAAoE,IAArC2B,EAAWvB,wBAIrDuB,EAAW3B,sBAAwB,IAAMwD,GAAsB7B,EAAWvB,sBAAwB,IAAMqD,IACxG9B,EAAW3B,sBAAwBwD,EACnC7B,EAAWvB,sBAAwBqD,EAC/BrpC,KAAKknC,0BAA4BK,EAAWT,aAC5CS,EAAWT,YAAYj3B,KAAK,IAAI41B,EAAW2D,EAAoBzD,EAAqByD,EAAoBvD,EAAmBwD,EAAoBtD,EAAqBsD,EAAoBpD,KAErL,GAGd,KA/KL,KAiLA,SAAStB,EAAuB4E,EAAKzpC,GACjC,IAAMkM,EAAI5K,EAAAA,GAAgCmoC,GAC1C,OAAW,IAAPv9B,EACOlM,EAEJkM,EAAI,CACd,CACD,SAAS44B,EAAsB2E,EAAKzpC,GAChC,IAAMkM,EAAI5K,EAAAA,GAA+BmoC,GACzC,OAAW,IAAPv9B,EACOlM,EAEJkM,EAAI,CACd,CACD,SAASo8B,EAAkCoB,GACvC,GAAuB,IAAnBA,EACA,OAAO,kBAAM,CAAN,EAEX,IAAMC,EAAYz0B,KAAKC,MACvB,OAAO,WACH,OAAOD,KAAKC,MAAQw0B,EAAYD,CACnC,CACJ,C,kFCzYYE,EAAb,WACI,WAAYpiB,EAAIqiB,EAAOC,EAAOC,EAAcC,EAAKC,IAAmB,eAChE/pC,KAAKsnB,GAAKA,EACVtnB,KAAK2pC,MAAQA,EACb3pC,KAAK4pC,MAAQA,EACb5pC,KAAKgqC,cAAgBH,EACrB7pC,KAAKiqC,KAAOH,EACZ9pC,KAAKkqC,mBAAqBH,CAC7B,CARL,0CASI,WACI,OAAO/pC,KAAKkqC,mBAAmBC,oBAAoBnqC,KAAKgqC,cAC3D,GAXL,iBAYI,WACI,OAAKhqC,KAAKoqC,cAGHpqC,KAAKiqC,OAFDI,QAAQC,aAAQn+B,EAG9B,KAjBL,I,wDCDO,IAAMo+B,EAAa,CACtBC,YAAa,wBACbC,YAAa,wB,4DCCNC,E,uBACX,SAAWA,GACPA,EAAkBC,kBAAoB,IAAIC,EAAAA,GAAc,qBAAqB,GAAO,GAKpFF,EAAkBG,gBAAkB,IAAID,EAAAA,GAAc,mBAAmB,EAAOvnC,EAAAA,EAAa,kBAAmB,2DAIhHqnC,EAAkBI,MAAQ,IAAIF,EAAAA,GAAc,eAAe,EAAOvnC,EAAAA,EAAa,cAAe,wFAI9FqnC,EAAkBK,eAAiB,IAAIH,EAAAA,GAAc,kBAAkB,EAAOvnC,EAAAA,EAAa,iBAAkB,0EAC7GqnC,EAAkBlnB,SAAW,IAAIonB,EAAAA,GAAc,kBAAkB,EAAOvnC,EAAAA,EAAa,iBAAkB,oCACvGqnC,EAAkBM,aAAe,IAAIJ,EAAAA,GAAc,gBAAgB,EAAOvnC,EAAAA,EAAa,eAAgB,yCACvGqnC,EAAkBO,gBAAkB,IAAIL,EAAAA,GAAc,yBAAyB,EAAOvnC,EAAAA,EAAa,wBAAyB,gDAC5HqnC,EAAkBQ,SAAWR,EAAkBlnB,SAAS2nB,YACxDT,EAAkBU,qBAAuB,IAAIR,EAAAA,GAAc,sBAAsB,EAAOvnC,EAAAA,EAAa,qBAAsB,yCAC3HqnC,EAAkBW,sBAAwBX,EAAkBU,qBAAqBD,YACjFT,EAAkBY,sBAAwB,IAAIV,EAAAA,GAAc,+BAA+B,EAAOvnC,EAAAA,EAAa,8BAA+B,+CAC9IqnC,EAAkBa,mBAAqBb,EAAkBY,sBAAsBH,YAC/ET,EAAkBc,cAAgB,IAAIZ,EAAAA,GAAc,uBAAuB,EAAOvnC,EAAAA,EAAa,sBAAuB,oDACtHqnC,EAAkBe,oBAAsBf,EAAkBc,cAAcL,YACxET,EAAkBgB,uBAAyB,IAAId,EAAAA,GAAc,sBAAsB,GAAO,GAC1FF,EAAkBiB,QAAU,IAAIf,EAAAA,GAAc,WAAW,GAAO,GAChEF,EAAkBkB,QAAU,IAAIhB,EAAAA,GAAc,WAAW,GAAO,GAChEF,EAAkBmB,aAAe,IAAIjB,EAAAA,GAAc,sBAAsB,EAAOvnC,EAAAA,EAAa,qBAAsB,wCAKnHqnC,EAAkBoB,kBAAoB,IAAIlB,EAAAA,GAAc,yBAAqBz+B,EAAW9I,EAAAA,EAAa,oBAAqB,mEAC1HqnC,EAAkBqB,qBAAuBrB,EAAkBoB,kBAAkBX,YAE7ET,EAAkB7I,WAAa,IAAI+I,EAAAA,GAAc,eAAgB,GAAIvnC,EAAAA,EAAa,eAAgB,0CAClGqnC,EAAkBsB,0BAA4B,IAAIpB,EAAAA,GAAc,mCAAmC,EAAOvnC,EAAAA,EAAa,kCAAmC,sDAC1JqnC,EAAkBuB,uBAAyB,IAAIrB,EAAAA,GAAc,gCAAgC,EAAOvnC,EAAAA,EAAa,+BAAgC,mDACjJqnC,EAAkBwB,oBAAsB,IAAItB,EAAAA,GAAc,6BAA6B,EAAOvnC,EAAAA,EAAa,4BAA6B,gDACxIqnC,EAAkByB,sBAAwB,IAAIvB,EAAAA,GAAc,+BAA+B,EAAOvnC,EAAAA,EAAa,8BAA+B,iDAC9IqnC,EAAkB0B,uBAAyB,IAAIxB,EAAAA,GAAc,gCAAgC,EAAOvnC,EAAAA,EAAa,+BAAgC,kDACjJqnC,EAAkB2B,0BAA4B,IAAIzB,EAAAA,GAAc,mCAAmC,EAAOvnC,EAAAA,EAAa,kCAAmC,sDAC1JqnC,EAAkB4B,0BAA4B,IAAI1B,EAAAA,GAAc,mCAAmC,EAAOvnC,EAAAA,EAAa,kCAAmC,sDAC1JqnC,EAAkB6B,iBAAmB,IAAI3B,EAAAA,GAAc,0BAA0B,EAAOvnC,EAAAA,EAAa,yBAA0B,4CAC/HqnC,EAAkB8B,6BAA+B,IAAI5B,EAAAA,GAAc,sCAAsC,EAAOvnC,EAAAA,EAAa,qCAAsC,yDACnKqnC,EAAkB+B,0BAA4B,IAAI7B,EAAAA,GAAc,mCAAmC,EAAOvnC,EAAAA,EAAa,kCAAmC,sDAC1JqnC,EAAkBgC,qBAAuB,IAAI9B,EAAAA,GAAc,8BAA8B,EAAOvnC,EAAAA,EAAa,6BAA8B,gDAC3IqnC,EAAkBiC,kBAAoB,IAAI/B,EAAAA,GAAc,2BAA2B,EAAOvnC,EAAAA,EAAa,0BAA2B,6CAClIqnC,EAAkBkC,yBAA2B,IAAIhC,EAAAA,GAAc,kCAAkC,EAAOvnC,EAAAA,EAAa,iCAAkC,qDACvJqnC,EAAkBmC,sBAAwB,IAAIjC,EAAAA,GAAc,+BAA+B,EAAOvnC,EAAAA,EAAa,8BAA+B,oDAE9IqnC,EAAkBoC,8BAAgC,IAAIlC,EAAAA,GAAc,uCAAuC,EAAOvnC,EAAAA,EAAa,sCAAuC,0DACtKqnC,EAAkBqC,uCAAyC,IAAInC,EAAAA,GAAc,gDAAgD,EAAOvnC,EAAAA,EAAa,+CAAgD,oEACjMqnC,EAAkBsC,sCAAwC,IAAIpC,EAAAA,GAAc,+CAA+C,EAAOvnC,EAAAA,EAAa,8CAA+C,kEAC9LqnC,EAAkBuC,+CAAiD,IAAIrC,EAAAA,GAAc,wDAAwD,EAAOvnC,EAAAA,EAAa,uDAAwD,2EAvD7N,EAwDGqnC,IAAsBA,EAAoB,CAAC,G,kFC3DjCwC,EAAb,WACI,WAAYhmC,IAAO,eACflH,KAAKmtC,OAASjmC,CACjB,CAHL,iCAII,WACI,OAAOlH,KAAKmtC,OAAOvlC,IACtB,GANL,iBAOI,WACI,OAAO5H,KAAKmtC,MACf,GATL,oBAUI,SAAOjmC,GACHlH,KAAKmtC,OAASjmC,CACjB,GAZL,sBAaI,SAASkmC,GACL,OAAOptC,KAAKmtC,OAAO9lC,SAAS+lC,EAC/B,KAfL,I","sources":["../node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js","../node_modules/monaco-editor/esm/vs/editor/common/core/cursorColumns.js","../node_modules/monaco-editor/esm/vs/editor/common/core/editOperation.js","../node_modules/monaco-editor/esm/vs/editor/common/core/editorColorRegistry.js","../node_modules/monaco-editor/esm/vs/editor/common/core/eolCounter.js","../node_modules/monaco-editor/esm/vs/editor/common/core/indentation.js","../node_modules/monaco-editor/esm/vs/editor/common/core/position.js","../node_modules/monaco-editor/esm/vs/editor/common/core/range.js","../node_modules/monaco-editor/esm/vs/editor/common/core/rgba.js","../node_modules/monaco-editor/esm/vs/editor/common/core/selection.js","../node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js","../node_modules/monaco-editor/esm/vs/editor/common/core/textChange.js","../node_modules/monaco-editor/esm/vs/editor/common/core/textModelDefaults.js","../node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js","../node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/oneCursor.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorCollection.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorContext.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursor.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorAtomicMoveOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorColumnSelection.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorDeleteOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorMoveCommands.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorMoveOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorTypeOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursor/cursorWordOperations.js","../node_modules/monaco-editor/esm/vs/editor/common/cursorCommon.js","../node_modules/monaco-editor/esm/vs/editor/common/diff/diffComputer.js","../node_modules/monaco-editor/esm/vs/editor/common/editorAction.js","../node_modules/monaco-editor/esm/vs/editor/common/editorCommon.js","../node_modules/monaco-editor/esm/vs/editor/common/editorContextKeys.js","../node_modules/monaco-editor/esm/vs/editor/common/editorTheme.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { toUint8 } from '../../../base/common/uint.js';\n/**\n * A fast character classifier that uses a compact array for ASCII values.\n */\nexport class CharacterClassifier {\n    constructor(_defaultValue) {\n        const defaultValue = toUint8(_defaultValue);\n        this._defaultValue = defaultValue;\n        this._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);\n        this._map = new Map();\n    }\n    static _createAsciiMap(defaultValue) {\n        const asciiMap = new Uint8Array(256);\n        for (let i = 0; i < 256; i++) {\n            asciiMap[i] = defaultValue;\n        }\n        return asciiMap;\n    }\n    set(charCode, _value) {\n        const value = toUint8(_value);\n        if (charCode >= 0 && charCode < 256) {\n            this._asciiMap[charCode] = value;\n        }\n        else {\n            this._map.set(charCode, value);\n        }\n    }\n    get(charCode) {\n        if (charCode >= 0 && charCode < 256) {\n            return this._asciiMap[charCode];\n        }\n        else {\n            return (this._map.get(charCode) || this._defaultValue);\n        }\n    }\n}\nexport class CharacterSet {\n    constructor() {\n        this._actual = new CharacterClassifier(0 /* False */);\n    }\n    add(charCode) {\n        this._actual.set(charCode, 1 /* True */);\n    }\n    has(charCode) {\n        return (this._actual.get(charCode) === 1 /* True */);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\n/**\n * A column in a position is the gap between two adjacent characters. The methods here\n * work with a concept called \"visible column\". A visible column is a very rough approximation\n * of the horizontal screen position of a column. For example, using a tab size of 4:\n * ```txt\n * |<TAB>|<TAB>|T|ext\n * |     |     | \\---- column = 4, visible column = 9\n * |     |     \\------ column = 3, visible column = 8\n * |     \\------------ column = 2, visible column = 4\n * \\------------------ column = 1, visible column = 0\n * ```\n *\n * **NOTE**: Visual columns do not work well for RTL text or variable-width fonts or characters.\n *\n * **NOTE**: These methods work and make sense both on the model and on the view model.\n */\nexport class CursorColumns {\n    static _nextVisibleColumn(codePoint, visibleColumn, tabSize) {\n        if (codePoint === 9 /* Tab */) {\n            return CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        }\n        if (strings.isFullWidthCharacter(codePoint) || strings.isEmojiImprecise(codePoint)) {\n            return visibleColumn + 2;\n        }\n        return visibleColumn + 1;\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    static visibleColumnFromColumn(lineContent, column, tabSize) {\n        const textLen = Math.min(column - 1, lineContent.length);\n        const text = lineContent.substring(0, textLen);\n        const iterator = new strings.GraphemeIterator(text);\n        let result = 0;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(text, textLen, iterator.offset);\n            iterator.nextGraphemeLength();\n            result = this._nextVisibleColumn(codePoint, result, tabSize);\n        }\n        return result;\n    }\n    /**\n     * Returns a column from a visible column.\n     * @see {@link CursorColumns}\n     */\n    static columnFromVisibleColumn(lineContent, visibleColumn, tabSize) {\n        if (visibleColumn <= 0) {\n            return 1;\n        }\n        const lineContentLength = lineContent.length;\n        const iterator = new strings.GraphemeIterator(lineContent);\n        let beforeVisibleColumn = 0;\n        let beforeColumn = 1;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(lineContent, lineContentLength, iterator.offset);\n            iterator.nextGraphemeLength();\n            const afterVisibleColumn = this._nextVisibleColumn(codePoint, beforeVisibleColumn, tabSize);\n            const afterColumn = iterator.offset + 1;\n            if (afterVisibleColumn >= visibleColumn) {\n                const beforeDelta = visibleColumn - beforeVisibleColumn;\n                const afterDelta = afterVisibleColumn - visibleColumn;\n                if (afterDelta < beforeDelta) {\n                    return afterColumn;\n                }\n                else {\n                    return beforeColumn;\n                }\n            }\n            beforeVisibleColumn = afterVisibleColumn;\n            beforeColumn = afterColumn;\n        }\n        // walked the entire string\n        return lineContentLength + 1;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextRenderTabStop(visibleColumn, tabSize) {\n        return visibleColumn + tabSize - visibleColumn % tabSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextIndentTabStop(visibleColumn, indentSize) {\n        return visibleColumn + indentSize - visibleColumn % indentSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevRenderTabStop(column, tabSize) {\n        return Math.max(0, column - 1 - (column - 1) % tabSize);\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevIndentTabStop(column, indentSize) {\n        return Math.max(0, column - 1 - (column - 1) % indentSize);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from './range.js';\nexport class EditOperation {\n    static insert(position, text) {\n        return {\n            range: new Range(position.lineNumber, position.column, position.lineNumber, position.column),\n            text: text,\n            forceMoveMarkers: true\n        };\n    }\n    static delete(range) {\n        return {\n            range: range,\n            text: null\n        };\n    }\n    static replace(range, text) {\n        return {\n            range: range,\n            text: text\n        };\n    }\n    static replaceMove(range, text) {\n        return {\n            range: range,\n            text: text,\n            forceMoveMarkers: true\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { Color, RGBA } from '../../../base/common/color.js';\nimport { activeContrastBorder, editorBackground, editorForeground, registerColor, editorWarningForeground, editorInfoForeground, editorWarningBorder, editorInfoBorder, contrastBorder, editorFindMatchHighlight } from '../../../platform/theme/common/colorRegistry.js';\nimport { registerThemingParticipant } from '../../../platform/theme/common/themeService.js';\n/**\n * Definition of the editor colors\n */\nexport const editorLineHighlight = registerColor('editor.lineHighlightBackground', { dark: null, light: null, hc: null }, nls.localize('lineHighlight', 'Background color for the highlight of line at the cursor position.'));\nexport const editorLineHighlightBorder = registerColor('editor.lineHighlightBorder', { dark: '#282828', light: '#eeeeee', hc: '#f38518' }, nls.localize('lineHighlightBorderBox', 'Background color for the border around the line at the cursor position.'));\nexport const editorRangeHighlight = registerColor('editor.rangeHighlightBackground', { dark: '#ffffff0b', light: '#fdff0033', hc: null }, nls.localize('rangeHighlight', 'Background color of highlighted ranges, like by quick open and find features. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorRangeHighlightBorder = registerColor('editor.rangeHighlightBorder', { dark: null, light: null, hc: activeContrastBorder }, nls.localize('rangeHighlightBorder', 'Background color of the border around highlighted ranges.'), true);\nexport const editorSymbolHighlight = registerColor('editor.symbolHighlightBackground', { dark: editorFindMatchHighlight, light: editorFindMatchHighlight, hc: null }, nls.localize('symbolHighlight', 'Background color of highlighted symbol, like for go to definition or go next/previous symbol. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const editorSymbolHighlightBorder = registerColor('editor.symbolHighlightBorder', { dark: null, light: null, hc: activeContrastBorder }, nls.localize('symbolHighlightBorder', 'Background color of the border around highlighted symbols.'), true);\nexport const editorCursorForeground = registerColor('editorCursor.foreground', { dark: '#AEAFAD', light: Color.black, hc: Color.white }, nls.localize('caret', 'Color of the editor cursor.'));\nexport const editorCursorBackground = registerColor('editorCursor.background', null, nls.localize('editorCursorBackground', 'The background color of the editor cursor. Allows customizing the color of a character overlapped by a block cursor.'));\nexport const editorWhitespaces = registerColor('editorWhitespace.foreground', { dark: '#e3e4e229', light: '#33333333', hc: '#e3e4e229' }, nls.localize('editorWhitespaces', 'Color of whitespace characters in the editor.'));\nexport const editorIndentGuides = registerColor('editorIndentGuide.background', { dark: editorWhitespaces, light: editorWhitespaces, hc: editorWhitespaces }, nls.localize('editorIndentGuides', 'Color of the editor indentation guides.'));\nexport const editorActiveIndentGuides = registerColor('editorIndentGuide.activeBackground', { dark: editorWhitespaces, light: editorWhitespaces, hc: editorWhitespaces }, nls.localize('editorActiveIndentGuide', 'Color of the active editor indentation guides.'));\nexport const editorLineNumbers = registerColor('editorLineNumber.foreground', { dark: '#858585', light: '#237893', hc: Color.white }, nls.localize('editorLineNumbers', 'Color of editor line numbers.'));\nconst deprecatedEditorActiveLineNumber = registerColor('editorActiveLineNumber.foreground', { dark: '#c6c6c6', light: '#0B216F', hc: activeContrastBorder }, nls.localize('editorActiveLineNumber', 'Color of editor active line number'), false, nls.localize('deprecatedEditorActiveLineNumber', 'Id is deprecated. Use \\'editorLineNumber.activeForeground\\' instead.'));\nexport const editorActiveLineNumber = registerColor('editorLineNumber.activeForeground', { dark: deprecatedEditorActiveLineNumber, light: deprecatedEditorActiveLineNumber, hc: deprecatedEditorActiveLineNumber }, nls.localize('editorActiveLineNumber', 'Color of editor active line number'));\nexport const editorRuler = registerColor('editorRuler.foreground', { dark: '#5A5A5A', light: Color.lightgrey, hc: Color.white }, nls.localize('editorRuler', 'Color of the editor rulers.'));\nexport const editorCodeLensForeground = registerColor('editorCodeLens.foreground', { dark: '#999999', light: '#919191', hc: '#999999' }, nls.localize('editorCodeLensForeground', 'Foreground color of editor CodeLens'));\nexport const editorBracketMatchBackground = registerColor('editorBracketMatch.background', { dark: '#0064001a', light: '#0064001a', hc: '#0064001a' }, nls.localize('editorBracketMatchBackground', 'Background color behind matching brackets'));\nexport const editorBracketMatchBorder = registerColor('editorBracketMatch.border', { dark: '#888', light: '#B9B9B9', hc: contrastBorder }, nls.localize('editorBracketMatchBorder', 'Color for matching brackets boxes'));\nexport const editorOverviewRulerBorder = registerColor('editorOverviewRuler.border', { dark: '#7f7f7f4d', light: '#7f7f7f4d', hc: '#7f7f7f4d' }, nls.localize('editorOverviewRulerBorder', 'Color of the overview ruler border.'));\nexport const editorOverviewRulerBackground = registerColor('editorOverviewRuler.background', null, nls.localize('editorOverviewRulerBackground', 'Background color of the editor overview ruler. Only used when the minimap is enabled and placed on the right side of the editor.'));\nexport const editorGutter = registerColor('editorGutter.background', { dark: editorBackground, light: editorBackground, hc: editorBackground }, nls.localize('editorGutter', 'Background color of the editor gutter. The gutter contains the glyph margins and the line numbers.'));\nexport const editorUnnecessaryCodeBorder = registerColor('editorUnnecessaryCode.border', { dark: null, light: null, hc: Color.fromHex('#fff').transparent(0.8) }, nls.localize('unnecessaryCodeBorder', 'Border color of unnecessary (unused) source code in the editor.'));\nexport const editorUnnecessaryCodeOpacity = registerColor('editorUnnecessaryCode.opacity', { dark: Color.fromHex('#000a'), light: Color.fromHex('#0007'), hc: null }, nls.localize('unnecessaryCodeOpacity', 'Opacity of unnecessary (unused) source code in the editor. For example, \"#000000c0\" will render the code with 75% opacity. For high contrast themes, use the  \\'editorUnnecessaryCode.border\\' theme color to underline unnecessary code instead of fading it out.'));\nexport const ghostTextBorder = registerColor('editorGhostText.border', { dark: null, light: null, hc: Color.fromHex('#fff').transparent(0.8) }, nls.localize('editorGhostTextBorder', 'Border color of ghost text in the editor.'));\nexport const ghostTextForeground = registerColor('editorGhostText.foreground', { dark: Color.fromHex('#ffffff56'), light: Color.fromHex('#0007'), hc: null }, nls.localize('editorGhostTextForeground', 'Foreground color of the ghost text in the editor.'));\nexport const ghostTextBackground = registerColor('editorGhostText.background', { dark: null, light: null, hc: null }, nls.localize('editorGhostTextBackground', 'Background color of the ghost text in the editor.'));\nconst rulerRangeDefault = new Color(new RGBA(0, 122, 204, 0.6));\nexport const overviewRulerRangeHighlight = registerColor('editorOverviewRuler.rangeHighlightForeground', { dark: rulerRangeDefault, light: rulerRangeDefault, hc: rulerRangeDefault }, nls.localize('overviewRulerRangeHighlight', 'Overview ruler marker color for range highlights. The color must not be opaque so as not to hide underlying decorations.'), true);\nexport const overviewRulerError = registerColor('editorOverviewRuler.errorForeground', { dark: new Color(new RGBA(255, 18, 18, 0.7)), light: new Color(new RGBA(255, 18, 18, 0.7)), hc: new Color(new RGBA(255, 50, 50, 1)) }, nls.localize('overviewRuleError', 'Overview ruler marker color for errors.'));\nexport const overviewRulerWarning = registerColor('editorOverviewRuler.warningForeground', { dark: editorWarningForeground, light: editorWarningForeground, hc: editorWarningBorder }, nls.localize('overviewRuleWarning', 'Overview ruler marker color for warnings.'));\nexport const overviewRulerInfo = registerColor('editorOverviewRuler.infoForeground', { dark: editorInfoForeground, light: editorInfoForeground, hc: editorInfoBorder }, nls.localize('overviewRuleInfo', 'Overview ruler marker color for infos.'));\nexport const editorBracketHighlightingForeground1 = registerColor('editorBracketHighlight.foreground1', { dark: '#FFD700', light: '#0431FAFF', hc: '#FFD700' }, nls.localize('editorBracketHighlightForeground1', 'Foreground color of brackets (1). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground2 = registerColor('editorBracketHighlight.foreground2', { dark: '#DA70D6', light: '#319331FF', hc: '#DA70D6' }, nls.localize('editorBracketHighlightForeground2', 'Foreground color of brackets (2). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground3 = registerColor('editorBracketHighlight.foreground3', { dark: '#179FFF', light: '#7B3814FF', hc: '#87CEFA' }, nls.localize('editorBracketHighlightForeground3', 'Foreground color of brackets (3). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground4 = registerColor('editorBracketHighlight.foreground4', { dark: '#00000000', light: '#00000000', hc: '#00000000' }, nls.localize('editorBracketHighlightForeground4', 'Foreground color of brackets (4). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground5 = registerColor('editorBracketHighlight.foreground5', { dark: '#00000000', light: '#00000000', hc: '#00000000' }, nls.localize('editorBracketHighlightForeground5', 'Foreground color of brackets (5). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingForeground6 = registerColor('editorBracketHighlight.foreground6', { dark: '#00000000', light: '#00000000', hc: '#00000000' }, nls.localize('editorBracketHighlightForeground6', 'Foreground color of brackets (6). Requires enabling bracket pair colorization.'));\nexport const editorBracketHighlightingUnexpectedBracketForeground = registerColor('editorBracketHighlight.unexpectedBracket.foreground', { dark: new Color(new RGBA(255, 18, 18, 0.8)), light: new Color(new RGBA(255, 18, 18, 0.8)), hc: new Color(new RGBA(255, 50, 50, 1)) }, nls.localize('editorBracketHighlightUnexpectedBracketForeground', 'Foreground color of unexpected brackets.'));\nexport const editorBracketPairGuideBackground1 = registerColor('editorBracketPairGuide.background1', { dark: '#00000000', light: '#00000000', hc: '#00000000' }, nls.localize('editorBracketPairGuide.background1', 'Background color of inactive bracket pair guides (1). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground2 = registerColor('editorBracketPairGuide.background2', { dark: '#00000000', light: '#00000000', hc: '#00000000' }, nls.localize('editorBracketPairGuide.background2', 'Background color of inactive bracket pair guides (2). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground3 = registerColor('editorBracketPairGuide.background3', { dark: '#00000000', light: '#00000000', hc: '#00000000' }, nls.localize('editorBracketPairGuide.background3', 'Background color of inactive bracket pair guides (3). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground4 = registerColor('editorBracketPairGuide.background4', { dark: '#00000000', light: '#00000000', hc: '#00000000' }, nls.localize('editorBracketPairGuide.background4', 'Background color of inactive bracket pair guides (4). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground5 = registerColor('editorBracketPairGuide.background5', { dark: '#00000000', light: '#00000000', hc: '#00000000' }, nls.localize('editorBracketPairGuide.background5', 'Background color of inactive bracket pair guides (5). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideBackground6 = registerColor('editorBracketPairGuide.background6', { dark: '#00000000', light: '#00000000', hc: '#00000000' }, nls.localize('editorBracketPairGuide.background6', 'Background color of inactive bracket pair guides (6). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground1 = registerColor('editorBracketPairGuide.activeBackground1', { dark: '#00000000', light: '#00000000', hc: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground1', 'Background color of active bracket pair guides (1). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground2 = registerColor('editorBracketPairGuide.activeBackground2', { dark: '#00000000', light: '#00000000', hc: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground2', 'Background color of active bracket pair guides (2). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground3 = registerColor('editorBracketPairGuide.activeBackground3', { dark: '#00000000', light: '#00000000', hc: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground3', 'Background color of active bracket pair guides (3). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground4 = registerColor('editorBracketPairGuide.activeBackground4', { dark: '#00000000', light: '#00000000', hc: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground4', 'Background color of active bracket pair guides (4). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground5 = registerColor('editorBracketPairGuide.activeBackground5', { dark: '#00000000', light: '#00000000', hc: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground5', 'Background color of active bracket pair guides (5). Requires enabling bracket pair guides.'));\nexport const editorBracketPairGuideActiveBackground6 = registerColor('editorBracketPairGuide.activeBackground6', { dark: '#00000000', light: '#00000000', hc: '#00000000' }, nls.localize('editorBracketPairGuide.activeBackground6', 'Background color of active bracket pair guides (6). Requires enabling bracket pair guides.'));\nexport const editorUnicodeHighlightBorder = registerColor('editorUnicodeHighlight.border', { dark: '#BD9B03', light: '#CEA33D', hc: '#ff0000' }, nls.localize('editorUnicodeHighlight.border', 'Border color used to highlight unicode characters.'));\n// contains all color rules that used to defined in editor/browser/widget/editor.css\nregisterThemingParticipant((theme, collector) => {\n    const background = theme.getColor(editorBackground);\n    if (background) {\n        collector.addRule(`.monaco-editor, .monaco-editor-background, .monaco-editor .inputarea.ime-input { background-color: ${background}; }`);\n    }\n    const foreground = theme.getColor(editorForeground);\n    if (foreground) {\n        collector.addRule(`.monaco-editor, .monaco-editor .inputarea.ime-input { color: ${foreground}; }`);\n    }\n    const gutter = theme.getColor(editorGutter);\n    if (gutter) {\n        collector.addRule(`.monaco-editor .margin { background-color: ${gutter}; }`);\n    }\n    const rangeHighlight = theme.getColor(editorRangeHighlight);\n    if (rangeHighlight) {\n        collector.addRule(`.monaco-editor .rangeHighlight { background-color: ${rangeHighlight}; }`);\n    }\n    const rangeHighlightBorder = theme.getColor(editorRangeHighlightBorder);\n    if (rangeHighlightBorder) {\n        collector.addRule(`.monaco-editor .rangeHighlight { border: 1px ${theme.type === 'hc' ? 'dotted' : 'solid'} ${rangeHighlightBorder}; }`);\n    }\n    const symbolHighlight = theme.getColor(editorSymbolHighlight);\n    if (symbolHighlight) {\n        collector.addRule(`.monaco-editor .symbolHighlight { background-color: ${symbolHighlight}; }`);\n    }\n    const symbolHighlightBorder = theme.getColor(editorSymbolHighlightBorder);\n    if (symbolHighlightBorder) {\n        collector.addRule(`.monaco-editor .symbolHighlight { border: 1px ${theme.type === 'hc' ? 'dotted' : 'solid'} ${symbolHighlightBorder}; }`);\n    }\n    const invisibles = theme.getColor(editorWhitespaces);\n    if (invisibles) {\n        collector.addRule(`.monaco-editor .mtkw { color: ${invisibles} !important; }`);\n        collector.addRule(`.monaco-editor .mtkz { color: ${invisibles} !important; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function countEOL(text) {\n    let eolCount = 0;\n    let firstLineLength = 0;\n    let lastLineStart = 0;\n    let eol = 0 /* Unknown */;\n    for (let i = 0, len = text.length; i < len; i++) {\n        const chr = text.charCodeAt(i);\n        if (chr === 13 /* CarriageReturn */) {\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            if (i + 1 < len && text.charCodeAt(i + 1) === 10 /* LineFeed */) {\n                // \\r\\n... case\n                eol |= 2 /* CRLF */;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                eol |= 3 /* Invalid */;\n            }\n            lastLineStart = i + 1;\n        }\n        else if (chr === 10 /* LineFeed */) {\n            // \\n... case\n            eol |= 1 /* LF */;\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            lastLineStart = i + 1;\n        }\n    }\n    if (eolCount === 0) {\n        firstLineLength = text.length;\n    }\n    return [eolCount, firstLineLength, text.length - lastLineStart, eol];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nfunction _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {\n    let spacesCnt = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str.charAt(i) === '\\t') {\n            spacesCnt += indentSize;\n        }\n        else {\n            spacesCnt++;\n        }\n    }\n    let result = '';\n    if (!insertSpaces) {\n        const tabsCnt = Math.floor(spacesCnt / indentSize);\n        spacesCnt = spacesCnt % indentSize;\n        for (let i = 0; i < tabsCnt; i++) {\n            result += '\\t';\n        }\n    }\n    for (let i = 0; i < spacesCnt; i++) {\n        result += ' ';\n    }\n    return result;\n}\nexport function normalizeIndentation(str, indentSize, insertSpaces) {\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\n    if (firstNonWhitespaceIndex === -1) {\n        firstNonWhitespaceIndex = str.length;\n    }\n    return _normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A position in the editor.\n */\nexport class Position {\n    constructor(lineNumber, column) {\n        this.lineNumber = lineNumber;\n        this.column = column;\n    }\n    /**\n     * Create a new position from this position.\n     *\n     * @param newLineNumber new line number\n     * @param newColumn new column\n     */\n    with(newLineNumber = this.lineNumber, newColumn = this.column) {\n        if (newLineNumber === this.lineNumber && newColumn === this.column) {\n            return this;\n        }\n        else {\n            return new Position(newLineNumber, newColumn);\n        }\n    }\n    /**\n     * Derive a new position from this position.\n     *\n     * @param deltaLineNumber line number delta\n     * @param deltaColumn column delta\n     */\n    delta(deltaLineNumber = 0, deltaColumn = 0) {\n        return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);\n    }\n    /**\n     * Test if this position equals other position\n     */\n    equals(other) {\n        return Position.equals(this, other);\n    }\n    /**\n     * Test if position `a` equals position `b`\n     */\n    static equals(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        return (!!a &&\n            !!b &&\n            a.lineNumber === b.lineNumber &&\n            a.column === b.column);\n    }\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be false.\n     */\n    isBefore(other) {\n        return Position.isBefore(this, other);\n    }\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be false.\n     */\n    static isBefore(a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column < b.column;\n    }\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be true.\n     */\n    isBeforeOrEqual(other) {\n        return Position.isBeforeOrEqual(this, other);\n    }\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be true.\n     */\n    static isBeforeOrEqual(a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column <= b.column;\n    }\n    /**\n     * A function that compares positions, useful for sorting\n     */\n    static compare(a, b) {\n        const aLineNumber = a.lineNumber | 0;\n        const bLineNumber = b.lineNumber | 0;\n        if (aLineNumber === bLineNumber) {\n            const aColumn = a.column | 0;\n            const bColumn = b.column | 0;\n            return aColumn - bColumn;\n        }\n        return aLineNumber - bLineNumber;\n    }\n    /**\n     * Clone this position.\n     */\n    clone() {\n        return new Position(this.lineNumber, this.column);\n    }\n    /**\n     * Convert to a human-readable representation.\n     */\n    toString() {\n        return '(' + this.lineNumber + ',' + this.column + ')';\n    }\n    // ---\n    /**\n     * Create a `Position` from an `IPosition`.\n     */\n    static lift(pos) {\n        return new Position(pos.lineNumber, pos.column);\n    }\n    /**\n     * Test if `obj` is an `IPosition`.\n     */\n    static isIPosition(obj) {\n        return (obj\n            && (typeof obj.lineNumber === 'number')\n            && (typeof obj.column === 'number'));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\n/**\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\n */\nexport class Range {\n    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {\n        if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\n            this.startLineNumber = endLineNumber;\n            this.startColumn = endColumn;\n            this.endLineNumber = startLineNumber;\n            this.endColumn = startColumn;\n        }\n        else {\n            this.startLineNumber = startLineNumber;\n            this.startColumn = startColumn;\n            this.endLineNumber = endLineNumber;\n            this.endColumn = endColumn;\n        }\n    }\n    /**\n     * Test if this range is empty.\n     */\n    isEmpty() {\n        return Range.isEmpty(this);\n    }\n    /**\n     * Test if `range` is empty.\n     */\n    static isEmpty(range) {\n        return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\n    }\n    /**\n     * Test if position is in this range. If the position is at the edges, will return true.\n     */\n    containsPosition(position) {\n        return Range.containsPosition(this, position);\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return true.\n     */\n    static containsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return false.\n     * @internal\n     */\n    static strictContainsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if range is in this range. If the range is equal to this range, will return true.\n     */\n    containsRange(range) {\n        return Range.containsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\n     */\n    static containsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\n     */\n    strictContainsRange(range) {\n        return Range.strictContainsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.\n     */\n    static strictContainsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    plusRange(range) {\n        return Range.plusRange(this, range);\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    static plusRange(a, b) {\n        let startLineNumber;\n        let startColumn;\n        let endLineNumber;\n        let endColumn;\n        if (b.startLineNumber < a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = b.startColumn;\n        }\n        else if (b.startLineNumber === a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = Math.min(b.startColumn, a.startColumn);\n        }\n        else {\n            startLineNumber = a.startLineNumber;\n            startColumn = a.startColumn;\n        }\n        if (b.endLineNumber > a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = b.endColumn;\n        }\n        else if (b.endLineNumber === a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = Math.max(b.endColumn, a.endColumn);\n        }\n        else {\n            endLineNumber = a.endLineNumber;\n            endColumn = a.endColumn;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    intersectRanges(range) {\n        return Range.intersectRanges(this, range);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    static intersectRanges(a, b) {\n        let resultStartLineNumber = a.startLineNumber;\n        let resultStartColumn = a.startColumn;\n        let resultEndLineNumber = a.endLineNumber;\n        let resultEndColumn = a.endColumn;\n        let otherStartLineNumber = b.startLineNumber;\n        let otherStartColumn = b.startColumn;\n        let otherEndLineNumber = b.endLineNumber;\n        let otherEndColumn = b.endColumn;\n        if (resultStartLineNumber < otherStartLineNumber) {\n            resultStartLineNumber = otherStartLineNumber;\n            resultStartColumn = otherStartColumn;\n        }\n        else if (resultStartLineNumber === otherStartLineNumber) {\n            resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n        }\n        if (resultEndLineNumber > otherEndLineNumber) {\n            resultEndLineNumber = otherEndLineNumber;\n            resultEndColumn = otherEndColumn;\n        }\n        else if (resultEndLineNumber === otherEndLineNumber) {\n            resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n        }\n        // Check if selection is now empty\n        if (resultStartLineNumber > resultEndLineNumber) {\n            return null;\n        }\n        if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n            return null;\n        }\n        return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n    }\n    /**\n     * Test if this range equals other.\n     */\n    equalsRange(other) {\n        return Range.equalsRange(this, other);\n    }\n    /**\n     * Test if range `a` equals `b`.\n     */\n    static equalsRange(a, b) {\n        return (!!a &&\n            !!b &&\n            a.startLineNumber === b.startLineNumber &&\n            a.startColumn === b.startColumn &&\n            a.endLineNumber === b.endLineNumber &&\n            a.endColumn === b.endColumn);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    getEndPosition() {\n        return Range.getEndPosition(this);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    static getEndPosition(range) {\n        return new Position(range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    getStartPosition() {\n        return Range.getStartPosition(this);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    static getStartPosition(range) {\n        return new Position(range.startLineNumber, range.startColumn);\n    }\n    /**\n     * Transform to a user presentable string representation.\n     */\n    toString() {\n        return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\n    }\n    /**\n     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    collapseToStart() {\n        return Range.collapseToStart(this);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    static collapseToStart(range) {\n        return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n    }\n    // ---\n    static fromPositions(start, end = start) {\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    static lift(range) {\n        if (!range) {\n            return null;\n        }\n        return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Test if `obj` is an `IRange`.\n     */\n    static isIRange(obj) {\n        return (obj\n            && (typeof obj.startLineNumber === 'number')\n            && (typeof obj.startColumn === 'number')\n            && (typeof obj.endLineNumber === 'number')\n            && (typeof obj.endColumn === 'number'));\n    }\n    /**\n     * Test if the two ranges are touching in any way.\n     */\n    static areIntersectingOrTouching(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * Test if the two ranges are intersecting. If the ranges are touching it returns true.\n     */\n    static areIntersecting(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the startPosition and then on the endPosition\n     */\n    static compareRangesUsingStarts(a, b) {\n        if (a && b) {\n            const aStartLineNumber = a.startLineNumber | 0;\n            const bStartLineNumber = b.startLineNumber | 0;\n            if (aStartLineNumber === bStartLineNumber) {\n                const aStartColumn = a.startColumn | 0;\n                const bStartColumn = b.startColumn | 0;\n                if (aStartColumn === bStartColumn) {\n                    const aEndLineNumber = a.endLineNumber | 0;\n                    const bEndLineNumber = b.endLineNumber | 0;\n                    if (aEndLineNumber === bEndLineNumber) {\n                        const aEndColumn = a.endColumn | 0;\n                        const bEndColumn = b.endColumn | 0;\n                        return aEndColumn - bEndColumn;\n                    }\n                    return aEndLineNumber - bEndLineNumber;\n                }\n                return aStartColumn - bStartColumn;\n            }\n            return aStartLineNumber - bStartLineNumber;\n        }\n        const aExists = (a ? 1 : 0);\n        const bExists = (b ? 1 : 0);\n        return aExists - bExists;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the endPosition and then on the startPosition\n     */\n    static compareRangesUsingEnds(a, b) {\n        if (a.endLineNumber === b.endLineNumber) {\n            if (a.endColumn === b.endColumn) {\n                if (a.startLineNumber === b.startLineNumber) {\n                    return a.startColumn - b.startColumn;\n                }\n                return a.startLineNumber - b.startLineNumber;\n            }\n            return a.endColumn - b.endColumn;\n        }\n        return a.endLineNumber - b.endLineNumber;\n    }\n    /**\n     * Test if the range spans multiple lines.\n     */\n    static spansMultipleLines(range) {\n        return range.endLineNumber > range.startLineNumber;\n    }\n    toJSON() {\n        return this;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A very VM friendly rgba datastructure.\n * Please don't touch unless you take a look at the IR.\n */\nexport class RGBA8 {\n    constructor(r, g, b, a) {\n        this._rgba8Brand = undefined;\n        this.r = RGBA8._clamp(r);\n        this.g = RGBA8._clamp(g);\n        this.b = RGBA8._clamp(b);\n        this.a = RGBA8._clamp(a);\n    }\n    equals(other) {\n        return (this.r === other.r\n            && this.g === other.g\n            && this.b === other.b\n            && this.a === other.a);\n    }\n    static _clamp(c) {\n        if (c < 0) {\n            return 0;\n        }\n        if (c > 255) {\n            return 255;\n        }\n        return c | 0;\n    }\n}\nRGBA8.Empty = new RGBA8(0, 0, 0, 0);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\nimport { Range } from './range.js';\n/**\n * A selection in the editor.\n * The selection is a range that has an orientation.\n */\nexport class Selection extends Range {\n    constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {\n        super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);\n        this.selectionStartLineNumber = selectionStartLineNumber;\n        this.selectionStartColumn = selectionStartColumn;\n        this.positionLineNumber = positionLineNumber;\n        this.positionColumn = positionColumn;\n    }\n    /**\n     * Transform to a human-readable representation.\n     */\n    toString() {\n        return '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';\n    }\n    /**\n     * Test if equals other selection.\n     */\n    equalsSelection(other) {\n        return (Selection.selectionsEqual(this, other));\n    }\n    /**\n     * Test if the two selections are equal.\n     */\n    static selectionsEqual(a, b) {\n        return (a.selectionStartLineNumber === b.selectionStartLineNumber &&\n            a.selectionStartColumn === b.selectionStartColumn &&\n            a.positionLineNumber === b.positionLineNumber &&\n            a.positionColumn === b.positionColumn);\n    }\n    /**\n     * Get directions (LTR or RTL).\n     */\n    getDirection() {\n        if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {\n            return 0 /* LTR */;\n        }\n        return 1 /* RTL */;\n    }\n    /**\n     * Create a new selection with a different `positionLineNumber` and `positionColumn`.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        if (this.getDirection() === 0 /* LTR */) {\n            return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);\n    }\n    /**\n     * Get the position at `positionLineNumber` and `positionColumn`.\n     */\n    getPosition() {\n        return new Position(this.positionLineNumber, this.positionColumn);\n    }\n    /**\n     * Get the position at the start of the selection.\n    */\n    getSelectionStart() {\n        return new Position(this.selectionStartLineNumber, this.selectionStartColumn);\n    }\n    /**\n     * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        if (this.getDirection() === 0 /* LTR */) {\n            return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n        }\n        return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);\n    }\n    // ----\n    /**\n     * Create a `Selection` from one or two positions\n     */\n    static fromPositions(start, end = start) {\n        return new Selection(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    /**\n     * Creates a `Selection` from a range, given a direction.\n     */\n    static fromRange(range, direction) {\n        if (direction === 0 /* LTR */) {\n            return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n        }\n        else {\n            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n        }\n    }\n    /**\n     * Create a `Selection` from an `ISelection`.\n     */\n    static liftSelection(sel) {\n        return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);\n    }\n    /**\n     * `a` equals `b`.\n     */\n    static selectionsArrEqual(a, b) {\n        if (a && !b || !a && b) {\n            return false;\n        }\n        if (!a && !b) {\n            return true;\n        }\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (!this.selectionsEqual(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Test if `obj` is an `ISelection`.\n     */\n    static isISelection(obj) {\n        return (obj\n            && (typeof obj.selectionStartLineNumber === 'number')\n            && (typeof obj.selectionStartColumn === 'number')\n            && (typeof obj.positionLineNumber === 'number')\n            && (typeof obj.positionColumn === 'number'));\n    }\n    /**\n     * Create with a direction.\n     */\n    static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {\n        if (direction === 0 /* LTR */) {\n            return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as buffer from '../../../base/common/buffer.js';\nlet _utf16LE_TextDecoder;\nfunction getUTF16LE_TextDecoder() {\n    if (!_utf16LE_TextDecoder) {\n        _utf16LE_TextDecoder = new TextDecoder('UTF-16LE');\n    }\n    return _utf16LE_TextDecoder;\n}\nlet _utf16BE_TextDecoder;\nfunction getUTF16BE_TextDecoder() {\n    if (!_utf16BE_TextDecoder) {\n        _utf16BE_TextDecoder = new TextDecoder('UTF-16BE');\n    }\n    return _utf16BE_TextDecoder;\n}\nlet _platformTextDecoder;\nexport function getPlatformTextDecoder() {\n    if (!_platformTextDecoder) {\n        _platformTextDecoder = platform.isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n    }\n    return _platformTextDecoder;\n}\nexport const hasTextDecoder = (typeof TextDecoder !== 'undefined');\nexport let createStringBuilder;\nexport let decodeUTF16LE;\nif (hasTextDecoder) {\n    createStringBuilder = (capacity) => new StringBuilder(capacity);\n    decodeUTF16LE = standardDecodeUTF16LE;\n}\nelse {\n    createStringBuilder = (capacity) => new CompatStringBuilder();\n    decodeUTF16LE = compatDecodeUTF16LE;\n}\nfunction standardDecodeUTF16LE(source, offset, len) {\n    const view = new Uint16Array(source.buffer, offset, len);\n    if (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n        // UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n        // It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n        // We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n        // So we use the manual decoder\n        return compatDecodeUTF16LE(source, offset, len);\n    }\n    return getUTF16LE_TextDecoder().decode(view);\n}\nfunction compatDecodeUTF16LE(source, offset, len) {\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0; i < len; i++) {\n        const charCode = buffer.readUInt16LE(source, offset);\n        offset += 2;\n        result[resultLen++] = String.fromCharCode(charCode);\n    }\n    return result.join('');\n}\nclass StringBuilder {\n    constructor(capacity) {\n        this._capacity = capacity | 0;\n        this._buffer = new Uint16Array(this._capacity);\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    reset() {\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    build() {\n        if (this._completedStrings !== null) {\n            this._flushBuffer();\n            return this._completedStrings.join('');\n        }\n        return this._buildBuffer();\n    }\n    _buildBuffer() {\n        if (this._bufferLength === 0) {\n            return '';\n        }\n        const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);\n        return getPlatformTextDecoder().decode(view);\n    }\n    _flushBuffer() {\n        const bufferString = this._buildBuffer();\n        this._bufferLength = 0;\n        if (this._completedStrings === null) {\n            this._completedStrings = [bufferString];\n        }\n        else {\n            this._completedStrings[this._completedStrings.length] = bufferString;\n        }\n    }\n    write1(charCode) {\n        const remainingSpace = this._capacity - this._bufferLength;\n        if (remainingSpace <= 1) {\n            if (remainingSpace === 0 || strings.isHighSurrogate(charCode)) {\n                this._flushBuffer();\n            }\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendASCII(charCode) {\n        if (this._bufferLength === this._capacity) {\n            // buffer is full\n            this._flushBuffer();\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendASCIIString(str) {\n        const strLen = str.length;\n        if (this._bufferLength + strLen >= this._capacity) {\n            // This string does not fit in the remaining buffer space\n            this._flushBuffer();\n            this._completedStrings[this._completedStrings.length] = str;\n            return;\n        }\n        for (let i = 0; i < strLen; i++) {\n            this._buffer[this._bufferLength++] = str.charCodeAt(i);\n        }\n    }\n}\nclass CompatStringBuilder {\n    constructor() {\n        this._pieces = [];\n        this._piecesLen = 0;\n    }\n    reset() {\n        this._pieces = [];\n        this._piecesLen = 0;\n    }\n    build() {\n        return this._pieces.join('');\n    }\n    write1(charCode) {\n        this._pieces[this._piecesLen++] = String.fromCharCode(charCode);\n    }\n    appendASCII(charCode) {\n        this._pieces[this._piecesLen++] = String.fromCharCode(charCode);\n    }\n    appendASCIIString(str) {\n        this._pieces[this._piecesLen++] = str;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as buffer from '../../../base/common/buffer.js';\nimport { decodeUTF16LE } from './stringBuilder.js';\nfunction escapeNewLine(str) {\n    return (str\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r'));\n}\nexport class TextChange {\n    constructor(oldPosition, oldText, newPosition, newText) {\n        this.oldPosition = oldPosition;\n        this.oldText = oldText;\n        this.newPosition = newPosition;\n        this.newText = newText;\n    }\n    get oldLength() {\n        return this.oldText.length;\n    }\n    get oldEnd() {\n        return this.oldPosition + this.oldText.length;\n    }\n    get newLength() {\n        return this.newText.length;\n    }\n    get newEnd() {\n        return this.newPosition + this.newText.length;\n    }\n    toString() {\n        if (this.oldText.length === 0) {\n            return `(insert@${this.oldPosition} \"${escapeNewLine(this.newText)}\")`;\n        }\n        if (this.newText.length === 0) {\n            return `(delete@${this.oldPosition} \"${escapeNewLine(this.oldText)}\")`;\n        }\n        return `(replace@${this.oldPosition} \"${escapeNewLine(this.oldText)}\" with \"${escapeNewLine(this.newText)}\")`;\n    }\n    static _writeStringSize(str) {\n        return (4 + 2 * str.length);\n    }\n    static _writeString(b, str, offset) {\n        const len = str.length;\n        buffer.writeUInt32BE(b, len, offset);\n        offset += 4;\n        for (let i = 0; i < len; i++) {\n            buffer.writeUInt16LE(b, str.charCodeAt(i), offset);\n            offset += 2;\n        }\n        return offset;\n    }\n    static _readString(b, offset) {\n        const len = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        return decodeUTF16LE(b, offset, len);\n    }\n    writeSize() {\n        return (+4 // oldPosition\n            + 4 // newPosition\n            + TextChange._writeStringSize(this.oldText)\n            + TextChange._writeStringSize(this.newText));\n    }\n    write(b, offset) {\n        buffer.writeUInt32BE(b, this.oldPosition, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.newPosition, offset);\n        offset += 4;\n        offset = TextChange._writeString(b, this.oldText, offset);\n        offset = TextChange._writeString(b, this.newText, offset);\n        return offset;\n    }\n    static read(b, offset, dest) {\n        const oldPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const newPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const oldText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(oldText);\n        const newText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(newText);\n        dest.push(new TextChange(oldPosition, oldText, newPosition, newText));\n        return offset;\n    }\n}\nexport function compressConsecutiveTextChanges(prevEdits, currEdits) {\n    if (prevEdits === null || prevEdits.length === 0) {\n        return currEdits;\n    }\n    const compressor = new TextChangeCompressor(prevEdits, currEdits);\n    return compressor.compress();\n}\nclass TextChangeCompressor {\n    constructor(prevEdits, currEdits) {\n        this._prevEdits = prevEdits;\n        this._currEdits = currEdits;\n        this._result = [];\n        this._resultLen = 0;\n        this._prevLen = this._prevEdits.length;\n        this._prevDeltaOffset = 0;\n        this._currLen = this._currEdits.length;\n        this._currDeltaOffset = 0;\n    }\n    compress() {\n        let prevIndex = 0;\n        let currIndex = 0;\n        let prevEdit = this._getPrev(prevIndex);\n        let currEdit = this._getCurr(currIndex);\n        while (prevIndex < this._prevLen || currIndex < this._currLen) {\n            if (prevEdit === null) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (currEdit === null) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldEnd <= prevEdit.newPosition) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (prevEdit.newEnd <= currEdit.oldPosition) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldPosition < prevEdit.newPosition) {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newPosition - currEdit.oldPosition);\n                this._acceptCurr(e1);\n                currEdit = e2;\n                continue;\n            }\n            if (prevEdit.newPosition < currEdit.oldPosition) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldPosition - prevEdit.newPosition);\n                this._acceptPrev(e1);\n                prevEdit = e2;\n                continue;\n            }\n            // At this point, currEdit.oldPosition === prevEdit.newPosition\n            let mergePrev;\n            let mergeCurr;\n            if (currEdit.oldEnd === prevEdit.newEnd) {\n                mergePrev = prevEdit;\n                mergeCurr = currEdit;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = this._getCurr(++currIndex);\n            }\n            else if (currEdit.oldEnd < prevEdit.newEnd) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldLength);\n                mergePrev = e1;\n                mergeCurr = currEdit;\n                prevEdit = e2;\n                currEdit = this._getCurr(++currIndex);\n            }\n            else {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newLength);\n                mergePrev = prevEdit;\n                mergeCurr = e1;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = e2;\n            }\n            this._result[this._resultLen++] = new TextChange(mergePrev.oldPosition, mergePrev.oldText, mergeCurr.newPosition, mergeCurr.newText);\n            this._prevDeltaOffset += mergePrev.newLength - mergePrev.oldLength;\n            this._currDeltaOffset += mergeCurr.newLength - mergeCurr.oldLength;\n        }\n        const merged = TextChangeCompressor._merge(this._result);\n        const cleaned = TextChangeCompressor._removeNoOps(merged);\n        return cleaned;\n    }\n    _acceptCurr(currEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebaseCurr(this._prevDeltaOffset, currEdit);\n        this._currDeltaOffset += currEdit.newLength - currEdit.oldLength;\n    }\n    _getCurr(currIndex) {\n        return (currIndex < this._currLen ? this._currEdits[currIndex] : null);\n    }\n    _acceptPrev(prevEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebasePrev(this._currDeltaOffset, prevEdit);\n        this._prevDeltaOffset += prevEdit.newLength - prevEdit.oldLength;\n    }\n    _getPrev(prevIndex) {\n        return (prevIndex < this._prevLen ? this._prevEdits[prevIndex] : null);\n    }\n    static _rebaseCurr(prevDeltaOffset, currEdit) {\n        return new TextChange(currEdit.oldPosition - prevDeltaOffset, currEdit.oldText, currEdit.newPosition, currEdit.newText);\n    }\n    static _rebasePrev(currDeltaOffset, prevEdit) {\n        return new TextChange(prevEdit.oldPosition, prevEdit.oldText, prevEdit.newPosition + currDeltaOffset, prevEdit.newText);\n    }\n    static _splitPrev(edit, offset) {\n        const preText = edit.newText.substr(0, offset);\n        const postText = edit.newText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, edit.oldText, edit.newPosition, preText),\n            new TextChange(edit.oldEnd, '', edit.newPosition + offset, postText)\n        ];\n    }\n    static _splitCurr(edit, offset) {\n        const preText = edit.oldText.substr(0, offset);\n        const postText = edit.oldText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, preText, edit.newPosition, edit.newText),\n            new TextChange(edit.oldPosition + offset, postText, edit.newEnd, '')\n        ];\n    }\n    static _merge(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        let prev = edits[0];\n        for (let i = 1; i < edits.length; i++) {\n            const curr = edits[i];\n            if (prev.oldEnd === curr.oldPosition) {\n                // Merge into `prev`\n                prev = new TextChange(prev.oldPosition, prev.oldText + curr.oldText, prev.newPosition, prev.newText + curr.newText);\n            }\n            else {\n                result[resultLen++] = prev;\n                prev = curr;\n            }\n        }\n        result[resultLen++] = prev;\n        return result;\n    }\n    static _removeNoOps(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0; i < edits.length; i++) {\n            const edit = edits[i];\n            if (edit.oldText === edit.newText) {\n                continue;\n            }\n            result[resultLen++] = edit;\n        }\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const EDITOR_MODEL_DEFAULTS = {\n    tabSize: 4,\n    indentSize: 4,\n    insertSpaces: true,\n    detectIndentation: true,\n    trimAutoWhitespace: true,\n    largeFileOptimizations: true,\n    bracketPairColorizationOptions: { enabled: false }\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CharacterClassifier } from './characterClassifier.js';\nexport class WordCharacterClassifier extends CharacterClassifier {\n    constructor(wordSeparators) {\n        super(0 /* Regular */);\n        for (let i = 0, len = wordSeparators.length; i < len; i++) {\n            this.set(wordSeparators.charCodeAt(i), 2 /* WordSeparator */);\n        }\n        this.set(32 /* Space */, 1 /* Whitespace */);\n        this.set(9 /* Tab */, 1 /* Whitespace */);\n    }\n}\nfunction once(computeFn) {\n    const cache = {}; // TODO@Alex unbounded cache\n    return (input) => {\n        if (!cache.hasOwnProperty(input)) {\n            cache[input] = computeFn(input);\n        }\n        return cache[input];\n    };\n}\nexport const getMapForWordSeparators = once((input) => new WordCharacterClassifier(input));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n/**\n * Create a word definition regular expression based on default word separators.\n * Optionally provide allowed separators that should be included in words.\n *\n * The default would look like this:\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n */\nfunction createWordRegExp(allowInWords = '') {\n    let source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n    for (const sep of USUAL_WORD_SEPARATORS) {\n        if (allowInWords.indexOf(sep) >= 0) {\n            continue;\n        }\n        source += '\\\\' + sep;\n    }\n    source += '\\\\s]+)';\n    return new RegExp(source, 'g');\n}\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\nexport const DEFAULT_WORD_REGEXP = createWordRegExp();\nexport function ensureValidWordDefinition(wordDefinition) {\n    let result = DEFAULT_WORD_REGEXP;\n    if (wordDefinition && (wordDefinition instanceof RegExp)) {\n        if (!wordDefinition.global) {\n            let flags = 'g';\n            if (wordDefinition.ignoreCase) {\n                flags += 'i';\n            }\n            if (wordDefinition.multiline) {\n                flags += 'm';\n            }\n            if (wordDefinition.unicode) {\n                flags += 'u';\n            }\n            result = new RegExp(wordDefinition.source, flags);\n        }\n        else {\n            result = wordDefinition;\n        }\n    }\n    result.lastIndex = 0;\n    return result;\n}\nconst _defaultConfig = {\n    maxLen: 1000,\n    windowSize: 15,\n    timeBudget: 150\n};\nexport function getWordAtText(column, wordDefinition, text, textOffset, config = _defaultConfig) {\n    if (text.length > config.maxLen) {\n        // don't throw strings that long at the regexp\n        // but use a sub-string in which a word must occur\n        let start = column - config.maxLen / 2;\n        if (start < 0) {\n            start = 0;\n        }\n        else {\n            textOffset += start;\n        }\n        text = text.substring(start, column + config.maxLen / 2);\n        return getWordAtText(column, wordDefinition, text, textOffset, config);\n    }\n    const t1 = Date.now();\n    const pos = column - 1 - textOffset;\n    let prevRegexIndex = -1;\n    let match = null;\n    for (let i = 1;; i++) {\n        // check time budget\n        if (Date.now() - t1 >= config.timeBudget) {\n            break;\n        }\n        // reset the index at which the regexp should start matching, also know where it\n        // should stop so that subsequent search don't repeat previous searches\n        const regexIndex = pos - config.windowSize * i;\n        wordDefinition.lastIndex = Math.max(0, regexIndex);\n        const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\n        if (!thisMatch && match) {\n            // stop: we have something\n            break;\n        }\n        match = thisMatch;\n        // stop: searched at start\n        if (regexIndex <= 0) {\n            break;\n        }\n        prevRegexIndex = regexIndex;\n    }\n    if (match) {\n        const result = {\n            word: match[0],\n            startColumn: textOffset + 1 + match.index,\n            endColumn: textOffset + 1 + match.index + match[0].length\n        };\n        wordDefinition.lastIndex = 0;\n        return result;\n    }\n    return null;\n}\nfunction _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {\n    let match;\n    while (match = wordDefinition.exec(text)) {\n        const matchIndex = match.index || 0;\n        if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n            return match;\n        }\n        else if (stopPos > 0 && matchIndex > stopPos) {\n            return null;\n        }\n    }\n    return null;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorState, SingleCursorState } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\n/**\n * Represents a single cursor.\n*/\nexport class Cursor {\n    constructor(context) {\n        this._selTrackedRange = null;\n        this._trackSelection = true;\n        this._setState(context, new SingleCursorState(new Range(1, 1, 1, 1), 0, new Position(1, 1), 0), new SingleCursorState(new Range(1, 1, 1, 1), 0, new Position(1, 1), 0));\n    }\n    dispose(context) {\n        this._removeTrackedRange(context);\n    }\n    startTrackingSelection(context) {\n        this._trackSelection = true;\n        this._updateTrackedRange(context);\n    }\n    stopTrackingSelection(context) {\n        this._trackSelection = false;\n        this._removeTrackedRange(context);\n    }\n    _updateTrackedRange(context) {\n        if (!this._trackSelection) {\n            // don't track the selection\n            return;\n        }\n        this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, this.modelState.selection, 0 /* AlwaysGrowsWhenTypingAtEdges */);\n    }\n    _removeTrackedRange(context) {\n        this._selTrackedRange = context.model._setTrackedRange(this._selTrackedRange, null, 0 /* AlwaysGrowsWhenTypingAtEdges */);\n    }\n    asCursorState() {\n        return new CursorState(this.modelState, this.viewState);\n    }\n    readSelectionFromMarkers(context) {\n        const range = context.model._getTrackedRange(this._selTrackedRange);\n        return Selection.fromRange(range, this.modelState.selection.getDirection());\n    }\n    ensureValidState(context) {\n        this._setState(context, this.modelState, this.viewState);\n    }\n    setState(context, modelState, viewState) {\n        this._setState(context, modelState, viewState);\n    }\n    static _validatePositionWithCache(viewModel, position, cacheInput, cacheOutput) {\n        if (position.equals(cacheInput)) {\n            return cacheOutput;\n        }\n        return viewModel.normalizePosition(position, 2 /* None */);\n    }\n    static _validateViewState(viewModel, viewState) {\n        const position = viewState.position;\n        const sStartPosition = viewState.selectionStart.getStartPosition();\n        const sEndPosition = viewState.selectionStart.getEndPosition();\n        const validPosition = viewModel.normalizePosition(position, 2 /* None */);\n        const validSStartPosition = this._validatePositionWithCache(viewModel, sStartPosition, position, validPosition);\n        const validSEndPosition = this._validatePositionWithCache(viewModel, sEndPosition, sStartPosition, validSStartPosition);\n        if (position.equals(validPosition) && sStartPosition.equals(validSStartPosition) && sEndPosition.equals(validSEndPosition)) {\n            // fast path: the state is valid\n            return viewState;\n        }\n        return new SingleCursorState(Range.fromPositions(validSStartPosition, validSEndPosition), viewState.selectionStartLeftoverVisibleColumns + sStartPosition.column - validSStartPosition.column, validPosition, viewState.leftoverVisibleColumns + position.column - validPosition.column);\n    }\n    _setState(context, modelState, viewState) {\n        if (viewState) {\n            viewState = Cursor._validateViewState(context.viewModel, viewState);\n        }\n        if (!modelState) {\n            if (!viewState) {\n                return;\n            }\n            // We only have the view state => compute the model state\n            const selectionStart = context.model.validateRange(context.coordinatesConverter.convertViewRangeToModelRange(viewState.selectionStart));\n            const position = context.model.validatePosition(context.coordinatesConverter.convertViewPositionToModelPosition(viewState.position));\n            modelState = new SingleCursorState(selectionStart, viewState.selectionStartLeftoverVisibleColumns, position, viewState.leftoverVisibleColumns);\n        }\n        else {\n            // Validate new model state\n            const selectionStart = context.model.validateRange(modelState.selectionStart);\n            const selectionStartLeftoverVisibleColumns = modelState.selectionStart.equalsRange(selectionStart) ? modelState.selectionStartLeftoverVisibleColumns : 0;\n            const position = context.model.validatePosition(modelState.position);\n            const leftoverVisibleColumns = modelState.position.equals(position) ? modelState.leftoverVisibleColumns : 0;\n            modelState = new SingleCursorState(selectionStart, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns);\n        }\n        if (!viewState) {\n            // We only have the model state => compute the view state\n            const viewSelectionStart1 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.startLineNumber, modelState.selectionStart.startColumn));\n            const viewSelectionStart2 = context.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelState.selectionStart.endLineNumber, modelState.selectionStart.endColumn));\n            const viewSelectionStart = new Range(viewSelectionStart1.lineNumber, viewSelectionStart1.column, viewSelectionStart2.lineNumber, viewSelectionStart2.column);\n            const viewPosition = context.coordinatesConverter.convertModelPositionToViewPosition(modelState.position);\n            viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n        }\n        else {\n            // Validate new view state\n            const viewSelectionStart = context.coordinatesConverter.validateViewRange(viewState.selectionStart, modelState.selectionStart);\n            const viewPosition = context.coordinatesConverter.validateViewPosition(viewState.position, modelState.position);\n            viewState = new SingleCursorState(viewSelectionStart, modelState.selectionStartLeftoverVisibleColumns, viewPosition, modelState.leftoverVisibleColumns);\n        }\n        this.modelState = modelState;\n        this.viewState = viewState;\n        this._updateTrackedRange(context);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { compareBy, findLastMaxBy, findMinBy } from '../../../base/common/arrays.js';\nimport { CursorState } from '../cursorCommon.js';\nimport { Cursor } from './oneCursor.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nexport class CursorCollection {\n    constructor(context) {\n        this.context = context;\n        this.cursors = [new Cursor(context)];\n        this.lastAddedCursorIndex = 0;\n    }\n    dispose() {\n        for (const cursor of this.cursors) {\n            cursor.dispose(this.context);\n        }\n    }\n    startTrackingSelections() {\n        for (const cursor of this.cursors) {\n            cursor.startTrackingSelection(this.context);\n        }\n    }\n    stopTrackingSelections() {\n        for (const cursor of this.cursors) {\n            cursor.stopTrackingSelection(this.context);\n        }\n    }\n    updateContext(context) {\n        this.context = context;\n    }\n    ensureValidState() {\n        for (const cursor of this.cursors) {\n            cursor.ensureValidState(this.context);\n        }\n    }\n    readSelectionFromMarkers() {\n        return this.cursors.map(c => c.readSelectionFromMarkers(this.context));\n    }\n    getAll() {\n        return this.cursors.map(c => c.asCursorState());\n    }\n    getViewPositions() {\n        return this.cursors.map(c => c.viewState.position);\n    }\n    getTopMostViewPosition() {\n        return findMinBy(this.cursors, compareBy(c => c.viewState.position, Position.compare)).viewState.position;\n    }\n    getBottomMostViewPosition() {\n        return findLastMaxBy(this.cursors, compareBy(c => c.viewState.position, Position.compare)).viewState.position;\n    }\n    getSelections() {\n        return this.cursors.map(c => c.modelState.selection);\n    }\n    getViewSelections() {\n        return this.cursors.map(c => c.viewState.selection);\n    }\n    setSelections(selections) {\n        this.setStates(CursorState.fromModelSelections(selections));\n    }\n    getPrimaryCursor() {\n        return this.cursors[0].asCursorState();\n    }\n    setStates(states) {\n        if (states === null) {\n            return;\n        }\n        this.cursors[0].setState(this.context, states[0].modelState, states[0].viewState);\n        this._setSecondaryStates(states.slice(1));\n    }\n    /**\n     * Creates or disposes secondary cursors as necessary to match the number of `secondarySelections`.\n     */\n    _setSecondaryStates(secondaryStates) {\n        const secondaryCursorsLength = this.cursors.length - 1;\n        const secondaryStatesLength = secondaryStates.length;\n        if (secondaryCursorsLength < secondaryStatesLength) {\n            const createCnt = secondaryStatesLength - secondaryCursorsLength;\n            for (let i = 0; i < createCnt; i++) {\n                this._addSecondaryCursor();\n            }\n        }\n        else if (secondaryCursorsLength > secondaryStatesLength) {\n            const removeCnt = secondaryCursorsLength - secondaryStatesLength;\n            for (let i = 0; i < removeCnt; i++) {\n                this._removeSecondaryCursor(this.cursors.length - 2);\n            }\n        }\n        for (let i = 0; i < secondaryStatesLength; i++) {\n            this.cursors[i + 1].setState(this.context, secondaryStates[i].modelState, secondaryStates[i].viewState);\n        }\n    }\n    killSecondaryCursors() {\n        this._setSecondaryStates([]);\n    }\n    _addSecondaryCursor() {\n        this.cursors.push(new Cursor(this.context));\n        this.lastAddedCursorIndex = this.cursors.length - 1;\n    }\n    getLastAddedCursorIndex() {\n        if (this.cursors.length === 1 || this.lastAddedCursorIndex === 0) {\n            return 0;\n        }\n        return this.lastAddedCursorIndex;\n    }\n    _removeSecondaryCursor(removeIndex) {\n        if (this.lastAddedCursorIndex >= removeIndex + 1) {\n            this.lastAddedCursorIndex--;\n        }\n        this.cursors[removeIndex + 1].dispose(this.context);\n        this.cursors.splice(removeIndex + 1, 1);\n    }\n    normalize() {\n        if (this.cursors.length === 1) {\n            return;\n        }\n        const cursors = this.cursors.slice(0);\n        const sortedCursors = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            sortedCursors.push({\n                index: i,\n                selection: cursors[i].modelState.selection,\n            });\n        }\n        sortedCursors.sort(compareBy(s => s.selection, Range.compareRangesUsingStarts));\n        for (let sortedCursorIndex = 0; sortedCursorIndex < sortedCursors.length - 1; sortedCursorIndex++) {\n            const current = sortedCursors[sortedCursorIndex];\n            const next = sortedCursors[sortedCursorIndex + 1];\n            const currentSelection = current.selection;\n            const nextSelection = next.selection;\n            if (!this.context.cursorConfig.multiCursorMergeOverlapping) {\n                continue;\n            }\n            let shouldMergeCursors;\n            if (nextSelection.isEmpty() || currentSelection.isEmpty()) {\n                // Merge touching cursors if one of them is collapsed\n                shouldMergeCursors = nextSelection.getStartPosition().isBeforeOrEqual(currentSelection.getEndPosition());\n            }\n            else {\n                // Merge only overlapping cursors (i.e. allow touching ranges)\n                shouldMergeCursors = nextSelection.getStartPosition().isBefore(currentSelection.getEndPosition());\n            }\n            if (shouldMergeCursors) {\n                const winnerSortedCursorIndex = current.index < next.index ? sortedCursorIndex : sortedCursorIndex + 1;\n                const looserSortedCursorIndex = current.index < next.index ? sortedCursorIndex + 1 : sortedCursorIndex;\n                const looserIndex = sortedCursors[looserSortedCursorIndex].index;\n                const winnerIndex = sortedCursors[winnerSortedCursorIndex].index;\n                const looserSelection = sortedCursors[looserSortedCursorIndex].selection;\n                const winnerSelection = sortedCursors[winnerSortedCursorIndex].selection;\n                if (!looserSelection.equalsSelection(winnerSelection)) {\n                    const resultingRange = looserSelection.plusRange(winnerSelection);\n                    const looserSelectionIsLTR = (looserSelection.selectionStartLineNumber === looserSelection.startLineNumber && looserSelection.selectionStartColumn === looserSelection.startColumn);\n                    const winnerSelectionIsLTR = (winnerSelection.selectionStartLineNumber === winnerSelection.startLineNumber && winnerSelection.selectionStartColumn === winnerSelection.startColumn);\n                    // Give more importance to the last added cursor (think Ctrl-dragging + hitting another cursor)\n                    let resultingSelectionIsLTR;\n                    if (looserIndex === this.lastAddedCursorIndex) {\n                        resultingSelectionIsLTR = looserSelectionIsLTR;\n                        this.lastAddedCursorIndex = winnerIndex;\n                    }\n                    else {\n                        // Winner takes it all\n                        resultingSelectionIsLTR = winnerSelectionIsLTR;\n                    }\n                    let resultingSelection;\n                    if (resultingSelectionIsLTR) {\n                        resultingSelection = new Selection(resultingRange.startLineNumber, resultingRange.startColumn, resultingRange.endLineNumber, resultingRange.endColumn);\n                    }\n                    else {\n                        resultingSelection = new Selection(resultingRange.endLineNumber, resultingRange.endColumn, resultingRange.startLineNumber, resultingRange.startColumn);\n                    }\n                    sortedCursors[winnerSortedCursorIndex].selection = resultingSelection;\n                    const resultingState = CursorState.fromModelSelection(resultingSelection);\n                    cursors[winnerIndex].setState(this.context, resultingState.modelState, resultingState.viewState);\n                }\n                for (const sortedCursor of sortedCursors) {\n                    if (sortedCursor.index > looserIndex) {\n                        sortedCursor.index--;\n                    }\n                }\n                cursors.splice(looserIndex, 1);\n                sortedCursors.splice(looserSortedCursorIndex, 1);\n                this._removeSecondaryCursor(looserIndex - 1);\n                sortedCursorIndex--;\n            }\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class CursorContext {\n    constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n        this._cursorContextBrand = undefined;\n        this.model = model;\n        this.viewModel = viewModel;\n        this.coordinatesConverter = coordinatesConverter;\n        this.cursorConfig = cursorConfig;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorCollection } from './cursorCollection.js';\nimport { CursorState, EditOperationResult } from '../cursorCommon.js';\nimport { CursorContext } from './cursorContext.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { TypeOperations, TypeWithAutoClosingCommand } from './cursorTypeOperations.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { ModelInjectedTextChangedEvent } from '../textModelEvents.js';\nimport { ViewCursorStateChangedEvent, ViewRevealRangeRequestEvent } from '../viewEvents.js';\nimport { dispose, Disposable } from '../../../base/common/lifecycle.js';\nimport { CursorStateChangedEvent } from '../viewModelEventDispatcher.js';\nexport class CursorsController extends Disposable {\n    constructor(model, viewModel, coordinatesConverter, cursorConfig) {\n        super();\n        this._model = model;\n        this._knownModelVersionId = this._model.getVersionId();\n        this._viewModel = viewModel;\n        this._coordinatesConverter = coordinatesConverter;\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors = new CursorCollection(this.context);\n        this._hasFocus = false;\n        this._isHandling = false;\n        this._isDoingComposition = false;\n        this._selectionsWhenCompositionStarted = null;\n        this._columnSelectData = null;\n        this._autoClosedActions = [];\n        this._prevEditOperationType = 0 /* Other */;\n    }\n    dispose() {\n        this._cursors.dispose();\n        this._autoClosedActions = dispose(this._autoClosedActions);\n        super.dispose();\n    }\n    updateConfiguration(cursorConfig) {\n        this.context = new CursorContext(this._model, this._viewModel, this._coordinatesConverter, cursorConfig);\n        this._cursors.updateContext(this.context);\n    }\n    onLineMappingChanged(eventsCollector) {\n        if (this._knownModelVersionId !== this._model.getVersionId()) {\n            // There are model change events that I didn't yet receive.\n            //\n            // This can happen when editing the model, and the view model receives the change events first,\n            // and the view model emits line mapping changed events, all before the cursor gets a chance to\n            // recover from markers.\n            //\n            // The model change listener above will be called soon and we'll ensure a valid cursor state there.\n            return;\n        }\n        // Ensure valid state\n        this.setStates(eventsCollector, 'viewModel', 0 /* NotSet */, this.getCursorStates());\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n    }\n    _validateAutoClosedActions() {\n        if (this._autoClosedActions.length > 0) {\n            const selections = this._cursors.getSelections();\n            for (let i = 0; i < this._autoClosedActions.length; i++) {\n                const autoClosedAction = this._autoClosedActions[i];\n                if (!autoClosedAction.isValid(selections)) {\n                    autoClosedAction.dispose();\n                    this._autoClosedActions.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n    }\n    // ------ some getters/setters\n    getPrimaryCursorState() {\n        return this._cursors.getPrimaryCursor();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursors.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursors.getAll();\n    }\n    setStates(eventsCollector, source, reason, states) {\n        let reachedMaxCursorCount = false;\n        if (states !== null && states.length > CursorsController.MAX_CURSOR_COUNT) {\n            states = states.slice(0, CursorsController.MAX_CURSOR_COUNT);\n            reachedMaxCursorCount = true;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.setStates(states);\n        this._cursors.normalize();\n        this._columnSelectData = null;\n        this._validateAutoClosedActions();\n        return this._emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount);\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._columnSelectData = columnSelectData;\n    }\n    revealPrimary(eventsCollector, source, minimalReveal, verticalType, revealHorizontal, scrollType) {\n        const viewPositions = this._cursors.getViewPositions();\n        let revealViewRange = null;\n        let revealViewSelections = null;\n        if (viewPositions.length > 1) {\n            revealViewSelections = this._cursors.getViewSelections();\n        }\n        else {\n            revealViewRange = Range.fromPositions(viewPositions[0], viewPositions[0]);\n        }\n        eventsCollector.emitViewEvent(new ViewRevealRangeRequestEvent(source, minimalReveal, revealViewRange, revealViewSelections, verticalType, revealHorizontal, scrollType));\n    }\n    saveState() {\n        const result = [];\n        const selections = this._cursors.getSelections();\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            result.push({\n                inSelectionMode: !selection.isEmpty(),\n                selectionStart: {\n                    lineNumber: selection.selectionStartLineNumber,\n                    column: selection.selectionStartColumn,\n                },\n                position: {\n                    lineNumber: selection.positionLineNumber,\n                    column: selection.positionColumn,\n                }\n            });\n        }\n        return result;\n    }\n    restoreState(eventsCollector, states) {\n        const desiredSelections = [];\n        for (let i = 0, len = states.length; i < len; i++) {\n            const state = states[i];\n            let positionLineNumber = 1;\n            let positionColumn = 1;\n            // Avoid missing properties on the literal\n            if (state.position && state.position.lineNumber) {\n                positionLineNumber = state.position.lineNumber;\n            }\n            if (state.position && state.position.column) {\n                positionColumn = state.position.column;\n            }\n            let selectionStartLineNumber = positionLineNumber;\n            let selectionStartColumn = positionColumn;\n            // Avoid missing properties on the literal\n            if (state.selectionStart && state.selectionStart.lineNumber) {\n                selectionStartLineNumber = state.selectionStart.lineNumber;\n            }\n            if (state.selectionStart && state.selectionStart.column) {\n                selectionStartColumn = state.selectionStart.column;\n            }\n            desiredSelections.push({\n                selectionStartLineNumber: selectionStartLineNumber,\n                selectionStartColumn: selectionStartColumn,\n                positionLineNumber: positionLineNumber,\n                positionColumn: positionColumn\n            });\n        }\n        this.setStates(eventsCollector, 'restoreState', 0 /* NotSet */, CursorState.fromModelSelections(desiredSelections));\n        this.revealPrimary(eventsCollector, 'restoreState', false, 0 /* Simple */, true, 1 /* Immediate */);\n    }\n    onModelContentChanged(eventsCollector, e) {\n        if (e instanceof ModelInjectedTextChangedEvent) {\n            // If injected texts change, the view positions of all cursors need to be updated.\n            if (this._isHandling) {\n                // The view positions will be updated when handling finishes\n                return;\n            }\n            // setStates might remove markers, which could trigger a decoration change.\n            // If there are injected text decorations for that line, `onModelContentChanged` is emitted again\n            // and an endless recursion happens.\n            // _isHandling prevents that.\n            this._isHandling = true;\n            try {\n                this.setStates(eventsCollector, 'modelChange', 0 /* NotSet */, this.getCursorStates());\n            }\n            finally {\n                this._isHandling = false;\n            }\n        }\n        else {\n            this._knownModelVersionId = e.versionId;\n            if (this._isHandling) {\n                return;\n            }\n            const hadFlushEvent = e.containsEvent(1 /* Flush */);\n            this._prevEditOperationType = 0 /* Other */;\n            if (hadFlushEvent) {\n                // a model.setValue() was called\n                this._cursors.dispose();\n                this._cursors = new CursorCollection(this.context);\n                this._validateAutoClosedActions();\n                this._emitStateChangedIfNecessary(eventsCollector, 'model', 1 /* ContentFlush */, null, false);\n            }\n            else {\n                if (this._hasFocus && e.resultingSelection && e.resultingSelection.length > 0) {\n                    const cursorState = CursorState.fromModelSelections(e.resultingSelection);\n                    if (this.setStates(eventsCollector, 'modelChange', e.isUndoing ? 5 /* Undo */ : e.isRedoing ? 6 /* Redo */ : 2 /* RecoverFromMarkers */, cursorState)) {\n                        this.revealPrimary(eventsCollector, 'modelChange', false, 0 /* Simple */, true, 0 /* Smooth */);\n                    }\n                }\n                else {\n                    const selectionsFromMarkers = this._cursors.readSelectionFromMarkers();\n                    this.setStates(eventsCollector, 'modelChange', 2 /* RecoverFromMarkers */, CursorState.fromModelSelections(selectionsFromMarkers));\n                }\n            }\n        }\n    }\n    getSelection() {\n        return this._cursors.getPrimaryCursor().modelState.selection;\n    }\n    getTopMostViewPosition() {\n        return this._cursors.getTopMostViewPosition();\n    }\n    getBottomMostViewPosition() {\n        return this._cursors.getBottomMostViewPosition();\n    }\n    getCursorColumnSelectData() {\n        if (this._columnSelectData) {\n            return this._columnSelectData;\n        }\n        const primaryCursor = this._cursors.getPrimaryCursor();\n        const viewSelectionStart = primaryCursor.viewState.selectionStart.getStartPosition();\n        const viewPosition = primaryCursor.viewState.position;\n        return {\n            isReal: false,\n            fromViewLineNumber: viewSelectionStart.lineNumber,\n            fromViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewSelectionStart),\n            toViewLineNumber: viewPosition.lineNumber,\n            toViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, viewPosition),\n        };\n    }\n    getSelections() {\n        return this._cursors.getSelections();\n    }\n    setSelections(eventsCollector, source, selections, reason) {\n        this.setStates(eventsCollector, source, reason, CursorState.fromModelSelections(selections));\n    }\n    getPrevEditOperationType() {\n        return this._prevEditOperationType;\n    }\n    setPrevEditOperationType(type) {\n        this._prevEditOperationType = type;\n    }\n    // ------ auxiliary handling logic\n    _pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges) {\n        const autoClosedCharactersDeltaDecorations = [];\n        const autoClosedEnclosingDeltaDecorations = [];\n        for (let i = 0, len = autoClosedCharactersRanges.length; i < len; i++) {\n            autoClosedCharactersDeltaDecorations.push({\n                range: autoClosedCharactersRanges[i],\n                options: {\n                    description: 'auto-closed-character',\n                    inlineClassName: 'auto-closed-character',\n                    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */\n                }\n            });\n            autoClosedEnclosingDeltaDecorations.push({\n                range: autoClosedEnclosingRanges[i],\n                options: {\n                    description: 'auto-closed-enclosing',\n                    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */\n                }\n            });\n        }\n        const autoClosedCharactersDecorations = this._model.deltaDecorations([], autoClosedCharactersDeltaDecorations);\n        const autoClosedEnclosingDecorations = this._model.deltaDecorations([], autoClosedEnclosingDeltaDecorations);\n        this._autoClosedActions.push(new AutoClosedAction(this._model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations));\n    }\n    _executeEditOperation(opResult) {\n        if (!opResult) {\n            // Nothing to execute\n            return;\n        }\n        if (opResult.shouldPushStackElementBefore) {\n            this._model.pushStackElement();\n        }\n        const result = CommandExecutor.executeCommands(this._model, this._cursors.getSelections(), opResult.commands);\n        if (result) {\n            // The commands were applied correctly\n            this._interpretCommandResult(result);\n            // Check for auto-closing closed characters\n            const autoClosedCharactersRanges = [];\n            const autoClosedEnclosingRanges = [];\n            for (let i = 0; i < opResult.commands.length; i++) {\n                const command = opResult.commands[i];\n                if (command instanceof TypeWithAutoClosingCommand && command.enclosingRange && command.closeCharacterRange) {\n                    autoClosedCharactersRanges.push(command.closeCharacterRange);\n                    autoClosedEnclosingRanges.push(command.enclosingRange);\n                }\n            }\n            if (autoClosedCharactersRanges.length > 0) {\n                this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n            }\n            this._prevEditOperationType = opResult.type;\n        }\n        if (opResult.shouldPushStackElementAfter) {\n            this._model.pushStackElement();\n        }\n    }\n    _interpretCommandResult(cursorState) {\n        if (!cursorState || cursorState.length === 0) {\n            cursorState = this._cursors.readSelectionFromMarkers();\n        }\n        this._columnSelectData = null;\n        this._cursors.setSelections(cursorState);\n        this._cursors.normalize();\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- emitting events\n    _emitStateChangedIfNecessary(eventsCollector, source, reason, oldState, reachedMaxCursorCount) {\n        const newState = CursorModelState.from(this._model, this);\n        if (newState.equals(oldState)) {\n            return false;\n        }\n        const selections = this._cursors.getSelections();\n        const viewSelections = this._cursors.getViewSelections();\n        // Let the view get the event first.\n        eventsCollector.emitViewEvent(new ViewCursorStateChangedEvent(viewSelections, selections));\n        // Only after the view has been notified, let the rest of the world know...\n        if (!oldState\n            || oldState.cursorState.length !== newState.cursorState.length\n            || newState.cursorState.some((newCursorState, i) => !newCursorState.modelState.equals(oldState.cursorState[i].modelState))) {\n            const oldSelections = oldState ? oldState.cursorState.map(s => s.modelState.selection) : null;\n            const oldModelVersionId = oldState ? oldState.modelVersionId : 0;\n            eventsCollector.emitOutgoingEvent(new CursorStateChangedEvent(oldSelections, selections, oldModelVersionId, newState.modelVersionId, source || 'keyboard', reason, reachedMaxCursorCount));\n        }\n        return true;\n    }\n    // -----------------------------------------------------------------------------------------------------------\n    // ----- handlers beyond this point\n    _findAutoClosingPairs(edits) {\n        if (!edits.length) {\n            return null;\n        }\n        const indices = [];\n        for (let i = 0, len = edits.length; i < len; i++) {\n            const edit = edits[i];\n            if (!edit.text || edit.text.indexOf('\\n') >= 0) {\n                return null;\n            }\n            const m = edit.text.match(/([)\\]}>'\"`])([^)\\]}>'\"`]*)$/);\n            if (!m) {\n                return null;\n            }\n            const closeChar = m[1];\n            const autoClosingPairsCandidates = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(closeChar);\n            if (!autoClosingPairsCandidates || autoClosingPairsCandidates.length !== 1) {\n                return null;\n            }\n            const openChar = autoClosingPairsCandidates[0].open;\n            const closeCharIndex = edit.text.length - m[2].length - 1;\n            const openCharIndex = edit.text.lastIndexOf(openChar, closeCharIndex - 1);\n            if (openCharIndex === -1) {\n                return null;\n            }\n            indices.push([openCharIndex, closeCharIndex]);\n        }\n        return indices;\n    }\n    executeEdits(eventsCollector, source, edits, cursorStateComputer) {\n        let autoClosingIndices = null;\n        if (source === 'snippet') {\n            autoClosingIndices = this._findAutoClosingPairs(edits);\n        }\n        if (autoClosingIndices) {\n            edits[0]._isTracked = true;\n        }\n        const autoClosedCharactersRanges = [];\n        const autoClosedEnclosingRanges = [];\n        const selections = this._model.pushEditOperations(this.getSelections(), edits, (undoEdits) => {\n            if (autoClosingIndices) {\n                for (let i = 0, len = autoClosingIndices.length; i < len; i++) {\n                    const [openCharInnerIndex, closeCharInnerIndex] = autoClosingIndices[i];\n                    const undoEdit = undoEdits[i];\n                    const lineNumber = undoEdit.range.startLineNumber;\n                    const openCharIndex = undoEdit.range.startColumn - 1 + openCharInnerIndex;\n                    const closeCharIndex = undoEdit.range.startColumn - 1 + closeCharInnerIndex;\n                    autoClosedCharactersRanges.push(new Range(lineNumber, closeCharIndex + 1, lineNumber, closeCharIndex + 2));\n                    autoClosedEnclosingRanges.push(new Range(lineNumber, openCharIndex + 1, lineNumber, closeCharIndex + 2));\n                }\n            }\n            const selections = cursorStateComputer(undoEdits);\n            if (selections) {\n                // Don't recover the selection from markers because\n                // we know what it should be.\n                this._isHandling = true;\n            }\n            return selections;\n        });\n        if (selections) {\n            this._isHandling = false;\n            this.setSelections(eventsCollector, source, selections, 0 /* NotSet */);\n        }\n        if (autoClosedCharactersRanges.length > 0) {\n            this._pushAutoClosedAction(autoClosedCharactersRanges, autoClosedEnclosingRanges);\n        }\n    }\n    _executeEdit(callback, eventsCollector, source, cursorChangeReason = 0 /* NotSet */) {\n        if (this.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            return;\n        }\n        const oldState = CursorModelState.from(this._model, this);\n        this._cursors.stopTrackingSelections();\n        this._isHandling = true;\n        try {\n            this._cursors.ensureValidState();\n            callback();\n        }\n        catch (err) {\n            onUnexpectedError(err);\n        }\n        this._isHandling = false;\n        this._cursors.startTrackingSelections();\n        this._validateAutoClosedActions();\n        if (this._emitStateChangedIfNecessary(eventsCollector, source, cursorChangeReason, oldState, false)) {\n            this.revealPrimary(eventsCollector, source, false, 0 /* Simple */, true, 0 /* Smooth */);\n        }\n    }\n    setIsDoingComposition(isDoingComposition) {\n        this._isDoingComposition = isDoingComposition;\n    }\n    getAutoClosedCharacters() {\n        return AutoClosedAction.getAllAutoClosedCharacters(this._autoClosedActions);\n    }\n    startComposition(eventsCollector) {\n        this._selectionsWhenCompositionStarted = this.getSelections().slice(0);\n    }\n    endComposition(eventsCollector, source) {\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // composition finishes, let's check if we need to auto complete if necessary.\n                this._executeEditOperation(TypeOperations.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this._selectionsWhenCompositionStarted, this.getSelections(), this.getAutoClosedCharacters()));\n                this._selectionsWhenCompositionStarted = null;\n            }\n        }, eventsCollector, source);\n    }\n    type(eventsCollector, text, source) {\n        this._executeEdit(() => {\n            if (source === 'keyboard') {\n                // If this event is coming straight from the keyboard, look for electric characters and enter\n                const len = text.length;\n                let offset = 0;\n                while (offset < len) {\n                    const charLength = strings.nextCharLength(text, offset);\n                    const chr = text.substr(offset, charLength);\n                    // Here we must interpret each typed character individually\n                    this._executeEditOperation(TypeOperations.typeWithInterceptors(this._isDoingComposition, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), chr));\n                    offset += charLength;\n                }\n            }\n            else {\n                this._executeEditOperation(TypeOperations.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text));\n            }\n        }, eventsCollector, source);\n    }\n    compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        if (text.length === 0 && replacePrevCharCnt === 0 && replaceNextCharCnt === 0) {\n            // this edit is a no-op\n            if (positionDelta !== 0) {\n                // but it still wants to move the cursor\n                const newSelections = this.getSelections().map(selection => {\n                    const position = selection.getPosition();\n                    return new Selection(position.lineNumber, position.column + positionDelta, position.lineNumber, position.column + positionDelta);\n                });\n                this.setSelections(eventsCollector, source, newSelections, 0 /* NotSet */);\n            }\n            return;\n        }\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        }, eventsCollector, source);\n    }\n    paste(eventsCollector, text, pasteOnNewLine, multicursorText, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(TypeOperations.paste(this.context.cursorConfig, this._model, this.getSelections(), text, pasteOnNewLine, multicursorText || []));\n        }, eventsCollector, source, 4 /* Paste */);\n    }\n    cut(eventsCollector, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(DeleteOperations.cut(this.context.cursorConfig, this._model, this.getSelections()));\n        }, eventsCollector, source);\n    }\n    executeCommand(eventsCollector, command, source) {\n        this._executeEdit(() => {\n            this._cursors.killSecondaryCursors();\n            this._executeEditOperation(new EditOperationResult(0 /* Other */, [command], {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n    executeCommands(eventsCollector, commands, source) {\n        this._executeEdit(() => {\n            this._executeEditOperation(new EditOperationResult(0 /* Other */, commands, {\n                shouldPushStackElementBefore: false,\n                shouldPushStackElementAfter: false\n            }));\n        }, eventsCollector, source);\n    }\n}\nCursorsController.MAX_CURSOR_COUNT = 10000;\n/**\n * A snapshot of the cursor and the model state\n */\nclass CursorModelState {\n    constructor(modelVersionId, cursorState) {\n        this.modelVersionId = modelVersionId;\n        this.cursorState = cursorState;\n    }\n    static from(model, cursor) {\n        return new CursorModelState(model.getVersionId(), cursor.getCursorStates());\n    }\n    equals(other) {\n        if (!other) {\n            return false;\n        }\n        if (this.modelVersionId !== other.modelVersionId) {\n            return false;\n        }\n        if (this.cursorState.length !== other.cursorState.length) {\n            return false;\n        }\n        for (let i = 0, len = this.cursorState.length; i < len; i++) {\n            if (!this.cursorState[i].equals(other.cursorState[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass AutoClosedAction {\n    constructor(model, autoClosedCharactersDecorations, autoClosedEnclosingDecorations) {\n        this._model = model;\n        this._autoClosedCharactersDecorations = autoClosedCharactersDecorations;\n        this._autoClosedEnclosingDecorations = autoClosedEnclosingDecorations;\n    }\n    static getAllAutoClosedCharacters(autoClosedActions) {\n        let autoClosedCharacters = [];\n        for (const autoClosedAction of autoClosedActions) {\n            autoClosedCharacters = autoClosedCharacters.concat(autoClosedAction.getAutoClosedCharactersRanges());\n        }\n        return autoClosedCharacters;\n    }\n    dispose() {\n        this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []);\n        this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);\n    }\n    getAutoClosedCharactersRanges() {\n        const result = [];\n        for (let i = 0; i < this._autoClosedCharactersDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedCharactersDecorations[i]);\n            if (decorationRange) {\n                result.push(decorationRange);\n            }\n        }\n        return result;\n    }\n    isValid(selections) {\n        const enclosingRanges = [];\n        for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {\n            const decorationRange = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);\n            if (decorationRange) {\n                enclosingRanges.push(decorationRange);\n                if (decorationRange.startLineNumber !== decorationRange.endLineNumber) {\n                    // Stop tracking if the range becomes multiline...\n                    return false;\n                }\n            }\n        }\n        enclosingRanges.sort(Range.compareRangesUsingStarts);\n        selections.sort(Range.compareRangesUsingStarts);\n        for (let i = 0; i < selections.length; i++) {\n            if (i >= enclosingRanges.length) {\n                return false;\n            }\n            if (!enclosingRanges[i].strictContainsRange(selections[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nclass CommandExecutor {\n    static executeCommands(model, selectionsBefore, commands) {\n        const ctx = {\n            model: model,\n            selectionsBefore: selectionsBefore,\n            trackedRanges: [],\n            trackedRangesDirection: []\n        };\n        const result = this._innerExecuteCommands(ctx, commands);\n        for (let i = 0, len = ctx.trackedRanges.length; i < len; i++) {\n            ctx.model._setTrackedRange(ctx.trackedRanges[i], null, 0 /* AlwaysGrowsWhenTypingAtEdges */);\n        }\n        return result;\n    }\n    static _innerExecuteCommands(ctx, commands) {\n        if (this._arrayIsEmpty(commands)) {\n            return null;\n        }\n        const commandsData = this._getEditOperations(ctx, commands);\n        if (commandsData.operations.length === 0) {\n            return null;\n        }\n        const rawOperations = commandsData.operations;\n        const loserCursorsMap = this._getLoserCursorMap(rawOperations);\n        if (loserCursorsMap.hasOwnProperty('0')) {\n            // These commands are very messed up\n            console.warn('Ignoring commands');\n            return null;\n        }\n        // Remove operations belonging to losing cursors\n        const filteredOperations = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {\n                filteredOperations.push(rawOperations[i]);\n            }\n        }\n        // TODO@Alex: find a better way to do this.\n        // give the hint that edit operations are tracked to the model\n        if (commandsData.hadTrackedEditOperation && filteredOperations.length > 0) {\n            filteredOperations[0]._isTracked = true;\n        }\n        let selectionsAfter = ctx.model.pushEditOperations(ctx.selectionsBefore, filteredOperations, (inverseEditOperations) => {\n            const groupedInverseEditOperations = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                groupedInverseEditOperations[i] = [];\n            }\n            for (const op of inverseEditOperations) {\n                if (!op.identifier) {\n                    // perhaps auto whitespace trim edits\n                    continue;\n                }\n                groupedInverseEditOperations[op.identifier.major].push(op);\n            }\n            const minorBasedSorter = (a, b) => {\n                return a.identifier.minor - b.identifier.minor;\n            };\n            const cursorSelections = [];\n            for (let i = 0; i < ctx.selectionsBefore.length; i++) {\n                if (groupedInverseEditOperations[i].length > 0) {\n                    groupedInverseEditOperations[i].sort(minorBasedSorter);\n                    cursorSelections[i] = commands[i].computeCursorState(ctx.model, {\n                        getInverseEditOperations: () => {\n                            return groupedInverseEditOperations[i];\n                        },\n                        getTrackedSelection: (id) => {\n                            const idx = parseInt(id, 10);\n                            const range = ctx.model._getTrackedRange(ctx.trackedRanges[idx]);\n                            if (ctx.trackedRangesDirection[idx] === 0 /* LTR */) {\n                                return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n                            }\n                            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n                        }\n                    });\n                }\n                else {\n                    cursorSelections[i] = ctx.selectionsBefore[i];\n                }\n            }\n            return cursorSelections;\n        });\n        if (!selectionsAfter) {\n            selectionsAfter = ctx.selectionsBefore;\n        }\n        // Extract losing cursors\n        const losingCursors = [];\n        for (let losingCursorIndex in loserCursorsMap) {\n            if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {\n                losingCursors.push(parseInt(losingCursorIndex, 10));\n            }\n        }\n        // Sort losing cursors descending\n        losingCursors.sort((a, b) => {\n            return b - a;\n        });\n        // Remove losing cursors\n        for (const losingCursor of losingCursors) {\n            selectionsAfter.splice(losingCursor, 1);\n        }\n        return selectionsAfter;\n    }\n    static _arrayIsEmpty(commands) {\n        for (let i = 0, len = commands.length; i < len; i++) {\n            if (commands[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _getEditOperations(ctx, commands) {\n        let operations = [];\n        let hadTrackedEditOperation = false;\n        for (let i = 0, len = commands.length; i < len; i++) {\n            const command = commands[i];\n            if (command) {\n                const r = this._getEditOperationsFromCommand(ctx, i, command);\n                operations = operations.concat(r.operations);\n                hadTrackedEditOperation = hadTrackedEditOperation || r.hadTrackedEditOperation;\n            }\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getEditOperationsFromCommand(ctx, majorIdentifier, command) {\n        // This method acts as a transaction, if the command fails\n        // everything it has done is ignored\n        const operations = [];\n        let operationMinor = 0;\n        const addEditOperation = (range, text, forceMoveMarkers = false) => {\n            if (Range.isEmpty(range) && text === '') {\n                // This command wants to add a no-op => no thank you\n                return;\n            }\n            operations.push({\n                identifier: {\n                    major: majorIdentifier,\n                    minor: operationMinor++\n                },\n                range: range,\n                text: text,\n                forceMoveMarkers: forceMoveMarkers,\n                isAutoWhitespaceEdit: command.insertsAutoWhitespace\n            });\n        };\n        let hadTrackedEditOperation = false;\n        const addTrackedEditOperation = (selection, text, forceMoveMarkers) => {\n            hadTrackedEditOperation = true;\n            addEditOperation(selection, text, forceMoveMarkers);\n        };\n        const trackSelection = (_selection, trackPreviousOnEmpty) => {\n            const selection = Selection.liftSelection(_selection);\n            let stickiness;\n            if (selection.isEmpty()) {\n                if (typeof trackPreviousOnEmpty === 'boolean') {\n                    if (trackPreviousOnEmpty) {\n                        stickiness = 2 /* GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n                else {\n                    // Try to lock it with surrounding text\n                    const maxLineColumn = ctx.model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn === maxLineColumn) {\n                        stickiness = 2 /* GrowsOnlyWhenTypingBefore */;\n                    }\n                    else {\n                        stickiness = 3 /* GrowsOnlyWhenTypingAfter */;\n                    }\n                }\n            }\n            else {\n                stickiness = 1 /* NeverGrowsWhenTypingAtEdges */;\n            }\n            const l = ctx.trackedRanges.length;\n            const id = ctx.model._setTrackedRange(null, selection, stickiness);\n            ctx.trackedRanges[l] = id;\n            ctx.trackedRangesDirection[l] = selection.getDirection();\n            return l.toString();\n        };\n        const editOperationBuilder = {\n            addEditOperation: addEditOperation,\n            addTrackedEditOperation: addTrackedEditOperation,\n            trackSelection: trackSelection\n        };\n        try {\n            command.getEditOperations(ctx.model, editOperationBuilder);\n        }\n        catch (e) {\n            // TODO@Alex use notification service if this should be user facing\n            // e.friendlyMessage = nls.localize('corrupt.commands', \"Unexpected exception while executing command.\");\n            onUnexpectedError(e);\n            return {\n                operations: [],\n                hadTrackedEditOperation: false\n            };\n        }\n        return {\n            operations: operations,\n            hadTrackedEditOperation: hadTrackedEditOperation\n        };\n    }\n    static _getLoserCursorMap(operations) {\n        // This is destructive on the array\n        operations = operations.slice(0);\n        // Sort operations with last one first\n        operations.sort((a, b) => {\n            // Note the minus!\n            return -(Range.compareRangesUsingEnds(a.range, b.range));\n        });\n        // Operations can not overlap!\n        const loserCursorsMap = {};\n        for (let i = 1; i < operations.length; i++) {\n            const previousOp = operations[i - 1];\n            const currentOp = operations[i];\n            if (Range.getStartPosition(previousOp.range).isBefore(Range.getEndPosition(currentOp.range))) {\n                let loserMajor;\n                if (previousOp.identifier.major > currentOp.identifier.major) {\n                    // previousOp loses the battle\n                    loserMajor = previousOp.identifier.major;\n                }\n                else {\n                    loserMajor = currentOp.identifier.major;\n                }\n                loserCursorsMap[loserMajor.toString()] = true;\n                for (let j = 0; j < operations.length; j++) {\n                    if (operations[j].identifier.major === loserMajor) {\n                        operations.splice(j, 1);\n                        if (j < i) {\n                            i--;\n                        }\n                        j--;\n                    }\n                }\n                if (i > 0) {\n                    i--;\n                }\n            }\n        }\n        return loserCursorsMap;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CursorColumns } from '../core/cursorColumns.js';\nexport class AtomicTabMoveOperations {\n    /**\n     * Get the visible column at the position. If we get to a non-whitespace character first\n     * or past the end of string then return -1.\n     *\n     * **Note** `position` and the return value are 0-based.\n     */\n    static whitespaceVisibleColumn(lineContent, position, tabSize) {\n        const lineLength = lineContent.length;\n        let visibleColumn = 0;\n        let prevTabStopPosition = -1;\n        let prevTabStopVisibleColumn = -1;\n        for (let i = 0; i < lineLength; i++) {\n            if (i === position) {\n                return [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn];\n            }\n            if (visibleColumn % tabSize === 0) {\n                prevTabStopPosition = i;\n                prevTabStopVisibleColumn = visibleColumn;\n            }\n            const chCode = lineContent.charCodeAt(i);\n            switch (chCode) {\n                case 32 /* Space */:\n                    visibleColumn += 1;\n                    break;\n                case 9 /* Tab */:\n                    // Skip to the next multiple of tabSize.\n                    visibleColumn = CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n                    break;\n                default:\n                    return [-1, -1, -1];\n            }\n        }\n        if (position === lineLength) {\n            return [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn];\n        }\n        return [-1, -1, -1];\n    }\n    /**\n     * Return the position that should result from a move left, right or to the\n     * nearest tab, if atomic tabs are enabled. Left and right are used for the\n     * arrow key movements, nearest is used for mouse selection. It returns\n     * -1 if atomic tabs are not relevant and you should fall back to normal\n     * behaviour.\n     *\n     * **Note**: `position` and the return value are 0-based.\n     */\n    static atomicPosition(lineContent, position, tabSize, direction) {\n        const lineLength = lineContent.length;\n        // Get the 0-based visible column corresponding to the position, or return\n        // -1 if it is not in the initial whitespace.\n        const [prevTabStopPosition, prevTabStopVisibleColumn, visibleColumn] = AtomicTabMoveOperations.whitespaceVisibleColumn(lineContent, position, tabSize);\n        if (visibleColumn === -1) {\n            return -1;\n        }\n        // Is the output left or right of the current position. The case for nearest\n        // where it is the same as the current position is handled in the switch.\n        let left;\n        switch (direction) {\n            case 0 /* Left */:\n                left = true;\n                break;\n            case 1 /* Right */:\n                left = false;\n                break;\n            case 2 /* Nearest */:\n                // The code below assumes the output position is either left or right\n                // of the input position. If it is the same, return immediately.\n                if (visibleColumn % tabSize === 0) {\n                    return position;\n                }\n                // Go to the nearest indentation.\n                left = visibleColumn % tabSize <= (tabSize / 2);\n                break;\n        }\n        // If going left, we can just use the info about the last tab stop position and\n        // last tab stop visible column that we computed in the first walk over the whitespace.\n        if (left) {\n            if (prevTabStopPosition === -1) {\n                return -1;\n            }\n            // If the direction is left, we need to keep scanning right to ensure\n            // that targetVisibleColumn + tabSize is before non-whitespace.\n            // This is so that when we press left at the end of a partial\n            // indentation it only goes one character. For example '      foo' with\n            // tabSize 4, should jump from position 6 to position 5, not 4.\n            let currentVisibleColumn = prevTabStopVisibleColumn;\n            for (let i = prevTabStopPosition; i < lineLength; ++i) {\n                if (currentVisibleColumn === prevTabStopVisibleColumn + tabSize) {\n                    // It is a full indentation.\n                    return prevTabStopPosition;\n                }\n                const chCode = lineContent.charCodeAt(i);\n                switch (chCode) {\n                    case 32 /* Space */:\n                        currentVisibleColumn += 1;\n                        break;\n                    case 9 /* Tab */:\n                        currentVisibleColumn = CursorColumns.nextRenderTabStop(currentVisibleColumn, tabSize);\n                        break;\n                    default:\n                        return -1;\n                }\n            }\n            if (currentVisibleColumn === prevTabStopVisibleColumn + tabSize) {\n                return prevTabStopPosition;\n            }\n            // It must have been a partial indentation.\n            return -1;\n        }\n        // We are going right.\n        const targetVisibleColumn = CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        // We can just continue from where whitespaceVisibleColumn got to.\n        let currentVisibleColumn = visibleColumn;\n        for (let i = position; i < lineLength; i++) {\n            if (currentVisibleColumn === targetVisibleColumn) {\n                return i;\n            }\n            const chCode = lineContent.charCodeAt(i);\n            switch (chCode) {\n                case 32 /* Space */:\n                    currentVisibleColumn += 1;\n                    break;\n                case 9 /* Tab */:\n                    currentVisibleColumn = CursorColumns.nextRenderTabStop(currentVisibleColumn, tabSize);\n                    break;\n                default:\n                    return -1;\n            }\n        }\n        // This condition handles when the target column is at the end of the line.\n        if (currentVisibleColumn === targetVisibleColumn) {\n            return lineLength;\n        }\n        return -1;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class ColumnSelection {\n    static columnSelect(config, model, fromLineNumber, fromVisibleColumn, toLineNumber, toVisibleColumn) {\n        const lineCount = Math.abs(toLineNumber - fromLineNumber) + 1;\n        const reversed = (fromLineNumber > toLineNumber);\n        const isRTL = (fromVisibleColumn > toVisibleColumn);\n        const isLTR = (fromVisibleColumn < toVisibleColumn);\n        const result = [];\n        // console.log(`fromVisibleColumn: ${fromVisibleColumn}, toVisibleColumn: ${toVisibleColumn}`);\n        for (let i = 0; i < lineCount; i++) {\n            const lineNumber = fromLineNumber + (reversed ? -i : i);\n            const startColumn = config.columnFromVisibleColumn(model, lineNumber, fromVisibleColumn);\n            const endColumn = config.columnFromVisibleColumn(model, lineNumber, toVisibleColumn);\n            const visibleStartColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, startColumn));\n            const visibleEndColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, endColumn));\n            // console.log(`lineNumber: ${lineNumber}: visibleStartColumn: ${visibleStartColumn}, visibleEndColumn: ${visibleEndColumn}`);\n            if (isLTR) {\n                if (visibleStartColumn > toVisibleColumn) {\n                    continue;\n                }\n                if (visibleEndColumn < fromVisibleColumn) {\n                    continue;\n                }\n            }\n            if (isRTL) {\n                if (visibleEndColumn > fromVisibleColumn) {\n                    continue;\n                }\n                if (visibleStartColumn < toVisibleColumn) {\n                    continue;\n                }\n            }\n            result.push(new SingleCursorState(new Range(lineNumber, startColumn, lineNumber, startColumn), 0, new Position(lineNumber, endColumn), 0));\n        }\n        if (result.length === 0) {\n            // We are after all the lines, so add cursor at the end of each line\n            for (let i = 0; i < lineCount; i++) {\n                const lineNumber = fromLineNumber + (reversed ? -i : i);\n                const maxColumn = model.getLineMaxColumn(lineNumber);\n                result.push(new SingleCursorState(new Range(lineNumber, maxColumn, lineNumber, maxColumn), 0, new Position(lineNumber, maxColumn), 0));\n            }\n        }\n        return {\n            viewStates: result,\n            reversed: reversed,\n            fromLineNumber: fromLineNumber,\n            fromVisualColumn: fromVisibleColumn,\n            toLineNumber: toLineNumber,\n            toVisualColumn: toVisibleColumn\n        };\n    }\n    static columnSelectLeft(config, model, prevColumnSelectData) {\n        let toViewVisualColumn = prevColumnSelectData.toViewVisualColumn;\n        if (toViewVisualColumn > 0) {\n            toViewVisualColumn--;\n        }\n        return ColumnSelection.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, prevColumnSelectData.toViewLineNumber, toViewVisualColumn);\n    }\n    static columnSelectRight(config, model, prevColumnSelectData) {\n        let maxVisualViewColumn = 0;\n        const minViewLineNumber = Math.min(prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.toViewLineNumber);\n        const maxViewLineNumber = Math.max(prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.toViewLineNumber);\n        for (let lineNumber = minViewLineNumber; lineNumber <= maxViewLineNumber; lineNumber++) {\n            const lineMaxViewColumn = model.getLineMaxColumn(lineNumber);\n            const lineMaxVisualViewColumn = config.visibleColumnFromColumn(model, new Position(lineNumber, lineMaxViewColumn));\n            maxVisualViewColumn = Math.max(maxVisualViewColumn, lineMaxVisualViewColumn);\n        }\n        let toViewVisualColumn = prevColumnSelectData.toViewVisualColumn;\n        if (toViewVisualColumn < maxVisualViewColumn) {\n            toViewVisualColumn++;\n        }\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, prevColumnSelectData.toViewLineNumber, toViewVisualColumn);\n    }\n    static columnSelectUp(config, model, prevColumnSelectData, isPaged) {\n        const linesCount = isPaged ? config.pageSize : 1;\n        const toViewLineNumber = Math.max(1, prevColumnSelectData.toViewLineNumber - linesCount);\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, toViewLineNumber, prevColumnSelectData.toViewVisualColumn);\n    }\n    static columnSelectDown(config, model, prevColumnSelectData, isPaged) {\n        const linesCount = isPaged ? config.pageSize : 1;\n        const toViewLineNumber = Math.min(model.getLineCount(), prevColumnSelectData.toViewLineNumber + linesCount);\n        return this.columnSelect(config, model, prevColumnSelectData.fromViewLineNumber, prevColumnSelectData.fromViewVisualColumn, toViewLineNumber, prevColumnSelectData.toViewVisualColumn);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand } from '../commands/replaceCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { Range } from '../core/range.js';\nimport { Position } from '../core/position.js';\nexport class DeleteOperations {\n    static deleteRight(prevEditOperationType, config, model, selections) {\n        const commands = [];\n        let shouldPushStackElementBefore = (prevEditOperationType !== 3 /* DeletingRight */);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            let deleteSelection = selection;\n            if (deleteSelection.isEmpty()) {\n                const position = selection.getPosition();\n                const rightOfPosition = MoveOperations.right(config, model, position);\n                deleteSelection = new Range(rightOfPosition.lineNumber, rightOfPosition.column, position.lineNumber, position.column);\n            }\n            if (deleteSelection.isEmpty()) {\n                // Probably at end of file => ignore\n                commands[i] = null;\n                continue;\n            }\n            if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {\n                shouldPushStackElementBefore = true;\n            }\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n        }\n        return [shouldPushStackElementBefore, commands];\n    }\n    static isAutoClosingPairDelete(autoClosingDelete, autoClosingBrackets, autoClosingQuotes, autoClosingPairsOpen, model, selections, autoClosedCharacters) {\n        if (autoClosingBrackets === 'never' && autoClosingQuotes === 'never') {\n            return false;\n        }\n        if (autoClosingDelete === 'never') {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            if (!selection.isEmpty()) {\n                return false;\n            }\n            const lineText = model.getLineContent(position.lineNumber);\n            if (position.column < 2 || position.column >= lineText.length + 1) {\n                return false;\n            }\n            const character = lineText.charAt(position.column - 2);\n            const autoClosingPairCandidates = autoClosingPairsOpen.get(character);\n            if (!autoClosingPairCandidates) {\n                return false;\n            }\n            if (isQuote(character)) {\n                if (autoClosingQuotes === 'never') {\n                    return false;\n                }\n            }\n            else {\n                if (autoClosingBrackets === 'never') {\n                    return false;\n                }\n            }\n            const afterCharacter = lineText.charAt(position.column - 1);\n            let foundAutoClosingPair = false;\n            for (const autoClosingPairCandidate of autoClosingPairCandidates) {\n                if (autoClosingPairCandidate.open === character && autoClosingPairCandidate.close === afterCharacter) {\n                    foundAutoClosingPair = true;\n                }\n            }\n            if (!foundAutoClosingPair) {\n                return false;\n            }\n            // Must delete the pair only if it was automatically inserted by the editor\n            if (autoClosingDelete === 'auto') {\n                let found = false;\n                for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                    const autoClosedCharacter = autoClosedCharacters[j];\n                    if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runAutoClosingPairDelete(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const position = selections[i].getPosition();\n            const deleteSelection = new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(deleteSelection, '');\n        }\n        return [true, commands];\n    }\n    static deleteLeft(prevEditOperationType, config, model, selections, autoClosedCharacters) {\n        if (this.isAutoClosingPairDelete(config.autoClosingDelete, config.autoClosingBrackets, config.autoClosingQuotes, config.autoClosingPairs.autoClosingPairsOpenByEnd, model, selections, autoClosedCharacters)) {\n            return this._runAutoClosingPairDelete(config, model, selections);\n        }\n        const commands = [];\n        let shouldPushStackElementBefore = (prevEditOperationType !== 2 /* DeletingLeft */);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const deleteRange = DeleteOperations.getDeleteRange(selections[i], model, config);\n            // Ignore empty delete ranges, as they have no effect\n            // They happen if the cursor is at the beginning of the file.\n            if (deleteRange.isEmpty()) {\n                commands[i] = null;\n                continue;\n            }\n            if (deleteRange.startLineNumber !== deleteRange.endLineNumber) {\n                shouldPushStackElementBefore = true;\n            }\n            commands[i] = new ReplaceCommand(deleteRange, '');\n        }\n        return [shouldPushStackElementBefore, commands];\n    }\n    static getDeleteRange(selection, model, config) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = selection.getPosition();\n        // Unintend when using tab stops and cursor is within indentation\n        if (config.useTabStops && position.column > 1) {\n            const lineContent = model.getLineContent(position.lineNumber);\n            const firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);\n            const lastIndentationColumn = (firstNonWhitespaceIndex === -1\n                ? /* entire string is whitespace */ lineContent.length + 1\n                : firstNonWhitespaceIndex + 1);\n            if (position.column <= lastIndentationColumn) {\n                const fromVisibleColumn = config.visibleColumnFromColumn(model, position);\n                const toVisibleColumn = CursorColumns.prevIndentTabStop(fromVisibleColumn, config.indentSize);\n                const toColumn = config.columnFromVisibleColumn(model, position.lineNumber, toVisibleColumn);\n                return new Range(position.lineNumber, toColumn, position.lineNumber, position.column);\n            }\n        }\n        return Range.fromPositions(DeleteOperations.getPositionAfterDeleteLeft(position, model), position);\n    }\n    static getPositionAfterDeleteLeft(position, model) {\n        if (position.column > 1) {\n            // Convert 1-based columns to 0-based offsets and back.\n            const idx = strings.getLeftDeleteOffset(position.column - 1, model.getLineContent(position.lineNumber));\n            return position.with(undefined, idx + 1);\n        }\n        else if (position.lineNumber > 1) {\n            const newLine = position.lineNumber - 1;\n            return new Position(newLine, model.getLineMaxColumn(newLine));\n        }\n        else {\n            return position;\n        }\n    }\n    static cut(config, model, selections) {\n        const commands = [];\n        let lastCutRange = null;\n        selections.sort((a, b) => Position.compare(a.getStartPosition(), b.getEndPosition()));\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                if (config.emptySelectionClipboard) {\n                    // This is a full line cut\n                    const position = selection.getPosition();\n                    let startLineNumber, startColumn, endLineNumber, endColumn;\n                    if (position.lineNumber < model.getLineCount()) {\n                        // Cutting a line in the middle of the model\n                        startLineNumber = position.lineNumber;\n                        startColumn = 1;\n                        endLineNumber = position.lineNumber + 1;\n                        endColumn = 1;\n                    }\n                    else if (position.lineNumber > 1 && (lastCutRange === null || lastCutRange === void 0 ? void 0 : lastCutRange.endLineNumber) !== position.lineNumber) {\n                        // Cutting the last line & there are more than 1 lines in the model & a previous cut operation does not touch the current cut operation\n                        startLineNumber = position.lineNumber - 1;\n                        startColumn = model.getLineMaxColumn(position.lineNumber - 1);\n                        endLineNumber = position.lineNumber;\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\n                    }\n                    else {\n                        // Cutting the single line that the model contains\n                        startLineNumber = position.lineNumber;\n                        startColumn = 1;\n                        endLineNumber = position.lineNumber;\n                        endColumn = model.getLineMaxColumn(position.lineNumber);\n                    }\n                    const deleteSelection = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n                    lastCutRange = deleteSelection;\n                    if (!deleteSelection.isEmpty()) {\n                        commands[i] = new ReplaceCommand(deleteSelection, '');\n                    }\n                    else {\n                        commands[i] = null;\n                    }\n                }\n                else {\n                    // Cannot cut empty selection\n                    commands[i] = null;\n                }\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, '');\n            }\n        }\n        return new EditOperationResult(0 /* Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as types from '../../../base/common/types.js';\nimport { CursorState, SingleCursorState } from '../cursorCommon.js';\nimport { MoveOperations } from './cursorMoveOperations.js';\nimport { WordOperations } from './cursorWordOperations.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class CursorMoveCommands {\n    static addCursorDown(viewModel, cursors, useLogicalLine) {\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n            if (useLogicalLine) {\n                result[resultLen++] = CursorState.fromModelState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n            }\n            else {\n                result[resultLen++] = CursorState.fromViewState(MoveOperations.translateDown(viewModel.cursorConfig, viewModel, cursor.viewState));\n            }\n        }\n        return result;\n    }\n    static addCursorUp(viewModel, cursors, useLogicalLine) {\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[resultLen++] = new CursorState(cursor.modelState, cursor.viewState);\n            if (useLogicalLine) {\n                result[resultLen++] = CursorState.fromModelState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel.model, cursor.modelState));\n            }\n            else {\n                result[resultLen++] = CursorState.fromViewState(MoveOperations.translateUp(viewModel.cursorConfig, viewModel, cursor.viewState));\n            }\n        }\n        return result;\n    }\n    static moveToBeginningOfLine(viewModel, cursors, inSelectionMode) {\n        let result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = this._moveToLineStart(viewModel, cursor, inSelectionMode);\n        }\n        return result;\n    }\n    static _moveToLineStart(viewModel, cursor, inSelectionMode) {\n        const currentViewStateColumn = cursor.viewState.position.column;\n        const currentModelStateColumn = cursor.modelState.position.column;\n        const isFirstLineOfWrappedLine = currentViewStateColumn === currentModelStateColumn;\n        const currentViewStatelineNumber = cursor.viewState.position.lineNumber;\n        const firstNonBlankColumn = viewModel.getLineFirstNonWhitespaceColumn(currentViewStatelineNumber);\n        const isBeginningOfViewLine = currentViewStateColumn === firstNonBlankColumn;\n        if (!isFirstLineOfWrappedLine && !isBeginningOfViewLine) {\n            return this._moveToLineStartByView(viewModel, cursor, inSelectionMode);\n        }\n        else {\n            return this._moveToLineStartByModel(viewModel, cursor, inSelectionMode);\n        }\n    }\n    static _moveToLineStartByView(viewModel, cursor, inSelectionMode) {\n        return CursorState.fromViewState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode));\n    }\n    static _moveToLineStartByModel(viewModel, cursor, inSelectionMode) {\n        return CursorState.fromModelState(MoveOperations.moveToBeginningOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n    }\n    static moveToEndOfLine(viewModel, cursors, inSelectionMode, sticky) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = this._moveToLineEnd(viewModel, cursor, inSelectionMode, sticky);\n        }\n        return result;\n    }\n    static _moveToLineEnd(viewModel, cursor, inSelectionMode, sticky) {\n        const viewStatePosition = cursor.viewState.position;\n        const viewModelMaxColumn = viewModel.getLineMaxColumn(viewStatePosition.lineNumber);\n        const isEndOfViewLine = viewStatePosition.column === viewModelMaxColumn;\n        const modelStatePosition = cursor.modelState.position;\n        const modelMaxColumn = viewModel.model.getLineMaxColumn(modelStatePosition.lineNumber);\n        const isEndLineOfWrappedLine = viewModelMaxColumn - viewStatePosition.column === modelMaxColumn - modelStatePosition.column;\n        if (isEndOfViewLine || isEndLineOfWrappedLine) {\n            return this._moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky);\n        }\n        else {\n            return this._moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky);\n        }\n    }\n    static _moveToLineEndByView(viewModel, cursor, inSelectionMode, sticky) {\n        return CursorState.fromViewState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, sticky));\n    }\n    static _moveToLineEndByModel(viewModel, cursor, inSelectionMode, sticky) {\n        return CursorState.fromModelState(MoveOperations.moveToEndOfLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, sticky));\n    }\n    static expandLineSelection(viewModel, cursors) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const startLineNumber = cursor.modelState.selection.startLineNumber;\n            const lineCount = viewModel.model.getLineCount();\n            let endLineNumber = cursor.modelState.selection.endLineNumber;\n            let endColumn;\n            if (endLineNumber === lineCount) {\n                endColumn = viewModel.model.getLineMaxColumn(lineCount);\n            }\n            else {\n                endLineNumber++;\n                endColumn = 1;\n            }\n            result[i] = CursorState.fromModelState(new SingleCursorState(new Range(startLineNumber, 1, startLineNumber, 1), 0, new Position(endLineNumber, endColumn), 0));\n        }\n        return result;\n    }\n    static moveToBeginningOfBuffer(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveToBeginningOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n        }\n        return result;\n    }\n    static moveToEndOfBuffer(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveToEndOfBuffer(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode));\n        }\n        return result;\n    }\n    static selectAll(viewModel, cursor) {\n        const lineCount = viewModel.model.getLineCount();\n        const maxColumn = viewModel.model.getLineMaxColumn(lineCount);\n        return CursorState.fromModelState(new SingleCursorState(new Range(1, 1, 1, 1), 0, new Position(lineCount, maxColumn), 0));\n    }\n    static line(viewModel, cursor, inSelectionMode, _position, _viewPosition) {\n        const position = viewModel.model.validatePosition(_position);\n        const viewPosition = (_viewPosition\n            ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\n            : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position));\n        if (!inSelectionMode || !cursor.modelState.hasSelection()) {\n            // Entering line selection for the first time\n            const lineCount = viewModel.model.getLineCount();\n            let selectToLineNumber = position.lineNumber + 1;\n            let selectToColumn = 1;\n            if (selectToLineNumber > lineCount) {\n                selectToLineNumber = lineCount;\n                selectToColumn = viewModel.model.getLineMaxColumn(selectToLineNumber);\n            }\n            return CursorState.fromModelState(new SingleCursorState(new Range(position.lineNumber, 1, selectToLineNumber, selectToColumn), 0, new Position(selectToLineNumber, selectToColumn), 0));\n        }\n        // Continuing line selection\n        const enteringLineNumber = cursor.modelState.selectionStart.getStartPosition().lineNumber;\n        if (position.lineNumber < enteringLineNumber) {\n            return CursorState.fromViewState(cursor.viewState.move(cursor.modelState.hasSelection(), viewPosition.lineNumber, 1, 0));\n        }\n        else if (position.lineNumber > enteringLineNumber) {\n            const lineCount = viewModel.getLineCount();\n            let selectToViewLineNumber = viewPosition.lineNumber + 1;\n            let selectToViewColumn = 1;\n            if (selectToViewLineNumber > lineCount) {\n                selectToViewLineNumber = lineCount;\n                selectToViewColumn = viewModel.getLineMaxColumn(selectToViewLineNumber);\n            }\n            return CursorState.fromViewState(cursor.viewState.move(cursor.modelState.hasSelection(), selectToViewLineNumber, selectToViewColumn, 0));\n        }\n        else {\n            const endPositionOfSelectionStart = cursor.modelState.selectionStart.getEndPosition();\n            return CursorState.fromModelState(cursor.modelState.move(cursor.modelState.hasSelection(), endPositionOfSelectionStart.lineNumber, endPositionOfSelectionStart.column, 0));\n        }\n    }\n    static word(viewModel, cursor, inSelectionMode, _position) {\n        const position = viewModel.model.validatePosition(_position);\n        return CursorState.fromModelState(WordOperations.word(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, position));\n    }\n    static cancelSelection(viewModel, cursor) {\n        if (!cursor.modelState.hasSelection()) {\n            return new CursorState(cursor.modelState, cursor.viewState);\n        }\n        const lineNumber = cursor.viewState.position.lineNumber;\n        const column = cursor.viewState.position.column;\n        return CursorState.fromViewState(new SingleCursorState(new Range(lineNumber, column, lineNumber, column), 0, new Position(lineNumber, column), 0));\n    }\n    static moveTo(viewModel, cursor, inSelectionMode, _position, _viewPosition) {\n        const position = viewModel.model.validatePosition(_position);\n        const viewPosition = (_viewPosition\n            ? viewModel.coordinatesConverter.validateViewPosition(new Position(_viewPosition.lineNumber, _viewPosition.column), position)\n            : viewModel.coordinatesConverter.convertModelPositionToViewPosition(position));\n        return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, viewPosition.lineNumber, viewPosition.column, 0));\n    }\n    static simpleMove(viewModel, cursors, direction, inSelectionMode, value, unit) {\n        switch (direction) {\n            case 0 /* Left */: {\n                if (unit === 4 /* HalfLine */) {\n                    // Move left by half the current line length\n                    return this._moveHalfLineLeft(viewModel, cursors, inSelectionMode);\n                }\n                else {\n                    // Move left by `moveParams.value` columns\n                    return this._moveLeft(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 1 /* Right */: {\n                if (unit === 4 /* HalfLine */) {\n                    // Move right by half the current line length\n                    return this._moveHalfLineRight(viewModel, cursors, inSelectionMode);\n                }\n                else {\n                    // Move right by `moveParams.value` columns\n                    return this._moveRight(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 2 /* Up */: {\n                if (unit === 2 /* WrappedLine */) {\n                    // Move up by view lines\n                    return this._moveUpByViewLines(viewModel, cursors, inSelectionMode, value);\n                }\n                else {\n                    // Move up by model lines\n                    return this._moveUpByModelLines(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 3 /* Down */: {\n                if (unit === 2 /* WrappedLine */) {\n                    // Move down by view lines\n                    return this._moveDownByViewLines(viewModel, cursors, inSelectionMode, value);\n                }\n                else {\n                    // Move down by model lines\n                    return this._moveDownByModelLines(viewModel, cursors, inSelectionMode, value);\n                }\n            }\n            case 4 /* PrevBlankLine */: {\n                if (unit === 2 /* WrappedLine */) {\n                    return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)));\n                }\n                else {\n                    return cursors.map(cursor => CursorState.fromModelState(MoveOperations.moveToPrevBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)));\n                }\n            }\n            case 5 /* NextBlankLine */: {\n                if (unit === 2 /* WrappedLine */) {\n                    return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode)));\n                }\n                else {\n                    return cursors.map(cursor => CursorState.fromModelState(MoveOperations.moveToNextBlankLine(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode)));\n                }\n            }\n            case 6 /* WrappedLineStart */: {\n                // Move to the beginning of the current view line\n                return this._moveToViewMinColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 7 /* WrappedLineFirstNonWhitespaceCharacter */: {\n                // Move to the first non-whitespace column of the current view line\n                return this._moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 8 /* WrappedLineColumnCenter */: {\n                // Move to the \"center\" of the current view line\n                return this._moveToViewCenterColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 9 /* WrappedLineEnd */: {\n                // Move to the end of the current view line\n                return this._moveToViewMaxColumn(viewModel, cursors, inSelectionMode);\n            }\n            case 10 /* WrappedLineLastNonWhitespaceCharacter */: {\n                // Move to the last non-whitespace column of the current view line\n                return this._moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode);\n            }\n            default:\n                return null;\n        }\n    }\n    static viewportMove(viewModel, cursors, direction, inSelectionMode, value) {\n        const visibleViewRange = viewModel.getCompletelyVisibleViewRange();\n        const visibleModelRange = viewModel.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n        switch (direction) {\n            case 11 /* ViewPortTop */: {\n                // Move to the nth line start in the viewport (from the top)\n                const modelLineNumber = this._firstLineNumberInRange(viewModel.model, visibleModelRange, value);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 13 /* ViewPortBottom */: {\n                // Move to the nth line start in the viewport (from the bottom)\n                const modelLineNumber = this._lastLineNumberInRange(viewModel.model, visibleModelRange, value);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 12 /* ViewPortCenter */: {\n                // Move to the line start in the viewport center\n                const modelLineNumber = Math.round((visibleModelRange.startLineNumber + visibleModelRange.endLineNumber) / 2);\n                const modelColumn = viewModel.model.getLineFirstNonWhitespaceColumn(modelLineNumber);\n                return [this._moveToModelPosition(viewModel, cursors[0], inSelectionMode, modelLineNumber, modelColumn)];\n            }\n            case 14 /* ViewPortIfOutside */: {\n                // Move to a position inside the viewport\n                const result = [];\n                for (let i = 0, len = cursors.length; i < len; i++) {\n                    const cursor = cursors[i];\n                    result[i] = this.findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode);\n                }\n                return result;\n            }\n            default:\n                return null;\n        }\n    }\n    static findPositionInViewportIfOutside(viewModel, cursor, visibleViewRange, inSelectionMode) {\n        const viewLineNumber = cursor.viewState.position.lineNumber;\n        if (visibleViewRange.startLineNumber <= viewLineNumber && viewLineNumber <= visibleViewRange.endLineNumber - 1) {\n            // Nothing to do, cursor is in viewport\n            return new CursorState(cursor.modelState, cursor.viewState);\n        }\n        else {\n            let newViewLineNumber;\n            if (viewLineNumber > visibleViewRange.endLineNumber - 1) {\n                newViewLineNumber = visibleViewRange.endLineNumber - 1;\n            }\n            else if (viewLineNumber < visibleViewRange.startLineNumber) {\n                newViewLineNumber = visibleViewRange.startLineNumber;\n            }\n            else {\n                newViewLineNumber = viewLineNumber;\n            }\n            const position = MoveOperations.vertical(viewModel.cursorConfig, viewModel, viewLineNumber, cursor.viewState.position.column, cursor.viewState.leftoverVisibleColumns, newViewLineNumber, false);\n            return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, position.lineNumber, position.column, position.leftoverVisibleColumns));\n        }\n    }\n    /**\n     * Find the nth line start included in the range (from the start).\n     */\n    static _firstLineNumberInRange(model, range, count) {\n        let startLineNumber = range.startLineNumber;\n        if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n            // Move on to the second line if the first line start is not included in the range\n            startLineNumber++;\n        }\n        return Math.min(range.endLineNumber, startLineNumber + count - 1);\n    }\n    /**\n     * Find the nth line start included in the range (from the end).\n     */\n    static _lastLineNumberInRange(model, range, count) {\n        let startLineNumber = range.startLineNumber;\n        if (range.startColumn !== model.getLineMinColumn(startLineNumber)) {\n            // Move on to the second line if the first line start is not included in the range\n            startLineNumber++;\n        }\n        return Math.max(startLineNumber, range.endLineNumber - count + 1);\n    }\n    static _moveLeft(viewModel, cursors, inSelectionMode, noOfColumns) {\n        return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)));\n    }\n    static _moveHalfLineLeft(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const halfLine = Math.round(viewModel.getLineContent(viewLineNumber).length / 2);\n            result[i] = CursorState.fromViewState(MoveOperations.moveLeft(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n        }\n        return result;\n    }\n    static _moveRight(viewModel, cursors, inSelectionMode, noOfColumns) {\n        return cursors.map(cursor => CursorState.fromViewState(MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, noOfColumns)));\n    }\n    static _moveHalfLineRight(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const halfLine = Math.round(viewModel.getLineContent(viewLineNumber).length / 2);\n            result[i] = CursorState.fromViewState(MoveOperations.moveRight(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, halfLine));\n        }\n        return result;\n    }\n    static _moveDownByViewLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromViewState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveDownByModelLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveDown(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveUpByViewLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromViewState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel, cursor.viewState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveUpByModelLines(viewModel, cursors, inSelectionMode, linesCount) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            result[i] = CursorState.fromModelState(MoveOperations.moveUp(viewModel.cursorConfig, viewModel.model, cursor.modelState, inSelectionMode, linesCount));\n        }\n        return result;\n    }\n    static _moveToViewPosition(viewModel, cursor, inSelectionMode, toViewLineNumber, toViewColumn) {\n        return CursorState.fromViewState(cursor.viewState.move(inSelectionMode, toViewLineNumber, toViewColumn, 0));\n    }\n    static _moveToModelPosition(viewModel, cursor, inSelectionMode, toModelLineNumber, toModelColumn) {\n        return CursorState.fromModelState(cursor.modelState.move(inSelectionMode, toModelLineNumber, toModelColumn, 0));\n    }\n    static _moveToViewMinColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineMinColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewFirstNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineFirstNonWhitespaceColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewCenterColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = Math.round((viewModel.getLineMaxColumn(viewLineNumber) + viewModel.getLineMinColumn(viewLineNumber)) / 2);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewMaxColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineMaxColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n    static _moveToViewLastNonWhitespaceColumn(viewModel, cursors, inSelectionMode) {\n        const result = [];\n        for (let i = 0, len = cursors.length; i < len; i++) {\n            const cursor = cursors[i];\n            const viewLineNumber = cursor.viewState.position.lineNumber;\n            const viewColumn = viewModel.getLineLastNonWhitespaceColumn(viewLineNumber);\n            result[i] = this._moveToViewPosition(viewModel, cursor, inSelectionMode, viewLineNumber, viewColumn);\n        }\n        return result;\n    }\n}\nexport var CursorMove;\n(function (CursorMove) {\n    const isCursorMoveArgs = function (arg) {\n        if (!types.isObject(arg)) {\n            return false;\n        }\n        const cursorMoveArg = arg;\n        if (!types.isString(cursorMoveArg.to)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.select) && !types.isBoolean(cursorMoveArg.select)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.by) && !types.isString(cursorMoveArg.by)) {\n            return false;\n        }\n        if (!types.isUndefined(cursorMoveArg.value) && !types.isNumber(cursorMoveArg.value)) {\n            return false;\n        }\n        return true;\n    };\n    CursorMove.description = {\n        description: 'Move cursor to a logical position in the view',\n        args: [\n            {\n                name: 'Cursor move argument object',\n                description: `Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'to': A mandatory logical position value providing where to move the cursor.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine',\n\t\t\t\t\t\t'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'\n\t\t\t\t\t\t'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'\n\t\t\t\t\t\t'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'by': Unit to move. Default is computed based on 'to' value.\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t\t'line', 'wrappedLine', 'character', 'halfLine'\n\t\t\t\t\t\t\\`\\`\\`\n\t\t\t\t\t* 'value': Number of units to move. Default is '1'.\n\t\t\t\t\t* 'select': If 'true' makes the selection. Default is 'false'.\n\t\t\t\t`,\n                constraint: isCursorMoveArgs,\n                schema: {\n                    'type': 'object',\n                    'required': ['to'],\n                    'properties': {\n                        'to': {\n                            'type': 'string',\n                            'enum': ['left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine', 'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter', 'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter', 'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside']\n                        },\n                        'by': {\n                            'type': 'string',\n                            'enum': ['line', 'wrappedLine', 'character', 'halfLine']\n                        },\n                        'value': {\n                            'type': 'number',\n                            'default': 1\n                        },\n                        'select': {\n                            'type': 'boolean',\n                            'default': false\n                        }\n                    }\n                }\n            }\n        ]\n    };\n    /**\n     * Positions in the view for cursor move command.\n     */\n    CursorMove.RawDirection = {\n        Left: 'left',\n        Right: 'right',\n        Up: 'up',\n        Down: 'down',\n        PrevBlankLine: 'prevBlankLine',\n        NextBlankLine: 'nextBlankLine',\n        WrappedLineStart: 'wrappedLineStart',\n        WrappedLineFirstNonWhitespaceCharacter: 'wrappedLineFirstNonWhitespaceCharacter',\n        WrappedLineColumnCenter: 'wrappedLineColumnCenter',\n        WrappedLineEnd: 'wrappedLineEnd',\n        WrappedLineLastNonWhitespaceCharacter: 'wrappedLineLastNonWhitespaceCharacter',\n        ViewPortTop: 'viewPortTop',\n        ViewPortCenter: 'viewPortCenter',\n        ViewPortBottom: 'viewPortBottom',\n        ViewPortIfOutside: 'viewPortIfOutside'\n    };\n    /**\n     * Units for Cursor move 'by' argument\n     */\n    CursorMove.RawUnit = {\n        Line: 'line',\n        WrappedLine: 'wrappedLine',\n        Character: 'character',\n        HalfLine: 'halfLine'\n    };\n    function parse(args) {\n        if (!args.to) {\n            // illegal arguments\n            return null;\n        }\n        let direction;\n        switch (args.to) {\n            case CursorMove.RawDirection.Left:\n                direction = 0 /* Left */;\n                break;\n            case CursorMove.RawDirection.Right:\n                direction = 1 /* Right */;\n                break;\n            case CursorMove.RawDirection.Up:\n                direction = 2 /* Up */;\n                break;\n            case CursorMove.RawDirection.Down:\n                direction = 3 /* Down */;\n                break;\n            case CursorMove.RawDirection.PrevBlankLine:\n                direction = 4 /* PrevBlankLine */;\n                break;\n            case CursorMove.RawDirection.NextBlankLine:\n                direction = 5 /* NextBlankLine */;\n                break;\n            case CursorMove.RawDirection.WrappedLineStart:\n                direction = 6 /* WrappedLineStart */;\n                break;\n            case CursorMove.RawDirection.WrappedLineFirstNonWhitespaceCharacter:\n                direction = 7 /* WrappedLineFirstNonWhitespaceCharacter */;\n                break;\n            case CursorMove.RawDirection.WrappedLineColumnCenter:\n                direction = 8 /* WrappedLineColumnCenter */;\n                break;\n            case CursorMove.RawDirection.WrappedLineEnd:\n                direction = 9 /* WrappedLineEnd */;\n                break;\n            case CursorMove.RawDirection.WrappedLineLastNonWhitespaceCharacter:\n                direction = 10 /* WrappedLineLastNonWhitespaceCharacter */;\n                break;\n            case CursorMove.RawDirection.ViewPortTop:\n                direction = 11 /* ViewPortTop */;\n                break;\n            case CursorMove.RawDirection.ViewPortBottom:\n                direction = 13 /* ViewPortBottom */;\n                break;\n            case CursorMove.RawDirection.ViewPortCenter:\n                direction = 12 /* ViewPortCenter */;\n                break;\n            case CursorMove.RawDirection.ViewPortIfOutside:\n                direction = 14 /* ViewPortIfOutside */;\n                break;\n            default:\n                // illegal arguments\n                return null;\n        }\n        let unit = 0 /* None */;\n        switch (args.by) {\n            case CursorMove.RawUnit.Line:\n                unit = 1 /* Line */;\n                break;\n            case CursorMove.RawUnit.WrappedLine:\n                unit = 2 /* WrappedLine */;\n                break;\n            case CursorMove.RawUnit.Character:\n                unit = 3 /* Character */;\n                break;\n            case CursorMove.RawUnit.HalfLine:\n                unit = 4 /* HalfLine */;\n                break;\n        }\n        return {\n            direction: direction,\n            unit: unit,\n            select: (!!args.select),\n            value: (args.value || 1)\n        };\n    }\n    CursorMove.parse = parse;\n})(CursorMove || (CursorMove = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { AtomicTabMoveOperations } from './cursorAtomicMoveOperations.js';\nexport class CursorPosition {\n    constructor(lineNumber, column, leftoverVisibleColumns) {\n        this._cursorPositionBrand = undefined;\n        this.lineNumber = lineNumber;\n        this.column = column;\n        this.leftoverVisibleColumns = leftoverVisibleColumns;\n    }\n}\nexport class MoveOperations {\n    static leftPosition(model, position) {\n        if (position.column > model.getLineMinColumn(position.lineNumber)) {\n            return position.delta(undefined, -strings.prevCharLength(model.getLineContent(position.lineNumber), position.column - 1));\n        }\n        else if (position.lineNumber > 1) {\n            const newLineNumber = position.lineNumber - 1;\n            return new Position(newLineNumber, model.getLineMaxColumn(newLineNumber));\n        }\n        else {\n            return position;\n        }\n    }\n    static leftPositionAtomicSoftTabs(model, position, tabSize) {\n        if (position.column <= model.getLineIndentColumn(position.lineNumber)) {\n            const minColumn = model.getLineMinColumn(position.lineNumber);\n            const lineContent = model.getLineContent(position.lineNumber);\n            const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, 0 /* Left */);\n            if (newPosition !== -1 && newPosition + 1 >= minColumn) {\n                return new Position(position.lineNumber, newPosition + 1);\n            }\n        }\n        return this.leftPosition(model, position);\n    }\n    static left(config, model, position) {\n        const pos = config.stickyTabStops\n            ? MoveOperations.leftPositionAtomicSoftTabs(model, position, config.tabSize)\n            : MoveOperations.leftPosition(model, position);\n        return new CursorPosition(pos.lineNumber, pos.column, 0);\n    }\n    /**\n     * @param noOfColumns Must be either `1`\n     * or `Math.round(viewModel.getLineContent(viewLineNumber).length / 2)` (for half lines).\n    */\n    static moveLeft(config, model, cursor, inSelectionMode, noOfColumns) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If the user has a selection and does not want to extend it,\n            // put the cursor at the beginning of the selection.\n            lineNumber = cursor.selection.startLineNumber;\n            column = cursor.selection.startColumn;\n        }\n        else {\n            // This has no effect if noOfColumns === 1.\n            // It is ok to do so in the half-line scenario.\n            const pos = cursor.position.delta(undefined, -(noOfColumns - 1));\n            // We clip the position before normalization, as normalization is not defined\n            // for possibly negative columns.\n            const normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 0 /* Left */);\n            const p = MoveOperations.left(config, model, normalizedPos);\n            lineNumber = p.lineNumber;\n            column = p.column;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    /**\n     * Adjusts the column so that it is within min/max of the line.\n    */\n    static clipPositionColumn(position, model) {\n        return new Position(position.lineNumber, MoveOperations.clipRange(position.column, model.getLineMinColumn(position.lineNumber), model.getLineMaxColumn(position.lineNumber)));\n    }\n    static clipRange(value, min, max) {\n        if (value < min) {\n            return min;\n        }\n        if (value > max) {\n            return max;\n        }\n        return value;\n    }\n    static rightPosition(model, lineNumber, column) {\n        if (column < model.getLineMaxColumn(lineNumber)) {\n            column = column + strings.nextCharLength(model.getLineContent(lineNumber), column - 1);\n        }\n        else if (lineNumber < model.getLineCount()) {\n            lineNumber = lineNumber + 1;\n            column = model.getLineMinColumn(lineNumber);\n        }\n        return new Position(lineNumber, column);\n    }\n    static rightPositionAtomicSoftTabs(model, lineNumber, column, tabSize, indentSize) {\n        if (column < model.getLineIndentColumn(lineNumber)) {\n            const lineContent = model.getLineContent(lineNumber);\n            const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, column - 1, tabSize, 1 /* Right */);\n            if (newPosition !== -1) {\n                return new Position(lineNumber, newPosition + 1);\n            }\n        }\n        return this.rightPosition(model, lineNumber, column);\n    }\n    static right(config, model, position) {\n        const pos = config.stickyTabStops\n            ? MoveOperations.rightPositionAtomicSoftTabs(model, position.lineNumber, position.column, config.tabSize, config.indentSize)\n            : MoveOperations.rightPosition(model, position.lineNumber, position.column);\n        return new CursorPosition(pos.lineNumber, pos.column, 0);\n    }\n    static moveRight(config, model, cursor, inSelectionMode, noOfColumns) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move right without selection cancels selection and puts cursor at the end of the selection\n            lineNumber = cursor.selection.endLineNumber;\n            column = cursor.selection.endColumn;\n        }\n        else {\n            const pos = cursor.position.delta(undefined, noOfColumns - 1);\n            const normalizedPos = model.normalizePosition(MoveOperations.clipPositionColumn(pos, model), 1 /* Right */);\n            const r = MoveOperations.right(config, model, normalizedPos);\n            lineNumber = r.lineNumber;\n            column = r.column;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    static vertical(config, model, lineNumber, column, leftoverVisibleColumns, newLineNumber, allowMoveOnEdgeLine, normalizationAffinity) {\n        const currentVisibleColumn = CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize) + leftoverVisibleColumns;\n        const lineCount = model.getLineCount();\n        const wasOnFirstPosition = (lineNumber === 1 && column === 1);\n        const wasOnLastPosition = (lineNumber === lineCount && column === model.getLineMaxColumn(lineNumber));\n        const wasAtEdgePosition = (newLineNumber < lineNumber ? wasOnFirstPosition : wasOnLastPosition);\n        lineNumber = newLineNumber;\n        if (lineNumber < 1) {\n            lineNumber = 1;\n            if (allowMoveOnEdgeLine) {\n                column = model.getLineMinColumn(lineNumber);\n            }\n            else {\n                column = Math.min(model.getLineMaxColumn(lineNumber), column);\n            }\n        }\n        else if (lineNumber > lineCount) {\n            lineNumber = lineCount;\n            if (allowMoveOnEdgeLine) {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n            else {\n                column = Math.min(model.getLineMaxColumn(lineNumber), column);\n            }\n        }\n        else {\n            column = config.columnFromVisibleColumn(model, lineNumber, currentVisibleColumn);\n        }\n        if (wasAtEdgePosition) {\n            leftoverVisibleColumns = 0;\n        }\n        else {\n            leftoverVisibleColumns = currentVisibleColumn - CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize);\n        }\n        if (normalizationAffinity !== undefined) {\n            const position = new Position(lineNumber, column);\n            const newPosition = model.normalizePosition(position, normalizationAffinity);\n            leftoverVisibleColumns = leftoverVisibleColumns + (column - newPosition.column);\n            lineNumber = newPosition.lineNumber;\n            column = newPosition.column;\n        }\n        return new CursorPosition(lineNumber, column, leftoverVisibleColumns);\n    }\n    static down(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnLastLine) {\n        return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber + count, allowMoveOnLastLine, 1 /* Right */);\n    }\n    static moveDown(config, model, cursor, inSelectionMode, linesCount) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move down acts relative to the end of selection\n            lineNumber = cursor.selection.endLineNumber;\n            column = cursor.selection.endColumn;\n        }\n        else {\n            lineNumber = cursor.position.lineNumber;\n            column = cursor.position.column;\n        }\n        const r = MoveOperations.down(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);\n        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n    }\n    static translateDown(config, model, cursor) {\n        const selection = cursor.selection;\n        const selectionStart = MoveOperations.down(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n        const position = MoveOperations.down(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n    }\n    static up(config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnFirstLine) {\n        return this.vertical(config, model, lineNumber, column, leftoverVisibleColumns, lineNumber - count, allowMoveOnFirstLine, 0 /* Left */);\n    }\n    static moveUp(config, model, cursor, inSelectionMode, linesCount) {\n        let lineNumber, column;\n        if (cursor.hasSelection() && !inSelectionMode) {\n            // If we are in selection mode, move up acts relative to the beginning of selection\n            lineNumber = cursor.selection.startLineNumber;\n            column = cursor.selection.startColumn;\n        }\n        else {\n            lineNumber = cursor.position.lineNumber;\n            column = cursor.position.column;\n        }\n        const r = MoveOperations.up(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);\n        return cursor.move(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns);\n    }\n    static translateUp(config, model, cursor) {\n        const selection = cursor.selection;\n        const selectionStart = MoveOperations.up(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);\n        const position = MoveOperations.up(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);\n        return new SingleCursorState(new Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), selectionStart.leftoverVisibleColumns, new Position(position.lineNumber, position.column), position.leftoverVisibleColumns);\n    }\n    static _isBlankLine(model, lineNumber) {\n        if (model.getLineFirstNonWhitespaceColumn(lineNumber) === 0) {\n            // empty or contains only whitespace\n            return true;\n        }\n        return false;\n    }\n    static moveToPrevBlankLine(config, model, cursor, inSelectionMode) {\n        let lineNumber = cursor.position.lineNumber;\n        // If our current line is blank, move to the previous non-blank line\n        while (lineNumber > 1 && this._isBlankLine(model, lineNumber)) {\n            lineNumber--;\n        }\n        // Find the previous blank line\n        while (lineNumber > 1 && !this._isBlankLine(model, lineNumber)) {\n            lineNumber--;\n        }\n        return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n    }\n    static moveToNextBlankLine(config, model, cursor, inSelectionMode) {\n        const lineCount = model.getLineCount();\n        let lineNumber = cursor.position.lineNumber;\n        // If our current line is blank, move to the next non-blank line\n        while (lineNumber < lineCount && this._isBlankLine(model, lineNumber)) {\n            lineNumber++;\n        }\n        // Find the next blank line\n        while (lineNumber < lineCount && !this._isBlankLine(model, lineNumber)) {\n            lineNumber++;\n        }\n        return cursor.move(inSelectionMode, lineNumber, model.getLineMinColumn(lineNumber), 0);\n    }\n    static moveToBeginningOfLine(config, model, cursor, inSelectionMode) {\n        const lineNumber = cursor.position.lineNumber;\n        const minColumn = model.getLineMinColumn(lineNumber);\n        const firstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(lineNumber) || minColumn;\n        let column;\n        const relevantColumnNumber = cursor.position.column;\n        if (relevantColumnNumber === firstNonBlankColumn) {\n            column = minColumn;\n        }\n        else {\n            column = firstNonBlankColumn;\n        }\n        return cursor.move(inSelectionMode, lineNumber, column, 0);\n    }\n    static moveToEndOfLine(config, model, cursor, inSelectionMode, sticky) {\n        const lineNumber = cursor.position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        return cursor.move(inSelectionMode, lineNumber, maxColumn, sticky ? 1073741824 /* MAX_SAFE_SMALL_INTEGER */ - maxColumn : 0);\n    }\n    static moveToBeginningOfBuffer(config, model, cursor, inSelectionMode) {\n        return cursor.move(inSelectionMode, 1, 1, 0);\n    }\n    static moveToEndOfBuffer(config, model, cursor, inSelectionMode) {\n        const lastLineNumber = model.getLineCount();\n        const lastColumn = model.getLineMaxColumn(lastLineNumber);\n        return cursor.move(inSelectionMode, lastLineNumber, lastColumn, 0);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { ReplaceCommand, ReplaceCommandWithOffsetCursorState, ReplaceCommandWithoutChangingPosition, ReplaceCommandThatPreservesSelection } from '../commands/replaceCommand.js';\nimport { ShiftCommand } from '../commands/shiftCommand.js';\nimport { SurroundSelectionCommand } from '../commands/surroundSelectionCommand.js';\nimport { EditOperationResult, isQuote } from '../cursorCommon.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { Position } from '../core/position.js';\nimport { IndentAction } from '../languages/languageConfiguration.js';\nimport { LanguageConfigurationRegistry } from '../languages/languageConfigurationRegistry.js';\nimport { createScopedLineTokens } from '../languages/supports.js';\nexport class TypeOperations {\n    static indent(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: false,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            });\n        }\n        return commands;\n    }\n    static outdent(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ShiftCommand(selections[i], {\n                isUnshift: true,\n                tabSize: config.tabSize,\n                indentSize: config.indentSize,\n                insertSpaces: config.insertSpaces,\n                useTabStops: config.useTabStops,\n                autoIndent: config.autoIndent\n            });\n        }\n        return commands;\n    }\n    static shiftIndent(config, indentation, count) {\n        count = count || 1;\n        return ShiftCommand.shiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n    static unshiftIndent(config, indentation, count) {\n        count = count || 1;\n        return ShiftCommand.unshiftIndent(indentation, indentation.length + count, config.tabSize, config.indentSize, config.insertSpaces);\n    }\n    static _distributedPaste(config, model, selections, text) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], text[i]);\n        }\n        return new EditOperationResult(0 /* Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _simplePaste(config, model, selections, text, pasteOnNewLine) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            if (pasteOnNewLine && !selection.isEmpty()) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine && text.indexOf('\\n') !== text.length - 1) {\n                pasteOnNewLine = false;\n            }\n            if (pasteOnNewLine) {\n                // Paste entire line at the beginning of line\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, 1);\n                commands[i] = new ReplaceCommandThatPreservesSelection(typeSelection, text, selection, true);\n            }\n            else {\n                commands[i] = new ReplaceCommand(selection, text);\n            }\n        }\n        return new EditOperationResult(0 /* Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText) {\n        if (pasteOnNewLine) {\n            return null;\n        }\n        if (selections.length === 1) {\n            return null;\n        }\n        if (multicursorText && multicursorText.length === selections.length) {\n            return multicursorText;\n        }\n        if (config.multiCursorPaste === 'spread') {\n            // Try to spread the pasted text in case the line count matches the cursor count\n            // Remove trailing \\n if present\n            if (text.charCodeAt(text.length - 1) === 10 /* LineFeed */) {\n                text = text.substr(0, text.length - 1);\n            }\n            // Remove trailing \\r if present\n            if (text.charCodeAt(text.length - 1) === 13 /* CarriageReturn */) {\n                text = text.substr(0, text.length - 1);\n            }\n            const lines = strings.splitLines(text);\n            if (lines.length === selections.length) {\n                return lines;\n            }\n        }\n        return null;\n    }\n    static paste(config, model, selections, text, pasteOnNewLine, multicursorText) {\n        const distributedPaste = this._distributePasteToCursors(config, selections, text, pasteOnNewLine, multicursorText);\n        if (distributedPaste) {\n            selections = selections.sort(Range.compareRangesUsingStarts);\n            return this._distributedPaste(config, model, selections, distributedPaste);\n        }\n        else {\n            return this._simplePaste(config, model, selections, text, pasteOnNewLine);\n        }\n    }\n    static _goodIndentForLine(config, model, lineNumber) {\n        let action = null;\n        let indentation = '';\n        const expectedIndentAction = LanguageConfigurationRegistry.getInheritIndentForLine(config.autoIndent, model, lineNumber, false);\n        if (expectedIndentAction) {\n            action = expectedIndentAction.action;\n            indentation = expectedIndentAction.indentation;\n        }\n        else if (lineNumber > 1) {\n            let lastLineNumber;\n            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n                const lineText = model.getLineContent(lastLineNumber);\n                const nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);\n                if (nonWhitespaceIdx >= 0) {\n                    break;\n                }\n            }\n            if (lastLineNumber < 1) {\n                // No previous line with content found\n                return null;\n            }\n            const maxColumn = model.getLineMaxColumn(lastLineNumber);\n            const expectedEnterAction = LanguageConfigurationRegistry.getEnterAction(config.autoIndent, model, new Range(lastLineNumber, maxColumn, lastLineNumber, maxColumn));\n            if (expectedEnterAction) {\n                indentation = expectedEnterAction.indentation + expectedEnterAction.appendText;\n            }\n        }\n        if (action) {\n            if (action === IndentAction.Indent) {\n                indentation = TypeOperations.shiftIndent(config, indentation);\n            }\n            if (action === IndentAction.Outdent) {\n                indentation = TypeOperations.unshiftIndent(config, indentation);\n            }\n            indentation = config.normalizeIndentation(indentation);\n        }\n        if (!indentation) {\n            return null;\n        }\n        return indentation;\n    }\n    static _replaceJumpToNextIndent(config, model, selection, insertsAutoWhitespace) {\n        let typeText = '';\n        const position = selection.getStartPosition();\n        if (config.insertSpaces) {\n            const visibleColumnFromColumn = config.visibleColumnFromColumn(model, position);\n            const indentSize = config.indentSize;\n            const spacesCnt = indentSize - (visibleColumnFromColumn % indentSize);\n            for (let i = 0; i < spacesCnt; i++) {\n                typeText += ' ';\n            }\n        }\n        else {\n            typeText = '\\t';\n        }\n        return new ReplaceCommand(selection, typeText, insertsAutoWhitespace);\n    }\n    static tab(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                const lineText = model.getLineContent(selection.startLineNumber);\n                if (/^\\s*$/.test(lineText) && model.isCheapToTokenize(selection.startLineNumber)) {\n                    let goodIndent = this._goodIndentForLine(config, model, selection.startLineNumber);\n                    goodIndent = goodIndent || '\\t';\n                    const possibleTypeText = config.normalizeIndentation(goodIndent);\n                    if (!lineText.startsWith(possibleTypeText)) {\n                        commands[i] = new ReplaceCommand(new Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText, true);\n                        continue;\n                    }\n                }\n                commands[i] = this._replaceJumpToNextIndent(config, model, selection, true);\n            }\n            else {\n                if (selection.startLineNumber === selection.endLineNumber) {\n                    const lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);\n                    if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {\n                        // This is a single line selection that is not the entire line\n                        commands[i] = this._replaceJumpToNextIndent(config, model, selection, false);\n                        continue;\n                    }\n                }\n                commands[i] = new ShiftCommand(selection, {\n                    isUnshift: false,\n                    tabSize: config.tabSize,\n                    indentSize: config.indentSize,\n                    insertSpaces: config.insertSpaces,\n                    useTabStops: config.useTabStops,\n                    autoIndent: config.autoIndent\n                });\n            }\n        }\n        return commands;\n    }\n    static compositionType(prevEditOperationType, config, model, selections, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        const commands = selections.map(selection => this._compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta));\n        return new EditOperationResult(4 /* TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _compositionType(model, selection, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta) {\n        if (!selection.isEmpty()) {\n            // looks like https://github.com/microsoft/vscode/issues/2773\n            // where a cursor operation occurred before a canceled composition\n            // => ignore composition\n            return null;\n        }\n        const pos = selection.getPosition();\n        const startColumn = Math.max(1, pos.column - replacePrevCharCnt);\n        const endColumn = Math.min(model.getLineMaxColumn(pos.lineNumber), pos.column + replaceNextCharCnt);\n        const range = new Range(pos.lineNumber, startColumn, pos.lineNumber, endColumn);\n        const oldText = model.getValueInRange(range);\n        if (oldText === text && positionDelta === 0) {\n            // => ignore composition that doesn't do anything\n            return null;\n        }\n        return new ReplaceCommandWithOffsetCursorState(range, text, 0, positionDelta);\n    }\n    static _typeCommand(range, text, keepPosition) {\n        if (keepPosition) {\n            return new ReplaceCommandWithoutChangingPosition(range, text, true);\n        }\n        else {\n            return new ReplaceCommand(range, text, true);\n        }\n    }\n    static _enter(config, model, keepPosition, range) {\n        if (config.autoIndent === 0 /* None */) {\n            return TypeOperations._typeCommand(range, '\\n', keepPosition);\n        }\n        if (!model.isCheapToTokenize(range.getStartPosition().lineNumber) || config.autoIndent === 1 /* Keep */) {\n            const lineText = model.getLineContent(range.startLineNumber);\n            const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n            return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n        }\n        const r = LanguageConfigurationRegistry.getEnterAction(config.autoIndent, model, range);\n        if (r) {\n            if (r.indentAction === IndentAction.None) {\n                // Nothing special\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.Indent) {\n                // Indent once\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(r.indentation + r.appendText), keepPosition);\n            }\n            else if (r.indentAction === IndentAction.IndentOutdent) {\n                // Ultra special\n                const normalIndent = config.normalizeIndentation(r.indentation);\n                const increasedIndent = config.normalizeIndentation(r.indentation + r.appendText);\n                const typeText = '\\n' + increasedIndent + '\\n' + normalIndent;\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, typeText, true);\n                }\n                else {\n                    return new ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length, true);\n                }\n            }\n            else if (r.indentAction === IndentAction.Outdent) {\n                const actualIndentation = TypeOperations.unshiftIndent(config, r.indentation);\n                return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(actualIndentation + r.appendText), keepPosition);\n            }\n        }\n        const lineText = model.getLineContent(range.startLineNumber);\n        const indentation = strings.getLeadingWhitespace(lineText).substring(0, range.startColumn - 1);\n        if (config.autoIndent >= 4 /* Full */) {\n            const ir = LanguageConfigurationRegistry.getIndentForEnter(config.autoIndent, model, range, {\n                unshiftIndent: (indent) => {\n                    return TypeOperations.unshiftIndent(config, indent);\n                },\n                shiftIndent: (indent) => {\n                    return TypeOperations.shiftIndent(config, indent);\n                },\n                normalizeIndentation: (indent) => {\n                    return config.normalizeIndentation(indent);\n                }\n            });\n            if (ir) {\n                let oldEndViewColumn = config.visibleColumnFromColumn(model, range.getEndPosition());\n                const oldEndColumn = range.endColumn;\n                const newLineContent = model.getLineContent(range.endLineNumber);\n                const firstNonWhitespace = strings.firstNonWhitespaceIndex(newLineContent);\n                if (firstNonWhitespace >= 0) {\n                    range = range.setEndPosition(range.endLineNumber, Math.max(range.endColumn, firstNonWhitespace + 1));\n                }\n                else {\n                    range = range.setEndPosition(range.endLineNumber, model.getLineMaxColumn(range.endLineNumber));\n                }\n                if (keepPosition) {\n                    return new ReplaceCommandWithoutChangingPosition(range, '\\n' + config.normalizeIndentation(ir.afterEnter), true);\n                }\n                else {\n                    let offset = 0;\n                    if (oldEndColumn <= firstNonWhitespace + 1) {\n                        if (!config.insertSpaces) {\n                            oldEndViewColumn = Math.ceil(oldEndViewColumn / config.indentSize);\n                        }\n                        offset = Math.min(oldEndViewColumn + 1 - config.normalizeIndentation(ir.afterEnter).length - 1, 0);\n                    }\n                    return new ReplaceCommandWithOffsetCursorState(range, '\\n' + config.normalizeIndentation(ir.afterEnter), 0, offset, true);\n                }\n            }\n        }\n        return TypeOperations._typeCommand(range, '\\n' + config.normalizeIndentation(indentation), keepPosition);\n    }\n    static _isAutoIndentType(config, model, selections) {\n        if (config.autoIndent < 4 /* Full */) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            if (!model.isCheapToTokenize(selections[i].getEndPosition().lineNumber)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _runAutoIndentType(config, model, range, ch) {\n        const currentIndentation = LanguageConfigurationRegistry.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n        const actualIndentation = LanguageConfigurationRegistry.getIndentActionForType(config.autoIndent, model, range, ch, {\n            shiftIndent: (indentation) => {\n                return TypeOperations.shiftIndent(config, indentation);\n            },\n            unshiftIndent: (indentation) => {\n                return TypeOperations.unshiftIndent(config, indentation);\n            },\n        });\n        if (actualIndentation === null) {\n            return null;\n        }\n        if (actualIndentation !== config.normalizeIndentation(currentIndentation)) {\n            const firstNonWhitespace = model.getLineFirstNonWhitespaceColumn(range.startLineNumber);\n            if (firstNonWhitespace === 0) {\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) + ch, false);\n            }\n            else {\n                return TypeOperations._typeCommand(new Range(range.startLineNumber, 1, range.endLineNumber, range.endColumn), config.normalizeIndentation(actualIndentation) +\n                    model.getLineContent(range.startLineNumber).substring(firstNonWhitespace - 1, range.startColumn - 1) + ch, false);\n            }\n        }\n        return null;\n    }\n    static _isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch) {\n        if (config.autoClosingOvertype === 'never') {\n            return false;\n        }\n        if (!config.autoClosingPairs.autoClosingPairsCloseSingleChar.has(ch)) {\n            return false;\n        }\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (!selection.isEmpty()) {\n                return false;\n            }\n            const position = selection.getPosition();\n            const lineText = model.getLineContent(position.lineNumber);\n            const afterCharacter = lineText.charAt(position.column - 1);\n            if (afterCharacter !== ch) {\n                return false;\n            }\n            // Do not over-type quotes after a backslash\n            const chIsQuote = isQuote(ch);\n            const beforeCharacter = position.column > 2 ? lineText.charCodeAt(position.column - 2) : 0 /* Null */;\n            if (beforeCharacter === 92 /* Backslash */ && chIsQuote) {\n                return false;\n            }\n            // Must over-type a closing character typed by the editor\n            if (config.autoClosingOvertype === 'auto') {\n                let found = false;\n                for (let j = 0, lenJ = autoClosedCharacters.length; j < lenJ; j++) {\n                    const autoClosedCharacter = autoClosedCharacters[j];\n                    if (position.lineNumber === autoClosedCharacter.startLineNumber && position.column === autoClosedCharacter.startColumn) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const position = selection.getPosition();\n            const typeSelection = new Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);\n            commands[i] = new ReplaceCommand(typeSelection, ch);\n        }\n        return new EditOperationResult(4 /* TypingOther */, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, 4 /* TypingOther */),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _isBeforeClosingBrace(config, lineAfter) {\n        // If the start of lineAfter can be interpretted as both a starting or ending brace, default to returning false\n        const nextChar = lineAfter.charAt(0);\n        const potentialStartingBraces = config.autoClosingPairs.autoClosingPairsOpenByStart.get(nextChar) || [];\n        const potentialClosingBraces = config.autoClosingPairs.autoClosingPairsCloseByStart.get(nextChar) || [];\n        const isBeforeStartingBrace = potentialStartingBraces.some(x => lineAfter.startsWith(x.open));\n        const isBeforeClosingBrace = potentialClosingBraces.some(x => lineAfter.startsWith(x.close));\n        return !isBeforeStartingBrace && isBeforeClosingBrace;\n    }\n    /**\n     * Determine if typing `ch` at all `positions` in the `model` results in an\n     * auto closing open sequence being typed.\n     *\n     * Auto closing open sequences can consist of multiple characters, which\n     * can lead to ambiguities. In such a case, the longest auto-closing open\n     * sequence is returned.\n     */\n    static _findAutoClosingPairOpen(config, model, positions, ch) {\n        const candidates = config.autoClosingPairs.autoClosingPairsOpenByEnd.get(ch);\n        if (!candidates) {\n            return null;\n        }\n        // Determine which auto-closing pair it is\n        let result = null;\n        for (const candidate of candidates) {\n            if (result === null || candidate.open.length > result.open.length) {\n                let candidateIsMatch = true;\n                for (const position of positions) {\n                    const relevantText = model.getValueInRange(new Range(position.lineNumber, position.column - candidate.open.length + 1, position.lineNumber, position.column));\n                    if (relevantText + ch !== candidate.open) {\n                        candidateIsMatch = false;\n                        break;\n                    }\n                }\n                if (candidateIsMatch) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Find another auto-closing pair that is contained by the one passed in.\n     *\n     * e.g. when having [(,)] and [(*,*)] as auto-closing pairs\n     * this method will find [(,)] as a containment pair for [(*,*)]\n     */\n    static _findContainedAutoClosingPair(config, pair) {\n        if (pair.open.length <= 1) {\n            return null;\n        }\n        const lastChar = pair.close.charAt(pair.close.length - 1);\n        // get candidates with the same last character as close\n        const candidates = config.autoClosingPairs.autoClosingPairsCloseByEnd.get(lastChar) || [];\n        let result = null;\n        for (const candidate of candidates) {\n            if (candidate.open !== pair.open && pair.open.includes(candidate.open) && pair.close.endsWith(candidate.close)) {\n                if (!result || candidate.open.length > result.open.length) {\n                    result = candidate;\n                }\n            }\n        }\n        return result;\n    }\n    static _getAutoClosingPairClose(config, model, selections, ch, chIsAlreadyTyped) {\n        const chIsQuote = isQuote(ch);\n        const autoCloseConfig = (chIsQuote ? config.autoClosingQuotes : config.autoClosingBrackets);\n        const shouldAutoCloseBefore = (chIsQuote ? config.shouldAutoCloseBefore.quote : config.shouldAutoCloseBefore.bracket);\n        if (autoCloseConfig === 'never') {\n            return null;\n        }\n        for (const selection of selections) {\n            if (!selection.isEmpty()) {\n                return null;\n            }\n        }\n        // This method is called both when typing (regularly) and when composition ends\n        // This means that we need to work with a text buffer where sometimes `ch` is not\n        // there (it is being typed right now) or with a text buffer where `ch` has already been typed\n        //\n        // In order to avoid adding checks for `chIsAlreadyTyped` in all places, we will work\n        // with two conceptual positions, the position before `ch` and the position after `ch`\n        //\n        const positions = selections.map((s) => {\n            const position = s.getPosition();\n            if (chIsAlreadyTyped) {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column - ch.length, afterColumn: position.column };\n            }\n            else {\n                return { lineNumber: position.lineNumber, beforeColumn: position.column, afterColumn: position.column };\n            }\n        });\n        // Find the longest auto-closing open pair in case of multiple ending in `ch`\n        // e.g. when having [f\",\"] and [\",\"], it picks [f\",\"] if the character before is f\n        const pair = this._findAutoClosingPairOpen(config, model, positions.map(p => new Position(p.lineNumber, p.beforeColumn)), ch);\n        if (!pair) {\n            return null;\n        }\n        // Sometimes, it is possible to have two auto-closing pairs that have a containment relationship\n        // e.g. when having [(,)] and [(*,*)]\n        // - when typing (, the resulting state is (|)\n        // - when typing *, the desired resulting state is (*|*), not (*|*))\n        const containedPair = this._findContainedAutoClosingPair(config, pair);\n        const containedPairClose = containedPair ? containedPair.close : '';\n        let isContainedPairPresent = true;\n        for (const position of positions) {\n            const { lineNumber, beforeColumn, afterColumn } = position;\n            const lineText = model.getLineContent(lineNumber);\n            const lineBefore = lineText.substring(0, beforeColumn - 1);\n            const lineAfter = lineText.substring(afterColumn - 1);\n            if (!lineAfter.startsWith(containedPairClose)) {\n                isContainedPairPresent = false;\n            }\n            // Only consider auto closing the pair if an allowed character follows or if another autoclosed pair closing brace follows\n            if (lineAfter.length > 0) {\n                const characterAfter = lineAfter.charAt(0);\n                const isBeforeCloseBrace = TypeOperations._isBeforeClosingBrace(config, lineAfter);\n                if (!isBeforeCloseBrace && !shouldAutoCloseBefore(characterAfter)) {\n                    return null;\n                }\n            }\n            // Do not auto-close ' or \" after a word character\n            if (pair.open.length === 1 && (ch === '\\'' || ch === '\"') && autoCloseConfig !== 'always') {\n                const wordSeparators = getMapForWordSeparators(config.wordSeparators);\n                if (lineBefore.length > 0) {\n                    const characterBefore = lineBefore.charCodeAt(lineBefore.length - 1);\n                    if (wordSeparators.get(characterBefore) === 0 /* Regular */) {\n                        return null;\n                    }\n                }\n            }\n            if (!model.isCheapToTokenize(lineNumber)) {\n                // Do not force tokenization\n                return null;\n            }\n            model.forceTokenization(lineNumber);\n            const lineTokens = model.getLineTokens(lineNumber);\n            const scopedLineTokens = createScopedLineTokens(lineTokens, beforeColumn - 1);\n            if (!pair.shouldAutoClose(scopedLineTokens, beforeColumn - scopedLineTokens.firstCharOffset)) {\n                return null;\n            }\n            // Typing for example a quote could either start a new string, in which case auto-closing is desirable\n            // or it could end a previously started string, in which case auto-closing is not desirable\n            //\n            // In certain cases, it is really not possible to look at the previous token to determine\n            // what would happen. That's why we do something really unusual, we pretend to type a different\n            // character and ask the tokenizer what the outcome of doing that is: after typing a neutral\n            // character, are we in a string (i.e. the quote would most likely end a string) or not?\n            //\n            const neutralCharacter = pair.findNeutralCharacter();\n            if (neutralCharacter) {\n                const tokenType = model.getTokenTypeIfInsertingCharacter(lineNumber, beforeColumn, neutralCharacter);\n                if (!pair.isOK(tokenType)) {\n                    return null;\n                }\n            }\n        }\n        if (isContainedPairPresent) {\n            return pair.close.substring(0, pair.close.length - containedPairClose.length);\n        }\n        else {\n            return pair.close;\n        }\n    }\n    static _runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, chIsAlreadyTyped, autoClosingPairClose) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            commands[i] = new TypeWithAutoClosingCommand(selection, ch, !chIsAlreadyTyped, autoClosingPairClose);\n        }\n        return new EditOperationResult(4 /* TypingOther */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: false\n        });\n    }\n    static _shouldSurroundChar(config, ch) {\n        if (isQuote(ch)) {\n            return (config.autoSurround === 'quotes' || config.autoSurround === 'languageDefined');\n        }\n        else {\n            // Character is a bracket\n            return (config.autoSurround === 'brackets' || config.autoSurround === 'languageDefined');\n        }\n    }\n    static _isSurroundSelectionType(config, model, selections, ch) {\n        if (!TypeOperations._shouldSurroundChar(config, ch) || !config.surroundingPairs.hasOwnProperty(ch)) {\n            return false;\n        }\n        const isTypingAQuoteCharacter = isQuote(ch);\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            if (selection.isEmpty()) {\n                return false;\n            }\n            let selectionContainsOnlyWhitespace = true;\n            for (let lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {\n                const lineText = model.getLineContent(lineNumber);\n                const startIndex = (lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0);\n                const endIndex = (lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length);\n                const selectedText = lineText.substring(startIndex, endIndex);\n                if (/[^ \\t]/.test(selectedText)) {\n                    // this selected text contains something other than whitespace\n                    selectionContainsOnlyWhitespace = false;\n                    break;\n                }\n            }\n            if (selectionContainsOnlyWhitespace) {\n                return false;\n            }\n            if (isTypingAQuoteCharacter && selection.startLineNumber === selection.endLineNumber && selection.startColumn + 1 === selection.endColumn) {\n                const selectionText = model.getValueInRange(selection);\n                if (isQuote(selectionText)) {\n                    // Typing a quote character on top of another quote character\n                    // => disable surround selection type\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    static _runSurroundSelectionType(prevEditOperationType, config, model, selections, ch) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const selection = selections[i];\n            const closeCharacter = config.surroundingPairs[ch];\n            commands[i] = new SurroundSelectionCommand(selection, ch, closeCharacter);\n        }\n        return new EditOperationResult(0 /* Other */, commands, {\n            shouldPushStackElementBefore: true,\n            shouldPushStackElementAfter: true\n        });\n    }\n    static _isTypeInterceptorElectricChar(config, model, selections) {\n        if (selections.length === 1 && model.isCheapToTokenize(selections[0].getEndPosition().lineNumber)) {\n            return true;\n        }\n        return false;\n    }\n    static _typeInterceptorElectricChar(prevEditOperationType, config, model, selection, ch) {\n        if (!config.electricChars.hasOwnProperty(ch) || !selection.isEmpty()) {\n            return null;\n        }\n        const position = selection.getPosition();\n        model.forceTokenization(position.lineNumber);\n        const lineTokens = model.getLineTokens(position.lineNumber);\n        let electricAction;\n        try {\n            electricAction = config.onElectricCharacter(ch, lineTokens, position.column);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n        if (!electricAction) {\n            return null;\n        }\n        if (electricAction.matchOpenBracket) {\n            const endColumn = (lineTokens.getLineContent() + ch).lastIndexOf(electricAction.matchOpenBracket) + 1;\n            const match = model.bracketPairs.findMatchingBracketUp(electricAction.matchOpenBracket, {\n                lineNumber: position.lineNumber,\n                column: endColumn\n            }, 500 /* give at most 500ms to compute */);\n            if (match) {\n                if (match.startLineNumber === position.lineNumber) {\n                    // matched something on the same line => no change in indentation\n                    return null;\n                }\n                const matchLine = model.getLineContent(match.startLineNumber);\n                const matchLineIndentation = strings.getLeadingWhitespace(matchLine);\n                const newIndentation = config.normalizeIndentation(matchLineIndentation);\n                const lineText = model.getLineContent(position.lineNumber);\n                const lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;\n                const prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);\n                const typeText = newIndentation + prefix + ch;\n                const typeSelection = new Range(position.lineNumber, 1, position.lineNumber, position.column);\n                const command = new ReplaceCommand(typeSelection, typeText);\n                return new EditOperationResult(getTypingOperation(typeText, prevEditOperationType), [command], {\n                    shouldPushStackElementBefore: false,\n                    shouldPushStackElementAfter: true\n                });\n            }\n        }\n        return null;\n    }\n    /**\n     * This is very similar with typing, but the character is already in the text buffer!\n     */\n    static compositionEndWithInterceptors(prevEditOperationType, config, model, selectionsWhenCompositionStarted, selections, autoClosedCharacters) {\n        if (!selectionsWhenCompositionStarted || Selection.selectionsArrEqual(selectionsWhenCompositionStarted, selections)) {\n            // no content was typed\n            return null;\n        }\n        let ch = null;\n        // extract last typed character\n        for (const selection of selections) {\n            if (!selection.isEmpty()) {\n                return null;\n            }\n            const position = selection.getPosition();\n            const currentChar = model.getValueInRange(new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column));\n            if (ch === null) {\n                ch = currentChar;\n            }\n            else if (ch !== currentChar) {\n                return null;\n            }\n        }\n        if (!ch) {\n            return null;\n        }\n        if (this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            // Unfortunately, the close character is at this point \"doubled\", so we need to delete it...\n            const commands = selections.map(s => new ReplaceCommand(new Range(s.positionLineNumber, s.positionColumn, s.positionLineNumber, s.positionColumn + 1), '', false));\n            return new EditOperationResult(4 /* TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false\n            });\n        }\n        const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, true);\n        if (autoClosingPairClose !== null) {\n            return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, true, autoClosingPairClose);\n        }\n        return null;\n    }\n    static typeWithInterceptors(isDoingComposition, prevEditOperationType, config, model, selections, autoClosedCharacters, ch) {\n        if (!isDoingComposition && ch === '\\n') {\n            const commands = [];\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = TypeOperations._enter(config, model, false, selections[i]);\n            }\n            return new EditOperationResult(4 /* TypingOther */, commands, {\n                shouldPushStackElementBefore: true,\n                shouldPushStackElementAfter: false,\n            });\n        }\n        if (!isDoingComposition && this._isAutoIndentType(config, model, selections)) {\n            const commands = [];\n            let autoIndentFails = false;\n            for (let i = 0, len = selections.length; i < len; i++) {\n                commands[i] = this._runAutoIndentType(config, model, selections[i], ch);\n                if (!commands[i]) {\n                    autoIndentFails = true;\n                    break;\n                }\n            }\n            if (!autoIndentFails) {\n                return new EditOperationResult(4 /* TypingOther */, commands, {\n                    shouldPushStackElementBefore: true,\n                    shouldPushStackElementAfter: false,\n                });\n            }\n        }\n        if (!isDoingComposition && this._isAutoClosingOvertype(config, model, selections, autoClosedCharacters, ch)) {\n            return this._runAutoClosingOvertype(prevEditOperationType, config, model, selections, ch);\n        }\n        if (!isDoingComposition) {\n            const autoClosingPairClose = this._getAutoClosingPairClose(config, model, selections, ch, false);\n            if (autoClosingPairClose) {\n                return this._runAutoClosingOpenCharType(prevEditOperationType, config, model, selections, ch, false, autoClosingPairClose);\n            }\n        }\n        if (this._isSurroundSelectionType(config, model, selections, ch)) {\n            return this._runSurroundSelectionType(prevEditOperationType, config, model, selections, ch);\n        }\n        // Electric characters make sense only when dealing with a single cursor,\n        // as multiple cursors typing brackets for example would interfer with bracket matching\n        if (!isDoingComposition && this._isTypeInterceptorElectricChar(config, model, selections)) {\n            const r = this._typeInterceptorElectricChar(prevEditOperationType, config, model, selections[0], ch);\n            if (r) {\n                return r;\n            }\n        }\n        // A simple character type\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], ch);\n        }\n        const opType = getTypingOperation(ch, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static typeWithoutInterceptors(prevEditOperationType, config, model, selections, str) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = new ReplaceCommand(selections[i], str);\n        }\n        const opType = getTypingOperation(str, prevEditOperationType);\n        return new EditOperationResult(opType, commands, {\n            shouldPushStackElementBefore: shouldPushStackElementBetween(prevEditOperationType, opType),\n            shouldPushStackElementAfter: false\n        });\n    }\n    static lineInsertBefore(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            let lineNumber = selections[i].positionLineNumber;\n            if (lineNumber === 1) {\n                commands[i] = new ReplaceCommandWithoutChangingPosition(new Range(1, 1, 1, 1), '\\n');\n            }\n            else {\n                lineNumber--;\n                const column = model.getLineMaxColumn(lineNumber);\n                commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n            }\n        }\n        return commands;\n    }\n    static lineInsertAfter(config, model, selections) {\n        if (model === null || selections === null) {\n            return [];\n        }\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            const lineNumber = selections[i].positionLineNumber;\n            const column = model.getLineMaxColumn(lineNumber);\n            commands[i] = this._enter(config, model, false, new Range(lineNumber, column, lineNumber, column));\n        }\n        return commands;\n    }\n    static lineBreakInsert(config, model, selections) {\n        const commands = [];\n        for (let i = 0, len = selections.length; i < len; i++) {\n            commands[i] = this._enter(config, model, true, selections[i]);\n        }\n        return commands;\n    }\n}\nexport class TypeWithAutoClosingCommand extends ReplaceCommandWithOffsetCursorState {\n    constructor(selection, openCharacter, insertOpenCharacter, closeCharacter) {\n        super(selection, (insertOpenCharacter ? openCharacter : '') + closeCharacter, 0, -closeCharacter.length);\n        this._openCharacter = openCharacter;\n        this._closeCharacter = closeCharacter;\n        this.closeCharacterRange = null;\n        this.enclosingRange = null;\n    }\n    computeCursorState(model, helper) {\n        const inverseEditOperations = helper.getInverseEditOperations();\n        const range = inverseEditOperations[0].range;\n        this.closeCharacterRange = new Range(range.startLineNumber, range.endColumn - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        this.enclosingRange = new Range(range.startLineNumber, range.endColumn - this._openCharacter.length - this._closeCharacter.length, range.endLineNumber, range.endColumn);\n        return super.computeCursorState(model, helper);\n    }\n}\nfunction getTypingOperation(typedText, previousTypingOperation) {\n    if (typedText === ' ') {\n        return previousTypingOperation === 5 /* TypingFirstSpace */\n            || previousTypingOperation === 6 /* TypingConsecutiveSpace */\n            ? 6 /* TypingConsecutiveSpace */\n            : 5 /* TypingFirstSpace */;\n    }\n    return 4 /* TypingOther */;\n}\nfunction shouldPushStackElementBetween(previousTypingOperation, typingOperation) {\n    if (isTypingOperation(previousTypingOperation) && !isTypingOperation(typingOperation)) {\n        // Always set an undo stop before non-type operations\n        return true;\n    }\n    if (previousTypingOperation === 5 /* TypingFirstSpace */) {\n        // `abc |d`: No undo stop\n        // `abc  |d`: Undo stop\n        return false;\n    }\n    // Insert undo stop between different operation types\n    return normalizeOperationType(previousTypingOperation) !== normalizeOperationType(typingOperation);\n}\nfunction normalizeOperationType(type) {\n    return (type === 6 /* TypingConsecutiveSpace */ || type === 5 /* TypingFirstSpace */)\n        ? 'space'\n        : type;\n}\nfunction isTypingOperation(type) {\n    return type === 4 /* TypingOther */\n        || type === 5 /* TypingFirstSpace */\n        || type === 6 /* TypingConsecutiveSpace */;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { SingleCursorState } from '../cursorCommon.js';\nimport { DeleteOperations } from './cursorDeleteOperations.js';\nimport { getMapForWordSeparators } from '../core/wordCharacterClassifier.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nexport class WordOperations {\n    static _createWord(lineContent, wordType, nextCharClass, start, end) {\n        // console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');\n        return { start: start, end: end, wordType: wordType, nextCharClass: nextCharClass };\n    }\n    static _findPreviousWordOnLine(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindPreviousWordOnLine(lineContent, wordSeparators, position);\n    }\n    static _doFindPreviousWordOnLine(lineContent, wordSeparators, position) {\n        let wordType = 0 /* None */;\n        for (let chIndex = position.column - 2; chIndex >= 0; chIndex--) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 0 /* Regular */) {\n                if (wordType === 2 /* Separator */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = 1 /* Regular */;\n            }\n            else if (chClass === 2 /* WordSeparator */) {\n                if (wordType === 1 /* Regular */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n                wordType = 2 /* Separator */;\n            }\n            else if (chClass === 1 /* Whitespace */) {\n                if (wordType !== 0 /* None */) {\n                    return this._createWord(lineContent, wordType, chClass, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));\n                }\n            }\n        }\n        if (wordType !== 0 /* None */) {\n            return this._createWord(lineContent, wordType, 1 /* Whitespace */, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));\n        }\n        return null;\n    }\n    static _findEndOfWord(lineContent, wordSeparators, wordType, startIndex) {\n        const len = lineContent.length;\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 1 /* Whitespace */) {\n                return chIndex;\n            }\n            if (wordType === 1 /* Regular */ && chClass === 2 /* WordSeparator */) {\n                return chIndex;\n            }\n            if (wordType === 2 /* Separator */ && chClass === 0 /* Regular */) {\n                return chIndex;\n            }\n        }\n        return len;\n    }\n    static _findNextWordOnLine(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        return this._doFindNextWordOnLine(lineContent, wordSeparators, position);\n    }\n    static _doFindNextWordOnLine(lineContent, wordSeparators, position) {\n        let wordType = 0 /* None */;\n        const len = lineContent.length;\n        for (let chIndex = position.column - 1; chIndex < len; chIndex++) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 0 /* Regular */) {\n                if (wordType === 2 /* Separator */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = 1 /* Regular */;\n            }\n            else if (chClass === 2 /* WordSeparator */) {\n                if (wordType === 1 /* Regular */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n                wordType = 2 /* Separator */;\n            }\n            else if (chClass === 1 /* Whitespace */) {\n                if (wordType !== 0 /* None */) {\n                    return this._createWord(lineContent, wordType, chClass, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);\n                }\n            }\n        }\n        if (wordType !== 0 /* None */) {\n            return this._createWord(lineContent, wordType, 1 /* Whitespace */, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);\n        }\n        return null;\n    }\n    static _findStartOfWord(lineContent, wordSeparators, wordType, startIndex) {\n        for (let chIndex = startIndex; chIndex >= 0; chIndex--) {\n            const chCode = lineContent.charCodeAt(chIndex);\n            const chClass = wordSeparators.get(chCode);\n            if (chClass === 1 /* Whitespace */) {\n                return chIndex + 1;\n            }\n            if (wordType === 1 /* Regular */ && chClass === 2 /* WordSeparator */) {\n                return chIndex + 1;\n            }\n            if (wordType === 2 /* Separator */ && chClass === 0 /* Regular */) {\n                return chIndex + 1;\n            }\n        }\n        return 0;\n    }\n    static moveWordLeft(wordSeparators, model, position, wordNavigationType) {\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        if (column === 1) {\n            if (lineNumber > 1) {\n                lineNumber = lineNumber - 1;\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n        if (wordNavigationType === 0 /* WordStart */) {\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        if (wordNavigationType === 1 /* WordStartFast */) {\n            if (prevWordOnLine\n                && prevWordOnLine.wordType === 2 /* Separator */\n                && prevWordOnLine.end - prevWordOnLine.start === 1\n                && prevWordOnLine.nextCharClass === 0 /* Regular */) {\n                // Skip over a word made up of one single separator and followed by a regular character\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        if (wordNavigationType === 3 /* WordAccessibility */) {\n            while (prevWordOnLine\n                && prevWordOnLine.wordType === 2 /* Separator */) {\n                // Skip over words made up of only separators\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.start + 1 : 1);\n        }\n        // We are stopping at the ending of words\n        if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n            prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n        }\n        return new Position(lineNumber, prevWordOnLine ? prevWordOnLine.end + 1 : 1);\n    }\n    static _moveWordPartLeft(model, position) {\n        const lineNumber = position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === 1) {\n            return (lineNumber > 1 ? new Position(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)) : position);\n        }\n        const lineContent = model.getLineContent(lineNumber);\n        for (let column = position.column - 1; column > 1; column--) {\n            const left = lineContent.charCodeAt(column - 2);\n            const right = lineContent.charCodeAt(column - 1);\n            if (left === 95 /* Underline */ && right !== 95 /* Underline */) {\n                // snake_case_variables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isLowerAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    const rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight)) {\n                        return new Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new Position(lineNumber, 1);\n    }\n    static moveWordRight(wordSeparators, model, position, wordNavigationType) {\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        let movedDown = false;\n        if (column === model.getLineMaxColumn(lineNumber)) {\n            if (lineNumber < model.getLineCount()) {\n                movedDown = true;\n                lineNumber = lineNumber + 1;\n                column = 1;\n            }\n        }\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, column));\n        if (wordNavigationType === 2 /* WordEnd */) {\n            if (nextWordOnLine && nextWordOnLine.wordType === 2 /* Separator */) {\n                if (nextWordOnLine.end - nextWordOnLine.start === 1 && nextWordOnLine.nextCharClass === 0 /* Regular */) {\n                    // Skip over a word made up of one single separator and followed by a regular character\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n                }\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        else if (wordNavigationType === 3 /* WordAccessibility */) {\n            if (movedDown) {\n                // If we move to the next line, pretend that the cursor is right before the first character.\n                // This is needed when the first word starts right at the first character - and in order not to miss it,\n                // we need to start before.\n                column = 0;\n            }\n            while (nextWordOnLine\n                && (nextWordOnLine.wordType === 2 /* Separator */\n                    || nextWordOnLine.start + 1 <= column)) {\n                // Skip over a word made up of one single separator\n                // Also skip over word if it begins before current cursor position to ascertain we're moving forward at least 1 character.\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        else {\n            if (nextWordOnLine && !movedDown && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                column = model.getLineMaxColumn(lineNumber);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    static _moveWordPartRight(model, position) {\n        const lineNumber = position.lineNumber;\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (position.column === maxColumn) {\n            return (lineNumber < model.getLineCount() ? new Position(lineNumber + 1, 1) : position);\n        }\n        const lineContent = model.getLineContent(lineNumber);\n        for (let column = position.column + 1; column < maxColumn; column++) {\n            const left = lineContent.charCodeAt(column - 2);\n            const right = lineContent.charCodeAt(column - 1);\n            if (left !== 95 /* Underline */ && right === 95 /* Underline */) {\n                // snake_case_variables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isLowerAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // camelCaseVariables\n                return new Position(lineNumber, column);\n            }\n            if (strings.isUpperAsciiLetter(left) && strings.isUpperAsciiLetter(right)) {\n                // thisIsACamelCaseWithOneLetterWords\n                if (column + 1 < maxColumn) {\n                    const rightRight = lineContent.charCodeAt(column);\n                    if (strings.isLowerAsciiLetter(rightRight)) {\n                        return new Position(lineNumber, column);\n                    }\n                }\n            }\n        }\n        return new Position(lineNumber, maxColumn);\n    }\n    static _deleteWordLeftWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const startIndex = position.column - 2;\n        const lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);\n        if (lastNonWhitespace + 1 < startIndex) {\n            return new Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);\n        }\n        return null;\n    }\n    static deleteWordLeft(ctx, wordNavigationType) {\n        const wordSeparators = ctx.wordSeparators;\n        const model = ctx.model;\n        const selection = ctx.selection;\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        if (DeleteOperations.isAutoClosingPairDelete(ctx.autoClosingDelete, ctx.autoClosingBrackets, ctx.autoClosingQuotes, ctx.autoClosingPairs.autoClosingPairsOpenByEnd, ctx.model, [ctx.selection], ctx.autoClosedCharacters)) {\n            const position = ctx.selection.getPosition();\n            return new Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        if (lineNumber === 1 && column === 1) {\n            // Ignore deleting at beginning of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            const r = this._deleteWordLeftWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        let prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === 0 /* WordStart */) {\n            if (prevWordOnLine) {\n                column = prevWordOnLine.start + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        else {\n            if (prevWordOnLine && column <= prevWordOnLine.end + 1) {\n                prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, new Position(lineNumber, prevWordOnLine.start + 1));\n            }\n            if (prevWordOnLine) {\n                column = prevWordOnLine.end + 1;\n            }\n            else {\n                if (column > 1) {\n                    column = 1;\n                }\n                else {\n                    lineNumber--;\n                    column = model.getLineMaxColumn(lineNumber);\n                }\n            }\n        }\n        return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n    static deleteInsideWord(wordSeparators, model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        const r = this._deleteInsideWordWhitespace(model, position);\n        if (r) {\n            return r;\n        }\n        return this._deleteInsideWordDetermineDeleteRange(wordSeparators, model, position);\n    }\n    static _charAtIsWhitespace(str, index) {\n        const charCode = str.charCodeAt(index);\n        return (charCode === 32 /* Space */ || charCode === 9 /* Tab */);\n    }\n    static _deleteInsideWordWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const lineContentLength = lineContent.length;\n        if (lineContentLength === 0) {\n            // empty line\n            return null;\n        }\n        let leftIndex = Math.max(position.column - 2, 0);\n        if (!this._charAtIsWhitespace(lineContent, leftIndex)) {\n            // touches a non-whitespace character to the left\n            return null;\n        }\n        let rightIndex = Math.min(position.column - 1, lineContentLength - 1);\n        if (!this._charAtIsWhitespace(lineContent, rightIndex)) {\n            // touches a non-whitespace character to the right\n            return null;\n        }\n        // walk over whitespace to the left\n        while (leftIndex > 0 && this._charAtIsWhitespace(lineContent, leftIndex - 1)) {\n            leftIndex--;\n        }\n        // walk over whitespace to the right\n        while (rightIndex + 1 < lineContentLength && this._charAtIsWhitespace(lineContent, rightIndex + 1)) {\n            rightIndex++;\n        }\n        return new Range(position.lineNumber, leftIndex + 1, position.lineNumber, rightIndex + 2);\n    }\n    static _deleteInsideWordDetermineDeleteRange(wordSeparators, model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const lineLength = lineContent.length;\n        if (lineLength === 0) {\n            // empty line\n            if (position.lineNumber > 1) {\n                return new Range(position.lineNumber - 1, model.getLineMaxColumn(position.lineNumber - 1), position.lineNumber, 1);\n            }\n            else {\n                if (position.lineNumber < model.getLineCount()) {\n                    return new Range(position.lineNumber, 1, position.lineNumber + 1, 1);\n                }\n                else {\n                    // empty model\n                    return new Range(position.lineNumber, 1, position.lineNumber, 1);\n                }\n            }\n        }\n        const touchesWord = (word) => {\n            return (word.start + 1 <= position.column && position.column <= word.end + 1);\n        };\n        const createRangeWithPosition = (startColumn, endColumn) => {\n            startColumn = Math.min(startColumn, position.column);\n            endColumn = Math.max(endColumn, position.column);\n            return new Range(position.lineNumber, startColumn, position.lineNumber, endColumn);\n        };\n        const deleteWordAndAdjacentWhitespace = (word) => {\n            let startColumn = word.start + 1;\n            let endColumn = word.end + 1;\n            let expandedToTheRight = false;\n            while (endColumn - 1 < lineLength && this._charAtIsWhitespace(lineContent, endColumn - 1)) {\n                expandedToTheRight = true;\n                endColumn++;\n            }\n            if (!expandedToTheRight) {\n                while (startColumn > 1 && this._charAtIsWhitespace(lineContent, startColumn - 2)) {\n                    startColumn--;\n                }\n            }\n            return createRangeWithPosition(startColumn, endColumn);\n        };\n        const prevWordOnLine = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (prevWordOnLine && touchesWord(prevWordOnLine)) {\n            return deleteWordAndAdjacentWhitespace(prevWordOnLine);\n        }\n        const nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (nextWordOnLine && touchesWord(nextWordOnLine)) {\n            return deleteWordAndAdjacentWhitespace(nextWordOnLine);\n        }\n        if (prevWordOnLine && nextWordOnLine) {\n            return createRangeWithPosition(prevWordOnLine.end + 1, nextWordOnLine.start + 1);\n        }\n        if (prevWordOnLine) {\n            return createRangeWithPosition(prevWordOnLine.start + 1, prevWordOnLine.end + 1);\n        }\n        if (nextWordOnLine) {\n            return createRangeWithPosition(nextWordOnLine.start + 1, nextWordOnLine.end + 1);\n        }\n        return createRangeWithPosition(1, lineLength + 1);\n    }\n    static _deleteWordPartLeft(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const pos = selection.getPosition();\n        const toPosition = WordOperations._moveWordPartLeft(model, pos);\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n    static _findFirstNonWhitespaceChar(str, startIndex) {\n        const len = str.length;\n        for (let chIndex = startIndex; chIndex < len; chIndex++) {\n            const ch = str.charAt(chIndex);\n            if (ch !== ' ' && ch !== '\\t') {\n                return chIndex;\n            }\n        }\n        return len;\n    }\n    static _deleteWordRightWhitespace(model, position) {\n        const lineContent = model.getLineContent(position.lineNumber);\n        const startIndex = position.column - 1;\n        const firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);\n        if (startIndex + 1 < firstNonWhitespace) {\n            // bingo\n            return new Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);\n        }\n        return null;\n    }\n    static deleteWordRight(ctx, wordNavigationType) {\n        const wordSeparators = ctx.wordSeparators;\n        const model = ctx.model;\n        const selection = ctx.selection;\n        const whitespaceHeuristics = ctx.whitespaceHeuristics;\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const position = new Position(selection.positionLineNumber, selection.positionColumn);\n        let lineNumber = position.lineNumber;\n        let column = position.column;\n        const lineCount = model.getLineCount();\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (lineNumber === lineCount && column === maxColumn) {\n            // Ignore deleting at end of file\n            return null;\n        }\n        if (whitespaceHeuristics) {\n            const r = this._deleteWordRightWhitespace(model, position);\n            if (r) {\n                return r;\n            }\n        }\n        let nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (wordNavigationType === 2 /* WordEnd */) {\n            if (nextWordOnLine) {\n                column = nextWordOnLine.end + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        else {\n            if (nextWordOnLine && column >= nextWordOnLine.start + 1) {\n                nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, nextWordOnLine.end + 1));\n            }\n            if (nextWordOnLine) {\n                column = nextWordOnLine.start + 1;\n            }\n            else {\n                if (column < maxColumn || lineNumber === lineCount) {\n                    column = maxColumn;\n                }\n                else {\n                    lineNumber++;\n                    nextWordOnLine = WordOperations._findNextWordOnLine(wordSeparators, model, new Position(lineNumber, 1));\n                    if (nextWordOnLine) {\n                        column = nextWordOnLine.start + 1;\n                    }\n                    else {\n                        column = model.getLineMaxColumn(lineNumber);\n                    }\n                }\n            }\n        }\n        return new Range(lineNumber, column, position.lineNumber, position.column);\n    }\n    static _deleteWordPartRight(model, selection) {\n        if (!selection.isEmpty()) {\n            return selection;\n        }\n        const pos = selection.getPosition();\n        const toPosition = WordOperations._moveWordPartRight(model, pos);\n        return new Range(pos.lineNumber, pos.column, toPosition.lineNumber, toPosition.column);\n    }\n    static _createWordAtPosition(model, lineNumber, word) {\n        const range = new Range(lineNumber, word.start + 1, lineNumber, word.end + 1);\n        return {\n            word: model.getValueInRange(range),\n            startColumn: range.startColumn,\n            endColumn: range.endColumn\n        };\n    }\n    static getWordAtPosition(model, _wordSeparators, position) {\n        const wordSeparators = getMapForWordSeparators(_wordSeparators);\n        const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        if (prevWord && prevWord.wordType === 1 /* Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n            return WordOperations._createWordAtPosition(model, position.lineNumber, prevWord);\n        }\n        const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (nextWord && nextWord.wordType === 1 /* Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n            return WordOperations._createWordAtPosition(model, position.lineNumber, nextWord);\n        }\n        return null;\n    }\n    static word(config, model, cursor, inSelectionMode, position) {\n        const wordSeparators = getMapForWordSeparators(config.wordSeparators);\n        const prevWord = WordOperations._findPreviousWordOnLine(wordSeparators, model, position);\n        const nextWord = WordOperations._findNextWordOnLine(wordSeparators, model, position);\n        if (!inSelectionMode) {\n            // Entering word selection for the first time\n            let startColumn;\n            let endColumn;\n            if (prevWord && prevWord.wordType === 1 /* Regular */ && prevWord.start <= position.column - 1 && position.column - 1 <= prevWord.end) {\n                // isTouchingPrevWord\n                startColumn = prevWord.start + 1;\n                endColumn = prevWord.end + 1;\n            }\n            else if (nextWord && nextWord.wordType === 1 /* Regular */ && nextWord.start <= position.column - 1 && position.column - 1 <= nextWord.end) {\n                // isTouchingNextWord\n                startColumn = nextWord.start + 1;\n                endColumn = nextWord.end + 1;\n            }\n            else {\n                if (prevWord) {\n                    startColumn = prevWord.end + 1;\n                }\n                else {\n                    startColumn = 1;\n                }\n                if (nextWord) {\n                    endColumn = nextWord.start + 1;\n                }\n                else {\n                    endColumn = model.getLineMaxColumn(position.lineNumber);\n                }\n            }\n            return new SingleCursorState(new Range(position.lineNumber, startColumn, position.lineNumber, endColumn), 0, new Position(position.lineNumber, endColumn), 0);\n        }\n        let startColumn;\n        let endColumn;\n        if (prevWord && prevWord.wordType === 1 /* Regular */ && prevWord.start < position.column - 1 && position.column - 1 < prevWord.end) {\n            // isInsidePrevWord\n            startColumn = prevWord.start + 1;\n            endColumn = prevWord.end + 1;\n        }\n        else if (nextWord && nextWord.wordType === 1 /* Regular */ && nextWord.start < position.column - 1 && position.column - 1 < nextWord.end) {\n            // isInsideNextWord\n            startColumn = nextWord.start + 1;\n            endColumn = nextWord.end + 1;\n        }\n        else {\n            startColumn = position.column;\n            endColumn = position.column;\n        }\n        const lineNumber = position.lineNumber;\n        let column;\n        if (cursor.selectionStart.containsPosition(position)) {\n            column = cursor.selectionStart.endColumn;\n        }\n        else if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {\n            column = startColumn;\n            const possiblePosition = new Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.endColumn;\n            }\n        }\n        else {\n            column = endColumn;\n            const possiblePosition = new Position(lineNumber, column);\n            if (cursor.selectionStart.containsPosition(possiblePosition)) {\n                column = cursor.selectionStart.startColumn;\n            }\n        }\n        return cursor.move(true, lineNumber, column, 0);\n    }\n}\nexport class WordPartOperations extends WordOperations {\n    static deleteWordPartLeft(ctx) {\n        const candidates = enforceDefined([\n            WordOperations.deleteWordLeft(ctx, 0 /* WordStart */),\n            WordOperations.deleteWordLeft(ctx, 2 /* WordEnd */),\n            WordOperations._deleteWordPartLeft(ctx.model, ctx.selection)\n        ]);\n        candidates.sort(Range.compareRangesUsingEnds);\n        return candidates[2];\n    }\n    static deleteWordPartRight(ctx) {\n        const candidates = enforceDefined([\n            WordOperations.deleteWordRight(ctx, 0 /* WordStart */),\n            WordOperations.deleteWordRight(ctx, 2 /* WordEnd */),\n            WordOperations._deleteWordPartRight(ctx.model, ctx.selection)\n        ]);\n        candidates.sort(Range.compareRangesUsingStarts);\n        return candidates[0];\n    }\n    static moveWordPartLeft(wordSeparators, model, position) {\n        const candidates = enforceDefined([\n            WordOperations.moveWordLeft(wordSeparators, model, position, 0 /* WordStart */),\n            WordOperations.moveWordLeft(wordSeparators, model, position, 2 /* WordEnd */),\n            WordOperations._moveWordPartLeft(model, position)\n        ]);\n        candidates.sort(Position.compare);\n        return candidates[2];\n    }\n    static moveWordPartRight(wordSeparators, model, position) {\n        const candidates = enforceDefined([\n            WordOperations.moveWordRight(wordSeparators, model, position, 0 /* WordStart */),\n            WordOperations.moveWordRight(wordSeparators, model, position, 2 /* WordEnd */),\n            WordOperations._moveWordPartRight(model, position)\n        ]);\n        candidates.sort(Position.compare);\n        return candidates[0];\n    }\n}\nfunction enforceDefined(arr) {\n    return arr.filter(el => Boolean(el));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './core/position.js';\nimport { Range } from './core/range.js';\nimport { Selection } from './core/selection.js';\nimport { createScopedLineTokens } from './languages/supports.js';\nimport { CursorColumns } from './core/cursorColumns.js';\nimport { normalizeIndentation } from './core/indentation.js';\nconst autoCloseAlways = () => true;\nconst autoCloseNever = () => false;\nconst autoCloseBeforeWhitespace = (chr) => (chr === ' ' || chr === '\\t');\nexport class CursorConfiguration {\n    constructor(languageId, modelOptions, configuration, languageConfigurationService) {\n        this.languageConfigurationService = languageConfigurationService;\n        this._cursorMoveConfigurationBrand = undefined;\n        this._languageId = languageId;\n        const options = configuration.options;\n        const layoutInfo = options.get(131 /* layoutInfo */);\n        this.readOnly = options.get(81 /* readOnly */);\n        this.tabSize = modelOptions.tabSize;\n        this.indentSize = modelOptions.indentSize;\n        this.insertSpaces = modelOptions.insertSpaces;\n        this.stickyTabStops = options.get(104 /* stickyTabStops */);\n        this.lineHeight = options.get(59 /* lineHeight */);\n        this.pageSize = Math.max(1, Math.floor(layoutInfo.height / this.lineHeight) - 2);\n        this.useTabStops = options.get(116 /* useTabStops */);\n        this.wordSeparators = options.get(117 /* wordSeparators */);\n        this.emptySelectionClipboard = options.get(32 /* emptySelectionClipboard */);\n        this.copyWithSyntaxHighlighting = options.get(21 /* copyWithSyntaxHighlighting */);\n        this.multiCursorMergeOverlapping = options.get(69 /* multiCursorMergeOverlapping */);\n        this.multiCursorPaste = options.get(71 /* multiCursorPaste */);\n        this.autoClosingBrackets = options.get(5 /* autoClosingBrackets */);\n        this.autoClosingQuotes = options.get(8 /* autoClosingQuotes */);\n        this.autoClosingDelete = options.get(6 /* autoClosingDelete */);\n        this.autoClosingOvertype = options.get(7 /* autoClosingOvertype */);\n        this.autoSurround = options.get(11 /* autoSurround */);\n        this.autoIndent = options.get(9 /* autoIndent */);\n        this.surroundingPairs = {};\n        this._electricChars = null;\n        this.shouldAutoCloseBefore = {\n            quote: this._getShouldAutoClose(languageId, this.autoClosingQuotes),\n            bracket: this._getShouldAutoClose(languageId, this.autoClosingBrackets)\n        };\n        this.autoClosingPairs = this.languageConfigurationService.getLanguageConfiguration(languageId).getAutoClosingPairs();\n        const surroundingPairs = this.languageConfigurationService.getLanguageConfiguration(languageId).getSurroundingPairs();\n        if (surroundingPairs) {\n            for (const pair of surroundingPairs) {\n                this.surroundingPairs[pair.open] = pair.close;\n            }\n        }\n    }\n    static shouldRecreate(e) {\n        return (e.hasChanged(131 /* layoutInfo */)\n            || e.hasChanged(117 /* wordSeparators */)\n            || e.hasChanged(32 /* emptySelectionClipboard */)\n            || e.hasChanged(69 /* multiCursorMergeOverlapping */)\n            || e.hasChanged(71 /* multiCursorPaste */)\n            || e.hasChanged(5 /* autoClosingBrackets */)\n            || e.hasChanged(8 /* autoClosingQuotes */)\n            || e.hasChanged(6 /* autoClosingDelete */)\n            || e.hasChanged(7 /* autoClosingOvertype */)\n            || e.hasChanged(11 /* autoSurround */)\n            || e.hasChanged(116 /* useTabStops */)\n            || e.hasChanged(59 /* lineHeight */)\n            || e.hasChanged(81 /* readOnly */));\n    }\n    get electricChars() {\n        var _a;\n        if (!this._electricChars) {\n            this._electricChars = {};\n            const electricChars = (_a = this.languageConfigurationService.getLanguageConfiguration(this._languageId).electricCharacter) === null || _a === void 0 ? void 0 : _a.getElectricCharacters();\n            if (electricChars) {\n                for (const char of electricChars) {\n                    this._electricChars[char] = true;\n                }\n            }\n        }\n        return this._electricChars;\n    }\n    /**\n     * Should return opening bracket type to match indentation with\n     */\n    onElectricCharacter(character, context, column) {\n        const scopedLineTokens = createScopedLineTokens(context, column - 1);\n        const electricCharacterSupport = this.languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId).electricCharacter;\n        if (!electricCharacterSupport) {\n            return null;\n        }\n        return electricCharacterSupport.onElectricCharacter(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);\n    }\n    normalizeIndentation(str) {\n        return normalizeIndentation(str, this.indentSize, this.insertSpaces);\n    }\n    _getShouldAutoClose(languageId, autoCloseConfig) {\n        switch (autoCloseConfig) {\n            case 'beforeWhitespace':\n                return autoCloseBeforeWhitespace;\n            case 'languageDefined':\n                return this._getLanguageDefinedShouldAutoClose(languageId);\n            case 'always':\n                return autoCloseAlways;\n            case 'never':\n                return autoCloseNever;\n        }\n    }\n    _getLanguageDefinedShouldAutoClose(languageId) {\n        const autoCloseBeforeSet = this.languageConfigurationService.getLanguageConfiguration(languageId).getAutoCloseBeforeSet();\n        return c => autoCloseBeforeSet.indexOf(c) !== -1;\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    visibleColumnFromColumn(model, position) {\n        return CursorColumns.visibleColumnFromColumn(model.getLineContent(position.lineNumber), position.column, this.tabSize);\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    columnFromVisibleColumn(model, lineNumber, visibleColumn) {\n        const result = CursorColumns.columnFromVisibleColumn(model.getLineContent(lineNumber), visibleColumn, this.tabSize);\n        const minColumn = model.getLineMinColumn(lineNumber);\n        if (result < minColumn) {\n            return minColumn;\n        }\n        const maxColumn = model.getLineMaxColumn(lineNumber);\n        if (result > maxColumn) {\n            return maxColumn;\n        }\n        return result;\n    }\n}\nexport class CursorState {\n    constructor(modelState, viewState) {\n        this._cursorStateBrand = undefined;\n        this.modelState = modelState;\n        this.viewState = viewState;\n    }\n    static fromModelState(modelState) {\n        return new PartialModelCursorState(modelState);\n    }\n    static fromViewState(viewState) {\n        return new PartialViewCursorState(viewState);\n    }\n    static fromModelSelection(modelSelection) {\n        const selection = Selection.liftSelection(modelSelection);\n        const modelState = new SingleCursorState(Range.fromPositions(selection.getSelectionStart()), 0, selection.getPosition(), 0);\n        return CursorState.fromModelState(modelState);\n    }\n    static fromModelSelections(modelSelections) {\n        const states = [];\n        for (let i = 0, len = modelSelections.length; i < len; i++) {\n            states[i] = this.fromModelSelection(modelSelections[i]);\n        }\n        return states;\n    }\n    equals(other) {\n        return (this.viewState.equals(other.viewState) && this.modelState.equals(other.modelState));\n    }\n}\nexport class PartialModelCursorState {\n    constructor(modelState) {\n        this.modelState = modelState;\n        this.viewState = null;\n    }\n}\nexport class PartialViewCursorState {\n    constructor(viewState) {\n        this.modelState = null;\n        this.viewState = viewState;\n    }\n}\n/**\n * Represents the cursor state on either the model or on the view model.\n */\nexport class SingleCursorState {\n    constructor(selectionStart, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns) {\n        this._singleCursorStateBrand = undefined;\n        this.selectionStart = selectionStart;\n        this.selectionStartLeftoverVisibleColumns = selectionStartLeftoverVisibleColumns;\n        this.position = position;\n        this.leftoverVisibleColumns = leftoverVisibleColumns;\n        this.selection = SingleCursorState._computeSelection(this.selectionStart, this.position);\n    }\n    equals(other) {\n        return (this.selectionStartLeftoverVisibleColumns === other.selectionStartLeftoverVisibleColumns\n            && this.leftoverVisibleColumns === other.leftoverVisibleColumns\n            && this.position.equals(other.position)\n            && this.selectionStart.equalsRange(other.selectionStart));\n    }\n    hasSelection() {\n        return (!this.selection.isEmpty() || !this.selectionStart.isEmpty());\n    }\n    move(inSelectionMode, lineNumber, column, leftoverVisibleColumns) {\n        if (inSelectionMode) {\n            // move just position\n            return new SingleCursorState(this.selectionStart, this.selectionStartLeftoverVisibleColumns, new Position(lineNumber, column), leftoverVisibleColumns);\n        }\n        else {\n            // move everything\n            return new SingleCursorState(new Range(lineNumber, column, lineNumber, column), leftoverVisibleColumns, new Position(lineNumber, column), leftoverVisibleColumns);\n        }\n    }\n    static _computeSelection(selectionStart, position) {\n        if (selectionStart.isEmpty() || !position.isBeforeOrEqual(selectionStart.getStartPosition())) {\n            return Selection.fromPositions(selectionStart.getStartPosition(), position);\n        }\n        else {\n            return Selection.fromPositions(selectionStart.getEndPosition(), position);\n        }\n    }\n}\nexport class EditOperationResult {\n    constructor(type, commands, opts) {\n        this._editOperationResultBrand = undefined;\n        this.type = type;\n        this.commands = commands;\n        this.shouldPushStackElementBefore = opts.shouldPushStackElementBefore;\n        this.shouldPushStackElementAfter = opts.shouldPushStackElementAfter;\n    }\n}\nexport function isQuote(ch) {\n    return (ch === '\\'' || ch === '\"' || ch === '`');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../base/common/diff/diff.js';\nimport * as strings from '../../../base/common/strings.js';\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n    return diffAlgo.ComputeDiff(pretty);\n}\nclass LineSequence {\n    constructor(lines) {\n        const startColumns = [];\n        const endColumns = [];\n        for (let i = 0, length = lines.length; i < length; i++) {\n            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n            endColumns[i] = getLastNonBlankColumn(lines[i], 1);\n        }\n        this.lines = lines;\n        this._startColumns = startColumns;\n        this._endColumns = endColumns;\n    }\n    getElements() {\n        const elements = [];\n        for (let i = 0, len = this.lines.length; i < len; i++) {\n            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n        }\n        return elements;\n    }\n    getStrictElement(index) {\n        return this.lines[index];\n    }\n    getStartLineNumber(i) {\n        return i + 1;\n    }\n    getEndLineNumber(i) {\n        return i + 1;\n    }\n    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\n        const charCodes = [];\n        const lineNumbers = [];\n        const columns = [];\n        let len = 0;\n        for (let index = startIndex; index <= endIndex; index++) {\n            const lineContent = this.lines[index];\n            const startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\n            const endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\n            for (let col = startColumn; col < endColumn; col++) {\n                charCodes[len] = lineContent.charCodeAt(col - 1);\n                lineNumbers[len] = index + 1;\n                columns[len] = col;\n                len++;\n            }\n        }\n        return new CharSequence(charCodes, lineNumbers, columns);\n    }\n}\nclass CharSequence {\n    constructor(charCodes, lineNumbers, columns) {\n        this._charCodes = charCodes;\n        this._lineNumbers = lineNumbers;\n        this._columns = columns;\n    }\n    getElements() {\n        return this._charCodes;\n    }\n    getStartLineNumber(i) {\n        return this._lineNumbers[i];\n    }\n    getStartColumn(i) {\n        return this._columns[i];\n    }\n    getEndLineNumber(i) {\n        return this._lineNumbers[i];\n    }\n    getEndColumn(i) {\n        return this._columns[i] + 1;\n    }\n}\nclass CharChange {\n    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalStartColumn = originalStartColumn;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.originalEndColumn = originalEndColumn;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedStartColumn = modifiedStartColumn;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.modifiedEndColumn = modifiedEndColumn;\n    }\n    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\n        let originalStartLineNumber;\n        let originalStartColumn;\n        let originalEndLineNumber;\n        let originalEndColumn;\n        let modifiedStartLineNumber;\n        let modifiedStartColumn;\n        let modifiedEndLineNumber;\n        let modifiedEndColumn;\n        if (diffChange.originalLength === 0) {\n            originalStartLineNumber = 0;\n            originalStartColumn = 0;\n            originalEndLineNumber = 0;\n            originalEndColumn = 0;\n        }\n        else {\n            originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n            originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n            originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n            originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n        }\n        if (diffChange.modifiedLength === 0) {\n            modifiedStartLineNumber = 0;\n            modifiedStartColumn = 0;\n            modifiedEndLineNumber = 0;\n            modifiedEndColumn = 0;\n        }\n        else {\n            modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n            modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n            modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n            modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        }\n        return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\n    }\n}\nfunction postProcessCharChanges(rawChanges) {\n    if (rawChanges.length <= 1) {\n        return rawChanges;\n    }\n    const result = [rawChanges[0]];\n    let prevChange = result[0];\n    for (let i = 1, len = rawChanges.length; i < len; i++) {\n        const currChange = rawChanges[i];\n        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n        // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n            // Merge the current change into the previous one\n            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n        }\n        else {\n            // Add the current change\n            result.push(currChange);\n            prevChange = currChange;\n        }\n    }\n    return result;\n}\nclass LineChange {\n    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.charChanges = charChanges;\n    }\n    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\n        let originalStartLineNumber;\n        let originalEndLineNumber;\n        let modifiedStartLineNumber;\n        let modifiedEndLineNumber;\n        let charChanges = undefined;\n        if (diffChange.originalLength === 0) {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n            originalEndLineNumber = 0;\n        }\n        else {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        }\n        if (diffChange.modifiedLength === 0) {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n            modifiedEndLineNumber = 0;\n        }\n        else {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        }\n        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n            // Compute character changes for diff chunks of at most 20 lines...\n            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n            let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n            if (shouldPostProcessCharChanges) {\n                rawChanges = postProcessCharChanges(rawChanges);\n            }\n            charChanges = [];\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\n                charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n            }\n        }\n        return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n    }\n}\nexport class DiffComputer {\n    constructor(originalLines, modifiedLines, opts) {\n        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n        this.originalLines = originalLines;\n        this.modifiedLines = modifiedLines;\n        this.original = new LineSequence(originalLines);\n        this.modified = new LineSequence(modifiedLines);\n        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n    }\n    computeDiff() {\n        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n            // empty original => fast path\n            if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n                return {\n                    quitEarly: false,\n                    changes: []\n                };\n            }\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: 1,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: this.modified.lines.length,\n                        charChanges: [{\n                                modifiedEndColumn: 0,\n                                modifiedEndLineNumber: 0,\n                                modifiedStartColumn: 0,\n                                modifiedStartLineNumber: 0,\n                                originalEndColumn: 0,\n                                originalEndLineNumber: 0,\n                                originalStartColumn: 0,\n                                originalStartLineNumber: 0\n                            }]\n                    }]\n            };\n        }\n        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n            // empty modified => fast path\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: this.original.lines.length,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: 1,\n                        charChanges: [{\n                                modifiedEndColumn: 0,\n                                modifiedEndLineNumber: 0,\n                                modifiedStartColumn: 0,\n                                modifiedStartLineNumber: 0,\n                                originalEndColumn: 0,\n                                originalEndLineNumber: 0,\n                                originalStartColumn: 0,\n                                originalStartLineNumber: 0\n                            }]\n                    }]\n            };\n        }\n        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n        const rawChanges = diffResult.changes;\n        const quitEarly = diffResult.quitEarly;\n        // The diff is always computed with ignoring trim whitespace\n        // This ensures we get the prettiest diff\n        if (this.shouldIgnoreTrimWhitespace) {\n            const lineChanges = [];\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\n                lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n            }\n            return {\n                quitEarly: quitEarly,\n                changes: lineChanges\n            };\n        }\n        // Need to post-process and introduce changes where the trim whitespace is different\n        // Note that we are looping starting at -1 to also cover the lines before the first change\n        const result = [];\n        let originalLineIndex = 0;\n        let modifiedLineIndex = 0;\n        for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n            const nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\n            const originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\n            const modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\n            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n                const originalLine = this.originalLines[originalLineIndex];\n                const modifiedLine = this.modifiedLines[modifiedLineIndex];\n                if (originalLine !== modifiedLine) {\n                    // These lines differ only in trim whitespace\n                    // Check the leading whitespace\n                    {\n                        let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n                        let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {\n                            const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n                            const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalStartColumn--;\n                            modifiedStartColumn--;\n                        }\n                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n                        }\n                    }\n                    // Check the trailing whitespace\n                    {\n                        let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n                        let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n                        const originalMaxColumn = originalLine.length + 1;\n                        const modifiedMaxColumn = modifiedLine.length + 1;\n                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n                            const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n                            const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalEndColumn++;\n                            modifiedEndColumn++;\n                        }\n                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n                        }\n                    }\n                }\n                originalLineIndex++;\n                modifiedLineIndex++;\n            }\n            if (nextChange) {\n                // Emit the actual change\n                result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n                originalLineIndex += nextChange.originalLength;\n                modifiedLineIndex += nextChange.modifiedLength;\n            }\n        }\n        return {\n            quitEarly: quitEarly,\n            changes: result\n        };\n    }\n    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n            // Merged into previous\n            return;\n        }\n        let charChanges = undefined;\n        if (this.shouldComputeCharChanges) {\n            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\n        }\n        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\n    }\n    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        const len = result.length;\n        if (len === 0) {\n            return false;\n        }\n        const prevChange = result[len - 1];\n        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n            // Don't merge with inserts/deletes\n            return false;\n        }\n        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n            prevChange.originalEndLineNumber = originalLineNumber;\n            prevChange.modifiedEndLineNumber = modifiedLineNumber;\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        return false;\n    }\n}\nfunction getFirstNonBlankColumn(txt, defaultValue) {\n    const r = strings.firstNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 1;\n}\nfunction getLastNonBlankColumn(txt, defaultValue) {\n    const r = strings.lastNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 2;\n}\nfunction createContinueProcessingPredicate(maximumRuntime) {\n    if (maximumRuntime === 0) {\n        return () => true;\n    }\n    const startTime = Date.now();\n    return () => {\n        return Date.now() - startTime < maximumRuntime;\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class InternalEditorAction {\n    constructor(id, label, alias, precondition, run, contextKeyService) {\n        this.id = id;\n        this.label = label;\n        this.alias = alias;\n        this._precondition = precondition;\n        this._run = run;\n        this._contextKeyService = contextKeyService;\n    }\n    isSupported() {\n        return this._contextKeyService.contextMatchesRules(this._precondition);\n    }\n    run() {\n        if (!this.isSupported()) {\n            return Promise.resolve(undefined);\n        }\n        return this._run();\n    }\n}\n","/**\n * The type of the `IEditor`.\n */\nexport const EditorType = {\n    ICodeEditor: 'vs.editor.ICodeEditor',\n    IDiffEditor: 'vs.editor.IDiffEditor'\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../nls.js';\nimport { RawContextKey } from '../../platform/contextkey/common/contextkey.js';\nexport var EditorContextKeys;\n(function (EditorContextKeys) {\n    EditorContextKeys.editorSimpleInput = new RawContextKey('editorSimpleInput', false, true);\n    /**\n     * A context key that is set when the editor's text has focus (cursor is blinking).\n     * Is false when focus is in simple editor widgets (repl input, scm commit input).\n     */\n    EditorContextKeys.editorTextFocus = new RawContextKey('editorTextFocus', false, nls.localize('editorTextFocus', \"Whether the editor text has focus (cursor is blinking)\"));\n    /**\n     * A context key that is set when the editor's text or an editor's widget has focus.\n     */\n    EditorContextKeys.focus = new RawContextKey('editorFocus', false, nls.localize('editorFocus', \"Whether the editor or an editor widget has focus (e.g. focus is in the find widget)\"));\n    /**\n     * A context key that is set when any editor input has focus (regular editor, repl input...).\n     */\n    EditorContextKeys.textInputFocus = new RawContextKey('textInputFocus', false, nls.localize('textInputFocus', \"Whether an editor or a rich text input has focus (cursor is blinking)\"));\n    EditorContextKeys.readOnly = new RawContextKey('editorReadonly', false, nls.localize('editorReadonly', \"Whether the editor is read only\"));\n    EditorContextKeys.inDiffEditor = new RawContextKey('inDiffEditor', false, nls.localize('inDiffEditor', \"Whether the context is a diff editor\"));\n    EditorContextKeys.columnSelection = new RawContextKey('editorColumnSelection', false, nls.localize('editorColumnSelection', \"Whether `editor.columnSelection` is enabled\"));\n    EditorContextKeys.writable = EditorContextKeys.readOnly.toNegated();\n    EditorContextKeys.hasNonEmptySelection = new RawContextKey('editorHasSelection', false, nls.localize('editorHasSelection', \"Whether the editor has text selected\"));\n    EditorContextKeys.hasOnlyEmptySelection = EditorContextKeys.hasNonEmptySelection.toNegated();\n    EditorContextKeys.hasMultipleSelections = new RawContextKey('editorHasMultipleSelections', false, nls.localize('editorHasMultipleSelections', \"Whether the editor has multiple selections\"));\n    EditorContextKeys.hasSingleSelection = EditorContextKeys.hasMultipleSelections.toNegated();\n    EditorContextKeys.tabMovesFocus = new RawContextKey('editorTabMovesFocus', false, nls.localize('editorTabMovesFocus', \"Whether `Tab` will move focus out of the editor\"));\n    EditorContextKeys.tabDoesNotMoveFocus = EditorContextKeys.tabMovesFocus.toNegated();\n    EditorContextKeys.isInWalkThroughSnippet = new RawContextKey('isInEmbeddedEditor', false, true);\n    EditorContextKeys.canUndo = new RawContextKey('canUndo', false, true);\n    EditorContextKeys.canRedo = new RawContextKey('canRedo', false, true);\n    EditorContextKeys.hoverVisible = new RawContextKey('editorHoverVisible', false, nls.localize('editorHoverVisible', \"Whether the editor hover is visible\"));\n    /**\n     * A context key that is set when an editor is part of a larger editor, like notebooks or\n     * (future) a diff editor\n     */\n    EditorContextKeys.inCompositeEditor = new RawContextKey('inCompositeEditor', undefined, nls.localize('inCompositeEditor', \"Whether the editor is part of a larger editor (e.g. notebooks)\"));\n    EditorContextKeys.notInCompositeEditor = EditorContextKeys.inCompositeEditor.toNegated();\n    // -- mode context keys\n    EditorContextKeys.languageId = new RawContextKey('editorLangId', '', nls.localize('editorLangId', \"The language identifier of the editor\"));\n    EditorContextKeys.hasCompletionItemProvider = new RawContextKey('editorHasCompletionItemProvider', false, nls.localize('editorHasCompletionItemProvider', \"Whether the editor has a completion item provider\"));\n    EditorContextKeys.hasCodeActionsProvider = new RawContextKey('editorHasCodeActionsProvider', false, nls.localize('editorHasCodeActionsProvider', \"Whether the editor has a code actions provider\"));\n    EditorContextKeys.hasCodeLensProvider = new RawContextKey('editorHasCodeLensProvider', false, nls.localize('editorHasCodeLensProvider', \"Whether the editor has a code lens provider\"));\n    EditorContextKeys.hasDefinitionProvider = new RawContextKey('editorHasDefinitionProvider', false, nls.localize('editorHasDefinitionProvider', \"Whether the editor has a definition provider\"));\n    EditorContextKeys.hasDeclarationProvider = new RawContextKey('editorHasDeclarationProvider', false, nls.localize('editorHasDeclarationProvider', \"Whether the editor has a declaration provider\"));\n    EditorContextKeys.hasImplementationProvider = new RawContextKey('editorHasImplementationProvider', false, nls.localize('editorHasImplementationProvider', \"Whether the editor has an implementation provider\"));\n    EditorContextKeys.hasTypeDefinitionProvider = new RawContextKey('editorHasTypeDefinitionProvider', false, nls.localize('editorHasTypeDefinitionProvider', \"Whether the editor has a type definition provider\"));\n    EditorContextKeys.hasHoverProvider = new RawContextKey('editorHasHoverProvider', false, nls.localize('editorHasHoverProvider', \"Whether the editor has a hover provider\"));\n    EditorContextKeys.hasDocumentHighlightProvider = new RawContextKey('editorHasDocumentHighlightProvider', false, nls.localize('editorHasDocumentHighlightProvider', \"Whether the editor has a document highlight provider\"));\n    EditorContextKeys.hasDocumentSymbolProvider = new RawContextKey('editorHasDocumentSymbolProvider', false, nls.localize('editorHasDocumentSymbolProvider', \"Whether the editor has a document symbol provider\"));\n    EditorContextKeys.hasReferenceProvider = new RawContextKey('editorHasReferenceProvider', false, nls.localize('editorHasReferenceProvider', \"Whether the editor has a reference provider\"));\n    EditorContextKeys.hasRenameProvider = new RawContextKey('editorHasRenameProvider', false, nls.localize('editorHasRenameProvider', \"Whether the editor has a rename provider\"));\n    EditorContextKeys.hasSignatureHelpProvider = new RawContextKey('editorHasSignatureHelpProvider', false, nls.localize('editorHasSignatureHelpProvider', \"Whether the editor has a signature help provider\"));\n    EditorContextKeys.hasInlayHintsProvider = new RawContextKey('editorHasInlayHintsProvider', false, nls.localize('editorHasInlayHintsProvider', \"Whether the editor has an inline hints provider\"));\n    // -- mode context keys: formatting\n    EditorContextKeys.hasDocumentFormattingProvider = new RawContextKey('editorHasDocumentFormattingProvider', false, nls.localize('editorHasDocumentFormattingProvider', \"Whether the editor has a document formatting provider\"));\n    EditorContextKeys.hasDocumentSelectionFormattingProvider = new RawContextKey('editorHasDocumentSelectionFormattingProvider', false, nls.localize('editorHasDocumentSelectionFormattingProvider', \"Whether the editor has a document selection formatting provider\"));\n    EditorContextKeys.hasMultipleDocumentFormattingProvider = new RawContextKey('editorHasMultipleDocumentFormattingProvider', false, nls.localize('editorHasMultipleDocumentFormattingProvider', \"Whether the editor has multiple document formatting providers\"));\n    EditorContextKeys.hasMultipleDocumentSelectionFormattingProvider = new RawContextKey('editorHasMultipleDocumentSelectionFormattingProvider', false, nls.localize('editorHasMultipleDocumentSelectionFormattingProvider', \"Whether the editor has multiple document selection formatting providers\"));\n})(EditorContextKeys || (EditorContextKeys = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class EditorTheme {\n    constructor(theme) {\n        this._theme = theme;\n    }\n    get type() {\n        return this._theme.type;\n    }\n    get value() {\n        return this._theme;\n    }\n    update(theme) {\n        this._theme = theme;\n    }\n    getColor(color) {\n        return this._theme.getColor(color);\n    }\n}\n"],"names":["CharacterClassifier","_defaultValue","defaultValue","toUint8","this","_asciiMap","_createAsciiMap","_map","Map","charCode","_value","value","set","get","asciiMap","Uint8Array","i","CharacterSet","_actual","CursorColumns","codePoint","visibleColumn","tabSize","nextRenderTabStop","strings","lineContent","column","textLen","Math","min","length","text","substring","iterator","result","eol","offset","nextGraphemeLength","_nextVisibleColumn","lineContentLength","beforeVisibleColumn","beforeColumn","afterVisibleColumn","afterColumn","indentSize","max","EditOperation","position","range","Range","lineNumber","forceMoveMarkers","editorLineHighlight","registerColor","dark","light","hc","nls","editorLineHighlightBorder","editorRangeHighlight","editorRangeHighlightBorder","activeContrastBorder","editorSymbolHighlight","editorFindMatchHighlight","editorSymbolHighlightBorder","editorCursorForeground","Color","editorCursorBackground","editorWhitespaces","editorIndentGuides","editorActiveIndentGuides","editorLineNumbers","deprecatedEditorActiveLineNumber","editorActiveLineNumber","editorRuler","editorBracketMatchBackground","editorBracketMatchBorder","contrastBorder","editorOverviewRulerBorder","editorOverviewRulerBackground","editorGutter","editorBackground","editorUnnecessaryCodeBorder","transparent","editorUnnecessaryCodeOpacity","ghostTextBorder","ghostTextForeground","ghostTextBackground","rulerRangeDefault","RGBA","overviewRulerRangeHighlight","overviewRulerError","overviewRulerWarning","editorWarningForeground","editorWarningBorder","overviewRulerInfo","editorInfoForeground","editorInfoBorder","editorBracketHighlightingForeground1","editorBracketHighlightingForeground2","editorBracketHighlightingForeground3","editorBracketHighlightingForeground4","editorBracketHighlightingForeground5","editorBracketHighlightingForeground6","editorBracketHighlightingUnexpectedBracketForeground","editorBracketPairGuideBackground1","editorBracketPairGuideBackground2","editorBracketPairGuideBackground3","editorBracketPairGuideBackground4","editorBracketPairGuideBackground5","editorBracketPairGuideBackground6","editorBracketPairGuideActiveBackground1","editorBracketPairGuideActiveBackground2","editorBracketPairGuideActiveBackground3","editorBracketPairGuideActiveBackground4","editorBracketPairGuideActiveBackground5","editorBracketPairGuideActiveBackground6","registerThemingParticipant","theme","collector","background","getColor","addRule","foreground","editorForeground","gutter","rangeHighlight","rangeHighlightBorder","type","symbolHighlight","symbolHighlightBorder","invisibles","countEOL","eolCount","firstLineLength","lastLineStart","len","chr","charCodeAt","normalizeIndentation","str","insertSpaces","firstNonWhitespaceIndex","spacesCnt","charAt","tabsCnt","floor","_normalizeIndentationFromWhitespace","Position","newLineNumber","newColumn","deltaLineNumber","deltaColumn","with","other","equals","isBefore","isBeforeOrEqual","a","b","aLineNumber","bLineNumber","pos","obj","startLineNumber","startColumn","endLineNumber","endColumn","isEmpty","containsPosition","containsRange","strictContainsRange","plusRange","intersectRanges","equalsRange","getEndPosition","getStartPosition","collapseToStart","otherRange","resultStartLineNumber","resultStartColumn","resultEndLineNumber","resultEndColumn","otherStartLineNumber","otherStartColumn","otherEndLineNumber","otherEndColumn","start","end","aStartLineNumber","bStartLineNumber","aStartColumn","bStartColumn","aEndLineNumber","bEndLineNumber","RGBA8","r","g","_rgba8Brand","undefined","_clamp","c","Empty","Selection","selectionStartLineNumber","selectionStartColumn","positionLineNumber","positionColumn","selectionsEqual","getDirection","direction","sel","_utf16LE_TextDecoder","_utf16BE_TextDecoder","_platformTextDecoder","getUTF16LE_TextDecoder","TextDecoder","getPlatformTextDecoder","platform","createStringBuilder","decodeUTF16LE","hasTextDecoder","compatDecodeUTF16LE","source","resultLen","buffer","String","fromCharCode","join","capacity","StringBuilder","view","Uint16Array","decode","CompatStringBuilder","_capacity","_buffer","_completedStrings","_bufferLength","_flushBuffer","_buildBuffer","bufferString","remainingSpace","strLen","_pieces","_piecesLen","escapeNewLine","replace","TextChange","oldPosition","oldText","newPosition","newText","_writeStringSize","_writeString","dest","_readString","push","compressConsecutiveTextChanges","prevEdits","currEdits","TextChangeCompressor","compress","_prevEdits","_currEdits","_result","_resultLen","_prevLen","_prevDeltaOffset","_currLen","_currDeltaOffset","prevIndex","currIndex","prevEdit","_getPrev","currEdit","_getCurr","oldEnd","_acceptCurr","newEnd","_acceptPrev","_splitCurr","e1","e2","_splitPrev","mergePrev","mergeCurr","oldLength","newLength","merged","_merge","_removeNoOps","_rebaseCurr","_rebasePrev","prevDeltaOffset","currDeltaOffset","edit","preText","substr","postText","edits","prev","curr","EDITOR_MODEL_DEFAULTS","detectIndentation","trimAutoWhitespace","largeFileOptimizations","bracketPairColorizationOptions","enabled","WordCharacterClassifier","wordSeparators","getMapForWordSeparators","computeFn","cache","input","hasOwnProperty","once","USUAL_WORD_SEPARATORS","DEFAULT_WORD_REGEXP","allowInWords","sep","indexOf","RegExp","createWordRegExp","ensureValidWordDefinition","wordDefinition","global","flags","ignoreCase","multiline","unicode","lastIndex","_defaultConfig","maxLen","windowSize","timeBudget","getWordAtText","textOffset","config","t1","Date","now","prevRegexIndex","match","regexIndex","thisMatch","_findRegexMatchEnclosingPosition","word","index","stopPos","exec","matchIndex","Cursor","context","_selTrackedRange","_trackSelection","_setState","SingleCursorState","_removeTrackedRange","_updateTrackedRange","model","_setTrackedRange","modelState","selection","CursorState","viewState","_getTrackedRange","_validateViewState","viewModel","selectionStart","validateRange","selectionStartLeftoverVisibleColumns","validatePosition","leftoverVisibleColumns","coordinatesConverter","convertViewRangeToModelRange","convertViewPositionToModelPosition","viewSelectionStart","validateViewRange","viewPosition","validateViewPosition","viewSelectionStart1","convertModelPositionToViewPosition","viewSelectionStart2","cacheInput","cacheOutput","normalizePosition","sStartPosition","sEndPosition","validPosition","validSStartPosition","_validatePositionWithCache","validSEndPosition","CursorCollection","cursors","lastAddedCursorIndex","dispose","startTrackingSelection","stopTrackingSelection","ensureValidState","map","readSelectionFromMarkers","asCursorState","findMinBy","compareBy","findLastMaxBy","selections","setStates","states","setState","_setSecondaryStates","slice","secondaryStates","secondaryCursorsLength","secondaryStatesLength","createCnt","_addSecondaryCursor","removeCnt","_removeSecondaryCursor","removeIndex","splice","sortedCursors","sort","s","sortedCursorIndex","current","next","currentSelection","nextSelection","cursorConfig","multiCursorMergeOverlapping","winnerSortedCursorIndex","looserSortedCursorIndex","looserIndex","winnerIndex","looserSelection","winnerSelection","equalsSelection","resultingRange","looserSelectionIsLTR","winnerSelectionIsLTR","resultingSelectionIsLTR","resultingSelection","resultingState","sortedCursor","CursorContext","_cursorContextBrand","CursorsController","_model","_knownModelVersionId","getVersionId","_viewModel","_coordinatesConverter","_cursors","_hasFocus","_isHandling","_isDoingComposition","_selectionsWhenCompositionStarted","_columnSelectData","_autoClosedActions","_prevEditOperationType","updateContext","eventsCollector","getCursorStates","hasFocus","getSelections","autoClosedAction","isValid","getPrimaryCursor","getLastAddedCursorIndex","getAll","reason","reachedMaxCursorCount","MAX_CURSOR_COUNT","oldState","CursorModelState","from","normalize","_validateAutoClosedActions","_emitStateChangedIfNecessary","columnSelectData","minimalReveal","verticalType","revealHorizontal","scrollType","viewPositions","getViewPositions","revealViewRange","revealViewSelections","getViewSelections","emitViewEvent","ViewRevealRangeRequestEvent","inSelectionMode","desiredSelections","state","revealPrimary","e","ModelInjectedTextChangedEvent","versionId","hadFlushEvent","containsEvent","cursorState","isUndoing","isRedoing","selectionsFromMarkers","getTopMostViewPosition","getBottomMostViewPosition","primaryCursor","isReal","fromViewLineNumber","fromViewVisualColumn","visibleColumnFromColumn","toViewLineNumber","toViewVisualColumn","autoClosedCharactersRanges","autoClosedEnclosingRanges","autoClosedCharactersDeltaDecorations","autoClosedEnclosingDeltaDecorations","options","description","inlineClassName","stickiness","autoClosedCharactersDecorations","deltaDecorations","autoClosedEnclosingDecorations","AutoClosedAction","opResult","shouldPushStackElementBefore","pushStackElement","CommandExecutor","executeCommands","commands","_interpretCommandResult","command","TypeWithAutoClosingCommand","enclosingRange","closeCharacterRange","_pushAutoClosedAction","shouldPushStackElementAfter","setSelections","newState","viewSelections","ViewCursorStateChangedEvent","some","newCursorState","oldSelections","oldModelVersionId","modelVersionId","emitOutgoingEvent","CursorStateChangedEvent","indices","m","closeChar","autoClosingPairsCandidates","autoClosingPairs","autoClosingPairsCloseSingleChar","openChar","open","closeCharIndex","openCharIndex","lastIndexOf","cursorStateComputer","autoClosingIndices","_findAutoClosingPairs","_isTracked","pushEditOperations","undoEdits","openCharInnerIndex","closeCharInnerIndex","undoEdit","callback","cursorChangeReason","readOnly","stopTrackingSelections","err","onUnexpectedError","startTrackingSelections","isDoingComposition","getAllAutoClosedCharacters","_executeEdit","_executeEditOperation","TypeOperations","getAutoClosedCharacters","charLength","replacePrevCharCnt","replaceNextCharCnt","positionDelta","newSelections","getPosition","pasteOnNewLine","multicursorText","DeleteOperations","killSecondaryCursors","EditOperationResult","Disposable","cursor","_autoClosedCharactersDecorations","_autoClosedEnclosingDecorations","decorationRange","getDecorationRange","enclosingRanges","autoClosedActions","autoClosedCharacters","concat","getAutoClosedCharactersRanges","selectionsBefore","ctx","trackedRanges","trackedRangesDirection","_innerExecuteCommands","_arrayIsEmpty","commandsData","_getEditOperations","operations","rawOperations","loserCursorsMap","_getLoserCursorMap","console","warn","filteredOperations","identifier","major","toString","hadTrackedEditOperation","selectionsAfter","inverseEditOperations","groupedInverseEditOperations","op","minorBasedSorter","minor","cursorSelections","computeCursorState","getInverseEditOperations","getTrackedSelection","id","idx","parseInt","losingCursors","losingCursorIndex","losingCursor","_getEditOperationsFromCommand","majorIdentifier","operationMinor","addEditOperation","isAutoWhitespaceEdit","insertsAutoWhitespace","editOperationBuilder","addTrackedEditOperation","trackSelection","_selection","trackPreviousOnEmpty","maxLineColumn","getLineMaxColumn","l","getEditOperations","previousOp","currentOp","loserMajor","j","AtomicTabMoveOperations","lineLength","prevTabStopPosition","prevTabStopVisibleColumn","left","whitespaceVisibleColumn","currentVisibleColumn","targetVisibleColumn","ColumnSelection","fromLineNumber","fromVisibleColumn","toLineNumber","toVisibleColumn","lineCount","abs","reversed","isRTL","isLTR","columnFromVisibleColumn","visibleStartColumn","visibleEndColumn","maxColumn","viewStates","fromVisualColumn","toVisualColumn","prevColumnSelectData","columnSelect","maxVisualViewColumn","minViewLineNumber","maxViewLineNumber","lineMaxViewColumn","lineMaxVisualViewColumn","isPaged","linesCount","pageSize","getLineCount","prevEditOperationType","deleteSelection","rightOfPosition","MoveOperations","ReplaceCommand","autoClosingDelete","autoClosingBrackets","autoClosingQuotes","autoClosingPairsOpen","lineText","getLineContent","character","autoClosingPairCandidates","isQuote","afterCharacter","foundAutoClosingPair","autoClosingPairCandidate","close","found","lenJ","autoClosedCharacter","isAutoClosingPairDelete","autoClosingPairsOpenByEnd","_runAutoClosingPairDelete","deleteRange","getDeleteRange","useTabStops","lastIndentationColumn","toColumn","getPositionAfterDeleteLeft","newLine","lastCutRange","emptySelectionClipboard","CursorMove","CursorMoveCommands","useLogicalLine","_moveToLineStart","currentViewStateColumn","isFirstLineOfWrappedLine","currentViewStatelineNumber","firstNonBlankColumn","getLineFirstNonWhitespaceColumn","_moveToLineStartByModel","_moveToLineStartByView","sticky","_moveToLineEnd","viewStatePosition","viewModelMaxColumn","isEndOfViewLine","modelStatePosition","modelMaxColumn","isEndLineOfWrappedLine","_moveToLineEndByModel","_moveToLineEndByView","_position","_viewPosition","hasSelection","selectToLineNumber","selectToColumn","enteringLineNumber","move","selectToViewLineNumber","selectToViewColumn","endPositionOfSelectionStart","WordOperations","unit","_moveHalfLineLeft","_moveLeft","_moveHalfLineRight","_moveRight","_moveUpByViewLines","_moveUpByModelLines","_moveDownByViewLines","_moveDownByModelLines","_moveToViewMinColumn","_moveToViewFirstNonWhitespaceColumn","_moveToViewCenterColumn","_moveToViewMaxColumn","_moveToViewLastNonWhitespaceColumn","visibleViewRange","getCompletelyVisibleViewRange","visibleModelRange","modelLineNumber","_firstLineNumberInRange","modelColumn","_moveToModelPosition","_lastLineNumberInRange","round","findPositionInViewportIfOutside","newViewLineNumber","viewLineNumber","count","getLineMinColumn","noOfColumns","halfLine","toViewColumn","toModelLineNumber","toModelColumn","viewColumn","_moveToViewPosition","getLineLastNonWhitespaceColumn","args","name","constraint","arg","types","cursorMoveArg","to","select","by","schema","RawDirection","Left","Right","Up","Down","PrevBlankLine","NextBlankLine","WrappedLineStart","WrappedLineFirstNonWhitespaceCharacter","WrappedLineColumnCenter","WrappedLineEnd","WrappedLineLastNonWhitespaceCharacter","ViewPortTop","ViewPortCenter","ViewPortBottom","ViewPortIfOutside","RawUnit","Line","WrappedLine","Character","HalfLine","parse","CursorPosition","_cursorPositionBrand","delta","getLineIndentColumn","minColumn","leftPosition","stickyTabStops","leftPositionAtomicSoftTabs","normalizedPos","clipPositionColumn","p","clipRange","rightPosition","rightPositionAtomicSoftTabs","right","allowMoveOnEdgeLine","normalizationAffinity","wasOnFirstPosition","wasOnLastPosition","wasAtEdgePosition","allowMoveOnLastLine","vertical","down","allowMoveOnFirstLine","up","_isBlankLine","lastLineNumber","lastColumn","ShiftCommand","isUnshift","autoIndent","indentation","typeSelection","ReplaceCommandThatPreservesSelection","multiCursorPaste","lines","distributedPaste","_distributePasteToCursors","_distributedPaste","_simplePaste","action","expectedIndentAction","LanguageConfigurationRegistry","expectedEnterAction","appendText","IndentAction","shiftIndent","unshiftIndent","typeText","test","isCheapToTokenize","goodIndent","_goodIndentForLine","possibleTypeText","startsWith","_replaceJumpToNextIndent","lineMaxColumn","_compositionType","shouldPushStackElementBetween","getValueInRange","ReplaceCommandWithOffsetCursorState","keepPosition","ReplaceCommandWithoutChangingPosition","_typeCommand","indentAction","normalIndent","increasedIndent","actualIndentation","ir","indent","oldEndViewColumn","oldEndColumn","newLineContent","firstNonWhitespace","setEndPosition","afterEnter","ceil","ch","currentIndentation","autoClosingOvertype","has","chIsQuote","lineAfter","nextChar","potentialStartingBraces","autoClosingPairsOpenByStart","potentialClosingBraces","autoClosingPairsCloseByStart","isBeforeStartingBrace","x","isBeforeClosingBrace","positions","candidates","candidate","candidateIsMatch","pair","lastChar","autoClosingPairsCloseByEnd","includes","endsWith","chIsAlreadyTyped","autoCloseConfig","shouldAutoCloseBefore","quote","bracket","_findAutoClosingPairOpen","containedPair","_findContainedAutoClosingPair","containedPairClose","isContainedPairPresent","lineBefore","characterAfter","_isBeforeClosingBrace","characterBefore","forceTokenization","lineTokens","getLineTokens","scopedLineTokens","createScopedLineTokens","shouldAutoClose","firstCharOffset","neutralCharacter","findNeutralCharacter","tokenType","getTokenTypeIfInsertingCharacter","isOK","autoClosingPairClose","autoSurround","_shouldSurroundChar","surroundingPairs","isTypingAQuoteCharacter","selectionContainsOnlyWhitespace","startIndex","endIndex","selectedText","selectionText","closeCharacter","SurroundSelectionCommand","electricChars","electricAction","onElectricCharacter","matchOpenBracket","bracketPairs","findMatchingBracketUp","matchLine","matchLineIndentation","newIndentation","lineFirstNonBlankColumn","getTypingOperation","selectionsWhenCompositionStarted","currentChar","_isAutoClosingOvertype","_getAutoClosingPairClose","_runAutoClosingOpenCharType","_enter","_isAutoIndentType","autoIndentFails","_runAutoIndentType","_runAutoClosingOvertype","_isSurroundSelectionType","_runSurroundSelectionType","_isTypeInterceptorElectricChar","_typeInterceptorElectricChar","opType","openCharacter","insertOpenCharacter","_openCharacter","_closeCharacter","helper","typedText","previousTypingOperation","typingOperation","isTypingOperation","normalizeOperationType","wordType","nextCharClass","_doFindPreviousWordOnLine","chIndex","chCode","chClass","_createWord","_findEndOfWord","_doFindNextWordOnLine","_findStartOfWord","wordNavigationType","prevWordOnLine","_findPreviousWordOnLine","rightRight","movedDown","nextWordOnLine","_findNextWordOnLine","lastNonWhitespace","whitespaceHeuristics","_deleteWordLeftWhitespace","_deleteInsideWordWhitespace","_deleteInsideWordDetermineDeleteRange","leftIndex","_charAtIsWhitespace","rightIndex","touchesWord","createRangeWithPosition","deleteWordAndAdjacentWhitespace","expandedToTheRight","toPosition","_moveWordPartLeft","_findFirstNonWhitespaceChar","_deleteWordRightWhitespace","_moveWordPartRight","_wordSeparators","prevWord","_createWordAtPosition","nextWord","possiblePosition","WordPartOperations","enforceDefined","deleteWordLeft","_deleteWordPartLeft","deleteWordRight","_deleteWordPartRight","moveWordLeft","moveWordRight","arr","filter","el","Boolean","autoCloseAlways","autoCloseNever","autoCloseBeforeWhitespace","CursorConfiguration","languageId","modelOptions","configuration","languageConfigurationService","_cursorMoveConfigurationBrand","_languageId","layoutInfo","lineHeight","height","copyWithSyntaxHighlighting","_electricChars","_getShouldAutoClose","getLanguageConfiguration","getAutoClosingPairs","getSurroundingPairs","_a","electricCharacter","getElectricCharacters","char","electricCharacterSupport","_getLanguageDefinedShouldAutoClose","autoCloseBeforeSet","getAutoCloseBeforeSet","hasChanged","_cursorStateBrand","PartialModelCursorState","PartialViewCursorState","modelSelection","getSelectionStart","fromModelState","modelSelections","fromModelSelection","_singleCursorStateBrand","_computeSelection","opts","_editOperationResultBrand","computeDiff","originalSequence","modifiedSequence","continueProcessingPredicate","pretty","LcsDiff","ComputeDiff","LineSequence","startColumns","endColumns","getFirstNonBlankColumn","getLastNonBlankColumn","_startColumns","_endColumns","elements","shouldIgnoreTrimWhitespace","charCodes","lineNumbers","columns","col","CharSequence","_charCodes","_lineNumbers","_columns","CharChange","originalStartLineNumber","originalStartColumn","originalEndLineNumber","originalEndColumn","modifiedStartLineNumber","modifiedStartColumn","modifiedEndLineNumber","modifiedEndColumn","diffChange","originalCharSequence","modifiedCharSequence","originalLength","getStartLineNumber","originalStart","getStartColumn","getEndLineNumber","getEndColumn","modifiedLength","modifiedStart","LineChange","charChanges","originalLineSequence","modifiedLineSequence","continueCharDiff","shouldComputeCharChanges","shouldPostProcessCharChanges","createCharSequence","rawChanges","changes","prevChange","currChange","originalMatchingLength","modifiedMatchingLength","postProcessCharChanges","createFromDiffChange","DiffComputer","originalLines","modifiedLines","shouldMakePrettyDiff","original","modified","continueLineDiff","createContinueProcessingPredicate","maxComputationTime","quitEarly","diffResult","lineChanges","createFromDiffResult","originalLineIndex","modifiedLineIndex","nextChange","originalStop","modifiedStop","originalLine","modifiedLine","_pushTrimWhitespaceCharChange","originalMaxColumn","modifiedMaxColumn","originalLineNumber","modifiedLineNumber","_mergeTrimWhitespaceCharChange","txt","maximumRuntime","startTime","InternalEditorAction","label","alias","precondition","run","contextKeyService","_precondition","_run","_contextKeyService","contextMatchesRules","isSupported","Promise","resolve","EditorType","ICodeEditor","IDiffEditor","EditorContextKeys","editorSimpleInput","RawContextKey","editorTextFocus","focus","textInputFocus","inDiffEditor","columnSelection","writable","toNegated","hasNonEmptySelection","hasOnlyEmptySelection","hasMultipleSelections","hasSingleSelection","tabMovesFocus","tabDoesNotMoveFocus","isInWalkThroughSnippet","canUndo","canRedo","hoverVisible","inCompositeEditor","notInCompositeEditor","hasCompletionItemProvider","hasCodeActionsProvider","hasCodeLensProvider","hasDefinitionProvider","hasDeclarationProvider","hasImplementationProvider","hasTypeDefinitionProvider","hasHoverProvider","hasDocumentHighlightProvider","hasDocumentSymbolProvider","hasReferenceProvider","hasRenameProvider","hasSignatureHelpProvider","hasInlayHintsProvider","hasDocumentFormattingProvider","hasDocumentSelectionFormattingProvider","hasMultipleDocumentFormattingProvider","hasMultipleDocumentSelectionFormattingProvider","EditorTheme","_theme","color"],"sourceRoot":""}