(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{"./node_modules/code-example/lib/eiffel.js":function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.default='note\n    description: "[\n        Project-wide universal properties.\n        This class is an ancestor to all developer-written classes.\n        ANY may be customized for individual projects or teams.\n        ]"\n\n    library: "Free implementation of ELKS library"\n    status: "See notice at end of class."\n    legal: "See notice at end of class."\n    date: "$Date: 2013-01-25 11:49:00 -0800 (Fri, 25 Jan 2013) $"\n    revision: "$Revision: 712 $"\n\nclass\n    ANY\n\nfeature -- Customization\n\nfeature -- Access\n\n    generator: STRING\n            -- Name of current object\'s generating class\n            -- (base class of the type of which it is a direct instance)\n        external\n            "built_in"\n        ensure\n            generator_not_void: Result /= Void\n            generator_not_empty: not Result.is_empty\n        end\n\n    generating_type: TYPE [detachable like Current]\n            -- Type of current object\n            -- (type of which it is a direct instance)\n        do\n            Result := {detachable like Current}\n        ensure\n            generating_type_not_void: Result /= Void\n        end\n\nfeature -- Status report\n\n    conforms_to (other: ANY): BOOLEAN\n            -- Does type of current object conform to type\n            -- of `other\' (as per Eiffel: The Language, chapter 13)?\n        require\n            other_not_void: other /= Void\n        external\n            "built_in"\n        end\n\n    same_type (other: ANY): BOOLEAN\n            -- Is type of current object identical to type of `other\'?\n        require\n            other_not_void: other /= Void\n        external\n            "built_in"\n        ensure\n            definition: Result = (conforms_to (other) and\n                                        other.conforms_to (Current))\n        end\n\nfeature -- Comparison\n\n    is_equal (other: like Current): BOOLEAN\n            -- Is `other\' attached to an object considered\n            -- equal to current object?\n        require\n            other_not_void: other /= Void\n        external\n            "built_in"\n        ensure\n            symmetric: Result implies other ~ Current\n            consistent: standard_is_equal (other) implies Result\n        end\n\n    frozen standard_is_equal (other: like Current): BOOLEAN\n            -- Is `other\' attached to an object of the same type\n            -- as current object, and field-by-field identical to it?\n        require\n            other_not_void: other /= Void\n        external\n            "built_in"\n        ensure\n            same_type: Result implies same_type (other)\n            symmetric: Result implies other.standard_is_equal (Current)\n        end\n\n    frozen equal (a: detachable ANY; b: like a): BOOLEAN\n            -- Are `a\' and `b\' either both void or attached\n            -- to objects considered equal?\n        do\n            if a = Void then\n                Result := b = Void\n            else\n                Result := b /= Void and then\n                            a.is_equal (b)\n            end\n        ensure\n            definition: Result = (a = Void and b = Void) or else\n                        ((a /= Void and b /= Void) and then\n                        a.is_equal (b))\n        end\n\n    frozen standard_equal (a: detachable ANY; b: like a): BOOLEAN\n            -- Are `a\' and `b\' either both void or attached to\n            -- field-by-field identical objects of the same type?\n            -- Always uses default object comparison criterion.\n        do\n            if a = Void then\n                Result := b = Void\n            else\n                Result := b /= Void and then\n                            a.standard_is_equal (b)\n            end\n        ensure\n            definition: Result = (a = Void and b = Void) or else\n                        ((a /= Void and b /= Void) and then\n                        a.standard_is_equal (b))\n        end\n\n    frozen is_deep_equal (other: like Current): BOOLEAN\n            -- Are `Current\' and `other\' attached to isomorphic object structures?\n        require\n            other_not_void: other /= Void\n        external\n            "built_in"\n        ensure\n            shallow_implies_deep: standard_is_equal (other) implies Result\n            same_type: Result implies same_type (other)\n            symmetric: Result implies other.is_deep_equal (Current)\n        end\n\n    frozen deep_equal (a: detachable ANY; b: like a): BOOLEAN\n            -- Are `a\' and `b\' either both void\n            -- or attached to isomorphic object structures?\n        do\n            if a = Void then\n                Result := b = Void\n            else\n                Result := b /= Void and then a.is_deep_equal (b)\n            end\n        ensure\n            shallow_implies_deep: standard_equal (a, b) implies Result\n            both_or_none_void: (a = Void) implies (Result = (b = Void))\n            same_type: (Result and (a /= Void)) implies (b /= Void and then a.same_type (b))\n            symmetric: Result implies deep_equal (b, a)\n        end\n\nfeature -- Duplication\n\n    frozen twin: like Current\n            -- New object equal to `Current\'\n            -- `twin\' calls `copy\'; to change copying/twinning semantics, redefine `copy\'.\n        external\n            "built_in"\n        ensure\n            twin_not_void: Result /= Void\n            is_equal: Result ~ Current\n        end\n\n    copy (other: like Current)\n            -- Update current object using fields of object attached\n            -- to `other\', so as to yield equal objects.\n        require\n            other_not_void: other /= Void\n            type_identity: same_type (other)\n        external\n            "built_in"\n        ensure\n            is_equal: Current ~ other\n        end\n\n    frozen standard_copy (other: like Current)\n            -- Copy every field of `other\' onto corresponding field\n            -- of current object.\n        require\n            other_not_void: other /= Void\n            type_identity: same_type (other)\n        external\n            "built_in"\n        ensure\n            is_standard_equal: standard_is_equal (other)\n        end\n\n    frozen clone (other: detachable ANY): like other\n            -- Void if `other\' is void; otherwise new object\n            -- equal to `other\'\n            --\n            -- For non-void `other\', `clone\' calls `copy\';\n            -- to change copying/cloning semantics, redefine `copy\'.\n        obsolete\n            "Use `twin\' instead."\n        do\n            if other /= Void then\n                Result := other.twin\n            end\n        ensure\n            equal: Result ~ other\n        end\n\n    frozen standard_clone (other: detachable ANY): like other\n            -- Void if `other\' is void; otherwise new object\n            -- field-by-field identical to `other\'.\n            -- Always uses default copying semantics.\n        obsolete\n            "Use `standard_twin\' instead."\n        do\n            if other /= Void then\n                Result := other.standard_twin\n            end\n        ensure\n            equal: standard_equal (Result, other)\n        end\n\n    frozen standard_twin: like Current\n            -- New object field-by-field identical to `other\'.\n            -- Always uses default copying semantics.\n        external\n            "built_in"\n        ensure\n            standard_twin_not_void: Result /= Void\n            equal: standard_equal (Result, Current)\n        end\n\n    frozen deep_twin: like Current\n            -- New object structure recursively duplicated from Current.\n        external\n            "built_in"\n        ensure\n            deep_twin_not_void: Result /= Void\n            deep_equal: deep_equal (Current, Result)\n        end\n\n    frozen deep_clone (other: detachable ANY): like other\n            -- Void if `other\' is void: otherwise, new object structure\n            -- recursively duplicated from the one attached to `other\'\n        obsolete\n            "Use `deep_twin\' instead."\n        do\n            if other /= Void then\n                Result := other.deep_twin\n            end\n        ensure\n            deep_equal: deep_equal (other, Result)\n        end\n\n    frozen deep_copy (other: like Current)\n            -- Effect equivalent to that of:\n            --      `copy\' (`other\' . `deep_twin\')\n        require\n            other_not_void: other /= Void\n        do\n            copy (other.deep_twin)\n        ensure\n            deep_equal: deep_equal (Current, other)\n        end\n\nfeature {NONE} -- Retrieval\n\n    frozen internal_correct_mismatch\n            -- Called from runtime to perform a proper dynamic dispatch on `correct_mismatch\'\n            -- from MISMATCH_CORRECTOR.\n        local\n            l_msg: STRING\n            l_exc: EXCEPTIONS\n        do\n            if attached {MISMATCH_CORRECTOR} Current as l_corrector then\n                l_corrector.correct_mismatch\n            else\n                create l_msg.make_from_string ("Mismatch: ")\n                create l_exc\n                l_msg.append (generating_type.name)\n                l_exc.raise_retrieval_exception (l_msg)\n            end\n        end\n\nfeature -- Output\n\n    io: STD_FILES\n            -- Handle to standard file setup\n        once\n            create Result\n            Result.set_output_default\n        ensure\n            io_not_void: Result /= Void\n        end\n\n    out: STRING\n            -- New string containing terse printable representation\n            -- of current object\n        do\n            Result := tagged_out\n        ensure\n            out_not_void: Result /= Void\n        end\n\n    frozen tagged_out: STRING\n            -- New string containing terse printable representation\n            -- of current object\n        external\n            "built_in"\n        ensure\n            tagged_out_not_void: Result /= Void\n        end\n\n    print (o: detachable ANY)\n            -- Write terse external representation of `o\'\n            -- on standard output.\n        do\n            if o /= Void then\n                io.put_string (o.out)\n            end\n        end\n\nfeature -- Platform\n\n    Operating_environment: OPERATING_ENVIRONMENT\n            -- Objects available from the operating system\n        once\n            create Result\n        ensure\n            operating_environment_not_void: Result /= Void\n        end\n\nfeature {NONE} -- Initialization\n\n    default_create\n            -- Process instances of classes with no creation clause.\n            -- (Default: do nothing.)\n        do\n        end\n\nfeature -- Basic operations\n\n    default_rescue\n            -- Process exception for routines with no Rescue clause.\n            -- (Default: do nothing.)\n        do\n        end\n\n    frozen do_nothing\n            -- Execute a null action.\n        do\n        end\n\n    frozen default: detachable like Current\n            -- Default value of object\'s type\n        do\n        end\n\n    frozen default_pointer: POINTER\n            -- Default value of type `POINTER\'\n            -- (Avoid the need to write `p\'.`default\' for\n            -- some `p\' of type `POINTER\'.)\n        do\n        ensure\n            -- Result = Result.default\n        end\n\n    frozen as_attached: attached like Current\n            -- Attached version of Current\n            -- (Can be used during transitional period to convert\n            -- non-void-safe classes to void-safe ones.)\n        do\n            Result := Current\n        end\n\ninvariant\n    reflexive_equality: standard_is_equal (Current)\n    reflexive_conformance: conforms_to (Current)\n\nnote\n    copyright: "Copyright (c) 1984-2012, Eiffel Software and others"\n    license:   "Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)"\n    source: "[\n            Eiffel Software\n            5949 Hollister Ave., Goleta, CA 93117 USA\n            Telephone 805-685-1006, Fax 805-685-6869\n            Website http://www.eiffel.com\n            Customer support http://support.eiffel.com\n        ]"\n\nend\n'}}]);